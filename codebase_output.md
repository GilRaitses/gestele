

 \-\-\-

\#\#\# Folder: . (ID: 1\)

\-\-\-

\#\#\# File: MAGAT\_ANALYZER\_START\_HERE.m (ID: 1\.1\)

% this script sets up directories then runs the MAGAT\_ANALYZER\_DEMO
% for more details see MAGAT\_ANALYZER\_DEMO
% this script must be run from the Matlab\-Track\-Analysis directory

setupDirectories
addpath (genpath(fullfile(pwd, 'MAGATAnalyzer Example Scripts')));
help MAGAT\_ANALYZER\_DEMO
MAGAT\_ANALYZER\_DEMO
\-\-\-

\#\#\# File: DerivationRules.m (ID: 1\.2\)

classdef DerivationRules
 %Rules for Deriving Quantities in Tracks
 %no methods really
 
 %all times in seconds
 
 properties
 interpTime \= 0\.25; %all location data, etc. is resampled at this time scale
 smoothTime \= 0\.5; %sigma for gaussian smoothing filter
 derivTime \= 0\.25; %sigma for derivative filter (derivatives are taken of smoothed quantities)
 end
 
 methods
 end
 
end


\-\-\-

\#\#\# File: lineEdgesInImage.m (ID: 1\.3\)

function lns \= lineEdgesInImage(im, varargin )
%UNTITLED2 Summary of this function goes here
% Detailed explanation goes here

sigma \= 3;
thresh \= 0\.25;
eraseDist \= 15;
debug \= false;
varargin \= assignApplicable(varargin);
se \= strel('disk', eraseDist,4\);
\[xd,yd] \= imgradient(im, sigma);
\[xdl, ydl] \= imgradient(im, sigma\*2\); %lowpassed energy image

e \= xdl.^2 \+ ydl.^2;
e \= e/max(e(:));
e \= e.\*(e \> thresh);
j \= 0;
while (any(e(:) \> 0\))
 \[\~,I] \= max(e(:));
 
 \[y,x] \= ind2sub(size(e),I);
 erasemat \= ones(size(e));
 erasemat(y,x) \= 0;
 
 \[x,y] \= straightLineEdgeThruPoint(\[x y], im ,xd, yd);
 if (\~isempty(x) \&\& \~isempty(y))
 j \= j\+1;
 lns(j).x \= x;
 lns(j).y \= y;
 lns(j).len \= sqrt(diff(x).^2 \+ diff(y).^2\);
 xi \= round(linspace(x(1\),x(2\), ceil(lns(j).len)));
 yi \= round(linspace(y(1\),y(2\), ceil(lns(j).len)));
 valid \= (xi \>\= 1 \& xi \<\= size(erasemat,2\) \& yi \>\= 1 \& yi \<\= size(erasemat, 1\));
 erasemat(yi(valid), xi(valid)) \= 0;
 se2 \= strel('line', lns(j).len/2,atan2(diff(y), diff(x)));
 erasemat \= imerode(erasemat, se2\);
 end
 erasemat \= imerode(erasemat, se);
 e \= e.\*(erasemat); 
 if (\~exist('lns', 'var'))
 continue;
 end
 if debug
 figure(1\);
 imagesc(im); colormap gray; hold on; axis image
 for k \= 1:length(lns)
 plot (lns(k).x, lns(k).y, 'r\-', 'LineWidth', 2\);
 end
 hold off
 figure(2\);
 imagesc(e); colormap jet; axis image;
 % figure(3\);
 % imshow(erasemat);
 pause(0\.01\);
 
 end
end


\-\-\-

\#\#\# File: .gitignore (ID: 1\.4\)

\*.mat
\*.asv
\*.lnk
\*.xls
\*.jpg
\*.bin
\*.exe
\*.bmp
\*.fig
\*.avi
\*.m\~
\*.ps
documentation/

\-\-\-

\#\#\# File: setupDirectories.m (ID: 1\.5\)

function setupDirectories (username)
%function setupDirectories (username)
%adds paths to the matlab path so everything will run correctly
%(@Class directories do not need to be added to the path)
%if a username is given, adds user specific\\username and subdirectories
%to the path
addpath (pwd);
addpath (fullfile(pwd, 'basic routines'));
addpath (fullfile(pwd,'example scripts'));
addpath (fullfile(pwd,'useful extra classes'));
if (exist (fullfile (pwd, 'MartAnalysis'),'dir'))
 addpath (fullfile(pwd,'MartaAnalysis'));
end
if (exist (fullfile(pwd, 'AndyAnalysis'), 'dir'))
 addpath (fullfile(pwd, 'AndyAnalysis'));
 addpath (fullfile(pwd, 'AndyAnalysis', 'YMLUtils'));
end
addpath (genpath(fullfile(pwd,'utility functions')));
if (exist(fullfile(pwd, 'guis'), 'dir'))
 addpath (genpath(fullfile(pwd,'guis')));
end
if (exist (fullfile(pwd, 'Simulation Classes'), 'dir'))
 addpath (fullfile(pwd,'Simulation Classes'));
end
addpath(\[docroot '/techdoc/creating\_plots/examples']);
if (exist ('username', 'var') \&\& \~isempty(username))
 addpath (genpath(fullfile(pwd, 'user specific', username, '')));
end
addpath(genpath(fullfile(pwd, 'yamlMatlab')));
addpath(fullfile(pwd, 'SemiAutomaticAnalysis'));

\-\-\-

\#\#\# File: license.txt (ID: 1\.6\)

Could not read file: 'utf\-8' codec can't decode byte 0x96 in position 2994: invalid start byte

\-\-\-

\#\#\# Folder: example scripts (ID: example scripts)

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example.m (ID: example scripts.1\)

%% LOADING, SEGMENTING, AND OPERATING ON A WORM FILE
% An example script with annotations
%%

%% LOADING FILES FROM DISK
% loading specific files by name
existsAndDefault('marcmac', false);
if (marcmac)
 basedir \= '\~/Documents/lab data/n2cryo/';
else
 basedir \= '\\\\labnas1\\Share\\David\\Extracted\\Spatial\\N2\\18\-23GradientC15\\OutputFiles\\';
end
d \= dir(\[basedir '\*.bin']);
nfiles \= 1;
for j \= 1:nfiles
 fnames{j} \= \[basedir d(j).name];
end
%fnames \= {\[basedir '20090226\_N2g15\_1823\_tracks.bin'], \[basedir '20090226\_w1a\_N2g15\_1823\_tracks.bin']};

% load any track longer than 50 points
minpts \= 50;

% this code snippet loads the files if we haven't already loaded them, but
% otherwise skips them; that way we can change the script and rerun it
% without having to reload the files
if (\~exist('cryo', 'var'))
 cryo \= ExperimentSet.fromFiles(fnames{:}, 'minpts', minpts);
end

%% STITCH TRACKS
% sometimes we miss a frame, so let's stitch together tracks that are close
% by

frameDiff \= 3; % stitch together tracks if first ended 3 or fewer frames before second started
maxDist \= 7; % stitch together tracks if first ended within 7 pixels of second's start

% For the script, I am executing this function with interactive off, but if
% you set interactive to true, it will show you each potential stitch and
% let you decide whether or not to stitch it
cryo.executeExperimentFunction('stitchTracks', frameDiff, maxDist, 'interactive', false);

%% CLEAN UP TRACKS
% get rid of any tracks that don't go anywhere

% create an EsetCleaner object

ecl \= ESetCleaner();

% now let's look at the autogenerated report
% let's get rid of all tracks less than 750 points and speed less than 0\.4
% pixels per second
ecl.minPts \= 750;
ecl.minSpeed \= 0\.9;

ecl.getReport(cryo);

% the following code just forces the figures to appear in the example documentation
for j \= 1:3
 figure(j);
 snapnow; 
end


% we've already shown the report, so we don't need to have it ask us first,
% for the purposes of this script; generally a good idea to leave this
% enabled
ecl.askFirst \= false; 

ecl.clean(cryo);

%% Segmenting Tracks
% separate tracks into runs and reorientations

% the default segmentation options are pretty good
WormSegmentOptions

% but just for the heck of it, let's change the minimum run time

wso \= WormSegmentOptions;
wso.minRunTime \= 3; % seconds

% segment the tracks
cryo.executeExperimentFunction('segmentTracks', wso);

% pick a track and plot the segmentation
clf;
cryo.expt(1\).track(1\).plotSegmentation();
snapnow;
return
%% Statistics of Runs and Reorientations
% some elementary things to do

% descriptions of all these functions are found by typing 
% doc ExperimentSet

cryo.defaultTitle \= 'Cryophillic Navigation';

close all;

thetaAxis \= deg2rad(0:30:330\);
%% make a histogram of heading angle for all time
cryo.makeHistogram('theta', thetaAxis, 'polar', true, 'r2d', true);
snapnow;

%% make a histogram of heading angle only in runs
clf;
cryo.makeHistogram('theta', thetaAxis, 'runs','polar', true, 'r2d', true);
snapnow;

%% mark the probability of reorientation vs. heading angle
clf;
cryo.makeReorientationHistogram('theta', thetaAxis, 'polar', true, 'r2d', true);
snapnow;

%% make a scatter plot of angle change vs. starting angle
% and overlay the mean
runstart \= cryo.gatherSubField('run', 'startTheta');
runend \= cryo.gatherSubField('run', 'endTheta');
dt \= diff(unwrap(\[runstart;runend]));

% convert to degrees between 0 \& 360
runstart \= mod(rad2deg(runstart), 360\);

% convert to degrees; 
dt \= rad2deg(dt);

\[rs, meanchange, stderrchange] \= meanyvsx(runstart, dt, 0:30:360\);

clf;
plot (runstart, dt, 'k.'); hold on
errorbar(rs, meanchange, stderrchange, 'r', 'LineWidth', 2\); hold off
snapnow;


%% autocorrelate path direction

% the withinRuns flag means to only correlate within a run, but not between
% runs
\[ac, np, tx] \= cryo.autocorrelate('vnorm');
\[acr, npr, txr] \= cryo.autocorrelate('vnorm','withinRuns',true);
clf
semilogy(tx(ac\>0\), ac(ac\>0\)./np(ac\>0\), 'b.',txr(acr\>0\), acr(acr\>0\)./npr(acr\>0\),'g.'); 
xlim(\[0 600]);
xlabel ('$\\tau$ (s)','Interpreter', 'Latex');
ylabel('$\\langle\\hat{v}(t)\\cdot\\hat{v}(t \+ \\tau)\\rangle$','Interpreter','Latex');
title ('Auto\-Correlation of velocity direction');
legend('over whole track', 'within runs');
ylim(\[0\.01 1])
snapnow

%% autocorrelate change in heading over time
\[ac, np, tx] \= cryo.autocorrelate('deltatheta','withinRuns',true);
plot(tx, ac./np);
xlim(\[0 100])
xlabel ('$\\tau$ (s)','Interpreter', 'Latex');
ylabel('$\\langle\\dot{\\theta}(t)\\ast\\dot{\\theta}(t \+ \\tau)\\rangle$','Interpreter','Latex');
title ('Auto\-Correlation of heading angle change');
snapnow


%% a cross correlation
% a result of how we're differentiating, or something fundamental?
\[xc, np, tx] \= cryo.crosscorrelate('deltatheta', 'ddtheta', 'withinRuns', true);
plot (tx, xc./np); xlim(\[\-50 50])
xlabel ('$\\tau$ (s)','Interpreter', 'Latex');
ylabel('$\\langle\\ddot{\\theta}(t)\\ast\\dot{\\theta}(t \+ \\tau)\\rangle$','Interpreter','Latex');
title ('Cross correlation of first and second derivatives of heading');
snapnow

%% test on random noise
t \= cryo.expt(1\).track(1\);
t.dq.randomcrap \= randn(size(t.dq.eti));
t.dq.srandomcrap \= lowpass1D(t.dq.randomcrap, t.dr.smoothTime/t.dr.interpTime);
t.dq.dsrandomcrap \= deriv(t.dq.srandomcrap, t.dr.derivTime/t.dr.interpTime);
\[xccrap,npcrap,txcrap] \= t.crosscorrelate('srandomcrap', 'dsrandomcrap');

dgc \= \-conv(gausskernel(t.dr.smoothTime/t.dr.interpTime), dgausskernel(t.dr.derivTime/t.dr.interpTime),'same');
dgc \= dgc\*max(xccrap(round(length(xccrap)/2\) \+ \[\-100:100])./npcrap(round(length(xccrap)/2\) \+ \[\-100:100]))/max(dgc);
myt \= (1:length(dgc))\*t.dr.derivTime;
myt \= myt \- mean(myt);
plot (tx, xc./np,txcrap,xccrap./npcrap,myt,dgc); xlim(\[\-50 50])

\-\-\-

\#\#\# File: setupCryoPointLabeling.m (ID: example scripts.2\)

existsAndDefault('username', \[]);
existsAndDefault('segmodelname', 'fithmmmodel2\.mat');
if (exist('sm', 'var') \&\& isa (sm, 'SegmentationModel'))
 LabelPointGUI('sm', sm,'username',username,'basedir',fullfile(pwd, 'Segmentation Models', 'N2 Cryo', segmodelname));
 return;
end 

%% Set up cryophilic point labeling
% An example script with annotations
%%


%% LOADING FILES FROM DISK
% loading specific files by name
existsAndDefault('marcmac', false);
if (marcmac)
 basedir \= '\~/Documents/lab data/n2cryo/';
else
 basedir \= '\\\\labnas1\\Share\\David\\Extracted\\Spatial\\N2\\18\-23GradientC15\\OutputFiles\\';
end
d \= dir(\[basedir '\*.bin']);
nfiles \= 1;
for j \= 1:nfiles
 fnames{j} \= \[basedir d(j).name]; %\#ok
end
%fnames \= {\[basedir '20090226\_N2g15\_1823\_tracks.bin'], \[basedir '20090226\_w1a\_N2g15\_1823\_tracks.bin']};

% load any track longer than 50 points
minpts \= 50;

% this code snippet loads the files if we haven't already loaded them, but
% otherwise skips them; that way we can change the script and rerun it
% without having to reload the files
if (\~exist('cryo', 'var'))
 cryo \= ExperimentSet.fromFiles(fnames{:}, 'minpts', minpts);
end

%% STITCH TRACKS
% sometimes we miss a frame, so let's stitch together tracks that are close
% by

frameDiff \= 3; % stitch together tracks if first ended 3 or fewer frames before second started
maxDist \= 7; % stitch together tracks if first ended within 7 pixels of second's start

% For the script, I am executing this function with interactive off, but if
% you set interactive to true, it will show you each potential stitch and
% let you decide whether or not to stitch it
cryo.executeExperimentFunction('stitchTracks', frameDiff, maxDist, 'interactive', false);

%% CLEAN UP TRACKS
% get rid of any tracks that don't go anywhere

% create an EsetCleaner object

ecl \= ESetCleaner();

% now let's look at the autogenerated report
% let's get rid of all tracks less than 750 points and speed less than 0\.4
% pixels per second
ecl.minPts \= 750;
ecl.minSpeed \= 0\.9;

%ecl.getReport(cryo);

% the following code just forces the figures to appear in the example documentation
%{
for j \= 1:3
 figure(j);
 snapnow; 
end
%}

% we've already shown the report, so we don't need to have it ask us first,
% for the purposes of this script; generally a good idea to leave this
% enabled
ecl.askFirst \= false; 

ecl.clean(cryo);

%% Segmenting Tracks
% separate tracks into runs and reorientations

% the default segmentation options are pretty good
WormSegmentOptions

% but just for the heck of it, let's change the minimum run time

wso \= WormSegmentOptions;
wso.minRunTime \= 3; % seconds

% segment the tracks
cryo.executeExperimentFunction('segmentTracks', wso);

% pick a track and plot the segmentation

%% add lowpassed theta derivative
%{
if (isempty(\[cryo.expt.globalQuantity]) \|\| \~any(strcmpi({cryo.expt.globalQuantity.fieldname}, 'lrdtheta')))
 gq \= GlobalQuantity();
 gq.fieldname \= 'lrdtheta';
 gq.xField \= 'theta';
 gq.xData \= 5; %smoothing time in seconds
 gq.derivationMethod \= @(xin, xData, yData) deriv(unwrap(xin), xData(1\));

 % \[cryo.expt.globalQuantity] \= deal(\[]);
 cryo.executeExperimentFunction('addGlobalQuantity', gq);
end
%}
%% load segmentation model
sm \= SegmentationModel.fromMatFile(fullfile('Segmentation Models', 'N2 Cryo', segmodelname),cryo);
LabelPointGUI('sm', sm,'username',username);
\-\-\-

\#\#\# File: analyzeEthylAcetate.m (ID: example scripts.3\)

fnlist \= {'D:\\Marc Data\\20010205\\CS2\\CS2\_tracks\_2\.bin', ...
 'D:\\Marc Data\\20010205\\CS3\\CS3\_tracks.bin',...
 'D:\\Marc Data\\20010205\\CS4\\CS4\_tracks.bin'};
timfnlist \= {'D:\\Marc Data\\20010205\\CS2\\CS2\_.tim', ...
 'D:\\Marc Data\\20010205\\CS3\\CS3\_.tim',...
 'D:\\Marc Data\\20010205\\CS4\\CS4\_.tim'};
 
%load tracks from 3 experiments 
if \~exist ('expt', 'var')
 for j \= 1:3
 %load tracks including contours (no images though)
 %don't calibrate to camera (lengths are in pixels)
 %don't load tracks under 400 points (100 seconds)
 expt(j) \= Experiment.fromFile(fnlist{j}, timfnlist{j}, true, \[], 400\);
 
 %fix any gross head tail errors
 expt(j).executeTrackFunction('fixHTOrientation');
 

 validRect \= \[325 2200 125 1700]; %tracks must start inside this rectangle to be valid

 startPt \= zeros(\[2 length(expt(j).track)]);
 for k \= 1:length(expt(j).track)
 startPt(:,k) \= expt(j).track(k).pt(1\).loc;
 end
 valid \= insideRect(validRect, startPt);
 figure(j);
 for k \= find(valid)
 expt.track(k).plotPath('sloc', 'b\-'); hold on
 end
 for k \= find(\~valid)
 expt.track(k).plotPath('sloc', 'r\-');
 end
 hold off
 expt(j).track \= expt(j).track(valid);
 end
end

if (isempty(\[expt(1\).track.run]) \|\| (exist('startover', 'var') \&\& \~isempty(startover) \&\& startover)) 
 so \= MaggotSegmentOptions();
 for j \= 1:3
 expt(j).so \= so;
 expt(j).executeTrackFunction('recalculateDerivedQuantities');
 expt(j).executeTrackFunction('segmentTrack', so);
 end
 startover \= false;
end
runstartdir \= \[];
runenddir \= \[];
alldir \= \[];
hsdir \= \[];
hsaccepted \= \[];
hsang \= \[];
hsprevdir \= \[];
hstaildir \= \[];
runlen \= \[];
rundir \= \[];
for j \= 1:3
 runstartdir \= \[runstartdir rad2deg(expt(j).gatherSubField('run', 'startTheta'))];
 runenddir \= \[runenddir rad2deg(expt(j).gatherSubField('run', 'endTheta'))];
 alldir \= \[alldir rad2deg(expt(j).gatherField('theta','run'))];
 hsdir \= \[hsdir rad2deg(expt(j).gatherSubField('headSwing', 'headDir'))];
 hsaccepted \= \[hsaccepted (expt(j).gatherSubField('headSwing', 'accepted'))];
 hsang \= \[hsang rad2deg(expt(j).gatherSubField('headSwing', 'maxTheta'))];
 hsprevdir \= \[hsprevdir rad2deg(expt(j).gatherSubField('headSwing', 'prevDir'))];
 hstaildir \= \[hstaildir rad2deg(expt(j).gatherSubField('headSwing', 'tailDir'))];
 runlen \= \[runlen expt(j).gatherSubField('run', 'pathLength')];
 rundir \= \[rundir rad2deg(expt(j).gatherSubField('run', 'meanTheta'))];
end
close all;
fignum \= 0;
fignum \= fignum \+ 1;
figure(fignum);clf
tx \= \-180:30:180;
plot (tx,hist(runenddir,tx)./hist(alldir,tx) \* 60 / expt(j).dr.interpTime, 'LineWidth', 3\);
xlabel ('heading');
ylabel ('reorientation rate (min^{\-1})');
title ('probability of ending run vs. instantaneous heading');
embiggen();

fignum \= fignum \+ 1;
figure(fignum);clf
tx \= \-180:30:180;
h1 \= hist(runstartdir,tx);
h1(1\) \= h1(1\) \+ h1(end); h1(end) \= h1(1\);
h2 \= hist(runenddir,tx);
h2(1\) \= h2(1\) \+ h2(end); h2(end) \= h2(1\);
plot (tx, h1, 'g\-', tx, h2, 'r\-', 'LineWidth', 3\); ylim(\[0 max(\[h1 h2])]);
xlabel ('heading');
ylabel ('\# runs');
title ('distribution of run start and end directions');
legend ('start', 'end');
embiggen();

fignum \= fignum \+ 1;
figure(fignum); clf
rlx \= 50:50:1000;
semilogy (rlx, hist(runlen(abs(rundir \- 90\) \< 45\), rlx)/sum(abs(rundir \- 90\) \< 45\), 'r\-', rlx, hist(runlen(abs(rundir \+ 90\) \< 45\), rlx)/sum(abs(rundir \+ 90\) \< 45\), 'g\-',...
 rlx, hist (runlen(abs(rundir) \< 45\),rlx)/sum(abs(rundir) \< 45\), 'm\-', rlx, hist(runlen(abs(rundir) \> 135\),rlx)/sum(abs(rundir) \> 135\), 'c\-',...
 'LineWidth', 3\);
legend ('against gradient', 'with gradient', 'to left of gradient', 'to right of gradient');
xlabel ('run length (pixels)');
ylabel ('fraction of runs');
%{
fignum \= fignum \+ 1;
figure(fignum);clf
\[x,meany] \= meanyvsx (hstaildir, abs(hsang), tx);
plot (x, meany, 'LineWidth', 3\);
xlabel ('previous direction');
ylabel ('mean headsweep magnitude (degrees)');
title ('size of head sweep vs. previous direction');
embiggen()

inds \= find(hsaccepted);
inds2 \= find(\~hsaccepted);
fignum \= fignum \+ 1;
figure(fignum);clf
\[x1,meany1] \= meanyvsx (hstaildir(inds), hsang(inds), tx);
\[x2,meany2] \= meanyvsx (hstaildir(inds2\), hsang(inds2\), tx);
plot (x1,meany1, 'g\-', x2, meany2, 'r\-', 'LineWidth', 3\);
title ('mean headsweep angle vs. initial angle');
xlabel ('previous direction');
ylabel ('mean headsweep angle (degrees)');
legend ('accepted head sweeps', 'rejected head sweeps');
%}

rightup \= find(abs(hstaildir) \< 45 \& hsang \> 0\);
rightdown \= find(abs(hstaildir) \< 45 \& hsang \< 0\);
leftup \= find(abs(hstaildir) \> 135 \& hsang \< 0\);
leftdown \= find(abs(hstaildir) \> 135 \& hsang \> 0\);

\-\-\-

\#\#\# File: experimentAnalysisTemplate.m (ID: example scripts.4\)

%this is the directory where your .bin and .tim files are stored
basedir \= 'd:\\marc Processed\\maggots\\ethyl acetate 4 pct 20 2000\\';

minLoadPts \= 50; %don't load any tracks shorter than this

%load all the files, this will take a while, so we only do it
%if we haven't already loaded them
if (\~exist('eset', 'var'))
 eset \= ExperimentSet.fromFiles(basedir,'minpts',minLoadPts); 
 disp('files loaded; fixing head tail orientation; this may take a while');
 tic
 eset.executeTrackFunction('fixHTOrientation');
 toc
end

existsAndDefault('restitchAndTrim',true);
stitchDist \= 10; %distance that tracks can be apart to be stitched
stitchFrameDiff \= 5; %number of frames that can be between end and next start when stitching
minTrackDist \= 75; %minimum distance a track must travel in order to survive trimming
minTrackLength \= 400; %after stitching, minimum number of frames a track must have 
minTrackSpeed \= 0; %minimum average speed to avoid trimming

if (restitchAndTrim)
 disp('stitching tracks and trimming slow and short ones'); ts \= tic(); 
 ntstart \= length(\[eset.expt.track]);
 eset.executeExperimentFunction('stitchTracks', stitchFrameDiff, stitchDist);
 npoststitch \= length(\[eset.expt.track]);
 for j \= 1:length(eset.expt)
 meanspeed \= eset.expt(j).evaluateTrackExpression('mean(track.getDerivedQuantity(''speed''))');
 dt \= sqrt(eset.expt(j).evaluateTrackExpression('max(sum(track.getDerivedQuantity(''displacement'').^2\))'));
 valid \= \[eset.expt(j).track.npts] \> minTrackLength \& meanspeed \> minTrackSpeed \& dt \> minTrackDist;
 eset.expt(j).track \= eset.expt(j).track(valid);
 end
 nposttrim \= length(\[eset.expt.track]);
 disp(\['num tracks start: ' num2str(ntstart) ', after stitch: ' num2str(npoststitch) ' after trim: ' num2str(nposttrim)]);
 restitchAndTrim \= false;
 toc(ts)
end

%set segmentation options here
so \= MaggotSegmentOptions();
so.curv\_cut \= 1;

existsAndDefault('resegment', true);
if (resegment)
 %synch up segment options
 \[eset.expt.so] \= deal(so);
 for j \= 1:length(eset.expt)
 \[eset.expt(j).track.so] \= deal(eset.expt(j).so);
 end
% eset.executeExperimentFunction('\[expt.track.so] \= deal(expt.so)');
 
 %recommend running setSegmentSpeeds to let track set its own segment
 %speed based on high curvature regions
 eset.executeTrackFunction('setSegmentSpeeds');
 
 disp('segmenting tracks, this can take a while'); tic
 eset.executeTrackFunction('segmentTrack');
 toc
 resegment \= false;
end

varsToClean \= {'minLoadPts', 'stitchDist','stitchFrameDiff','minTrackDist \= 75','minTrackLength \= 400','minTrackSpeed',...
 'ntstart', 'npoststitch', 'meanspeed', 'dt', 'valid', 'nposttrim', 'so', 'varsToClean', 'ts'};
clear(varsToClean{:});

existsAndDefault('saveMe', false);
if (saveMe)
 disp('saving to disk, this can take an ass long time');
 tic
 save (\[basedir 'importedToMatlab.mat']);
 toc
 saveMe \= false;
end


\-\-\-

\#\#\# File: analyzeTemperatureWiggle.m (ID: example scripts.5\)

temperaturefn \= '\\\\labnas1\\Share\\Marc Data\\temperature ramp larvae\\20010204\\CS1\\CS1\_.tmp';
if (\~exist ('fepprobetemp', 'var') \|\| isempty(fepprobetemp))
 data \= load(temperaturefn);
 fepprobetemp \= data(21,:);
 figure(1\); clf(1\)
 smoothtemp \= lowpass1D(fepprobetemp, 2000\);
 smoothtemp2 \= lowpass1d(fepprobetemp, 4000\);
 plot (1:length(fepprobetemp), fepprobetemp, 1:length(smoothtemp), smoothtemp, 1:length(smoothtemp2\), smoothtemp2\);
 dtemp \= deriv(smoothtemp, 1\);
 figure(2\);clf(2\)
 plot (dtemp)

end

fn \= '\\\\labnas1\\Share\\Marc Data\\temperature ramp larvae\\20010204\\CS1\\CS1\_tracks\_2\.bin';
timfn \= '\\\\labnas1\\Share\\Marc Data\\temperature ramp larvae\\20010204\\CS1\\CS1\_.tim';

if (\~exist ('expt', 'var') \|\| isempty ('expt'))
 expt \= Experiment.fromFile(fn, timfn, true, \[], 200\);
 expt.executeTrackFunction('fixHTOrientation');
end

if (isempty(\[expt.track.run]) \|\| exist ('startover', 'var') \&\& startover)
 so \= MaggotSegmentOptions();
 expt.so \= so;
 if (exist ('startover', 'var') \&\& startover)
 expt.executeTrackFunction('recalculateDerivedQuantities');
 end
 expt.executeTrackFunction('segmentTrack', so);
 startover \= false;
end

hstime \= \[];
for j \= 1:length(expt.track)
 hstime \= \[hstime expt.track(j).dq.eti(\[expt.track(j).headSwing.startInd])];
end
timex \= 0:60:max(expt.elapsedTime);
plot (timex, hist(hstime,timex)./hist(expt.gatherField('eti'), timex));

\-\-\-

\#\#\# Folder: example scripts/html (ID: example scripts.html)

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example.html (ID: example scripts.html.1\)





LOADING, SEGMENTING, AND OPERATING ON A WORM FILE# LOADING, SEGMENTING, AND OPERATING ON A WORM FILE

An example script with annotations

## Contents

* [LOADING FILES FROM DISK](#2)
* [STITCH TRACKS](#3)
* [CLEAN UP TRACKS](#4)
* [Segmenting Tracks](#5)
* [Statistics of Runs and Reorientations](#6)
* [make a histogram of heading angle for all time](#7)
* [make a histogram of heading angle only in runs](#8)
* [mark the probability of reorientation vs. heading angle](#9)
* [make a scatter plot of angle change vs. starting angle](#10)
* [autocorrelate path direction](#11)
* [autocorrelate change in heading over time](#12)
* [a cross correlation](#13)
* [test on random noise](#14)
## LOADING FILES FROM DISK

loading specific files by name


```
basedir = '\\labnas1\Share\David\Extracted\Spatial\N2\18-23GradientC15\OutputFiles\';
d = dir([basedir '*.bin']);
nfiles = 5;
for j = 1:nfiles
    fnames{j} = [basedir d(j).name];
end
%fnames = {[basedir '20090226_N2g15_1823_tracks.bin'], [basedir '20090226_w1a_N2g15_1823_tracks.bin']};

% load any track longer than 50 points
minpts = 50;

% this code snippet loads the files if we haven't already loaded them, but
% otherwise skips them; that way we can change the script and rerun it
% without having to reload the files
if (~exist('cryo', 'var'))
    cryo = ExperimentSet.fromFiles(fnames{:}, 'minpts', minpts);
end

```

```
Loading file #1
code = 20101
adding timing information
Elapsed time is 18.557986 seconds.
Loading file #2
code = 20101
adding timing information
Elapsed time is 25.407170 seconds.
Loading file #3
code = 20101
adding timing information
Elapsed time is 19.171698 seconds.
Loading file #4
code = 20101
adding timing information
Elapsed time is 18.953077 seconds.
Loading file #5
code = 20101
adding timing information
Elapsed time is 12.020628 seconds.

```
## STITCH TRACKS

sometimes we miss a frame, so let's stitch together tracks that are close by


```
frameDiff = 3; % stitch together tracks if first ended 3 or fewer frames before second started
maxDist = 7; % stitch together tracks if first ended within 7 pixels of second's start

% For the script, I am executing this function with interactive off, but if
% you set interactive to true, it will show you each potential stitch and
% let you decide whether or not to stitch it
cryo.executeExperimentFunction('stitchTracks', frameDiff, maxDist, 'interactive', false);

```

```
merged 18 tracks
merged 4 tracks
merged 2 tracks
merged 6 tracks
merged 21 tracks

```
## CLEAN UP TRACKS

get rid of any tracks that don't go anywhere


```
% create an EsetCleaner object

ecl = ESetCleaner();

% now let's look at the autogenerated report

ecl.getReport(cryo);

% the following code just forces the figures to appear in the example documentation
for j = 1:3
    figure(j);
    snapnow;
end

% let's get rid of all tracks less than 750 points and speed less than 0.4
% pixels per second
ecl.minPts = 750;
ecl.minSpeed = 0.4;

% we've already shown the report, so we don't need to have it ask us first,
% for the purposes of this script;  generally a good idea to leave this
% enabled
ecl.askFirst = false;

ecl.clean(cryo);

```

```
0/188 tracks fail speed test
0/188 tracks fail displacement test
0/188 tracks fail npts test
0/188 tracks fail at least one test

```
![](cryo_worm_analysis_example_01.png) ![](cryo_worm_analysis_example_02.png) ![](cryo_worm_analysis_example_03.png) ## Segmenting Tracks

separate tracks into runs and reorientations


```
% the default segmentation options are pretty good
WormSegmentOptions

% but just for the heck of it, let's change the minimum run time

wso = WormSegmentOptions;
wso.minRunTime = 3; % seconds

% segment the tracks
cryo.executeExperimentFunction('segmentTracks', wso);

% pick a track and plot the segmentation
clf;
cryo.expt(1).track(1).plotSegmentation();
snapnow;

```

```

ans = 

  WormSegmentOptions

  Properties:
           dthetaThresh: 0.2618
              joinSTpts: 3
               ptBuffer: 3
           alignedTheta: 0.3491
             minRunTime: 5
    straightThetaThresh: 0.0524


Warning: Could not find an exact (case-sensitive) match for 'nthColor'.
c:\matlab track analysis\basic routines\nthcolor.m is a case-insensitive match and will be used
instead.
You can improve the performance of your code by using exact
name matches and we therefore recommend that you update your
usage accordingly. Alternatively, you can disable this warning using
warning('off','MATLAB:dispatcher:InexactCaseMatch').
This warning will become an error in future releases. 

```
![](cryo_worm_analysis_example_04.png) ## Statistics of Runs and Reorientations

some elementary things to do


```
% descriptions of all these functions are found by typing
% doc ExperimentSet

cryo.defaultTitle = 'Cryophillic Navigation';

close all;

thetaAxis = deg2rad(0:30:330);

```
## make a histogram of heading angle for all time


```
cryo.makeHistogram('theta', thetaAxis, 'polar', true, 'r2d', true);
snapnow;

```
![](cryo_worm_analysis_example_05.png) ## make a histogram of heading angle only in runs


```
clf;
cryo.makeHistogram('theta', thetaAxis, 'runs','polar', true, 'r2d', true);
snapnow;

```
![](cryo_worm_analysis_example_06.png) ## mark the probability of reorientation vs. heading angle


```
clf;
cryo.makeReorientationHistogram('theta', thetaAxis, 'polar', true, 'r2d', true);
snapnow;

```
![](cryo_worm_analysis_example_07.png) ## make a scatter plot of angle change vs. starting angle

and overlay the mean


```
runstart = cryo.gatherSubField('run', 'startTheta');
runend = cryo.gatherSubField('run', 'endTheta');
dt = diff(unwrap([runstart;runend]));

% convert to degrees between 0 & 360
runstart = mod(rad2deg(runstart), 360);

% convert to degrees;
dt = rad2deg(dt);

[rs, meanchange, stderrchange] = meanyvsx(runstart, dt, 0:30:360);

clf;
plot (runstart, dt, 'k.'); hold on
errorbar(rs, meanchange, stderrchange, 'r', 'LineWidth', 2); hold off
snapnow;

```
![](cryo_worm_analysis_example_08.png) ## autocorrelate path direction


```
% the withinRuns flag means to only correlate within a run, but not between
% runs
[ac, np, tx] = cryo.autocorrelate('vnorm');
[acr, npr, txr] = cryo.autocorrelate('vnorm','withinRuns',true);
clf
semilogy(tx(ac>0), ac(ac>0)./np(ac>0), 'b.',txr(acr>0), acr(acr>0)./npr(acr>0),'g.');
xlim([0 600]);
xlabel ('$\tau$ (s)','Interpreter', 'Latex');
ylabel('$\langle\hat{v}(t)\cdot\hat{v}(t + \tau)\rangle$','Interpreter','Latex');
title ('Auto-Correlation of velocity direction');
legend('over whole track', 'within runs');
ylim([0.01 1])
snapnow

```
![](cryo_worm_analysis_example_09.png) ## autocorrelate change in heading over time


```
[ac, np, tx] = cryo.autocorrelate('deltatheta','withinRuns',true);
plot(tx, ac./np);
xlim([0 100])
xlabel ('$\tau$ (s)','Interpreter', 'Latex');
ylabel('$\langle\dot{\theta}(t)\ast\dot{\theta}(t + \tau)\rangle$','Interpreter','Latex');
title ('Auto-Correlation of heading angle change');
snapnow

```
![](cryo_worm_analysis_example_10.png) ## a cross correlation

a result of how we're differentiating, or something fundamental?


```
[xc, np, tx] = cryo.crosscorrelate('deltatheta', 'ddtheta', 'withinRuns', true);
plot (tx, xc./np); xlim([-50 50])
xlabel ('$\tau$ (s)','Interpreter', 'Latex');
ylabel('$\langle\ddot{\theta}(t)\ast\dot{\theta}(t + \tau)\rangle$','Interpreter','Latex');
title ('Cross correlation of first and second derivatives of heading');
snapnow

```
![](cryo_worm_analysis_example_11.png) ## test on random noise


```
t = cryo.expt(1).track(1);
t.dq.randomcrap = randn(size(t.dq.eti));
t.dq.srandomcrap = lowpass1D(t.dq.randomcrap, t.dr.smoothTime/t.dr.interpTime);
t.dq.dsrandomcrap = deriv(t.dq.srandomcrap, t.dr.derivTime/t.dr.interpTime);
[xccrap,npcrap,txcrap] = t.crosscorrelate('srandomcrap', 'dsrandomcrap');

dgc = -conv(gausskernel(t.dr.smoothTime/t.dr.interpTime), dgausskernel(t.dr.derivTime/t.dr.interpTime),'same');
dgc = dgc*max(xccrap(round(length(xccrap)/2) + [-100:100])./npcrap(round(length(xccrap)/2) + [-100:100]))/max(dgc);
myt = (1:length(dgc))*t.dr.derivTime;
myt = myt - mean(myt);
plot (tx, xc./np,txcrap,xccrap./npcrap,myt,dgc); xlim([-50 50])

```

```
Warning: Could not find an exact (case-sensitive) match for 'gausskernel'.
c:\matlab track analysis\basic routines\gaussKernel.m is a case-insensitive match and will be
used instead.
You can improve the performance of your code by using exact
name matches and we therefore recommend that you update your
usage accordingly. Alternatively, you can disable this warning using
warning('off','MATLAB:dispatcher:InexactCaseMatch').
This warning will become an error in future releases. 

```
![](cryo_worm_analysis_example_12.png)   

 Published with MATLABÂ® 7\.10  



\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_09\.png (ID: example scripts.html.2\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_08\.png (ID: example scripts.html.3\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_03\.png (ID: example scripts.html.4\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_02\.png (ID: example scripts.html.5\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_01\.png (ID: example scripts.html.6\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_11\.png (ID: example scripts.html.7\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_05\.png (ID: example scripts.html.8\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_04\.png (ID: example scripts.html.9\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_10\.png (ID: example scripts.html.10\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_06\.png (ID: example scripts.html.11\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_12\.png (ID: example scripts.html.12\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example\_07\.png (ID: example scripts.html.13\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: cryo\_worm\_analysis\_example.png (ID: example scripts.html.14\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# Folder: @Track (ID: @Track)

\-\-\-

\#\#\# File: passesThroughBox.m (ID: @Track.1\)

function tf \= passesThroughBox (track, rect, timeInterval, varargin)
% whether a track passed through a region of space in a given time window
% function tf \= passesThroughBox (track, rect, timeInterval, varargin)
%
% outputs: TF(j) \- whether track(j) passes through rect in timeInterval
% inputs: TRACK \< Track
% RECT \- \[xmin xmax ymin ymax]
% TIMEINTERVAL \- \[tmin tmax]
% optional:
% 'locField' \- 'iloc' default

if (length(track) \> 1\)
 tf \= false(size(track));
 for j \= 1:length(tf)
 tf(j) \= track(j).passesThroughBox(rect, timeInterval, varargin{:});
 end
 return;
end

locField \= 'iloc';
varargin \= assignApplicable(varargin);

l \= track.getDerivedQuantity(locField);
t \= track.getDerivedQuantity('eti');

tf \= any(l(1,:) \>\= rect(1\) \& l(1,:) \<\= rect(2\) \& l(2,:) \>\= rect(3\) \& l(2,:) \<\= rect(4\)...
 \& t \>\= timeInterval(1\) \& t \<\= timeInterval(2\));

\-\-\-

\#\#\# File: indsAtTime.m (ID: @Track.2\)

function inds \= indsAtTime(track, elapsedTime)
% finds the indices nearest to the elapsedTime(s) specified;
% function inds \= indsAtTime(track, elapsedTime)
%
% finds the indices nearest to the elapsedTime(s) specified;
% returns no value for out of range indices (so size(inds) is not
% necessarily the same as size(elapsedTime) )
%
% outputs:
% INDS: a list of inds s.t. track.dq.eti(inds) approx ELAPSEDTIME
% inputs:
% TRACK: a member of the Track class
% ELAPSEDTIME: the times to find indices at

x \= track.getDerivedQuantity('eti');
y \= 1:length(x);
inds \= interp1(x, y, elapsedTime, 'nearest', NaN);
inds \= inds(isfinite(inds));
\-\-\-

\#\#\# File: Track.m (ID: @Track.3\)

classdef Track \< handle
 %Track of points loaded from an experiment (.bin) file
 %Tracks can be segmented into runs and reorientations
 %Also includes functions for getting derived information about track
 %(e.g. velocity, path curvature) and plotting tracks
 
 properties(Transient \= true)
 expt; %experiment this track came fro
 end
 
 % properties (AbortSet \= true, Transient \= false)
 
% end
 
 properties
 pt; %array of track points
 dr \= DerivationRules(); %rules for interpolating, smoothing, and differentiating 
 so \= WormSegmentOptions(); %rules for segmenting tracks into runs
 npts \= 0; %total number of points
 nt \= 1; %number of tracks on disk that make up this track
 locInFile \= 0; %the position (in bytes from beginning of file) of the track in the file
 startFrame \= 0; %the index of the first frame in which this track appears
 endFrame \= 0; %the index of the last frame in which this track appears
 isrun \= \[]; %isrun(j) is true if eti(j) is during a run
 iscollision \= \[]; %iscollision(j) is true if eti(j) is during a close pass with another track
 
 dq \= \[]; %derived quantities 
 saveData \= \[]; %store data from transient events to be saved here
 end
 properties (Transient \= true, AbortSet \= true) %no longer save segmentation
 run \= \[]; %periods of forward motion between reorientations
 reorientation \= \[]; %periods of direction change between runs
 end
 properties (Dependent \= true)
 trackNum; %track.expt.track(trackNum) \= track
 end
 
 methods %constructor
 function t \= Track(varargin)
 %constructor
 if (nargin \>\= 1 \&\& isa(varargin{1}, 'Track'))
 t.clone(varargin{1});
 end
 end
 end
 methods %access methods
 function set.reorientation(obj, value)
 if (\~isempty(value) \&\& isa(value, 'TrackPart'))
 \[value.track] \= deal(obj);
 end
 obj.reorientation \= value;
 end
 function set.run(obj, value)
 if (\~isempty(value) \&\& isa(value, 'TrackPart'))

 \[value.track] \= deal(obj);
 end
 obj.run \= value;
 end
 function val \= get.trackNum(obj)
 if (isempty(obj) \|\| isempty(obj.expt) \|\| \~isa(obj.expt, 'Experiment') \|\| isempty(obj.expt.track) \|\| \~isa(obj.expt.track, 'Track'))
 val \= \[];
 return;
 end
 val \= find(obj.expt.track \=\= obj);
 end
 function set.trackNum(obj, value)
 return;
 end
 end
 
 methods(Static)
 track \= fromFile(fid, ptType, loadImageByIndex, loadContour, camcalinfo, minpts);
 varargout \= validDQName (varargin);
 track \= fromJava(jTr, ptType, trInd, loadImageByIndex, loadContour, camcalinfo, minpts);
 function track \= fromMatFile(fname)
 track \= loadObjectTypeFromMatFile(fname, 'Track');
 end
 end
 
 methods(Static, Access \= protected)
 varargout \= nameInList (list, varargin); 
 end
 
 methods 
 plotPath(track, pathType, linetype, varargin);
 % plotSegmentation(track, varargin);
 h \= plotColorPath(track, fieldName, varargin);
 h \= plotFields (track, xfield, yfields, varargin);
 addTime(track, indx, elapsedTime);
 calculateDerivedQuantity(track, quantityName, recalculate);
 recalculateDerivedQuantities(track, varargin); %recalculate all already derived quantities
 qvec \= getDerivedQuantity(track, quantityName, recalculate, varargin);
 qvec \= getSubFieldDQ (track, subfield, quantityName, varargin); 
 c \= precedes(track1, track2, maxFrameDiff, maxDist)
 \[pt, ind, dist] \= nearestPoint(track, loc)
 inds \= indsAtTime(track, elapsedTime);
 % segmentTrack (track, wormSegmentOptions)
 merge(track, track2\)
 track2 \= split(track, splitnum);
 playMovie(track, varargin)
 clickMovie(track, varargin)
 movieOps \= makeMovie(track, movieOps, varargin);
 
 qvec \= fieldAtTime(track, quantityName, elapsedTime);
 addGlobalQuantity (track, quantityName, time, value);
 deleteMe \= trim (track, timerange, validrect);
 \[ps, f, peakfs] \= powerSpectrum(track, quantityName, timeInterval, varargin);
 \[xc, np, tx] \= crosscorrelate (track, fieldname1, fieldname2, varargin);
 \[ac, np, tx] \= autocorrelate (track, fieldname, varargin);
 str \= getReport(track, startInd, endInd, varargin);
 tf \= passesThroughBox (track, rect, timeInterval, varargin);
 function toMatFile(track, fname)
 save(fixFileNameWin(fname), 'track');
 end
 
 
 
 end
 
 
 
 methods(Access \= protected)
 function mo \= makeMovieTrackSpecific(track, mo, pt, iind) %\#ok
 return; % put in specific stuff for maggots, worms, etc. in appropriate tracks
 end
 function clone(tr, oldtr)
 if (\~isa(oldtr, 'Track'))
 return;
 end
 fl \= intersect(fieldnames(tr),fieldnames(oldtr));
 for j \= 1:length(fl)
 tr.(fl{j}) \= oldtr.(fl{j});
 end
 end
 end
 
 
end


\-\-\-

\#\#\# File: clickMovie.m (ID: @Track.4\)

function clickMovie(track, varargin)
%plays a movie repeatedly between two points determined by mouse click
%function clickMovie(track, varargin)
%
%plots the path or segmentation of the track, then waits for user to zoom
%press enter to continue
%then waits for the user to click on points. Plays movie between the first
%point and last point clicked
%
%inputs:
%TRACK: a member of the Track class
%VARARGIN: anything that can be passed to Track/playMovie
f \= gcf;
figure(f);
clf(f);
if (isempty(track.run))
 track.plotPath('loc', 'bd\-', 'MarkerSize', 2, 'LineWidth', 0\.5\); hold on
 track.plotPath('sloc', 'rd\-', 'MarkerSize', 2, 'LineWidth', 0\.5\); hold off
else
 track.plotSegmentation();
end
pause
\[x,y] \= getpts();

clf(f);
while true
 figure(f);
 track.playMovie('startLoc', \[x(1\);y(1\)], 'stopLoc', \[x(end);y(end)], varargin{:});
end
\-\-\-

\#\#\# File: optimumArea.m (ID: @Track.5\)

function \[area, areas, threshold] \= optimumArea(track, varargin)
%function area \= optimumArea(track, varargin)
%
%optional args
%step \= length(track.pt)/200;
%minThresh \= 1;
%maxThresh \= 255;
%minArea \= 5;
%maxArea \= 500;
%scale \= \-1;
%blur \= true;
%showGraphs \= false;

blur \= false;
scale \= \-1;
step \= \[];
varargin \= assignApplicable(varargin);
track.expt.openDataFile;

pt \= \[track.pt];
if (isempty(step))
 step \= ceil(length(pt)/250\);
end
if \~(isa(pt, 'ImTrackPoint'))
 error('Need a track of image points');
end
inds \= 1:step:length(pt);
areas \= zeros(size(inds));
threshold \= zeros(size(inds));

for j \= 1:length(inds)
 if isempty(pt(inds(j)).imData)
 pt2 \= track.expt.reloadPoint(pt(inds(j)));
 im \= pt2\.imData;
 else
 im \= pt(inds(j)).imData;
 end
 if (scale \> 0\)
 im \= imresize(im, scale);
 end
 if (blur)
 imnb \= im;
 scale \= max(scale, 1\);
 im \= blurim(im,scale);
 end
 \[t,a] \= optimumThreshold(im, varargin{:});
 if (blur)
 a \= sum(imnb(:) \> t);
 end
 areas(j) \= a/scale^2;
 threshold(j) \= t;
end
area \= median(areas);
\-\-\-

\#\#\# File: flagReorientations.m (ID: @Track.6\)

function flagReorientations (track, wormSegmentOptions, varargin)
% groups sharp turns into periods of reorientation
% function flagReorientations (track, wormSegmentOptions)
%
% called by SegmentTrack; not usually used directly by end user
%
% outputs: none
% inputs: 
% TRACK: member of the track class (note MaggotTrack segmentation
% proceeds differently)
% WORMSEGMENTOPTIONS: segmentation options, see WormSegmentOptions class
% for details
% optional: 
% 'UseExistingSharpTurns', \[false]/true, if true, don't find new
% sharp turns \-\- so that when we load them from file, we don't nuke
% existing sharp turns \-\- if false, we overwrite existing turns, unless
% user has already started flagging
%
% 'OverwriteExistingSharpTurns', \[false]/true, if true, we
% overwrite existing turns EVEN IF USER HAS ALREADY FLAGGED THEM,
% eliminating user codes


existsAndDefault('wormSegmentOptions', track.so);
wso \= wormSegmentOptions;
track.so \= wso;
UseExistingSharpTurns \= false;
OverwriteExistingSharpTurns \= false;
varargin \= assignApplicable(varargin);


track.calculateDerivedQuantity({'eti', 'sloc', 'theta', 'deltatheta', 'ddtheta'});
if ((OverwriteExistingSharpTurns \|\| \~any(isfinite(\[track.sharpTurn.userCode]))) \&\& \~UseExistingSharpTurns)
 flagOmegaTurnsAndReversals (track, wso, varargin{:});
end
reoind \= 0;
st \= track.sharpTurn;
%group reorientations
%if two sharp turns are less than minRunTime apart (in seconds), they're
%part of the same reorientation
eti \= track.getDerivedQuantity('eti');
inreverse \= false;
for j \= 1:length(st)
 switch st(j).typeCode
 case {\-1,0}
 if (inreverse \&\& eti(st(j).startInd) \- eti(st(j\-1\).endInd) \< wso.maxBackTime)
 nextreo \= false;
 else
 nextreo \= (j \=\= 1 \|\| (eti(st(j).startInd) \- eti(st(j\-1\).endInd) \> wso.minRunTime));
 end
 inreverse \= false;
 case {1,2}
 if (inreverse \&\& eti(st(j).startInd) \- eti(st(j\-1\).endInd) \< wso.maxBackTime)
 st(j).typeCode \= 2;
 nextreo \= false;
 inreverse \= false;
 else
 nextreo \= (j \=\= 1 \|\| (eti(st(j).startInd) \- eti(st(j\-1\).endInd) \> wso.minRunTime));
 inreverse \= true;
 end
 otherwise
 j
 st(j)
 st(j).type
 pause
 end
 if (nextreo) % change from difference in central ind to difference from end to start
 if (reoind \> 0\)
 reo(reoind).calculateMetrics;
 end
 reoind \= reoind\+1;
 reo(reoind) \= WormReorientation(); %\#ok
 end
 reo(reoind).addTurn(st(j)); 
 reo(reoind).calculateMetrics();
end

track.reorientation \= reo;
\-\-\-

\#\#\# File: powerSpectrum.m (ID: @Track.7\)

function \[ps, f, peakfs] \= powerSpectrum(track, quantityName, timeInterval, varargin)
% calculate the power spectrum of quantityName;
% function \[ps, f] \= powerSpectrum(track, quantityName, timeInterval, varargin)
%
% calculate the power spectrum of quantityName; uses a window timeInterval
% long
% outputs:
% PS: the power spectrum
% F: the frequencies at which the power spectrum is defined
% inputs:
% TRACK \< Track
% QUANTITYNAME: the name of the quantity 
% TIMEINTERVAL: the size of the averaging window window
% VARARGINL: optional parameter value pairs
% 'MeanSubtracted', true/false (if true, subtracts mean value before
% computing psd)
%
% see Spectrum; Spectrum/Welch; Spectrum/PSD

MeanSubtracted \= true;
varargin \= assignApplicable(varargin);

Hs \= spectrum.welch('Hamming', timeInterval/track.dr.interpTime);
x \= track.getDerivedQuantity(quantityName);
if (MeanSubtracted)
 x \= x \- repmat(mean(x,2\),\[1 length(x)]);
end
%size(x)
for j \= 1:size(x,1\)
 hpsd \= Hs.psd(x(j,:), 'Fs', 1 / track.dr.interpTime, 'NormalizedFrequency', false);

 ps(j,:) \= hpsd.Data;
 f(j,:) \= hpsd.Frequencies;
 if (nargout \> 2\)
 \[\~,fs] \= hpsd.findPeaks('SORTSTR', 'descend');
 peakfs{j} \= fs;
 end
end


\-\-\-

\#\#\# File: fieldAtTime.m (ID: @Track.8\)

function qvec \= fieldAtTime(track, quantityName, elapsedTime) 
% gets the value(s) of track.dq.quantityName interpolated at elapsedTime(s)
% function qvec \= fieldAtTime(track, quantityName, elapsedTime) 
%
% gets the value(s) of track.dq.quantityName interpolated at elapsedTime(s)
% NaN is returned for any times before or after the end of the track
%
% outputs: 
% QVEC: a kxN array of values
% inputs:
% TRACK: a member of the track class
% QUANTITYNAME: the name of the quantity (see track.getDerivedQuantity)
% ELAPSEDTIME: the times at which to get the values

val \= transpose(track.getDerivedQuantity(quantityName));
x \= transpose(track.getDerivedQuantity('eti'));

qvec \= transpose(interp1(x, val, elapsedTime, 'linear', NaN));

\-\-\-

\#\#\# File: plotPath.m (ID: @Track.9\)

function plotPath(track, pathType, linetype, varargin)
% plots the track path
% function plotPath(track, pathType, linetype, varargin)
%
% outputs: none
% inputs:
% TRACK \< Track; a single track, or a list of tracks. if a list, same
% as calling track(j).plotPath(...) on each track with hold on
% PATHTYPE: the field that gives the location: default 'sloc'
% LINETYPE: a line type specifier, see PLOT. default 'b\-'
% VARARGIN: optional paramter/value pairs:
% 'inds', inds
% 'highlightinds', inds
% 'highlightinds' can also be a field of track, e.g.
% 'iscollision'
% 'highlightlinetype', lt (default 'r.')
% plots with highlightlinetype at highlight inds on top of line
% 'Axes', Axes \-\- which axes to plot in
% any parameter/value pair that can be passed to PLOT
% 'indsExpression', an expression evaluated to provide inds
% e.g. 'track.getDerivedQuantity(''eti'') \< 10'
% 'highlightindsExpression' 
Axes \= \[];
plotEnds \= false;
varargin \= assignApplicable (varargin);
if (isempty(Axes))
 Axes \= gca;
end 

if (length(track) \> 1\)
 ih \= ishold(Axes);
 existsAndDefault('pathType', 'sloc');
 existsAndDefault('linetype', 'b\-');
 for j \= 1:length(track)
 track(j).plotPath(pathType, linetype, 'Axes', Axes, varargin{:});
 hold (Axes,'on');
 end
 if (\~ih)
 hold (Axes,'off');
 end
 return;
end

if (\~exist ('pathType', 'var') \|\| isempty(pathType))
 pathType \= 'sloc';
end

x \= track.getDerivedQuantity(pathType);

inds \= 1:length(x);

highlightinds \= \[];
highlightlinetype \= 'r.';

if (\~exist ('linetype', 'var') \|\| isempty(linetype))
 linetype \= 'b\-';
end
indsExpression \= \[];
highlightindsExpression \= \[];
varargin \= assignApplicable (varargin);
if (\~isempty(indsExpression))
 inds \= eval(indsExpression);
end
if (\~isempty(highlightindsExpression))
 highlightinds \= eval(highlightindsExpression);
end

if (ischar(highlightinds) \&\& any(strcmp(properties(track), highlightinds)))
 highlightinds \= track.(highlightinds);
 if (length(highlightinds) \=\= length(x))
 highlightinds \= logical(highlightinds);
 end
 
end

%{
if (\~isfield (track.dq, 'sloc'))
 x \= \[track.pt.loc];
else
 x \= track.dq.sloc;
end
%}
inds \= inds(inds \> 0 \& inds \<\= length(track.dq.eti));

if (isempty(highlightinds))
 plot (Axes, x(1,inds), x(2,inds),linetype,varargin{:});
else
 plot (Axes, x(1,inds), x(2,inds),linetype, x(1,highlightinds), x(2,highlightinds), highlightlinetype, varargin{:});
end

if (plotEnds)
 try
 color \= linetype(1\); 
 hold on;
 scatter(Axes, x(1,1\), x(2,1\), \[color 'o']); 
 scatter(Axes, x(1,end), x(2,end), \[color 'o']);
 scatter(Axes, x(1,end), x(2,end), \[color 'x']);
 hold off;
 catch e
 hold on;
 scatter(Axes, x(1,1\), x(2,1\), 'bo'); 
 scatter(Axes, x(1,end), x(2,end), 'bo');
 scatter(Axes, x(1,end), x(2,end), 'bx');
 hold off;
 end
end

\-\-\-

\#\#\# File: crosscorrelate.m (ID: @Track.10\)

function \[xc, np, tx] \= crosscorrelate (track, fieldname1, fieldname2, varargin)
%cross correlates fieldname1 and fieldname2
%function \[xc, np, tx] \= crosscorrelate (track, fieldname1, fieldname2, varargin)
%
%returns the cross correlation for tracks.dq.(fieldname1\) tracks.dq.(fieldname2\) 
%we define the cross\-correlation to be
%xc(T) \= ; \-N denotes the average
%XC is the return 1x(2N\-1\) vector XC(j) \= xc(j\-N);
%
%outputs:
%XC is the unnormalized cross correlation (normalized is XC./NP)
%NP is the number of points contributing to a certain bin
%TX is the time axis for the cross correlation, so if TX(j) \= tau, then
% XC(j) \= xc(tau)
%
%inputs:
%TRACK: a member of the Track class
%FIELDNAME1, FIELDNAME2: the names of the fields to cross\-correlate
%VARARGIN: any parameter/value pair below
%
%'row', row number(s)
% if row \= m, just finds the correlation of track.dq.(fieldnames)(m,:)
%'inRuns', true/false
% if inRuns is true, we take the autocorrelation over the whole track, but
% first interpolate the fields over only the run indices
% this is useful if the fields are ill\-defined between runs (e.g. velocity
% direction)
%'withinRuns', true/false
% if withinRuns is true, we find the correlation only within each run
%'isangle', true/false
% if isangle is true, then we compute the correlation as cos (theta1 \-
% theta2\) instead of as theta1\*theta2
%'timerange', \[mintime maxtime] \-\- only consider data from this time range

q1 \= track.getDerivedQuantity(fieldname1\);
q2 \= track.getDerivedQuantity(fieldname2\);
eti \= track.getDerivedQuantity('eti');
timerange \= \[];%\[min(eti) max(eti)];
isangle \= false; 

row \= 1:size(q1, 1\);
inRuns \= false;
withinRuns \= false;
varargin \= assignApplicable(varargin);
if (isempty(timerange))
 timerange \= \[min(eti) max(eti)];
end
validtime \= eti \>\= min(timerange) \& eti \<\= max(timerange);


if (isangle)
 if ((size(q1,1\)) \~\= 1\)
 error ('Asked to correlate a field as an angle, but passed a vector field, not a scalar field');
 end
 q1 \= unwrap(q1\);
 q2 \= unwrap(q2\);
end
 

if (inRuns)
 if isempty(track.run)
 inds \= \[];
 else
 inds \= find(track.isrun);
 end
 if (isempty(inds))
 xc \= \[];
 tx \= \[];
 np \= 0;
% warning('GERSHOW:XC02', 'you asked for values in runs, but track.run is empty or has no points');
 return;
 end
 allinds \= min(inds):max(inds);
 extrapval \= zeros(size(q1(:,1\)));
 if (isangle)
 q1 \= interp1(inds, q1(:,inds)', allinds, 'linear');
 q2 \= interp1(inds, q2(:,inds)', allinds, 'linear');
 else 
 q1 \= interp1(inds, q1(:,inds)', allinds, 'linear','extrap',extrapval)';
 q2 \= interp1(inds, q2(:,inds)', allinds, 'linear','extrap',extrapval)';
 end
 validtime \= validtime(1,allinds);
end

if (isangle)
 q1 \= \[cos(q1\);sin(q1\)];
 q2 \= \[cos(q2\);sin(q2\)];
 row \= 1:2;
end

if (withinRuns)
 \[xc,np,tx] \= crossCorrelateRuns(track, q1, q2, row, validtime);
 return
end

if (any(\~isfinite(q1(:))) \|\| any (\~isfinite(q2(:))))
 xc \= \[];
 tx \= \[];
 np \= 0;
 warning('GERSHOW:XC01', 'non\-finite value encountered: not computing correlation');
 return;
end

\[\~, xc, np] \= xcorrVec(q1(row,validtime), q2(row,validtime));
tx \= ((1:length(xc)) \- nnz(validtime))\*track.dr.interpTime;

function \[xc, np, tx, nr] \= crossCorrelateRuns(track, q1, q2, row, validtime)

npr \= zeros(size(track.run));

 for j \= 1:length(track.run)
 npr(j) \= length(track.run(j).inds);
 end
 N \= max(npr);

 xc \= zeros(\[1 2\*N\-1]);
 np \= xc;
 nr \= np;
 tx \= ((1:(2\*N\-1\)) \- N)\*track.dr.interpTime;

 for j \= 1:length(track.run)
 if any(\~validtime(track.run(j).inds))
 continue;
 end
 if (any(any(\~isfinite(q1(row,track.run(j).inds)))) \|\| any(any(\~isfinite(q2(row,track.run(j).inds)))))
 warning('GERSHOW:XC01', 'non\-finite value encountered: not computing correlation');
 continue;
 end
 \[\~, x, npt] \= xcorrVec(q1(row,track.run(j).inds), q2(row,track.run(j).inds));
 n \= (length(x) \+ 1\) / 2;
 if (isempty(x))
 continue;
 end
 
 xc((N\-n\+1\):(N\+n\-1\)) \= xc((N\-n\+1\):(N\+n\-1\)) \+ x;
 np((N\-n\+1\):(N\+n\-1\)) \= np((N\-n\+1\):(N\+n\-1\)) \+ npt;
 nr((N\-n\+1\):(N\+n\-1\)) \= nr((N\-n\+1\):(N\+n\-1\)) \+ 1;
 end

\-\-\-

\#\#\# File: getReport.m (ID: @Track.11\)

function str \= getReport(track, startInd, endInd, varargin)
% returns in str a text report about the segment of track 
% function str \= getReport(track, startInd, endInd, varargin)
%
% output: 
% STR \- a string with the report
% input:
% TRACK \< Track
% startInd: starting index of segment (\[] for 1\)
% endInd: ending index of segment (\[] for end of track)
% optional args:
% 'tpreport', \[true]/false \- whether to generate a report for each
% run \& reorientation

existsAndDefault('startInd', 1\);
existsAndDefault('endInd', length(track.getDerivedQuantity('eti')));

if (startInd \> endInd)
 temp \= startInd;
 startInd \= endInd;
 endInd \= temp;
end

tpreport \= true;
precision \= '%.1f';
varargin \= assignApplicable(varargin);

time \= track.getDerivedQuantity('eti', false, \[startInd endInd]);
loc \= track.getDerivedQuantity('iloc', false, \[startInd endInd]);
displacement \= diff(track.getDerivedQuantity('pathLength', false, \[startInd endInd]));

locStr \= \['Segment starts at time ' num2str(time(1\), precision) ' x,y \= ' num2str(loc(1,1\),precision) ',' num2str(loc(2,1\),precision)...
 ' and ends at time ' num2str(time(2\),precision) ' x,y \= ' num2str(loc(1,2\), precision) ',' num2str(loc(2,2\),precision)];
 
dx \= diff(loc,\[],2\);

straightDist \= sqrt(sum(dx.^2\));
straightAngle \= rad2deg(atan2(dx(2\), dx(1\)));
displacementStr \= \['Elapsed time: ' num2str(diff(time), precision) 's Straight line distance \= ' num2str(straightDist, precision) ...
 ' angle \= ' num2str(straightAngle, precision) '(d) Path length \= ' num2str(displacement, precision)];
 
 
if (\~isempty(track.run))
 runinds \= find(\[track.run.endInd] \> startInd \& \[track.run.startInd] \< endInd);
 if \~isempty(runinds)
 runstr \= \['Segment intersects ' num2str(length(runinds)) ' runs'];
 else
 runstr \= 'Segment intersects no runs';
 end
else
 runstr \= 'Track was not segmented, or has no runs';
end

if (\~isempty(track.reorientation))
 reoinds \= find(\[track.reorientation.endInd] \> startInd \& \[track.reorientation.startInd] \< endInd);
 if \~isempty(reoinds)
 reostr \= \['Segment intersects ' num2str(length(reoinds)) ' reorientations'];
 else
 reostr \= 'Segment intersects no reorientations';
 end
else
 reostr \= \[];
end


str \= {locStr, displacementStr, runstr, reostr};
if (tpreport)
 if (\~isempty(track.run) \&\& \~isempty(track.reorientation)) 
 tp \= \[num2cell(track.run(runinds)), num2cell(track.reorientation(reoinds))];
 si \= zeros(size(tp));
 for j \= 1:length(tp)
 si(j) \= tp{j}.startInd;
 end
 \[\~,I] \= sort(si);
 for j \= I
 rp \= tp{j}.getReport('precision', precision);
 str \= \[str, '\-\-\-\-', rp{:}];
 end
 else
 if (\~isempty(track.run))
 for j \= runinds
 rp \= track.run(j).getReport('precision', precision);
 str \= \[str, '\-\-\-\-', rp{:}];
 end
 end
 if (\~isempty(track.reorientation))
 for j \= reoinds
 rp \= track.reorientation(j).getReport('precision', precision);
 str \= \[str, '\-\-\-\-', rp{:}];
 end
 end
 end
end
\-\-\-

\#\#\# File: playMovie.m (ID: @Track.12\)

function playMovie(track, varargin)
% plays a movie of the track with annotation
% function playMovie(track, varargin)
% outputs, none
% inputs:
% TRACK \< Track;
% VARARGIN:
% enter options as pairs, caps matter
% options, with defaults
%
% ptbuffer \= 200; \-\- how many points on either side of the current point
% to plot in annotations
% delayTime \= 0\.05; \-\- interframe delay
% axisSize (size of image or 50\) \-\- size of axes containing image
% inds \= 1:length(track.pt); \-\- inds to play
% iinds \= \[]; interped inds; if passed, we find inds \=
% gdq(mapinterpedtopts,iinds)
% startLoc \= \[];
% stopLoc \= \[]; if startLoc \& stopLoc are both not empty, we run the movie
% between these two points
% startTime \= \[];
% stopTime \= \[]; if startTime \& stopTime are both not empty, we run the
% movie between these times
% locField \= 'sloc'; what field to use to plot the path over the movie
% image


ptbuffer \= 200;
delayTime \= 0\.1;

axisSize \= max(size(track.pt(1\).imData));
if (axisSize \<\= 0\)
 axisSize \= 50;
end
iinds \= \[];
inds \= 1:length(track.pt);
startLoc \= \[];
stopLoc \= \[];
startTime \= \[];
stopTime \= \[];
track.expt.openDataFile;
fid \= track.expt.fid;
locField \= 'sloc';
varargin \= assignApplicable(varargin);
if (\~isempty(iinds))
 inds \= track.getDerivedQuantity('mapinterpedtopts', false,iinds);
end
if (\~isempty(startLoc) \&\& \~isempty(stopLoc))
 \[\~,s] \= track.nearestPoint (startLoc);
 \[\~,e] \= track.nearestPoint (stopLoc);
 if (s \> e)
 inds \= e:s;
 else
 inds \= s:e;
 end
end
pt \= \[track.pt];
if (\~isempty(startTime) \&\& \~isempty(stopTime))
 s \= find(\[pt.et] \>\= startTime, 1, 'first');
 e \= find(\[pt.et] \<\= stopTime, 1, 'last');
 inds \= s:e;
end
loc \= \[pt.loc];
sloc \= double(track.getDerivedQuantity(locField));
sind \= track.getDerivedQuantity('mapptstointerped');
track.calculateDerivedQuantity({'speed', 'deltatheta', 'ddtheta'});
sstart \= sind(1\) \- ptbuffer;
send \= sind(end) \+ ptbuffer;


if (sstart \< 1\)
 sstart \= 1;
end
if (send \> length(sloc))
 send \= length(sloc);
end
st \= \[track.sharpTurn];
if (\~isempty(st))
 st \= st(\[st.endInd] \> sstart \& \[st.startInd] \< send);
 revinds \= \[st(\[st.typeCode] \> 0\).centralInd];
 omegainds \= \[st(\[st.typeCode] \< 0\).centralInd];
 blipinds \= \[st(\[st.typeCode] \=\= 0\).centralInd];
else
 revinds \= \[];
 omegainds \= \[];
 blipinds \= \[];
end
datafields(track, sstart:send);
handles \= \[];
for j \= inds
 ts1 \= tic();
 subplot(2,2,1\); hold off; cla
 pt(j).drawTrackImage(\[],'fid', fid, varargin{:}); 
 
 %pause
 
 hold on
 sstart \= sind(j) \- ptbuffer;
 send \= sind(j) \+ ptbuffer;
 if (sstart \< 1\)
 sstart \= 1;
 end
 if (send \> length(sloc))
 send \= length(sloc);
 end
 
 plot (sloc(1,sstart:send), sloc(2,sstart:send), 'b.\-');
 plot (sloc(1,sind(j)), sloc(2,sind(j)), 'bo', 'MarkerSize', 5\);
 
 % pause
 
 rloc \= sloc(:,revinds(revinds \> sstart \& revinds \< send));
 oloc \= sloc(:,omegainds(omegainds \> sstart \& omegainds \< send));
 bloc \= sloc(:,blipinds(blipinds \> sstart \& blipinds \< send));
 rloc \= rloc(:,abs(rloc(1,:) \- loc(1,j)) \< axisSize/2 \& abs(rloc(2,:) \- loc(2,j)) \< axisSize/2\);
 oloc \= oloc(:,abs(oloc(1,:) \- loc(1,j)) \< axisSize/2 \& abs(oloc(2,:) \- loc(2,j)) \< axisSize/2\);
 bloc \= bloc(:,abs(bloc(1,:) \- loc(1,j)) \< axisSize/2 \& abs(bloc(2,:) \- loc(2,j)) \< axisSize/2\);
 
 
 if (\~isempty(rloc))
 text(rloc(1,:), rloc(2,:), 'R', 'Color', 'r', 'HorizontalAlignment', 'Center');
 end
 if (\~isempty(oloc))
 text(oloc(1,:), oloc(2,:), '\\Omega', 'Color', 'm', 'HorizontalAlignment', 'Center');
 end
 if (\~isempty(bloc))
 text(bloc(1,:), bloc(2,:), 'b', 'Color', 'g', 'HorizontalAlignment', 'Center');
 end
 %plot (sloc(1,ri), sloc(2,ri), 'r.', sloc(1,oi), sloc(2,oi), 'm.', sloc(1,bi), sloc(2,bi), 'g.',...
 % 'MarkerSize', 10\);
 
 % pause
 
 axis (\[loc(1,j) \+ \[\-axisSize/2 axisSize/2], loc(2,j) \+ \[\-axisSize/2 axisSize/2]]);
 axis equal; 
 axis (\[loc(1,j) \+ \[\-axisSize/2 axisSize/2], loc(2,j) \+ \[\-axisSize/2 axisSize/2]]);
 hold off
 set(gca, 'XTick', \[], 'YTick', \[]);
 if (\~isempty(track.run))
 t \= \[];
 if (track.isrun(sind(j)))
 t \= 'run';
 end

 if (\~isempty(track.reorientation) \&\& any(\[track.reorientation.inds] \=\= sind(j)))
 t \= 'reorientation';
 end
 title (t);
 end
 
 % pause
 
 handles \= updateCenter(handles, track, sind(j), sstart, send);
 
 timeleft \= delayTime \- toc(ts1\);
 if (timeleft \> 0\)
 pause(timeleft);
 else
 pause(0\.01\);
 end
 
 % pause
end
%{
drawtime
tracktime
otherplotstime
%}
end

function datafields(track, inds)
 fields \= {'deltatheta','scovRatio','speed'};
 track.calculateDerivedQuantity(fields);
 mult \= \[rad2deg(1\), 1, 1];
 for k \= 1:3
 subplot(2,2,k\+1\); hold off
 plot (track.dq.eti(inds), mult(k)\*track.dq.(fields{k})(inds), 'k.', 'MarkerSize', 5\); hold on
 
 
 if (\~isempty(track.run))
 runinds \= find(\[track.run.endInd] \> inds(1\) \& \[track.run.startInd] \< inds(end));
 else
 runinds \= \[];
 end
 for j \= runinds;
 plot (track.dq.eti(track.run(j).inds), mult(k)\*track.dq.(fields{k})(track.run(j).inds), 'm\-','LineWidth',2\);
 end
 title(fields{k});
 end

 spfields \= {{'dthetaHiThresh', 'dthetaLoThresh','straightThetaThresh'},{}, {}};
 spcolors \= {{'r\-','g\-','m\-'},{}, {}};
 spmirror \= \[1 0 0];
 for k \= 1:3
 subplot(2,2,k\+1\);
 x \= track.dq.eti(inds);
 for j \= 1:length(spfields{k})
 f \= spfields{k}{j};
 c \= spcolors{k}{j};
 y \= repmat (mult(k)\*track.so.(f), size(x));
 plot (x,y,c);
 if (spmirror(k));
 plot (x,\-y,c);
 end
 end
 end
end

function handles \= updateCenter(handles, track, cind, start, stop)
 if \~isempty(handles)
 for j \= 1:length(handles)
 delete(handles(j));
 end
 end
 fields \= {'deltatheta','scovRatio','speed'};
 mult \= \[rad2deg(1\), 1, 1];
 for k \= 1:3
 subplot(2,2,k\+1\); hold on
 ih \= ishold;
 handles(k) \= plot (track.dq.eti(cind), mult(k)\*track.dq.(fields{k})(cind), 'c.','MarkerSize',25\);
 xlim(\[min(track.dq.eti(start)) max(track.dq.eti(stop))]);
 if (\~ih)
 hold off
 end
 if (k \=\= 2\)
 ylim(\[1 4]);
 end
 end
end 





\-\-\-

\#\#\# File: precedes.m (ID: @Track.13\)

function c \= precedes(track1, track2, maxFrameDiff, maxDist)
% true if track1 precedes track2 in a stitch tracks sense
% function c \= precedes(track1, track2, maxFrameDiff, maxDist)
% utility function:
% returns true iff track2 starts within maxFrameDiff after the end of track1
% AND the distance between the start of track2 and the end of track 1 \<
% maxDist
%
% if track2 is a vector, returns a bool vector indicating whether track1
% preceds each element of track2
%
% outputs: 
% C: TRUE OR FALSE 
% inputs:
% TRACK1, TRACK2 \< Track
% MAXFRAMEDIFF: maximum number of frames between end of track1 \& start of
% track2 for C to be true
% MAXDIST: maximum distance between the end of track1 \& start of track 2
% for C to be true

if (length(track2\) \> 1\)
 c \= false(size(track2\));
 for j \= 1:length(track2\)
 c(j) \= precedes(track1, track2(j), maxFrameDiff, maxDist);
 end
 return;
end

c \= (track1\.pt(end).ind \< track2\.pt(1\).ind \&\& track1\.pt(end).ind \+ maxFrameDiff \>\= track2\.pt(1\).ind ...
 \&\& track1\.pt(end).distance(track2\.pt(1\)) \< maxDist);

\-\-\-

\#\#\# File: recalculateDerivedQuantities.m (ID: @Track.14\)

function recalculateDerivedQuantities(track, varargin)
% clears and recalculates all derived quantities
% function recalculateDerivedQuantities(track, varargin)
% outputs: none
% inputs:
% TRACK \< Track
% VARARGIN: if a list of field names is passed, only those fields are cleared
% and recalculated

if (isempty(track.dq))
 return;
end

fnames \= fieldnames(track.dq);
valid \= track.validDQName(fnames);
vf \= fnames(valid);
if (\~isempty(varargin))
 if (iscell(varargin{1}))
 vf \= intersect(vf, varargin{1});
 else
 vf \= intersect(vf, varargin);
 end
end

if (isempty(vf))
 return;
end
%vf
track.dq \= rmfield(track.dq, vf);
%track.dq \= \[];

track.calculateDerivedQuantity(vf);

\-\-\-

\#\#\# File: addTime.m (ID: @Track.15\)

function addTime(track, indx, elapsedTime)
%adds timing information to a track
%function addTime(track, indx, elapsedTime)
%track.addTime(indx, elapsedTime)
%
%inputs:
%TRACK: a member of the track class
%INDX: a list of frame indices
%ELAPSEDTIME: a list of times in seconds
%frame indx(j) occurred at elapsedTime(j)
if (isempty(elapsedTime))
 return;
end

try
 pt \= \[track.pt];
 et \= interp1(indx, elapsedTime, double(\[pt.ind]),'linear', NaN);
 pt \= pt(isfinite(et));
 et \= num2cell(et(isfinite(et)));
 \[pt.et] \= et{:};
 track.pt \= pt;
 track.npts \= length(track.pt);
 track.startFrame \= pt(1\).ind;
 track.endFrame \= pt(end).ind;
catch e
 disp(\['error adding time to track ' int2str(track.locInFile)]);
end
\-\-\-

\#\#\# File: plotFields.m (ID: @Track.16\)

function h \= plotFields (track, xfield, yfields, varargin)
%plots multiple yfields against one x field
%function plotFields (track, xfield, yfields, varargin)
%
%inputs:
% track \< Track
% xfield: the field defining the x variable
% yfield: the fields defining the y variables
%outputs:
% h \< graphics handle
%optional arguments:
% 'inds', inds to plot (default all)
% 'Axes', axes to plot in (default gca)
% 'makeLegend', whether to display the legend (default true)
% anything that can be passed to plot
% 'labeled', if true, label according to segmentation
% 
% if length(xfield) \= length(yfields) \= length(Axes), plots yfields{j}
% vs. xfield{j} in Axes(j)
Axes \= \[];
varargin \= assignApplicable(varargin);
if (iscell(xfield) \&\& iscell(yfield) \&\& length(xfield) \=\= length(yfields) \&\& length(xfield) \=\= length(Axes) \&\& length(Axes) \> 1\)
 for j \= 1:length(Axes)
 plotFields(track, xfield{j}, yfields{j}, 'Axes', Axes(j), varargin{:});
 end
 return
end
inds \= \[];
makeLegend \= true;
labeled \= false;
varargin \= assignApplicable(varargin);

if (isempty(Axes))
 Axes \= gca;
end


if (isempty(inds))
 x \= track.getDerivedQuantity(xfield);
 inds \= 1:length(x);
else
 x \= track.getDerivedQuantity(xfield,false,inds);
end
y \= \[];
if (\~iscell(yfields))
 yfields \= {yfields};
end
leg \= {};
for j \= 1:length(yfields)
 yf \= track.getDerivedQuantity(yfields{j},false,inds);
 if size(yf,1\) \=\= 1
 leg \= \[leg, yfields{j}];
 else
 for k \= 1:size(yf,1\)
 leg \= \[leg, \[yfields{j} '(' num2str(k) ')']];
 end
 end
 y \= \[y;yf];
end

hh \= plot (Axes, x, y, varargin{:});

hl \= \[];
lleg \= {};
if (labeled \&\& \~isempty(track.run) \&\& isa(track.run, 'Run') \&\& any(track.isrun(inds)))
 hold(Axes,'on');
 hlt \= plot(Axes, x(track.isrun(inds)), y(:, track.isrun(inds)),'m.','MarkerSize',5\);
 hl \= \[hl hlt(1\)];
 lleg \= \[lleg, 'run'];
 hold(Axes,'off');
end
if (labeled \&\& \~isa(track, 'MaggotTrack') \&\& \~isempty(track.sharpTurn) \&\& isa(track.sharpTurn, 'WormSharpTurn'))
 hold(Axes,'on');
 st \= track.sharpTurn;
 mcolors \= {'c\*', 'yo', 'rh', 'gh'};
 for j \= \-1:1:2
 if (\~any(\[st.typeCode] \=\= j))
 continue;
 end
 \[\~,indsom] \= intersect(inds, \[st(\[st.typeCode] \=\= j).inds]);
 if (\~isempty(indsom))
 hlt \= plot(Axes, x(indsom), y(:, indsom),mcolors{j\+2},'MarkerSize',5\);
 hl \= \[hl hlt(1\)];
 lleg \= \[lleg, st(find(\[st.typeCode]\=\=j,1\)).type];
 end
 end
 hold(Axes,'off');
end
 
if (makeLegend)
 xlabel(Axes, xfield);
 if (\~isempty(hl));
 legend(Axes, \[hh; hl'], \[leg, lleg]);
 else
 legend(Axes, hh,leg);
 end
end
if (nargout \> 0\)
 h \= hh;
end
\-\-\-

\#\#\# File: addGlobalQuantity.m (ID: @Track.17\)

function addGlobalQuantity (track, quantityName, time, value) 
%function addGlobalQuantity (track, quantityName, time, value) 
%
%this function will eventually migrate to
%addGlobalQuantity(track,globalQuantity) where globalQuantity is a member
%of the GlobalQuantity class
%
%adds a field called quantityName to track.dq
%value of this field is interp1(time, value, track.dq.eti, 'linear', NaN)
disp('Track.addGlobalQuantity is deprecated and will be removed; use addQuantityToTrack (gq, track) in GlobalQuantity class instead');

track.dq.(quantityName) \= interp1(time, value, track.getDerivedQuantity('eti'), 'linear', NaN);


\-\-\-

\#\#\# File: nameInList.m (ID: @Track.18\)

function varargout \= nameInList (list, varargin)
% varargout \= Track.nameInList (list, varargin)
% helper function for validDQName

switch (nargin\-1\)
 case 0
 varargout{1} \= list;
 case 1
 if (iscell(varargin{1}))
 tfarray \= repmat(false, size(varargin{1}));
 for j \= 1:length(varargin{1})
 tfarray(j) \= Track.nameInList(list, varargin{1}{j});
 end
 varargout{1} \= tfarray;
 else 
 varargout{1} \= (ischar(varargin{1}) \&\& (any(strcmp(varargin{1}, list))));
 end
 otherwise
 for j \= 1:(nargin\-1\)
 varargout{j} \= Track.nameInList(list, varargin{j});
 end
end
\-\-\-

\#\#\# File: fromJava.m (ID: @Track.19\)

function track \= fromJava(jTr, ptType, trInd, loadImageByIndex, loadContour, camcalinfo, minpts)
%Used in ExFromJava to load a Track object from a TrackExtrationJava.Track
% C:\\Users\\Natalie\\Documents\\GitHub\\Matlab\-Track\-Analysis\\@Track\\fromFile.m

% set flags/parameters
if (\~exist ('loadImageByIndex', 'var'))
 loadImageByIndex \= \[];
end
if (\~exist ('loadContour', 'var') \|\| isempty (loadContour))
 loadContour \= true;
end
if (\~exist ('camcalinfo', 'var')) 
 camcalinfo \= \[];
end
existsAndDefault('minpts', 0\);

% Check point type, create track, and set some so's if camcalinfo exists
if (isa(ptType, 'LarvaTrackPoint'))
 track \= LarvaTrack();
 if (\~isempty(camcalinfo)) %real points instead of camera points
 track.so.stop\_speed\_cut \= 0\.01;
 track.so.start\_speed\_cut \= 0\.015;
 track.so.curv\_cut \= 50;
 end
elseif (isa(ptType, 'MaggotTrackPoint'))
 track \= MaggotTrack();
 if (\~isempty(camcalinfo)) %real points instead of camera points
 track.so.stop\_speed\_cut \= 0\.01;
 track.so.start\_speed\_cut \= 0\.015;
 track.so.curv\_cut \= 50;
 end
else
 track \= WormTrack();
end

%Set locinFile? (trackID is \*indicative\* of locInFile...)
track.locInFile \= jTr.getTrackID();

% Determine nPts
track.npts \= jTr.getNumPoints;

% If the track is going to get clipped from the experiment, don't bother with the rest
if (track.npts \>\= minpts) 
 % \~\~ Ensure that loadImageByIndex.length \= nPts
 if (length (loadImageByIndex) \~\= track.npts)
 if (length(loadImageByIndex) \=\= 1\)
 loadImageByIndex \= repmat(loadImageByIndex, \[1 track.npts]);
 else
 if (\~isempty(loadImageByIndex))
 disp(\['length of loadImageByIndex \= ' num2str(length(loadImageByIndex)) ' but track.npts \= ' num2str(track.npts)]);
 end
 %By default, don't load any images
 loadImageByIndex \= true(\[1 track.npts]);%%TEMP
 end
 end
 
 % \~\~ Loop through nPts pts \& add points
 pts(track.npts) \= ptType;
 for i \= 0:(track.npts\-1\)
 pts(i\+1\) \= ptType.fromJava(jTr.getPoint(int32(i)), loadImageByIndex(i\+1\), loadContour, camcalinfo);
 end

 % \~\~ Set points
 track.pt \= pts;
 
 % \~\~ Set startFrame\&endFrame
 track.startFrame \= jTr.getStart.getFrameNum;
 track.endFrame \= jTr.getEnd.getFrameNum;
end


end
\-\-\-

\#\#\# File: nearestPoint.m (ID: @Track.20\)

function \[pt, ind, dist] \= nearestPoint(track, loc)
% finds the nearest point(s) in a track to given location(s)
% function \[pt, ind, dist] \= nearestPoint(track, loc)
%
% outputs:
% PT: TrackPoint(s) that duplicate the point(s) closest to LOC(s)
% IND: the index(ices) of the closest point(s) in TRACK
% DIST: the distance(s) between LOC(s) and PT(s)
% inputs:
% TRACK: a member of the track class
% LOC: (optional) a 2xN location vector
% if loc is empty, user is prompted for graphical input using getpts
updatept \= false;
if (\~exist('loc', 'var') \|\| isempty(loc))
 \[x,y] \= getpts();
 loc \= (\[x y])';
 size(loc)
 updatept \= true;
end

if (size(loc,2\) \> 1\)
 for j \= 1:size(loc,2\)
 \[p,i,d] \= nearestPoint (track, loc(:,j));
 pt(j) \= p;
 ind(j) \= i;
 dist(j) \= d;
 end
else 
 pt \= \[track.pt];
 \[dist, ind] \= min (sum((\[pt.loc] \- repmat(loc, \[1 length(track.pt)])).^2, 1\));
 pt \= track.pt(ind);
 dist \= sqrt(dist);
end

if (updatept)
 hh \= ishold;
 hold on;
 lnew \= \[pt.loc];
 plot (loc(1,:), loc(2,:), 'gx', lnew(1,:), lnew(2,:), 'ro');
 if (\~hh)
 hold off
 end
end
\-\-\-

\#\#\# File: autocorrelate.m (ID: @Track.21\)

function \[ac, np, tx] \= autocorrelate (track, fieldname, varargin)
%returns the auto correlation for track.dq.(fieldnames)
%function \[ac, np, tx] \= crosscorrelate (track, fieldname, varargin)
%
%
%outputs:
%AC is the unnormalized auto\-correlation (normalized is xc./np)
%NP is the number of points contributing to a certain bin
%TX is the time axis for the cross correlation
%
%we define the auto\-correlation to be
%ac(T) \= ; 0 denotes the average
%AC is the return 1xN vector AC(j) \= AC(j\-1\);
%
%inputs:
%TRACK: a member of the Track class
%FIELDNAME: the name of the field to auto\-correlate
%VARARGIN: any parameter/value pair passed to Track/crosscorrelate, see
%below
%
%arguments to pass in:
%'row', row number(s)
%if row \= m, just finds the correlation of track.dq.(fieldnames)(m,:)\\
%'inRuns', true/false
%if inRuns is true, we take the autocorrelation over the whole track, but
%first interpolate the fields over only the run indices
%this is useful if the fields are ill\-defined between runs (e.g. velocity
%direction)
%'withinRuns', true/false
%if withinRuns is true, we find the correlation only within each run
%'timerange', \[mintime maxtime] \-\- only consider data from this time range


\[xc, np, tx] \= track.crosscorrelate(fieldname, fieldname, varargin{:});
if (\~isempty(xc))
 %n \= ceil(length(xc)/2\);
 n \= find(tx \=\= 0, 1\);
end
ac \= xc(:,n:end);
np \= np(n:end);
tx \= tx(n:end);

\-\-\-

\#\#\# File: fromFile.m (ID: @Track.22\)

function track \= fromFile(fid, ptType, loadImageByIndex, loadContour, camcalinfo, minpts)
% loads a track from disk
% function track \= fromFile(fid, ptType, loadImageByIndex, loadContour,
% camcalinfo)
%
% outputs:
% TRACK: a track or a maggot track
% inputs:
% FID: open file ID
% PTTYPE: a TrackPoint or subclass thereof; tells how to load points
% LOADIMAGEBYINDEX: image(j) is loaded if loadImageByIndex(j) is true
% LOADCONTOUR: if the maggot contour should be stored on loading (only valid
% for MaggotPoint)
% CAMCALINFO: optional information to turn pixel coordinates into real
% coordinates
% MINPTS: tracks is not loaded if it has fewer than MINPTS, but the fid
% pointer is advanced to the next track



if (\~exist ('loadImageByIndex', 'var'))
 loadImageByIndex \= \[];
end
if (\~exist ('loadContour', 'var') \|\| isempty (loadContour))
 loadContour \= true;
end
if (\~exist ('camcalinfo', 'var')) 
 camcalinfo \= \[];
end
existsAndDefault('minpts', 0\);

intType \= 'int32';
floatType \= 'float32';
if (isa(ptType, 'MaggotTrackPoint'))
 track \= MaggotTrack();
 if (\~isempty(camcalinfo)) %real points instead of camera points
 track.so.stop\_speed\_cut \= 0\.01;
 track.so.start\_speed\_cut \= 0\.015;
 track.so.curv\_cut \= 50;
 end
else
 track \= WormTrack();
end
track.locInFile \= ftell(fid);
nbytes \= fread(fid,1,intType);
startOfTrackPosition \= ftell(fid);
track.npts \= fread(fid, 1, intType);
if (track.npts \>\= minpts)
 
 if (length (loadImageByIndex) \~\= track.npts)
 if (length(loadImageByIndex) \=\= 1\)
 loadImageByIndex \= repmat(loadImageByIndex, \[1 track.npts]);
 else
 if (\~isempty(loadImageByIndex))
 disp(\['length of loadImageByIndex \= ' num2str(length(loadImageByIndex)) ' but track.npts \= ' num2str(track.npts)]);
 end
 loadImageByIndex \= repmat(false, \[1 track.npts]);
 end
 end
 bob \= repmat(ptType, \[1 track.npts]);
 %ts \= tic;

 for j \= 1:track.npts
 
 % track.pt(j) \= track.pt(j).fromFile(fid, loadImageByIndex(j), loadContour, camcalinfo); 
 bob(j) \= ptType.fromFile(fid, loadImageByIndex(j), loadContour, camcalinfo); 
 
 end
 track.pt \= bob;
 %toc(ts);
 bytesLoaded \= ftell(fid)\-startOfTrackPosition;
 if (nbytes \~\= bytesLoaded)
 track.locInFile
 startOfTrackPosition
 track.npts
 bob
 disp (\['Expected to load ' num2str(nbytes) ' but loaded ' num2str(bytesLoaded)]);
 pause
 end
 track.startFrame \= track.pt(1\).ind;
 track.endFrame \= track.pt(end).ind;
else
 fseek(fid, startOfTrackPosition \+ nbytes, 'bof');
end
\-\-\-

\#\#\# File: getDerivedQuantity.m (ID: @Track.23\)

function qvec \= getDerivedQuantity(track, quantityName, recalculate, varargin)
% gets derived quantity, calculating it if necessary
% function qvec \= getDerivedQuantity(track, quantityName, recalculate,
% varargin)
%
% outputs:
% QVEC: a kxN matrix of values, where qvec(:,j) corresponds to the jth
% point
% inputs: 
% TRACK: a member of the track class
% QUANTITYNAME: the name of the quantity to get
% RECALCULATE: if the quantity should be recalculated
% VARARGIN:
% inds: provide indices to get field just in those indices 
% OR
% append 'run', 'hs', 'reo' to get field just in runs, headswings,
% reorientations
% append 'firsths' to get field in only the first headswing of a
% reorientation
% append 'runstart' or 'runend' to get field in only the beginning or end
% of a run (runstart excludes the first run, runend excludes the last one)
% append 'start', or 'end' to get field in only the beginning or end of a 
% run, headswing, or reorientation (includes the first and last);
%
% add 'mean' as a separate argument to take the mean 
% if 'mean' is passed as only additional argument, or in addition to
% numerical indices, you get a single value that is the mean of the derived
% quantity (over the entire track, or the set of indices)
% if 'mean' is passed in addition to 'run', 'hs', or 'reo', you get a vector
% that is the mean of the quantity over each run, headswing, or reorientation
% if mean is passed in addition to any other string argument, you get yelled
% at and behavior is undefined
% if 'notlast' or 'notfirst' is passed in addition to 'run', we exclude the
% last or first run
% if 'indsExpression', expression is passed, we get the quantity from the
% inds generated by inds \= intersect(find(eval(expression)),allinds,runinds, etc.);

 if (\~exist ('recalculate', 'var') \|\| isempty (recalculate))
 recalculate \= false;
 end

 switch lower(quantityName)
 % case lower(fieldnames(track.pt))
 % qvec \= interp1(\[track.pt.et], \[track.pt.(quantityName)], track.getDerivedQuantity('eti'), 'linear');
 case 'loc'
 pt \= \[track.pt];
 qvec \= \[pt.loc];
 case 'et'
 pt \= \[track.pt];
 qvec \= \[pt.et];
 case 'mapptstointerped' %qvec(j) is the index of eti closest to track.pt(j).et
 qvec \= mapPtsToInterped(track);
 case 'mapptstointerpedall' %qvec is a list of all interped points that map to a given pt
 
 otherwise
 if (strcmpi(quantityName, 'mapinterpedtopts'))
 quantityName \= lower(quantityName);
 end
 if (track.validDQName(quantityName))
 track.calculateDerivedQuantity(quantityName, recalculate);
 end
 if (strcmpi(quantityName, 'isrun') \|\| strcmpi(quantityName, 'iscollision'))
 qvec \= track.(quantityName);
 else
 qvec \= track.dq.(quantityName); 
 end
 end
 inds \= 1:length(qvec);
 indsExpression \= \[];
 varargin \= assignApplicable(varargin);
 if (\~isempty(indsExpression))
 goodinds \= find(eval(indsExpression));
 end
 findmean \= false;
 if (\~isempty(varargin)) 
 ismean \= false(size(varargin));
 for j \= 1:length(varargin)
 ismean(j) \= (ischar(varargin{j}) \&\& strcmpi('mean', varargin{j}));
 end
 if any(ismean)
 findmean \= true;
 end
 varargin \= varargin(\~ismean);
 if (findmean)
 if (\~isempty(varargin) \&\& ischar(varargin{1}))
 switch(lower(varargin{1}))
 case {'run','runs'}
 field \= 'run';
 case {'hs','headswing', 'headSwings'}
 field \= 'headSwing';
 case {'reo','reorientation', 'reorientations'}
 field \= 'reorientation';
 otherwise
 disp('can only take the mean of runs, reorientations, headsweep');
 return;
 end
 rval \= repmat(qvec(:,1\), \[1 length(track.(field))]);
 for j \= 1:length(track.(field))
 rval(j) \= mean(qvec(:,track.(field)(j).inds),2\);
 end
 qvec \= rval;
 else
 if (\~isempty(varargin))
 inds \= varargin{1};
 qvec \= qvec(:,inds);
 end
 qvec \= mean(qvec,2\);
 end
 else 
 if (ischar(varargin{1}))
 if any(strcmpi('start', varargin))
 ifield \= 'startInd';
 else
 if any(strcmpi('end', varargin))
 ifield \= 'endInd';
 else
 ifield \= 'inds';
 end
 end
 
 switch(lower(varargin{1}))
 
 
 case {'run','runs'}
 if any(strcmpi('notlast', varargin))
 if (length(track.run) \> 1\)
 inds \= \[track.run(1:(end\-1\)).(ifield)];
 else
 inds \= \[];
 end
 else 
 if any(strcmpi('notfirst', varargin))
 if (length(track.run) \> 1\)
 inds \= \[track.run(2:end).(ifield)];
 else
 inds \= \[];
 end
 else
 inds \= \[track.run.inds];
 end
 end
 case {'hs','headswing', 'headswings'}
 inds \= \[track.headSwing.(ifield)];
 case {'reo','reorientation', 'reorientations'}
 inds \= \[track.reorientation.(ifield)];
 case {'firsths', 'firstheadswing'}
 r \= \[track.reorientation];
 r \= r(\[r.numHS] \> 0\);
 hs \= repmat(HeadSwing, size(r));
 for k \= 1:length(r)
 hs(k) \= r(k).headSwing(1\);
 end
 inds \= \[hs.(ifield)];
 case {'runstart'}
 if (length(track.run) \> 1\)
 inds \= \[track.run(2:end).startInd];
 else
 inds \= \[];
 end
 case {'runend'}
 if (length(track.run) \> 1\)
 inds \= \[track.run(1:end\-1\).endInd];
 else
 inds \= \[];
 end
 case {'hsstart','headswingstart'}
 if (\~isempty(track.headSwing))
 inds \= \[track.headSwing.startInd];
 else
 inds \= \[];
 end
 case {'hsend','headswingend'}
 if (\~isempty(track.headSwing))
 inds \= \[track.headSwing.endInd];
 else
 inds \= \[];
 end
 otherwise
 inds \= \[];
 end 
 else
 inds \= varargin{1};
 end 
 end
 end
 if (\~isempty(indsExpression)) 
 inds \= intersect(inds, goodinds);
 end
 inds \= inds(isfinite(inds));
 if(\~findmean)
 try
 if (size(qvec, 3\) \> 1\)
 qvec \= qvec(:,:,inds);
 else
 qvec \= qvec(:,inds);
 end
 catch me
 disp(me.getReport);
 inds
 size(qvec)
 end
 end
end

function inds \= mapPtsToInterped(track)
 pt \= \[track.pt];
 et \= \[pt.et];
 track.calculateDerivedQuantity('eti', false);
 x \= 1:length(track.dq.eti);
 inds \= interp1(track.dq.eti, x, et, 'nearest','extrap');
end


\-\-\-

\#\#\# File: plotColorPath.m (ID: @Track.24\)

function h \= plotColorPath(track, fieldName, varargin)
% plots track path with intensity given by track.dq.fieldName
% function plotColorPath(track, fieldName, varargin)
% plots track path with intensity given by track.dq.fieldName
%
% outputs:
% H: (optional) handles to all points in the line
% inputs:
% TRACK \< Track
% FIELDNAME: the name of the field to plot
% VARARGIN: parameter/value pairs
% defaults that can be overwritten:
% pathType \= 'sloc' {'loc', 'iloc'}
% zdata \= track.dq.(fieldName) or empty if fieldName is empty
% to put in different zdata, leave fieldName empty and add pair
% 'zdata', zvalue
% inds \= all points
% if zdata has the same size as path, we plot path(:,inds) vs.
% zdata(inds)
% else if inds has the same size as zdata diff from path, we plot 
% path(:,inds) vs. zdata
% zrange \= range over which the zdata is scaled (default min(z) max(z))
% cmap \= colormap to use (default jet(256\))


pathType \= 'sloc';
if (\~isempty(fieldName))
 zdata \= track.getDerivedQuantity(fieldName);
else
 zdata \= \[];
end
inds \= \[];
zrange \= \[];
cmap \= jet();
varargin \= assignApplicable(varargin);

path \= track.getDerivedQuantity(pathType);

if (isempty(inds))
 inds \= 1:length(path);
end
if (length(zdata) \=\= length(path))
 zdata \= zdata(inds);
else
 if (length(zdata) \~\= length(inds))
 disp('length of zdata doesn''t match either length of path or length of inds');
 disp(\['length(inds) \= ' num2str(length(inds)) ' length(zdata) \= ' num2str(length(zdata)) ' length(path) \= ' num2str(length(path))]);
 return;
 end
end
 
if (nargout \> 0\)
 h \= plotColorLine (path(1,inds), path(2,inds), zdata, cmap, zrange, varargin{:});
else
 plotColorLine (path(1,inds), path(2,inds), zdata, cmap, zrange, varargin{:});
end
 
\-\-\-

\#\#\# File: validDQName.m (ID: @Track.25\)

function varargout \= validDQName (varargin)
% tells whether a name is a valid derived quantity/lists all valid DQs
% function varargout \= validDQName (varargin)
%
% tf \= validDQName(name) \-\- true or false if name is a valid derived
% field for a track
% tflist \= validDQName(namelist) \-\- array of true or falses, namelist is a cell
% tflist \= validDQName('name1', 'name2') \-\- nargout \= nargin t/f
% namelist \= validDQName() \- returns a cell containing all valid field names

validfieldlist \= {'eti', 'iloc','sloc','vel', 'speed', 'nspeed', 'nvel', 'vnorm', 'speed\_diff\_local', 'theta','deltatheta', 'ddtheta', 'acc', 'curv',...
 'pathLength','displacement','icov', 'covRatio', 'covTheta','scov', 'scovRatio', 'scovTheta', 'covMajor', 'adjspeed' ...
 'covMinor', 'scovMajor', 'scovMinor','iarea', 'sarea', 'totalTime', 'lrdtheta', 'dcovRatio','xloc','yloc', 'etiFromTrackStart','mapinterpedtopts',...
 'isrun', 'iscollision','iiscollision'};
 
 
varargout{:} \= Track.nameInList(validfieldlist, varargin{:});
%{
switch nargin
 case 0
 varargout{1} \= validfieldlist;
 case 1
 if (iscell(varargin{1}))
 tfarray \= repmat(false, size(varargin{1}));
 for j \= 1:length(varargin{1})
 tfarray(j) \= Track.validDQName(varargin{1}{j});
 end
 varargout{1} \= tfarray;
 else 
 varargout{1} \= (ischar(varargin{1}) \&\& (any(strcmp(varargin{1}, validfieldlist))));
 end
 otherwise
 for j \= 1:nargin
 varargout{j} \= Track.validDQName(varargin{j});
 end
end
%}
 
 

\-\-\-

\#\#\# File: makeMovie.m (ID: @Track.26\)

function mo \= makeMovie(track, mo, varargin)
% plays a movie of the track with annotation
% function playMovie(track, varargin)
% outputs, none
% inputs:
% TRACK \< Track;
% MO \< movieOptions;
% VARARGIN:
% enter options as pairs, caps matter
% options, with defaults
%
% inds \= 1:length(track.pt); \-\- inds to play
% iinds \= \[]; interped inds; if passed, we find inds \=
% gdq(mapinterpedtopts,iinds)
% startLoc \= \[];
% stopLoc \= \[]; if startLoc \& stopLoc are both not empty, we run the movie
% between these two points
% startTime \= \[];
% stopTime \= \[]; if startTime \& stopTime are both not empty, we run the
% movie between these times
%


iinds \= \[];
inds \= 1:length(track.pt);
startLoc \= \[];
stopLoc \= \[];
startTime \= \[];
stopTime \= \[];
fid \= \[];
varargin \= assignApplicable(varargin);
if (isempty(fid))
 track.expt.openDataFile;
 fid \= track.expt.fid;
end

%prepare figure window to show movie
if (isempty(mo.figHandle))
 mo.figHandle \= gcf;
end
figure(mo.figHandle);
clf(mo.figHandle);
set(mo.figHandle, 'DefaultTextInterpreter', 'Latex', 'DefaultTextFontSize', mo.fontSize);

if ((mo.makeAvi \|\| mo.addToAvi) \&\& mo.makeImStack)
 disp ('You can''t make both an image stack and an avi \-\- pick one');
 return;
end

if (mo.makeAvi)
 mo.avi \= avifile(mo.aviName, mo.avioptions{:});
 mo.addToAvi \= true;
end

if (mo.addToAvi)
 p \= get(0, 'ScreenSize');
 p(1\) \= round(p(3\)/2 \- mo.aviResolution(1\)/2\);
 p(2\) \= round(p(4\)/2 \- mo.aviResolution(2\)/2\);
 p(3\) \= mo.aviResolution(1\);
 p(4\) \= mo.aviResolution(2\);
 set(mo.figHandle, 'Position', p);
end
if (mo.makeImStack)
 p \= get(0, 'ScreenSize');
 p(1\) \= round(p(3\)/2 \- mo.jpegResolution(1\)/2\);
 p(2\) \= round(p(4\)/2 \- mo.jpegResolution(2\)/2\);
 p(3\) \= mo.jpegResolution(1\);
 p(4\) \= mo.jpegResolution(2\);
 set(mo.figHandle, 'Position', p);
end

set(mo.figHandle, 'Color', mo.backgroundColor);
if (isempty(mo.Axes))
 numAxes \= (length(mo.datafields) \+ 1\);
 nh \= ceil(sqrt(numAxes));
 nv \= ceil(numAxes/nh);
 for j \= 1:numAxes;
 mo.Axes(j) \= subplot(nh,nv,j, 'Parent', mo.figHandle);
 set(mo.Axes(j), 'Color', mo.dataBackgroundColor, 'XColor', mo.dataAxesColor, 'YColor', mo.dataAxesColor,...
 'Alim', \[0 1], 'Layer', 'top', 'DrawMode', 'normal','FontSize',mo.fontSize, 'LineWidth', 3, 'Box', 'on');
 end
end
set(mo.Axes(1\), 'Color', mo.imBackgroundColor, 'XColor', mo.imAxesColor, 'YColor', mo.imAxesColor);

tlength \= length(track.getDerivedQuantity('eti'));
 pt \= \[track.pt];
if (\~isempty(iinds))
 iinds \= iinds(iinds \>\=1 \& iinds \<\= tlength);
 inds \= track.getDerivedQuantity('mapinterpedtopts', false,iinds);
else
 if (\~isempty(startLoc) \&\& \~isempty(stopLoc))
 \[\~,s] \= track.nearestPoint (startLoc);
 \[\~,e] \= track.nearestPoint (stopLoc);
 if (s \> e)
 inds \= e:s;
 else
 inds \= s:e;
 end
 end

 
 if (\~isempty(startTime) \&\& \~isempty(stopTime))
 s \= find(\[pt.et] \>\= startTime, 1, 'first');
 e \= find(\[pt.et] \<\= stopTime, 1, 'last');
 inds \= s:e;
 end
 inds \= inds(inds \>\= 1 \& inds \<\= length(pt));
 indslim \= track.getDerivedQuantity('mapptstointerped', false, inds(\[1 end]));
 iinds \= indslim(1\):indslim(2\);
end
mo \= drawDataFields(track, mo);

handles \= \[];

if (mo.labelReorientations)
 isreo \= false(size(track.isrun));
 isreo(\[track.reorientation.inds]) \= true;
end
loc \= track.getDerivedQuantity(mo.locField); 
 
for j \= 1:length(iinds)
 ts1 \= tic();
 cla(mo.Axes(1\));
 pt(inds(j)).drawTrackImage(\[],'fid', fid, 'Axes', mo.Axes(1\), varargin{:}); 
 if (mo.interpImage)
 shading(mo.Axes(1\), 'interp');
 end
 set(mo.Axes(1\), 'Clim', mo.imCLim);
 hold (mo.Axes(1\), 'on');
 sstart \= max(iinds(j) \- mo.ptbuffer,1\);
 send \= min(iinds(j) \+ mo.ptbuffer, tlength);
 plot(mo.Axes(1\), loc(1, sstart:send), loc(2, sstart:send), mo.trackStyle, 'LineWidth', mo.trackWidth);
 plot(mo.Axes(1\), loc(1, iinds(j)), loc(2, iinds(j)), mo.ptMarker, 'MarkerSize', mo.ptMarkerSize);
 
 %track.plotPath(mo.locField, mo.trackStyle, 'inds', sstart:send, 'Axes', mo.Axes(1\), 'LineWidth', mo.trackWidth);
 %track.plotPath(mo.locField, mo.ptMarker, 'inds', iinds(j), 'Axes', mo.Axes(1\), 'MarkerSize', mo.ptMarkerSize);
 
 axis (mo.Axes(1\), \[loc(1,iinds(j)) \+ \[\-mo.imAxisSize/2 mo.imAxisSize/2], loc(2,iinds(j)) \+ \[\-mo.imAxisSize/2 mo.imAxisSize/2]]);
 axis (mo.Axes(1\), 'equal'); 
 axis (mo.Axes(1\), \[loc(1,iinds(j)) \+ \[\-mo.imAxisSize/2 mo.imAxisSize/2], loc(2,iinds(j)) \+ \[\-mo.imAxisSize/2 mo.imAxisSize/2]]);
 
 hold (mo.Axes(1\), 'off');
 set(mo.Axes(1\), 'XTick', \[], 'YTick', \[]);
 mo \= track.makeMovieTrackSpecific(mo, pt(inds(j)), iinds(j));
 
 xl \= get(mo.Axes(1\), 'XLim'); 
 yl \= get(mo.Axes(1\), 'YLim');
 if (mo.labelRuns \&\& \~isempty(track.run) \&\& track.isrun(iinds(j)))
 text(xl(1\), yl(1\), 'Run', 'Color', mo.runColor, 'HorizontalAlignment', 'left', 'VerticalAlignment', 'bottom',...
 'Parent', mo.Axes(1\)); 
 end
 if (mo.labelReorientations \&\& \~isempty(track.reorientation) \&\& isreo(iinds(j)))
 text(xl(2\), yl(1\), 'Reorientation', 'Color', mo.reorientationColor, 'HorizontalAlignment', 'right', 'VerticalAlignment', 'bottom',...
 'Parent', mo.Axes(1\)); 
 end
 
 handles \= updateCenter(track, iinds(j), mo, handles);
 for k \= 2:numAxes;
 set(mo.Axes(k), 'Color', mo.dataBackgroundColor, 'XColor', mo.dataAxesColor, 'YColor', mo.dataAxesColor,...
 'Alim', \[0 1], 'Layer', 'top', 'DrawMode', 'normal','FontSize',mo.fontSize, 'LineWidth', 1, 'Box', 'on');
 end
 timeleft \= mo.delayTime \- toc(ts1\);
 if (mo.addToAvi)
 mo.avi \= addframe(mo.avi, getframe(mo.figHandle));
 pause(0\.01\);
 else
 if (mo.makeImStack)
 drawnow('expose');
 figure(mo.figHandle);
 saveas(mo.figHandle, \[mo.jpegstub '\_' num2str(mo.imstackIndex) '.bmp']);
 mo.imstackIndex \= mo.imstackIndex \+ 1;
 else
 if (timeleft \> 0\)
 pause(timeleft);
 else
 pause(0\.01\);
 end
 end
 end
 
end
if (mo.makeAvi \&\& mo.closeAviWhenDone)
 mo.avi \= close(mo.avi);
 mo.addToAvi \= false;
end

function mo \= drawDataFields(track, mo)
if (isempty(mo.datafields))
 return;
end
for j \= 1:min(length(mo.datafields), (length(mo.Axes)\-1\))
 Ax \= mo.Axes(j\+1\);
 xdata \= track.getDerivedQuantity('eti');
 ydata \= mo.dataOps{j}(track.getDerivedQuantity(mo.datafields{j}));
 cla(Ax);
 plot(Ax, xdata, ydata, mo.dataLineColor, 'LineWidth', mo.dataLineWidth); 
 hold(Ax, 'all');
 if (isempty(mo.dataYLimits{j}))
 mo.dataYLimits{j} \= \[min(ydata) max(ydata)];
 end
 ypatchvertex \= \[mo.dataYLimits{j}(1\) mo.dataYLimits{j}(1\) mo.dataYLimits{j}(2\) mo.dataYLimits{j}(2\)]';
 
 if (mo.labelRuns)
 xstart \= track.run.getDerivedQuantity('eti','position', 'start');
 xend \= track.run.getDerivedQuantity('eti','position', 'end');
 patch(\[xstart;xend;xend;xstart], repmat(ypatchvertex, 1, length(xstart)), mo.runColor, ...
 'faceAlpha', 0\.4, 'edgeAlpha', 0, 'Parent', Ax);
 end
 if (mo.labelReorientations)
 xstart \= track.reorientation.getDerivedQuantity('eti','position', 'start');
 xend \= track.reorientation.getDerivedQuantity('eti','position', 'end');
 patch(\[xstart;xend;xend;xstart], repmat(ypatchvertex, 1, length(xstart)), mo.reorientationColor, ...
 'faceAlpha', 0\.4, 'edgeAlpha', 0, 'Parent', Ax);
 end
 if (\~isempty(mo.dataOverlays) \&\& \~isempty(mo.dataOverlays{j}))
 if (\~iscell(mo.dataOverlays{j}))
 mo.dataOverlays{j} \= mo.dataOverlays(j);
 end
 h \= \[];
 for k \= 1:length(mo.dataOverlays{j})
 h(k) \= plot(Ax, xdata, repmat(mo.dataOps{j}(parseDotField(track, mo.dataOverlays{j}{k})), size(xdata)),...
 'LineWidth', mo.dataLineWidth); %\#ok
 if (mo.mirrorOverlays(j))
 plot(Ax, xdata, repmat(\-mo.dataOps{j}(parseDotField(track, mo.dataOverlays{j}{k})), size(xdata)),...
 'LineWidth', mo.dataLineWidth, 'Color', get(h(k), 'Color'));
 end
 end
 % legend(h, mo.overlayLabels{j});
 end
 
 
 title(Ax, mo.dataTitles{j}, 'Color', mo.dataAxesColor);
 if (\~isempty(mo.dataYLabels{j}))
 ylabel(Ax, mo.dataYLabels{j}, 'Color', mo.dataAxesColor);
 end
 xlabel(Ax, 'time (s)', 'Color', mo.dataAxesColor);
 set(Ax, 'Color', mo.dataBackgroundColor, 'XColor', mo.dataAxesColor, 'YColor', mo.dataAxesColor,...
 'Alim', \[0 1], 'Layer', 'top', 'DrawMode', 'fast');
end

function handles \= updateCenter(track, cind, mo, handles)
if \~isempty(handles)
 for j \= 1:length(handles)
 delete(handles(j));
 end
end
if (isempty(mo.datafields))
 handles \= \[];
 return;
end
for j \= 1:length(mo.datafields) 

 Ax \= mo.Axes(j\+1\);
 xdata \= track.getDerivedQuantity('eti',false,cind);
 ydata \= mo.dataOps{j}(track.getDerivedQuantity(mo.datafields{j}, false, cind));
 handles(j) \= plot (Ax, xdata, ydata, mo.dataCurrentMarker, 'MarkerSize', mo.dataCurrentMarkerSize);
 xlim(Ax, xdata \+ \[\-mo.dataXRange mo.dataXRange]);
 ylim(Ax, mo.dataYLimits{j});
end
 
 



\-\-\-

\#\#\# File: calculateDerivedQuantity.m (ID: @Track.27\)

function calculateDerivedQuantity(track, quantityNames, recalculate)
%calculates derived quantity(ies) and stores in track.dq
%function calculateDerivedQuantity(track, quantityNames, recalculate)
%
%inputs: 
%TRACK: a member of the Track class
%QUANTITYNAMES: a list of quantities to calculate; for a list of valid
% quantities, see Track/validDQName
%RECALCULATE: if true, calculates the quantity again even if it already
% exists as a field of track.dq (default false)
 if \~iscell(quantityNames)
 quantityNames \= {quantityNames};
 end
 if (\~exist('recalculate', 'var'))
 recalculate \= false;
 end
 for j \= 1:length(quantityNames)
 if (isfield(track.dq, quantityNames{j}) \&\& \~recalculate)
 continue;
 end
 switch(quantityNames{j})
 case 'eti'
 calculateInterpedTime(track);
 case 'etiFromTrackStart'
 track.calculateDerivedQuantity('eti');
 track.dq.etiFromTrackStart \= track.dq.eti \- track.dq.eti(1\);
 case 'iloc'
 track.calculateDerivedQuantity('eti', false);
 calculateInterpedLocation(track);
 case 'sloc'
 track.calculateDerivedQuantity('iloc', false);
 calculateSmoothedLocation(track);
 case {'xloc', 'yloc'}
 track.calculateDerivedQuantity('sloc', recalculate);
 track.dq.xloc \= track.dq.sloc(1,:);
 track.dq.yloc \= track.dq.sloc(2,:);
 case {'vel', 'speed', 'vnorm', 'theta', 'nspeed', 'nvel'}
 track.calculateDerivedQuantity({'iloc','sloc'}, false);
 caclulateVelocity(track);
 case {'adjspeed'}
 track.calculateDerivedQuantity('speed', false);
 calculateAdjSpeed(track);
 case {'speed\_diff\_local'}
 track.calculateDerivedQuantity('speed');
 calculateSpeedDiff(track);
 case {'deltatheta', 'ddtheta', 'acc', 'curv'}
 track.calculateDerivedQuantity({'vel', 'theta'}, false);
 calculateAcceleration(track);
 case {'lrdtheta'}
 calculatelrdtheta(track); 
 case {'pathLength'}
 track.calculateDerivedQuantity({'iloc','sloc'}, false);
 calculatePathLength(track);
 case {'displacement'}
 track.calculateDerivedQuantity({'iloc','sloc'}, false);
 calculatePathLength(track);
 case {'icov', 'covRatio', 'covTheta', 'covMinor', 'covMajor'}
 track.calculateDerivedQuantity('eti', false);
 calculateCovariance(track);
 case {'scov', 'scovRatio', 'scovTheta', 'scovMinor', 'scovMajor'}
 track.calculateDerivedQuantity('icov', false);
 calculateSmoothedCovariance(track);
 case {'dcovRatio'}
 calculateDerivativeOfCovarianceRatio(track);
 case {'iarea', 'sarea'}
 calculateInterpedArea(track, quantityNames{j}); 
 case {'totalTime'}
 pt1 \= track.pt(1\);
 pt2 \= track.pt(end);
 track.dq.totalTime \= pt2\.et \- pt1\.et;
 case 'mapinterpedtopts'
 mapInterpedToPts(track); %qvec(j) is the index of \[track.pt.et] closets to eti(j)
 case {'isrun', 'iscollision'} 
 return;
 case {'iiscollision'}
 calculateInterpedCollision(track);
 
 otherwise
 disp (\['I don''t recognize the quantity: ' quantityNames{j}]);
 end%switch
 end%for
end %cdq
function calculateInterpedTime(track) 
 track.dq.eti \= track.pt(1\).et:track.dr.interpTime:track.pt(end).et;
end
% function calculateInterpedCollision(track)
% pt \= \[track.pt];
% et \= \[pt.et];
% ic \= track.iscollision();
% track.dq.iiscollision \= logical((interp1(et, double(ic), track.dq.eti, 'nearest', 'extrap')));
% end


function calculateInterpedLocation(track)
 pt \= \[track.pt];
 et \= \[pt.et];
 loc \= \[pt.loc];
 track.dq.iloc \= double((interp1(et, double(loc)', track.dq.eti, 'linear'))');
end

function calculateSmoothedLocation(track)
 sigma \= track.dr.smoothTime/track.dr.interpTime;
 track.dq.sloc \= double(lowpass1D(track.dq.iloc, sigma));
end

function caclulateVelocity(track) 
 sigma \= track.dr.derivTime/track.dr.interpTime;
 track.dq.vel \= double(deriv(track.dq.sloc, sigma))/track.dr.interpTime; %velocity is in pixels per second
 track.dq.speed \= double(sqrt(sum(track.dq.vel.^2, 1\)));
 track.dq.nspeed \= track.dq.speed / median(track.dq.speed);
 l \= track.dq.speed;
 track.dq.vnorm \= double(track.dq.vel./\[l;l]);
 track.dq.theta \= double(atan2(track.dq.vnorm(2,:), track.dq.vnorm(1,:)));
 track.dq.nvel \= track.dq.vel / sqrt(mean(track.dq.speed.^2\));
end

function calculateAdjSpeed(track)
 lrtime \= track.dr.smoothTime \* 3;
 if (\~isempty(track.isrun) \&\& any(track.isrun))
 track.dq.adjspeed \= lowpass1D(track.dq.speed / median(track.dq.speed(track.isrun)), lrtime/track.dr.interpTime);
 else
 track.dq.adjspeed \= lowpass1D(track.dq.nspeed, lrtime/track.dr.interpTime);
 end
end

function calculateSpeedDiff(track)
 npts \= 240/track.dr.interpTime;
 if (length(track.dq.speed) \< npts)
 spfilt \= repmat(median(track.dq.speed), size(track.dq.speed));
 else
 spfilt \= medfilt2(track.dq.speed, \[1 npts], 'symmetric');
 end
 track.dq.speed\_diff\_local \= track.dq.speed \- spfilt;
 
end

 
function calculateAcceleration(track) 
 sigma \= track.dr.derivTime/track.dr.interpTime;
 track.dq.deltatheta \= double (deriv(unwrap(track.dq.theta), sigma))/track.dr.interpTime;
 track.dq.ddtheta \= double (deriv(track.dq.deltatheta, sigma))/track.dr.interpTime;
 track.dq.acc \= double(deriv(track.dq.vel,sigma))/track.dr.interpTime;
 track.dq.curv \= double((track.dq.vel(1,:).\*track.dq.acc(2,:) \- track.dq.vel(2,:).\*track.dq.acc(1,:))./(track.dq.speed.^3\));
end

function calculateCovariance(track) 
 pt \= \[track.pt];
 et \= \[pt.et];
 cov \= \[pt.cov];
 valid \= find(all(isfinite(cov), 1\));
 c \= double((interp1(et(valid), double(cov(:,valid))', track.dq.eti, 'linear'))');
 u \= (c(1,:) \+ c(3,:))/2;
 d \= 0\.5\* sqrt((c(1,:)\-c(3,:)).^2 \+ 4 \* c(2,:).^2\);
 t \= 0\.5\*asin(abs(c(2,:))./d);
 t((c(1,:) \< c(3,:))) \= pi/2 \- t((c(1,:) \< c(3,:)));
 t(c(2,:) \< 0\) \= \-t(c(2,:) \< 0\);
 track.dq.icov \= c;
 track.dq.covMajor \= sqrt(u \+ d);
 track.dq.covMinor \= sqrt(u \- d);
 track.dq.covTheta \= t;
 track.dq.covRatio \= track.dq.covMajor ./ track.dq.covMinor;
end
function calculateSmoothedCovariance(track) 
 sigma \= track.dr.smoothTime/track.dr.interpTime;
 c \= double(lowpass1D(track.dq.icov, sigma));
 u \= (c(1,:) \+ c(3,:))/2;
 d \= 0\.5\* sqrt((c(1,:)\-c(3,:)).^2 \+ 4 \* c(2,:).^2\);
 t \= 0\.5\*asin(abs(c(2,:))./d);
 t((c(1,:) \< c(3,:))) \= pi/2 \- t((c(1,:) \< c(3,:)));
 t(c(2,:) \< 0\) \= \-t(c(2,:) \< 0\);
 track.dq.scov \= c;
 track.dq.scovMajor \= sqrt(u \+ d);
 track.dq.scovMinor \= sqrt(u \- d);
 track.dq.scovTheta \= t;
 track.dq.scovRatio \= track.dq.scovMajor ./ track.dq.scovMinor;
end

function calculatePathLength(track)
 track.dq.pathLength \= \[0 cumsum(sqrt(sum(diff(track.dq.sloc,1,2\).^2\)))];
 track.dq.displacement \= track.dq.sloc \- repmat(track.dq.sloc(:,1\), 1,length(track.dq.sloc));
end

function calculateInterpedArea(track, qn)
 if (qn(1\) \=\= 's')
 track.dq.sarea \= lowpass1D(track.getDerivedQuantity('iarea'), track.dr.smoothTime/track.dr.interpTime);
 else
 pt \= \[track.pt];
 et \= \[pt.et];
 area \= \[pt.area];
 track.dq.iarea \= double((interp1(et, double(area)', track.getDerivedQuantity('eti'), 'linear')));
 end
end

function calculatelrdtheta(track)
 lrtime \= 5;
 t \= track.getDerivedQuantity('theta');
 track.dq.lrdtheta \= deriv(unwrap(t), lrtime/track.dr.interpTime);
end

function calculateDerivativeOfCovarianceRatio(track) 
 sc \= track.getDerivedQuantity('scovRatio');
 sigma \= track.dr.derivTime./track.dr.interpTime;
 track.dq.dcovRatio \= deriv(sc, sigma);
end

function mapInterpedToPts(track)
 pt \= \[track.pt];
 et \= \[pt.et];
 track.calculateDerivedQuantity('eti', false);
 x \= 1:length(et);
 track.dq.mapinterpedtopts \= interp1(et,x,track.dq.eti, 'nearest','extrap');
end
\-\-\-

\#\#\# File: trim.m (ID: @Track.28\)

function deleteMe \= trim (track, timerange, validrect)
% removes excess points and determines if any are left
% function deleteMe \= trim (track, timerange, validrect)
%
% removes all points from the track outside timerange and 
% all points from the first time track location leaves validrect
% until the end of the track 
%
% if this would result in no points remaining in the track, we return
% true; trimming of points may or may not have already occurred
% otherwise, we return false
%
% if timerange or validrect is empty, no comparison is performed
% validrect has format \[x0 y0 x1 y1]
%
% outputs:
% DELETEME: true if trimming would remove all points
% inputs:
% TRACK \< Track
% TIMERANGE: \[t0 t1]; removes all points outside this range of times
% if empty, this step is skipped
% VALIDRECT: \[x0 y0 x1 y1]; removes all points from the first time track
% leaves VALIDRECT to end of track; if empty, this step is skipped

if (exist ('timerange', 'var') \&\& \~isempty(timerange))
 pt \= \[track.pt];
 validTime \= \[pt.et] \>\= min(timerange) \& \[pt.et] \<\= max(timerange);
 if (\~any(validTime))
 deleteMe \= true;
 return
 end
 track.pt \= track.pt(validTime);
 track.npts \= length(track.pt);
end

if (exist ('validrect', 'var') \&\& \~isempty(validrect))
 pt \= \[track.pt];
 x \= \[pt.loc];
 validLoc \= (x(1,:) \>\= validrect(1\) \& x(1,:) \<\= validrect(3\) \& x(2,:) \>\= validrect(2\) \& x(2,:) \<\= validrect(4\));
 ind \= find(\~validLoc, 1, 'first');
 if (\~isempty(ind))
 if (ind \=\= 1\)
 deleteMe \= true;
 return;
 end
 track.pt \= track.pt(1:(ind\-1\));
 end
end
track.npts \= length(track.pt);
track.startFrame \= track.pt(1\).ind;
track.endFrame \= track.pt(end).ind;
deleteMe \= false;

\-\-\-

\#\#\# File: merge.m (ID: @Track.29\)

function merge(track, track2\)
% merges two tracks into a single track; does not change track2
% function merge(track, track2\)
%
% this utility function is called by stitchTracks and not by end user
%
% outputs: none
% inputs:
% TRACK: first track; modified to contain track and track2
% TRACK2: second track; unchanged, but should be deleted later
%
% note after calling this function, derived quantities, segmentation, etc. are
% invalid

track.pt \= \[track.pt track2\.pt];
track.npts \= track.npts \+ track2\.npts;
track.nt \= track.nt \+ track2\.nt;
track.locInFile \= \[track.locInFile track2\.locInFile];
track.endFrame \= track2\.endFrame;

track.recalculateDerivedQuantities;
 

\-\-\-

\#\#\# File: getSubFieldDQ.m (ID: @Track.30\)

function qvec \= getSubFieldDQ (track, subfield, quantityName, varargin)
% gets derived quantity from a TrackPart
% function qvec \= getSubFieldDQ (track, subfield, quantityName, varargin)
%
% track.subfield must be a TrackPart 
% calls track.subfield(inds).getDerivedQuantity(quantityName,varargin)
%
% outputs:
% QVEC: a kxN matrix of values, where qvec(:,j) corresponds to the jth
% point
% inputs: 
% TRACK: a member of the track class
% SUBFIELD: the subfield; e.g. 'run', 'reorientation'
% QUANTITYNAME: the name of the quantity to get
% VARARGIN:
% passing 'inds', inds will use a subset of subfield
% passing 'indsExpression', expression will use expression to generate inds
%
% note these are indices of the SUBFIELD (e.g. to get from first second and
% fourth run, subfield \= 'run', inds \= \[1 2 4])
%
% if indsexpression is 'notlast' or 'notfirst', we gather all but the last
% or first in the track
%
% examples
% track.getSubFieldDQ('run','speed','position','mean') will get the mean
% speed for all tracks
% track.getSubFieldDQ('reorientation', 'eti', 'indsExpression', ...
% '\[track.reorientation.numHS] \=\= 1', 'position', 'start') 
% will get the start time of all reorientations with exactly 1 headsweep
%
% if both inds and indsExpression are passed, we select the intersection
% (but don't do this, come on already)
%
% iff subfield is 'firsths', we take the first headsweep in each
% reorienation only, and we ignore inds, indsExpression
%
% iff subfield is 'lasths', we take the first headsweep in each
% reorienation only, and we ignore inds, indsExpression
%

% 


inds \= \[];
indsExpression \= \[];
varargin \= assignApplicable(varargin);

if (strcmpi (subfield, 'firsths'))
 r \= \[track.reorientation];
 r \= r(\[r.numHS] \> 0\);
 f \= repmat(HeadSwing, size(r));
 for k \= 1:length(r)
 f(k) \= r(k).headSwing(1\);
 end
else
 if (strcmpi (subfield, 'lasths'))
 r \= \[track.reorientation];
 r \= r(\[r.numHS] \> 0\);
 f \= repmat(HeadSwing, size(r));
 for k \= 1:length(r)
 f(k) \= r(k).headSwing(end);
 end
 else
 f \= \[track.(subfield)];
 if (isempty(inds))
 inds \= 1:length(f);
 end
 if (\~isempty(indsExpression))
 switch(lower(indsExpression))
 case 'notfirst'
 if (length(inds) \> 1\)
 inds \= inds(2:end);
 else
 inds \= \[];
 end
 case 'notlast'
 if (length(inds) \> 1\)
 inds \= inds(1:(end\-1\));
 else
 inds \= \[];
 end
 otherwise
 goodinds \= find(eval(indsExpression));
 inds \= intersect(inds, goodinds);
 end
 end
 f \= f(inds);
 end
end
 
if (isempty(f))
 qvec \= \[];
 return;
end

%if (isempty(varargin))
 %if we don't need any additional computation or selection, then this is
 %fine
 % qvec \= track.getDerivedQuantity(quantityName, false, \[f.inds]);
%else
 qvec \= \[];
 for j \= 1:length(f)
 qvtemp \= f(j).getDerivedQuantity(quantityName, varargin{:});
 qvec \= \[qvec qvtemp]; 
 end
%end
\-\-\-

\#\#\# Folder: @TrackPoint (ID: @TrackPoint)

\-\-\-

\#\#\# File: TrackPoint.m (ID: @TrackPoint.1\)

classdef TrackPoint
 properties 
 loc \= single(\[0;0]); %location as a 2x1
 ind \= int32(0\); %frame number \-\- changed from int16 on 11/20/2014 by MHG
 area \= single(0\); %contour area
 cov \= single (\[0;0;0]); %covariance matrix, c11, c12\=c21,c22
 locInFile \= 0; %location in file
 et \= 0; %elapsed time
 end
 
 methods
 tp \= fromFile (tp, fid, loadIm, loadContour, camcalinfo)
 str \= toMWTBlobLine(tp, camcalinfo, varargin)
 tp \= fromJava(tp, jTP, loadIm, loadContour, camcalinfo)
 end %static methods
 methods
 dx \= minus(tp2, tp1\) %loc2 \- loc1
 d \= distance(tp1, tp2\)
 end
 
 methods %constructor, must be in classdef file
 function tp \= TrackPoint(varargin)
 switch (nargin) 
 case 0 
 case 1
 if (isa(varargin{1}, 'TrackPoint'))
 op \= varargin{1};
 tp.loc \= op.loc;
 tp.ind \= op.ind;
 tp.area \= op.area;
 tp.cov \= op.cov;
 tp.locInFile \= op.locInFile;
 tp.et \= op.et;
 else
 if (all(size(varargin{1}) \=\= \[1 2]))
 tp.loc \= varargin{1};
 %tp \= class(tp, 'trackpoint');
 else
 disp ('bad input to trackpoint constructor ');
 disp (varargin);
 %tp \= class(\[], 'trackpoint');
 end 
 end
 otherwise
 if (all(size(varargin{1}) \=\= \[1 2]))
 tp.loc \= varargin{1};
 varargin \= {varargin{2:end}};
 else
 tp.loc \= \[varargin{1} varargin{2}];
 varargin \= {varargin{3:end}};
 end
 flist \= {'ind', 'area', 'cov'};
 while (\~isempty(varargin) \&\& \~isempty(flist))
 tp.(flist{1}) \= varargin{1};
 varargin \= {varargin{2:end}};
 flist \= {flist{2:end}};
 end
 %tp \= class(tp, 'trackpoint');
 end%switch
 end%trackpoint
 
 
 %end
 end %constructor
end
%{
class TrackPoint {

 public:

 static const bool messagesOn \= true;

 /\*TrackPoint (double x, double y, int t)
 \*
 \* creates a track point with location x,y and frame t
 \* the ID code is generated automatically and is guaranteed to be
 \* different from all other automatically generated IDs
 \*/
// TrackPoint (double x, double y, int t);

 /\*TrackPoint (double x, double y, int t, int ID)
 \*
 \* creates a track point with location x,y and frame t
 \* the ID code is passed in by the creator and should
 \* be different from any other ID code, or track match may break
 \*/
 // TrackPoint (double x, double y, int t, int ID);


 /\*TrackPoint (double x, double y, double cov\[], int t)
 \*
 \* creates a track point with location x,y and frame t
 \* the ID code is generated automatically and is guaranteed to be
 \* different from all other automatically generated IDs
 \*
 \* cov\[] is either the covariance matrix, an array of 4 doubles
 \* or NULL
 \*/
 TrackPoint (double x, double y, double area, const double cov\[], int t);

 /\*TrackPoint (double x, double y, int t, int ID)
 \*
 \* creates a track point with location x,y and frame t
 \* the ID code is passed in by the creator and should
 \* be different from any other ID code, or track match may break
 \*
 \* cov\[] is either the covariance matrix, an array of 4 doubles
 \* or NULL
 \*/
 TrackPoint (double x, double y, double area, const double cov\[], int t,int ID);

 /\*TrackPoint (TrackPoint \*pt)
 \*
 \* copies data in \*pt to a new track point
 \*/
 TrackPoint (const TrackPoint \*pt);
 /\*returns the location as a cvPoint of doubles
 \*
 \*/
 inline CvPoint2D32f getLocation() {
 return cvPoint2D32f(x,y);
 }
 //finds the location relative to the image origin point x0,y0
 //e.g. if x,y \= 100, 80 and x0,y0 \= 20,10, then returns 80,70
 inline CvPoint2D32f getLocation (double x0, double y0\) {
 return cvPoint2D32f(x\-x0, y\-y0\);
 }
 inline CvPoint2D32f getLocation (CvPoint pt) {
 return cvPoint2D32f(x\-pt.x, y\-pt.y);
 }
 inline CvPoint2D32f getLocation (CvPoint2D32f pt) {
 return cvPoint2D32f(x\-pt.x, y\-pt.y);
 }
 inline void setCovariance(const double \*cov) {
 memcpy(\&(this\-\>cov), cov, 4\*sizeof(double));
 }

 inline void getCovariance(double \*cov) {
 memcpy(cov, \&(this\-\>cov), 4\*sizeof(double));
 }

 inline void setArea (double area) {
 this\-\>area \= area;
 }

 inline double getArea () {
 return area;
 }

 /\* changes the point's location
 \*
 \*/
 void setLocation(double x, double y);


 /\*getFrame, setFrame
 \*
 \* gets/sets frame number
 \*/
 inline int getFrame() {
 return frameNum;
 }

 void setFrame(int t);

 /\*getID()
 \*
 \* returns ID number; no setID function by design
 \*/
 inline int getID() {
 return idNum;
 }

 

 /\* int toDisk (FILE \*f)
 \* f is a pointer to a BINARY output file
 \* writes the trackpoint to disk in the format
 \* int frame, float x, float y
 \*
 \* nonzero return value indicates an error
 \*
 \* subclasses should override this function to output additional
 \* information
 \*/
 virtual int toDisk(FILE \*f);

 /\* sizeOnDisk
 \*
 \* returns the number of bytes that will be written to file
 \* when toDisk is called
 \*/
 virtual int sizeOnDisk();
 /\* static TrackPoint \*fromDisk(FILE \*f);
 \* reads int frame, float x, float y from disk (assumes f is
 \* open to a track point) and stuffs them into a new trackpoint
 \*
 \* note that the ID\# is unique but different from the ID\# of
 \* the TP when it was saved
 \*
 \* subclasses should override this function to match toDisk
 \*/
 static TrackPoint \*fromDisk(FILE \*f);

 /\*virtual string saveDescription()
 \*
 \* provides a description of how the string is stored on disk
 \*/
 virtual std::string saveDescription();

 virtual inline std::string name() {
 return std::string("TrackPoint");
 }


 virtual void draw(IplImage \*dst, bool active, int x0 \= 0, int y0 \= 0, int ptrad \= 1\);

 virtual void drawConnected(IplImage \*dst, bool active, int x0, int y0, TrackPoint \*pt);

 /\* distance, distSquared
 \* distance to another point; distSquared is faster
 \*
 \*/
 inline const double distSquared (const TrackPoint \&pt2\) {
 return ((pt2\.x \- x) \* (pt2\.x \- x) \+ (pt2\.y \- y) \* (pt2\.y \- y));
 }

 inline const double distance (const TrackPoint \&pt2\){
 return sqrt (distSquared(pt2\));
 }

 inline double distSquared (const TrackPoint \*pt2\) {
 return ((pt2\-\>x \- x) \* (pt2\-\>x \- x) \+ (pt2\-\>y \- y) \* (pt2\-\>y \- y));
 }

 inline double distance (const TrackPoint \*pt2\){
 return sqrt (distSquared(pt2\));
 }

 //finds the angle of vertex a(this)c
 inline double vertexAngle (const TrackPoint \*a, const TrackPoint \*c) {
 return acos(((x \- a\-\>x)\*(x \- c\-\>x) \+ (y \- a\-\>y)\*(y \- c\-\>y))/(distance(a)\*distance(c)));
 }
 inline double vertexAngle (const TrackPoint \&a, const TrackPoint \&c) {
 return acos(((x \- a.x)\*(x \- c.x) \+ (y \- a.y)\*(y \- c.y))/(distance(a)\*distance(c)));
 }

 YAML::Emitter\& toYAML (YAML::Emitter\& out);

 virtual inline uchar getTypeCode() {
 return \_id\_code;
 }
 virtual void setMessageHandler (communicator \*mh) {
 this\-\>mh \= mh;
 }
 protected:

 

 private:
 TrackPoint(); // keep anyone from instantiating a track point with no location
 static const uchar \_id\_code \= 0x01;
 };

 \#endif
%}



\-\-\-

\#\#\# File: minus.m (ID: @TrackPoint.2\)

function dx \= minus (tp2, tp1\)
%trackpoint/minus
%function dx \= minus (tp2, tp1\)
%dx is a 1x2 vector that contains tp2\.loc \- tp1\.loc

dx \= tp2\.loc \- tp1\.loc;

\-\-\-

\#\#\# File: distance.m (ID: @TrackPoint.3\)

function d \= distance (tp1, tp2\)
%@TrackPoint
%d \= tp1\.distance(tp2\)
%function d \= distance (tp1, tp2\)
%distance between the two track points

d \= sqrt (sum (tp1\.minus(tp2\).^2\));
\-\-\-

\#\#\# File: toMWTBlobLine.m (ID: @TrackPoint.4\)

function str \= toMWTBlobLine(tp, camcalinfo, varargin)
% function str \= toMWTBlobLine(tp, camcalinfo, varargin)
% produces a line of text corresponding to a line in the mwt blob file
%
% tp \< MaggotTrackPoint
% str \- character array

if (\~exist('camcalinfo', 'var')), camcalinfo \= \[]; end
varargin \= assignApplicable(varargin);

data \= zeros(10, 1\);

data(1\) \= round(tp.ind);
data(2\) \= tp.et;
if (\~isempty(camcalinfo))
 data(3:4\) \= camcalinfo.camPtsFromRealPts(tp.loc);
else
 data(3:4\) \= tp.loc;
end
data(5\) \= round(tp.area);
c \= \[tp.cov(1\) tp.cov(2\); tp.cov(2\) tp.cov(3\)];

\[V,D] \= eig(c);
\[\~,I] \= sort(sum(D));
data(6:7\) \= V(:,I(2\))\*D(I(2\),I(2\));
data(8\) \= D(I(1\),I(1\));

%MWT does a fit of the maggot to a line, then gives the maximum length of a line
%parallel to that fit line with endpoints on the contour, and a similar length for the perpendicular line
%in order to avoid loading the pixel values from disk again, we will just
%use the longest line within the contour and the longest line
%perpendicular to that one

if (\~isempty(camcalinfo))
 cpts \= round(camcalinfo.camPtsFromRealPts(tp.contour));
else
 cpts \= tp.contour;
end
x \= repmat(cpts(1,:), size(cpts,2\), 1\);
y \= repmat(cpts(2,:), size(cpts,2\), 1\);
dd \= (x\-x').^2 \+ (y\-y').^2; 
\[dm,I] \= max(dd(:));
%longest distance
data(9\) \= sqrt(dm);
\[I,J] \= ind2sub(size(dd), I);

%perpendicular vector
vp \= \[\-diff(cpts(2, \[I J])) diff(cpts(1,\[I J]))];
vp \= vp./sqrt(sum(vp.^2\));
dd \= abs(vp(1\)\*(x\-x') \+ vp(2\)\*(y\-y'));
data(10\) \= max(dd(:));
str \= sprintf('%8g\\t', data);

\-\-\-

\#\#\# File: fromJava.m (ID: @TrackPoint.5\)

function tp \= fromJava(tp, jTP, loadIm, loadContour, camcalinfo)

 if (\~exist('camcalinfo', 'var'))
 camcalinfo \= \[]; 
 end
 
 %NOT SETTING LOC IN FILE
 tp.ind \= jTP.getFrameNum;
 tp.loc \= properCoords(\[jTP.getX; jTP.getY], camcalinfo);
 tp.area \= jTP.getArea; %In pixels^2
 %NOT SETTING COV
 
 
end
\-\-\-

\#\#\# File: fromFile.m (ID: @TrackPoint.6\)

function tp \= fromFile (tp, fid, loadIm, loadContour, camcalinfo)
%trackpoint.fromFile
%function tp \= fromFile (fid, loadIm, loadContour, camcalinfo)
%
%loadIm, loadContour: ignored
%
%ts \= tic;
try 
 if (\~exist('camcalinfo', 'var'))
 camcalinfo \= \[];
 end

 intType \= 'int32';
 floatType \= 'float32';

 tp.locInFile \= ftell(fid);
 tp.ind \= int32(fread(fid, 1, intType));
 tp.loc \= single(readPointsFromFile (fid, 1, floatType, camcalinfo));
 tp.area \= single(fread(fid, 1, floatType));
 cov \= (fread(fid, 4, floatType));
 tp.cov \= \[cov(1\);cov(2\);cov(4\)];
catch me
 disp (me.getReport);
 disp (\['fid \= ' num2str(fid)]);
 disp (\['current location \= ' num2str(ftell(fid))]);
 disp (\['point location \= ' num2str(tp.locInFile)]);
 disp (\['fid error message \= ' ferror(fid)]);
end
 
 %{
 if all(isfinite(cov))
 \[V,D] \= eig(reshape(cov,\[2 2]));
 if (D(1,1\) \> D(2,2\))
 tp.cov \= \[D(1,1\);D(2,2\);atan2(V(2,1\), V(1,1\))];
 else
 tp.cov \= \[D(2,2\);D(1,1\);atan2(V(2,2\), V(1,2\))];
 end
 %{
 tp.cov \= \[D(2,2\);D(1,1\);acos(V(1,2\))];
 if (tp.cov(1\) \< tp.cov(2\))
 tp.cov \= \[D(1,1\);D(2,2\);acos(V(1,1\))];
 end
 %}
 end
 %}
%toc(ts)

\-\-\-

\#\#\# Folder: @GlobalQuantity (ID: @GlobalQuantity)

\-\-\-

\#\#\# File: oneDinterpolationNearest.m (ID: @GlobalQuantity.1\)

function yout \= oneDinterpolationNearest(xin, xData, yData)
% does a 1\-D lookup table with nearest neighbor interpolation
% function yout \= oneDinterpolation(xin, xData, yData)

%reshape y to have correct dimension
sz \= size(yData);
n \= length(xData);

ind \= find(sz \=\= n);
ind2 \= find(sz \~\= n);

if (\~any(ind))
 errmsg \= \['yData and xData have incommensurate sizes: size(yData) \= ' mat2str(sz) ...
 ' and size xData \= ' mat2str(size(xData))];
 error('GERSHOW:GQ01', errmsg);
end

order \= \[ind ind2];
yData \= permute(yData, order);
size(yData);

%make sure xin is a column vector
if (size(xin,2\) \=\= 1\)
 xin \= xin';
end
s \= warning('off','all');
%interpolate
yout \= interp1 (double(xData), double(yData), xin, 'nearest', NaN);
warning(s);
end
\-\-\-

\#\#\# File: tri2Dinterpolation.m (ID: @GlobalQuantity.2\)

function yout \= tri2Dinterpolation(xin, xData, yData)
% interpolates a function defined on a scattered set of 2D points
% function yout \= tri2Dinterpolation(xin, xData, yData)
%
% uses delauney triangulation (TriScatteredInterp) to interpolate from
% scattered lists of points and values
%
% xin is a 2xM list of points 
% xData is a 2xN list of points
% yData is a kxN list of values 
% yData(:,j) \= underlyingFunction(xdata(:,j));
% output is a kxM list of values
% output \= underlyingFunction(xin)


%preallocate yout, preserving type
yout \= repmat(yData(1\), \[size(yData,1\),size(xin,2\)]);
islog \= islogical(yData);
xin \= double(xin);
xData \= double(xData);
yData \= double(yData);


for k \= 1:size(yData,1\)
% size(xData')
% size(yData(k,:))
% size(xin)
 F \= TriScatteredInterp(xData',yData(k,:)');
 out \= F(xin');
% size(yout(k,:))
% size(out)
 yout(k,:) \= out';
end

if (islog)
 yout \= logical(round(yout));
end
\-\-\-

\#\#\# File: timeVaryingGasDerivation.m (ID: @GlobalQuantity.3\)

function gasval \= timeVaryingGasDerivation (xin, xdata, ydata)
%function gasval \= timeVaryingGasDerivation (xin, xdata, ydata)
%
% the gas value at time t, location x is given by the following formulae
% dist \= (x \- xdata.origin) . (xdata.flowdir)
% gasval \= gasval0(t \- dist/xdata.flowspeed)
% where gasval at 0 is given by ydata vs. xdata.et
try 
 
 fnames \= fieldnames(xin);
 if (isfield(xin, 'eti'))
 eti \= xin.eti;
 else
 eti \= xin.(fnames{1});
 end
 if (isfield(xin, 'sloc'))
 loc \= xin.sloc;
 else
 loc \= xin.(fnames{2});
 end

 flowspeed \= xdata.flowspeed;
 flowdir \= xdata.flowdir;
 origin \= xdata.origin;
 et \= xdata.et;

 d \= (loc(1,:) \- origin(1\))\*flowdir(1\) \+ (loc(2,:) \- origin(2\))\*flowdir(2\);
 toff \= d/flowspeed;
 if (islogical(ydata))
 gasval \= interp1(et, double(ydata), eti\-toff, 'linear', NaN);
 if (any(\~isfinite(gasval)))
 gasval(\~isfinite(gasval)) \= interp1(et, double(ydata), (eti(\~isfinite(gasval))\-toff(\~isfinite(gasval))), 'nearest', 'extrap');
 end
 gasval \= logical(round(gasval));
 else
 gasval \= interp1(et, ydata, eti\-toff, 'linear', NaN);
 if (any(\~isfinite(gasval)))
 gasval(\~isfinite(gasval)) \= interp1(et, ydata, (eti(\~isfinite(gasval))\-toff(\~isfinite(gasval))), 'nearest', 'extrap');
 end
 end
catch me
 disp ('error adding time varying gas quantity. make sure xdata has fields flowspeed, flowdir, origin, and et; make sure xin has a time field followed by a location field');
 disp (me.getReport);
 gasval \= \[];
end

\-\-\-

\#\#\# File: timeVaryingGasDerivationNearest.m (ID: @GlobalQuantity.4\)

function gasval \= timeVaryingGasDerivationNearest (xin, xdata, ydata)
%function gasval \= timeVaryingGasDerivationNearest (xin, xdata, ydata)
%
% the gas value at time t, location x is given by the following formulae
% dist \= (x \- xdata.origin) . (xdata.flowdir)
% gasval \= gasval0(t \- dist/xdata.flowspeed)
% where gasval at 0 is given by ydata vs. xdata.et
try 
 fnames \= fieldnames(xin);
 if (isfield(xin, 'eti'))
 eti \= xin.eti;
 else
 eti \= xin.(fnames{1});
 end
 if (isfield(xin, 'sloc'))
 loc \= xin.sloc;
 else
 loc \= xin.(fnames{2});
 end

 flowspeed \= xdata.flowspeed;
 flowdir \= xdata.flowdir;
 origin \= xdata.origin;
 et \= xdata.et;

 d \= (loc(1,:) \- origin(1\))\*flowdir(1\) \+ (loc(2,:) \- origin(2\))\*flowdir(2\);
 toff \= d/flowspeed;
 gasval \= interp1(et, ydata, eti\-toff, 'linear', NaN);
 gasval(\~isfinite(gasval)) \= interp1(et, ydata, (eti(\~isfinite(gasval))\-toff(\~isfinite(gasval))), 'nearest', 'extrap');
catch me
 disp ('error adding time varying gas quantity. make sure xdata has fields flowspeed, flowdir, origin, and et; make sure xin has a time field followed by a location field');
 disp (me.getReport);
 gasval \= \[];
end

\-\-\-

\#\#\# File: GlobalQuantity.m (ID: @GlobalQuantity.5\)

classdef GlobalQuantity
 %GlobalQuantity specifies an additional field that is derived
 %from the position/time/etc. of a track and some additional information
 %that is the same for all tracks
 %
 %an example: say the temperature varies with time, then you could
 %define a global quantity with
 %independent field 'eti' (interpolated time)
 %field name 'temperature'
 %xData (a sequence of times)
 %yData (a sequence of temperatures at those times)
 %derivation method: GlobalQuantity.oneDinterpolation
 
 properties
 xField \= 'eti'; %name of the derived quantity to which the derivationMethod will be applied 
 fieldname \= ''; %name of the field in which the global data will be stored
 xData \= \[]; %xData, yData form pairs mapping the xField to the new field
 yData \= \[]; %xData, yData form pairs mapping the xField to the new field
 derivationMethod \= @GlobalQuantity.oneDinterpolation; %yfield \= derivationMethod (xfield, xData, yData);
 
 %NOTES:
 %track.getDerivedQuantity(xField) must return valid data
 %derivationMethod is a function of the form
 %yfield \= derivationMethod (xfield, xData, yData);
 %see oneDinterpolation and twoDinterpolation in this file for an example
 
 end
 
 methods
 function addQuantityToTrack (gq, track)
 %applies Global Quantity to Track using derivationMethod
 if (length(track) \> 1\)
 for j \= 1:length(track)
 addQuantityToTrack(gq, track(j));
 end
 return;
 end
 if (ischar (gq.xField))
 track.dq.(gq.fieldname) \= gq.derivationMethod(track.getDerivedQuantity(gq.xField), gq.xData, gq.yData);
 else
 for j \= 1:length(gq.xField)
 xin.(gq.xField{j}) \= track.getDerivedQuantity(gq.xField{j}); 
 end
 track.dq.(gq.fieldname) \= gq.derivationMethod(xin, gq.xData, gq.yData);
 end
 end
 gqs \= timeOnOffGQs (gq, ramptype, varargin);
 gqs \= timeOnOffGQsVariance (gq, ramptype, varargin)
 end
 
 
 methods (Static)
 function yout \= oneDinterpolation(xin, xData, yData)
 % does a 1\-D lookup table
 % function yout \= oneDinterpolation(xin, xData, yData)
 
 %reshape y to have correct dimension
 sz \= size(yData);
 n \= length(xData);
 
 ind \= find(sz \=\= n);
 ind2 \= find(sz \~\= n);
 
 if (\~any(ind))
 errmsg \= \['yData and xData have incommensurate sizes: size(yData) \= ' mat2str(sz) ...
 ' and size xData \= ' mat2str(size(xData))];
 error('GERSHOW:GQ01', errmsg);
 end
 
 order \= \[ind ind2];
 yData \= permute(yData, order);
 size(yData);
 
 %make sure xin is a column vector
 if (size(xin,2\) \=\= 1\)
 xin \= xin';
 end
 s \= warning('off','all');
 %interpolate
 yout \= interp1 (double(xData), double(yData), xin, 'linear', NaN);
 warning(s);
 %reshape yout to have same shape as yData
 % size(yout)
 % yout \= ipermute(yout, order);
 % size(yout)
 end
 function yout \= oneDinterpolation\_Clipped(xin, xData, yData)
 % does a 1\-D lookup table with linear interpolation
 % function yout \= oneDinterpolation(xin, xData, yData)
 % prior to interpolation, if xin \< min(xData), xin is set to min(xData) and
 % if xin \> max(xData), xin is set to max(xData);
 
 %reshape y to have correct dimension
 sz \= size(yData);
 n \= length(xData);
 
 ind \= find(sz \=\= n);
 ind2 \= find(sz \~\= n);
 
 if (\~any(ind))
 errmsg \= \['yData and xData have incommensurate sizes: size(yData) \= ' mat2str(sz) ...
 ' and size xData \= ' mat2str(size(xData))];
 error('GERSHOW:GQ01', errmsg);
 end
 
 order \= \[ind ind2];
 yData \= permute(yData, order);
 size(yData);
 
 %make sure xin is a column vector
 if (size(xin,2\) \=\= 1\)
 xin \= xin';
 end
 s \= warning('off','all');
 %interpolate
 xin(xin \< min(xData)) \= double(min(xData));
 xin(xin \> max(xData)) \= double(max(xData));
 yout \= interp1 (double(xData), double(yData), xin, 'linear', NaN);
 warning(s);
 %reshape yout to have same shape as yData
 % size(yout)
 % yout \= ipermute(yout, order);
 % size(yout)
 end
 
 function yout \= twoDinterpolation(xin, xData, yData)
 % does a 2D lookup table
 % function yout \= twoDinterpolation(xin, xData, yData)
 % xData is a NYxNXx2 matrix of x \& y locations (x \= xData(:,:,1\)
 % and y \= xData(:,:,2\))
 % or xData is a struct with fields x and y
 % yData is a (NYxNXxk) matrix of values
 % xin is a 2XM vector of x\&y locations
 % yout is a kXM vector
 
 if (isstruct(xData))
 x \= xData.x;
 y \= xData.y;
 else
 if (size(xData,3\) \> 1\)
 x \= xData(:,:,1\);
 y \= xData(:,:,2\);
 else
 x \= xData(1,:);
 y \= xData(2,:);
 end
 end
 x \= double(x);
 y \= double(y);
 isl \= islogical(yData);
 yData \= double(yData);
 yout \= NaN(\[size(yData,3\) size(xin,2\)]);
 inds \= isfinite(xin(1,:)) \& isfinite(xin(2,:));
 
 for k \= 1:size(yData,3\)
 yout(k,inds) \= interp2(x,y,yData(:,:,k), xin(1,inds), xin(2,inds), 'linear');
 end
 if (isl)
 yout \= logical(round(yout));
 end
 end
 function yout \= interpAngleIm(xin, xdata, ydata)
 %interpolates 2D angle field correctly
 u \= GlobalQuantity.twoDinterpolation(xin, xdata, cos(ydata));
 v \= GlobalQuantity.twoDinterpolation(xin, xdata, sin(ydata));
 yout \= atan2(v,u);
 end
 
 function yout \= oneDinterpolationAndMultiplication(xin, xData, yData)
 % does a 1\-D lookup table
 % mf \= oneDinterpolation(xin, xData.field1, yData)
 % yout \= mf\*xData.field2
 
 %reshape y to have correct dimension
 sz \= size(yData);
 
 n \= length(xData);
 
 ind \= find(sz \=\= n);
 ind2 \= find(sz \~\= n);
 
 if (\~any(ind))
 errmsg \= \['yData and xData have incommensurate sizes: size(yData) \= ' mat2str(sz) ...
 ' and size xData \= ' mat2str(size(xData))];
 error('GERSHOW:GQ01', errmsg);
 end
 
 order \= \[ind ind2];
 yData \= permute(yData, order);
 fnames \= fieldnames(xin);
 xd1 \= xin.(fnames{1});
 xd2 \= xin.(fnames{2});
 
 if (size(xd1,2\) \=\= 1\)
 xd1 \= xd1';
 end
 if (size(xd2,2\) \=\= 1\)
 xd2 \= xd2';
 end
 s \= warning('off','all');
 
 if (any(\~isfinite(xd1\)))
 inds \= find(isfinite(xd1\));
 xd1 \= interp1(inds, xd1(:,inds), 1:length(xd1\), 'nearest', 'extrap');
 end
 
 %interpolate
 yout \= interp1 (double(xData), double(yData), xd1, 'linear', NaN).\*xd2;
 warning(s);
 
 end
 yout \= tri2Dinterpolation(xin, xData, yData);
 gasval \= timeVaryingGasDerivation (xin, xdata, ydata);
 gasval \= timeVaryingGasDerivationNearest (xin, xdata, ydata);
 yout \= interpLogicalIm(xin, xdata, ydata);
 yout \= oneDinterpolationNearest(xin, xData, yData)
 end
end


\-\-\-

\#\#\# File: interpLogicalIm.m (ID: @GlobalQuantity.6\)

function yout \= interpLogicalIm(xin, xdata, ydata) 
%function yout \= interpLogicalIm(xin, xdata, ydata) 


yout \= logical(round(interp2(double(xdata.x), double(xdata.y), double(bwunpack(ydata)), double(xin(1,:)), double(xin(2,:)), '\*linear')));

\-\-\-

\#\#\# File: timeOnOffGQs.m (ID: @GlobalQuantity.7\)

function gqs \= timeOnOffGQs (gq, ramptype, varargin)
%function gqs \= timeOnOffGQs (gq, ramptype, varargin)
%
%creates time on/off fields based on a global quantity
%the time on is the time since the quantity went high (or started rising
%for a ramp)
%
%ramptype is 'square', 'triangle', 'sine', 'exponential',
%varargin \- 'oldstyle', true uses method in place before 3/24/2016 update
% \- 'fixedPeriod', t \- if the period is known, input it here. (not
% used by oldstyle)


if (isstruct(gq.xData))
 et \= gq.xData.et;
else
 et \= gq.xData;
end
ydat \= gq.yData;
gqs \= repmat(gq, \[1 6]);

oldstyle \= false;
varagin \= assignApplicable(varargin);

if(\~oldstyle)
 inds \= ceil(.01\*length(et)):floor(.99\*length(et)); %discard outer 1% for fitting purposes
 inds \= inds(inds\-min(et) \> 10\); %and discard the first 10 seconds
 \[freq, phase] \= fitWave(et(inds), ydat(inds), ramptype, varargin{:});
 period \= 2\*pi/freq;
 ton \= mysawtooth(freq\*et \+ phase, 1, 0, period);
 toff \= mysawtooth(freq\*et \+ phase \+ pi, 1, 0, period);
 high \= logical (sign(sin(freq\*et \+ phase)) \> 0\);
 low \= logical (sign(sin(freq\*et \+ phase)) \< 0\);
 %
 % rising \= diff(yfit) \> 0; rising(end\+1\) \= rising(end);
 % falling \= diff(yfit) \< 0; falling(end\+1\) \= falling(end);
 onstart \= \[diff(ton) 1] \< 0;
 offstart \= \[diff(toff) 1] \< 0;
 cycleon \= cumsum(onstart);
 cycleoff \= cumsum(offstart);
 
 ton(cycleon \< 1\) \= \-100;
 toff(cycleoff \< 1\) \= \-100;
 
 switch (lower(ramptype))
 case 'square'
 gqs(1\).fieldname \= \[gq.fieldname '\_high'];
 gqs(2\).fieldname \= \[gq.fieldname '\_low'];
 otherwise
 gqs(1\).fieldname \= \[gq.fieldname '\_rising'];
 gqs(2\).fieldname \= \[gq.fieldname '\_falling'];
 end
 gqs(1\).yData \= high;
 gqs(2\).yData \= low;
 
 gqs(3\).fieldname \= \[gq.fieldname '\_ton'];
 gqs(4\).fieldname \= \[gq.fieldname '\_toff'];
 gqs(3\).yData \= ton;
 gqs(4\).yData \= toff;
 
 gqs(5\).fieldname \= \[gq.fieldname '\_cyclenum\_on'];
 gqs(6\).fieldname \= \[gq.fieldname '\_cyclenum\_off'];
 gqs(5\).yData \= cycleon;
 gqs(6\).yData \= cycleoff;
else
 
 switch (lower(ramptype))
 case 'square'
 \[idx, c] \= kmeans(ydat', 2, 'start', \[min(ydat);max(ydat)]);
 if (c(1\) \> c(2\))
 high \= idx' \=\= 1;
 low \= idx' \=\= 2;
 else
 high \= idx' \=\= 2;
 low \= idx' \=\= 1;
 end
 
 nclust \= 2;
 
 while (nnz(high) \> 5\*nnz(low) \|\| nnz(low) \> 5\*nnz(high))
 nclust \= nclust \+ 1;
 %bad clustering if we end up with too many of one kind
 if (nclust \> 5\)
 error ('couldn''t partition data into high and low');
 end
 yx \= linspace(min(ydat), max(ydat), 100\);
 h1 \= hist(ydat, yx);
 \[\~,I] \= sort(h1, 'descend');
 %yx(I(1:nclust))
 
 \[idx, c] \= kmeans(ydat', nclust, 'start', yx(I(1:nclust))','emptyaction', 'singleton');%linspace(min(ydat),max(ydat),nclust)'
 nc \= zeros(\[1 nclust]);
 for j \= 1:nclust
 nc(j) \= nnz(idx \=\= j);
 end
 \[\~,I] \= sort(nc, 'descend');
 if (c(I(1\)) \> c(I(2\)))
 high \= idx' \=\= I(1\);
 low \= idx' \=\= I(2\);
 else
 high \= idx' \=\= I(2\);
 low \= idx' \=\= I(1\);
 end
 
 
 c \= c(\[I(1\) I(2\)]);
 end
 if (false)
 disp(\['cluster centers are ' num2str(c')]);
 end
 notany \= (\~high \& \~low);
 notany \= medfilt2(notany, \[1 9] , 'symmetric');
 notany \= imdilate(notany, ones(\[1 5]));
 
 high \= \~notany\&medfilt2(high, \[1 9], 'symmetric');
 low \= \~notany\&medfilt2(low, \[1 9], 'symmetric');
 gqs(1\).fieldname \= \[gq.fieldname '\_high'];
 gqs(2\).fieldname \= \[gq.fieldname '\_low'];
 gqs(1\).yData \= high;
 gqs(2\).yData \= low;
 %this marks the point before the transition
 starthigh \= find(diff(high) \> 0 \& \~(diff(notany) \< 0\));
 startlow \= find(diff(low) \> 0 \& \~(diff(notany) \< 0\));
 oldstarthigh \= starthigh;
 dv \= deriv(ydat, median(diff(starthigh))/20\); %this is a disgusting kludge! fix it. why should the derivative be related to the period?
 valid \= true(size(starthigh));
 for j \= 1:length(starthigh)
 %find the last point before the derivative starts increasing
 ind \= find(dv(1:starthigh(j)) \< 0\.1\*dv(starthigh(j)), 1, 'last');
 if (\~isempty(ind))
 %find the first point with a value above the value at that
 %derivative point (shouldn't it always be the next point if
 %derivative is positive?)
 starthigh(j) \= ind \+find(ydat(ind:end) \> ydat(ind), 1, 'first') \-1;
 else
 valid(j) \= false;
 end
 end
 starthigh \= starthigh(valid);
 % figure(1\);
 % plot (gqs(1\).xData, high, gqs(1\).xData(oldstarthigh),high(oldstarthigh), 'r.', gqs(1\).xData(starthigh), high(starthigh), 'g.');
 % figure(2\);
 % plot (gqs(1\).xData, dv, gqs(1\).xData(oldstarthigh),dv(oldstarthigh), 'r.', gqs(1\).xData(starthigh), dv(starthigh), 'g.');
 %
 valid \= true(size(startlow));
 % figure(1\);
 % plot (1:length(dv), dv, 'b\-', startlow, dv(startlow), 'g.', starthigh, dv(starthigh), 'r.');
 for j \= 1:length(startlow)
 ind \= find(dv(1:startlow(j)) \> 0\.1\*dv(startlow(j)), 1, 'last');
 if (\~isempty(ind))
 startlow(j) \= ind \+find(ydat(ind:end) \< ydat(ind), 1, 'first') \- 1;
 else
 valid(j) \= false;
 
 end
 end
 startlow \= startlow(valid);
 % size(startlow)
 case {'triangle','exponential'}
 %{
 dv \= deriv(ydat, 20\);
 falling \= medfilt2(dv \< 0, \[1 9], 'symmetric');
 rising \= medfilt2(dv \> 0, \[1 9], 'symmetric');
 gqs(1\).fieldname \= \[gq.fieldname '\_rising'];
 gqs(2\).fieldname \= \[gq.fieldname '\_falling'];
 gqs(1\).yData \= rising;
 gqs(2\).yData \= falling;
 %hx \= linspace(min(dv), max(dv), 100\);
 %figure(1\); plot (hx, hist(dv(falling), hx), 'b\-', hx, hist(dv(rising), hx), 'r\-');
 %figure(2\); plot (et(falling), ydat(falling), 'b.', et(rising), ydat(rising), 'r.');
 starthigh \= find(diff(rising) \> 0\);
 startlow \= find(diff(falling) \> 0\);
 %}
 starthigh \= findPeriodicMaxima(\-ydat);
 startlow \= findPeriodicMaxima(ydat);
 
 falling \= zeros(size(ydat));
 falling(startlow) \= 1;
 falling(starthigh(starthigh \> startlow(1\))) \= \-1;
 falling \= cumsum(falling);
 
 rising \= zeros(size(ydat));
 rising(starthigh) \= 1;
 rising(startlow(startlow \> starthigh(1\))) \= \-1;
 rising \= cumsum(rising);
 
 gqs(1\).fieldname \= \[gq.fieldname '\_rising'];
 gqs(2\).fieldname \= \[gq.fieldname '\_falling'];
 gqs(1\).yData \= logical(rising);
 gqs(2\).yData \= logical(falling);
 
 otherwise
 disp ('not implemented yet');
 return;
 end
 
 etstart \= et(find(diff(et) \< 10\*median(diff(et)), 1, 'first'));
 etend \= et(find(diff(et) \< 10\*median(diff(et)), 1, 'last') \+ 1\);
 
 detf \= max(median(diff(et))/100, 1E\-3\); %finest resolution we desire is 1 ms
 
 etf \= \[et(et \< etstart) (etstart:detf:etend) et(et\>etend)];
 %length(etf)
 %median(diff(etf))
 
 ton \= \-100 \* ones(size(etf));
 toff \= ton;
 whichon \= \-1 \* ones(size(etf));
 whichoff \= \-1 \* ones(size(etf));
 
 hightime \= et(starthigh);
 lowtime \= et(startlow);
 
 for j \= 1:length(hightime)
 ton(etf \>\= hightime(j)) \= etf(etf \>\= hightime(j)) \- hightime(j);
 whichon(etf \>\= hightime(j)) \= j;
 end
 for j \= 1:length(lowtime)
 toff(etf \>\= lowtime(j)) \= etf(etf \>\= lowtime(j)) \- lowtime(j);
 whichoff(etf \>\= lowtime(j)) \= j;
 end
 % for j \= 1:length(startlow)
 % toff(startlow(j):end) \= et(startlow(j):end) \- et(startlow(j));
 % end
 
 xData \= gqs(3\).xData;
 if (isstruct(xData))
 xData.et \= etf;
 else
 xData \= etf;
 end
 for k \= 3:6
 gqs(k).xData \= xData;
 end
 % gqs(4\).xData \= xData;
 % gqs(5\).xData \= xData;
 % gqs(6\).xData \= xData;
 
 if(strcmpi(func2str(gqs(3\).derivationMethod), 'GlobalQuantity.oneDinterpolation'))
 gqs(3\).derivationMethod \= @GlobalQuantity.oneDinterpolationNearest;
 for k \= 4:6
 gqs(k).derivationMethod \= gqs(3\).derivationMethod;
 end
 end
 if(strcmpi(func2str(gqs(3\).derivationMethod), 'GlobalQuantity.timeVaryingGasDerivation'))
 gqs(3\).derivationMethod \= @GlobalQuantity.timeVaryingGasDerivationNearest;
 for k \= 4:6
 gqs(k).derivationMethod \= gqs(3\).derivationMethod;
 end
 end
 
 gqs(3\).fieldname \= \[gq.fieldname '\_ton'];
 gqs(4\).fieldname \= \[gq.fieldname '\_toff'];
 gqs(3\).yData \= ton;
 gqs(4\).yData \= toff;
 
 gqs(5\).fieldname \= \[gq.fieldname '\_cyclenum\_on'];
 gqs(6\).fieldname \= \[gq.fieldname '\_cyclenum\_off'];
 gqs(5\).yData \= whichon;
 gqs(6\).yData \= whichoff;
end
\-\-\-

\#\#\# File: timeOnOffGQsVariance.m (ID: @GlobalQuantity.8\)

function gqs \= timeOnOffGQsVariance (gq, ramptype, varargin)
%function gqs \= timeOnOffGQsVariance (gq, ramptype, varargin)
%
%creates time on/off fields based on the magnitude of the variance of a 
%particular gq 
%calculates variance, discarding outliers then calls timeOnOffGQsVariance
%see timeOnOffGQs for more information


ydat \= gq.yData;

%discard outliers/transients and find variance
yds \= (ydat\-median(ydat)).^2;
valid \= (yds \< 10\*percentile(yds,.99\));
yds \= (ydat \- mean(ydat(valid))).^2;
yds(\~valid) \= 0; %variance

gq.yData \= yds;
gq.fieldname \= \[gq.fieldname '\_var'];

gqs \= gq.timeOnOffGQs(ramptype, varargin{:});

return
%old code \- eliminate when sure new code works
sigma \= 0\.2 / median(diff(et)); % average variance over 0\.2 seconds
ydat \= medfilt1(lowpass1D(yds, sigma), ceil(sigma)); %median filter over 0\.2 second



gqs \= repmat(gq, \[1 6]);

switch (lower(ramptype))
 case 'square'
 \[idx, c] \= kmeans(ydat', 2, 'start', \[min(ydat);max(ydat)]);
 if (c(1\) \> c(2\))
 high \= idx' \=\= 1;
 low \= idx' \=\= 2;
 else
 high \= idx' \=\= 2;
 low \= idx' \=\= 1;
 end
 
 nclust \= 2;
 
 while (nnz(high) \> 5\*nnz(low) \|\| nnz(low) \> 5\*nnz(high))
 nclust \= nclust \+ 1;
 %bad clustering if we end up with too many of one kind
 if (nclust \> 5\)
 error ('couldn''t partition data into high and low');
 end
 yx \= linspace(min(ydat), max(ydat), 100\);
 h1 \= hist(ydat, yx);
 \[\~,I] \= sort(h1, 'descend');
 %yx(I(1:nclust))
 
 \[idx, c] \= kmeans(ydat', nclust, 'start', yx(I(1:nclust))','emptyaction', 'singleton');%linspace(min(ydat),max(ydat),nclust)'
 nc \= zeros(\[1 nclust]);
 for j \= 1:nclust
 nc(j) \= nnz(idx \=\= j);
 end
 \[\~,I] \= sort(nc, 'descend');
 if (c(I(1\)) \> c(I(2\)))
 high \= idx' \=\= I(1\);
 low \= idx' \=\= I(2\);
 else
 high \= idx' \=\= I(2\);
 low \= idx' \=\= I(1\);
 end
 
 
 c \= c(\[I(1\) I(2\)]);
 end
 if (false)
 disp(\['cluster centers are ' num2str(c')]);
 end
 notany \= (\~high \& \~low);
 notany \= medfilt2(notany, \[1 9] , 'symmetric');
 notany \= imdilate(notany, ones(\[1 5]));
 
 high \= \~notany\&medfilt2(high, \[1 ceil(1/median(diff(et)))], 'symmetric');
 low \= \~notany\&medfilt2(low, \[1 ceil(1/median(diff(et)))], 'symmetric');
 gqs(1\).fieldname \= \[gq.fieldname '\_var\_high'];
 gqs(2\).fieldname \= \[gq.fieldname '\_var\_low']; 
 gqs(1\).yData \= high;
 gqs(2\).yData \= low;
 %this marks the point before the transition
 starthigh \= find(diff(high) \> 0 \& \~(diff(notany) \< 0\));
 startlow \= find(diff(low) \> 0 \& \~(diff(notany) \< 0\));
% oldstarthigh \= starthigh;
% dv \= deriv(ydat, median(diff(starthigh))/20\); %this is a disgusting kludge! fix it. why should the derivative be related to the period?
% valid \= true(size(starthigh)); 
% for j \= 1:length(starthigh)
% %find the last point before the derivative starts increasing
% ind \= find(dv(1:starthigh(j)) \< 0\.1\*dv(starthigh(j)), 1, 'last');
% if (\~isempty(ind))
% %find the first point with a value above the value at that
% %derivative point (shouldn't it always be the next point if
% %derivative is positive?)
% starthigh(j) \= ind \+find(ydat(ind:end) \> ydat(ind), 1, 'first') \-1;
% else
% valid(j) \= false;
% end
% end
% starthigh \= starthigh(valid);
% % figure(1\);
% % plot (gqs(1\).xData, high, gqs(1\).xData(oldstarthigh),high(oldstarthigh), 'r.', gqs(1\).xData(starthigh), high(starthigh), 'g.');
% % figure(2\);
% % plot (gqs(1\).xData, dv, gqs(1\).xData(oldstarthigh),dv(oldstarthigh), 'r.', gqs(1\).xData(starthigh), dv(starthigh), 'g.');
% % 
% valid \= true(size(startlow)); 
% % figure(1\);
% % plot (1:length(dv), dv, 'b\-', startlow, dv(startlow), 'g.', starthigh, dv(starthigh), 'r.');
% for j \= 1:length(startlow)
% ind \= find(dv(1:startlow(j)) \> 0\.1\*dv(startlow(j)), 1, 'last');
% if (\~isempty(ind))
% startlow(j) \= ind \+find(ydat(ind:end) \< ydat(ind), 1, 'first') \- 1;
% else
% valid(j) \= false;
% 
% end
% end
% startlow \= startlow(valid);
 % size(startlow)
 if (false)
 plot (et(high), ydat(high), 'r.', et(low), ydat(low), 'b.');
 pause;
 end
 otherwise
 disp ('not implemented yet');
 return;
end



etstart \= et(find(diff(et) \< 10\*median(diff(et)), 1, 'first'));
etend \= et(find(diff(et) \< 10\*median(diff(et)), 1, 'last') \+ 1\);

detf \= max(median(diff(et))/100, 1E\-3\); %finest resolution we desire is 1 ms

etf \= \[et(et \< etstart) (etstart:detf:etend) et(et\>etend)];
%length(etf)
%median(diff(etf))

ton \= \-100 \* ones(size(etf));
toff \= ton;
whichon \= \-1 \* ones(size(etf));
whichoff \= \-1 \* ones(size(etf));

hightime \= et(starthigh);
lowtime \= et(startlow);

for j \= 1:length(hightime)
 ton(etf \>\= hightime(j)) \= etf(etf \>\= hightime(j)) \- hightime(j);
 whichon(etf \>\= hightime(j)) \= j;
end
for j \= 1:length(lowtime)
 toff(etf \>\= lowtime(j)) \= etf(etf \>\= lowtime(j)) \- lowtime(j);
 whichoff(etf \>\= lowtime(j)) \= j;
end
% for j \= 1:length(startlow)
% toff(startlow(j):end) \= et(startlow(j):end) \- et(startlow(j));
% end

xData \= gqs(3\).xData;
if (isstruct(xData))
 xData.et \= etf;
else
 xData \= etf;
end
for k \= 3:6
 gqs(k).xData \= xData;
end
% gqs(4\).xData \= xData;
% gqs(5\).xData \= xData;
% gqs(6\).xData \= xData;

if(strcmpi(func2str(gqs(3\).derivationMethod), 'GlobalQuantity.oneDinterpolation'))
 gqs(3\).derivationMethod \= @GlobalQuantity.oneDinterpolationNearest;
 for k \= 4:6
 gqs(k).derivationMethod \= gqs(3\).derivationMethod;
 end
end
if(strcmpi(func2str(gqs(3\).derivationMethod), 'GlobalQuantity.timeVaryingGasDerivation'))
 gqs(3\).derivationMethod \= @GlobalQuantity.timeVaryingGasDerivationNearest;
 for k \= 4:6
 gqs(k).derivationMethod \= gqs(3\).derivationMethod;
 end
end

gqs(3\).fieldname \= \[gq.fieldname '\_var\_ton'];
gqs(4\).fieldname \= \[gq.fieldname '\_var\_toff'];
gqs(3\).yData \= ton;
gqs(4\).yData \= toff;

gqs(5\).fieldname \= \[gq.fieldname '\_var\_cyclenum\_on'];
gqs(6\).fieldname \= \[gq.fieldname '\_var\_cyclenum\_off'];
gqs(5\).yData \= whichon;
gqs(6\).yData \= whichoff;






\-\-\-

\#\#\# Folder: @MWTTrack (ID: @MWTTrack)

\-\-\-

\#\#\# File: MWTTrack.m (ID: @MWTTrack.1\)

classdef MWTTrack \< MaggotTrack
 %Extension of MaggotTrack for Multi Worm Tracker blob files
 %main difference is how to load a file
 
 properties
 fname;
 end
 methods
 fixHTOrientation(track, varargin);
 markHTInvalid(track, thresh, varargin);
 valid \= removeCollisionPoints(track, maxArea, varargin); 
 calculateDerivedQuantity(track, quantityNames, recalculate);
 end
 methods %constructor
 function mt \= MWTTrack (varargin)
 mt \= mt@MaggotTrack(varargin);
 mt.dr.interpTime \= 0\.033; %video taken at \~30 fps
 mt.dr.smoothTime \= 0\.25; %try less smoothing \& see
 mt.dr.derivTime \= 0\.25; %1 pt derivative
 mt.so \= MaggotSegmentOptions();
 mt.so.speed\_field \= 'smoothSpeed';
 if ((nargin \>\= 1\) \&\& isa(varargin{1}, 'MaggotTrack'))
 mt.clone(varargin{1});
 end
 end
 end %constructor
 methods (Static)
 mt \= fromFile(fname, camcalinfo); %or fid
 varargout \= validDQName (varargin);
 end
 
end


\-\-\-

\#\#\# File: markHTInvalid.m (ID: @MWTTrack.2\)

function markHTInvalid(track, thresh, varargin)
%function markHTInvalid(track, thresh, varargin)
%
%marks as invalid any point where spineDist/spineLength is \> thresh
%spineDist \= average distance travelled spine segments relative to the the
%midpoints of the spine in frame n \& n\-1
%spineLength \= length of the spine along the contour

debug \= false;
varargin \= assignApplicable(varargin);

ihtvalid \= track.getDerivedQuantity('spineDist')./track.getDerivedQuantity('spineLength') \<\= thresh;

if (any(\~ihtvalid))
 pt \= \[track.pt];
 et \= \[pt.et];
 eti \= track.getDerivedQuantity('eti');
 htv \= interp1(eti, double(ihtvalid), et) \> 0\.99;
 htv \= imerode(htv, ones(\[1 3])); %knock out point on either side as well
 htv \= num2cell(logical(htv \& \[pt.htValid])); %if a point was previously invalid, it's still invalid
 
 \[pt.htValid] \= deal(htv{:});
 inds \= (find(\[pt.htValid], 1, 'first')):(find(\[pt.htValid], 1, 'last'));
 
 track.pt \= pt(inds);
 track.npts \= length(inds);
 if (debug)
 figure(1\); clf();
 for billybob \= 1:2
 track.playMovie('axisSize', 1\.25 \* max(track.getDerivedQuantity('spineLength')), 'delayTime', .25, 'inds', find(\~\[pt.htValid]));
 end
 end
end
\-\-\-

\#\#\# File: removeCollisionPoints.m (ID: @MWTTrack.3\)

function valid \= removeCollisionPoints(track, maxArea, varargin)
% maintains only the portion of the track where the contour area is below
% maxArea
% function valid \= removeCollisionPoints(track, maxArea, varargin)

valid \= true;
pt \= \[track.pt];
area \= \[pt.area];
if (mean(area) \> maxArea)
 valid \= false;
 return;
end
good \= (area/mean(area) \< 1\.5\);
if (all(good)) 
 return;
end

start \= find (diff(good) \> 0\) \+ 1;
if (good(1\))
 start \= \[1 start];
end
stop \= find(diff(good) \< 0\);
if (good(end))
 stop \= \[stop length(good)];
end

len \= stop \- start;
\[\~,I] \= max(len);
track.pt \= pt(start(I):stop(I));
track.npts \= length(track.pt);
track.dq \= \[];



\-\-\-

\#\#\# File: fixHTOrientation.m (ID: @MWTTrack.4\)

function fixHTOrientation(mt, varargin)
%makes sure each head and tail point is aligned
%by aligning the spines
%function fixHTOrientation(track, varargin)

detectInvalid \= true;
debug \= false;
varargin \= assignApplicable(varargin);

pt \= mt.pt;
inds \= find(\[pt.htValid]);
if (isempty(inds))
 return;
end
oldspine \= pt(inds(1\)).spine;

for j \= 2:length(inds)
 
 sp \= pt(inds(j)).spine;
 d1 \= sum(sqrt(sum((sp \- oldspine).^2\)));
 d2 \= sum(sqrt(sum((sp(:,end:\-1:1\) \- oldspine).^2\)));
 if (d2 \< d1\)
 sp \= sp(:,end:\-1:1\);
 pt(inds(j)).spine \= sp;
 
 pt(inds(j)).head \= sp(:,end);
 pt(inds(j)).tail \= sp(:,1\);
 end
 oldspine \= sp;
end


m \= \[pt.mid];
h \= \[pt.head];
t \= \[pt.tail];

m \= m(:,inds);
h \= h(:,inds);
t \= t(:,inds);

vel \= diff(m,\[],2\);
mh \= h(:,2:end) \- m(:,2:end);
midtail \= t(:,2:end) \- m(:,2:end);
% 
% vel \= diff(\[pt(inds).mid], \[], 2\);
% mh \= \[pt(inds(2:end)).head] \- \[pt(inds(2:end)).mid];
% midtail \= \[pt(inds(2:end)).tail] \- \[pt(inds(2:end)).mid];
if (sum(dot(vel, mh)) \< sum(dot(vel,midtail)))
 for j \= 1:length(pt)
 temp \= pt(j).head;
 pt(j).head \= pt(j).tail;
 pt(j).tail \= temp;
 sp \= pt(j).spine;
 sp \= sp(:,end:\-1:1\);
 pt(j).spine \= sp;
 end
end
%pt(1\)
mt.pt \= pt;
mt.dq \= \[];



%now look for points where the spine jumps a signficant amount compared to
%the contour length, \& mark as invalid
if (detectInvalid)
 mt.markHTInvalid(0\.05\);
 mt.fixHTOrientation('detectInvalid', false, varargin{:});
 return;
end

%now let's segment track into regions of continuously valid ht \& consider
%those individually
htv \= \[pt.htValid];
m \= \[pt.mid];
h \= \[pt.head];
t \= \[pt.tail];

if (any (\~htv))
 start \= \[1 find(diff(htv) \> 0\)];
 stop \= \[find(diff(htv) \< 0\) \- 1, length(htv)];
 for j \= 1:length(start)
 inds \= start(j):stop(j);
 if (length(inds) \< 6\) %why bother
 continue;
 end
 vel \= diff(m(:,inds), \[], 2\);
 mh \= h(:,inds(2:end)) \- m(:,inds(2:end));
 midtail \= t(:,inds(2:end)) \- m(:,inds(2:end));
 
 if (sum(dot(vel, mh)) \< sum(dot(vel,midtail)))
 for k \= inds
 
 temp \= pt(k).head;
 pt(k).head \= pt(k).tail;
 pt(k).tail \= temp;
 sp \= pt(k).spine;
 sp \= sp(:,end:\-1:1\);
 pt(k).spine \= sp;
 end
 end
 end
 mt.pt \= pt;
end

%on last run through, use median filtering to fix parts that continue to be
%bad


mintime \= 5; %seconds minimum time for something to be bad before it needs to be fixed
track \= mt;


if (sum(\[pt.htValid]) \< 4 \|\| sum(\[pt.htValid]) \< 4\*mintime/track.dr.interpTime)
 return; %track is too short
end
sp \= track.getDerivedQuantity('smoothSpeed');
speedthresh \= percentile(sp, 0\.33\);
dpthresh \= \-0\.5;
assignApplicable(varargin);
minpts \= ceil(mintime/track.dr.interpTime);
dp \= track.getDerivedQuantity('vel\_dp');

inds \= find(sp \> speedthresh \& isfinite(dp));

if (length(inds) \< 2\)
 disp ('no points above speed cut in fixHTOrientation');
 return;
end
%whos inds
dp \= double(interp1(inds,dp(inds), 0:(length(dp)\+1\), 'nearest', 'extrap'));
%whos dp
%whos minpts
dpfilt \= medfilt1(dp, minpts);
badinds \= dpfilt \< dpthresh;
badinds \= find(imdilate(badinds, ones(\[1 3])));
badinds \= badinds((badinds \>\= 1\) \& (badinds \<\= length(track.dq.eti))); 
badtimes \= track.dq.eti((badinds)); %time when it's going backwards

%find the original points that are in that time range
%note we are assuming that the interpolation time \<\= sampling time, which
%should be valid; we space out by thirds to make sure we cover all points
%note unique sorts, so there is no need to do that here
badtimes \= unique(\[badtimes, badtimes\-track.dr.interpTime/3, badtimes\+track.dr.interpTime/3]);
badinds \= unique(interp1(\[pt.et], 1:track.npts, badtimes,'nearest', 'extrap'));

%swap head and tail in bad time range
if (\~isempty(badinds))
 for j \= badinds
 temp \= pt(j).head;
 pt(j).head \= pt(j).tail;
 pt(j).tail \= temp;
 sp \= pt(j).spine;
 sp \= sp(:,end:\-1:1\);
 pt(j).spine \= sp; 
 end
 mt.pt \= pt;
 track.dq \= \[];
end
\-\-\-

\#\#\# File: fromFile.m (ID: @MWTTrack.5\)

function mt \= fromFile(fname, camcalinfo) 
% loads a MWT Track from file, specified by fname 
% mt \= fromFile(fname)
% if fname ends with "blobs," multiple tracks are loaded
existsAndDefault('camcalinfo', \[]);
if (iscell(fname))
 mt \= MWTTrack.fromFile(fname{1}, camcalinfo);
 for j \= 2:length(fname)
 mt \= \[mt MWTTrack.fromFile(fname{j}, camcalinfo)];
 end
 disp ('fixing head tail orientation'); ts1 \= tic;
 for j \= 1:length(mt)
 try
 mt(j).fixHTOrientation;
 catch me
 j
 disp(me.getReport);
 end
 
 end
 toc(ts1\);
 return;
end
\[\~,\~,ext] \= fileparts(fname);

if (strcmpi(ext, '.blob'))
 fid \= fopen(fname,'rt');
 if (fid \< 0 \|\| isempty(fid))
 error (\['could not open file: ' fname]);
 end
 mt \= fromBlobFile(fid, camcalinfo);
 mt.fname \= fname;
 fclose(fid);
 return
end
if (strcmpi(ext, '.blobs'))
 fid \= fopen(fname, 'rt');
 if (fid \< 0 \|\| isempty(fid))
 error (\['could not open file: ' fname]);
 end
 mt \= fromBlobsFile(fid, camcalinfo);
 \[mt.fname] \= deal(fname);
 fclose(fid);
 return
end

warning ('Multi Worm Tracker tracks must be loaded from .blob or .blobs files');
mt \= \[];
return


end


function mt \= fromBlobFile(fid,camcalinfo)
 mt \= MWTTrack;
 mt.locInFile \= fpos;
 pt \= readTrackPoints(fid);
 mt.pt \= pt;
 mt.startFrame \= pt(1\).ind;
 mt.endFrame \= pt(end).ind;
 mt.npts \= length(pt); 
end

function mt \= fromBlobsFile(fid,camcalinfo)
 nt \= 0;
 fpos \= ftell(fid);
 fseek(fid, 0, 'eof');
 totalsize \= ftell(fid);
 fseek(fid, fpos, 'bof');
 ts \= tic;
 lastelapsed \= 0;
 reportEvery \= 30;
 
 while (\~feof(fid) \&\& isempty(ferror(fid)))
 fpos \= ftell(fid);
 elapsed \= toc(ts);
 if (elapsed \- lastelapsed \> reportEvery)
 lastelapsed \= elapsed;
 disp (\[num2str(elapsed) 's: ' num2str(ftell(fid)) '/' num2str(totalsize) ' bytes (' num2str(100\*ftell(fid)/totalsize, 2\) '%) loaded' ...
 num2str(elapsed\*(totalsize \- ftell(fid))/ftell(fid)) ' s remain']);
 end

 nt \= nt\+1;
 mt(nt) \= MWTTrack; %\#ok\<\*AGROW\>
 mt(nt).locInFile \= fpos;
 str \= fgetl(fid);
 if (str(1\) \~\= '%' \&\& \~feof(fid) \&\& \~ferror(fid) \&\& str(1\) \~\= \-1\)
 warning (\['expected % to begin track designation at ' fpos ' into file']);
 disp ('discarding the following: ')
 while (str(1\) \~\= '%')
 disp(str);
 str \= fgetl(fid);
 end
 end
 mt(nt).trackNum \= sscanf(str(2:end),'%d');
 pt \= readTrackPoints(fid,camcalinfo);
 mt(nt).pt \= pt;
 if (isempty(pt))
 valid(nt) \= false;
 continue;
 end
 valid(nt) \= true;
 mt(nt).startFrame \= pt(1\).ind;
 mt(nt).endFrame \= pt(end).ind;
 mt(nt).npts \= length(pt); 
 
 end
 mt \= mt(valid);
end

function mtp \= readTrackPoints(fid,camcalinfo)
 fpos \= ftell(fid); 
 str \= fgetl(fid);
 npts \= 0;
 mwtp \= MWTTrackPoint;
 % mtp \= repmat(mwtp, \[1 1E4]);
 % valid \= false(size(mtp));
 while (\~feof(fid) \&\& isempty(ferror(fid)) \&\& str(1\) \~\= \-1 \&\& str(1\) \~\= '%')
 try
 npts \= npts\+1;
 pt \= mwtp.fromMWTString(str,camcalinfo);
 pt.locInFile \= fpos;
 mtp(npts) \= pt;
 valid(npts) \= true;
 catch
 mtp(npts) \= MWTTrackPoint;
 valid(npts) \= false;
 end
 fpos \= ftell(fid);
 str \= fgetl(fid);
 end
 if (str(1\) \=\= '%')
 fseek(fid, fpos,'bof');
 end
 mtp \= mtp(valid);
end

 
\-\-\-

\#\#\# File: validDQName.m (ID: @MWTTrack.6\)

function varargout \= validDQName (varargin)
%@MartaTrack/validDQName
%static function that tells whether a name is a valid derived quantity
%function varargout \= validDQName (varargin)
%
%tf \= validDQName(name) \- true or false if name is a valid derived
%field for a track
%tflist \= validDQName(namelist) \- array of true or falses, namelist is a cell
%tflist \= validDQName('name1', 'name2') \- nargout \= nargin t/f
%namelist \= validDQName() \- returns a cell containing all valid field names

validfieldlist \= {'smoothVel', 'smoothSpeed','spmax', 'spmin', 'spamp'};
validfieldlist \= union(validfieldlist, MaggotTrack.validDQName);

varargout{:} \= Track.nameInList(validfieldlist, varargin{:});

 
 

\-\-\-

\#\#\# File: calculateDerivedQuantity.m (ID: @MWTTrack.7\)

function calculateDerivedQuantity(track, quantityNames, recalculate)
%track.calculateDerivedQuantity(quantityName)
%calculateDerivedQuantity(track, quantityName)
 if \~iscell(quantityNames)
 quantityNames \= {quantityNames};
 end
 if (\~exist('recalculate', 'var'))
 recalculate \= false;
 end
 for j \= 1:length(quantityNames)

 if (isfield(track.dq, quantityNames{j}) \&\& \~recalculate)
 continue;
 end
 %short\-circuit the normal track location program and use 
 %the smoothed velocity
 if strcmp(quantityNames{j}, 'vel\_dp')
 calculateVel\_DP(track);
 continue
 end
 if any(strcmp(quantityNames{j}, {'deltatheta', 'ddtheta', 'acc', 'curv'}))
 %this is a kludge for now to take into account that when you
 %ask for deltatheta or ddtheta, Track calculates acc \& curv
 
 calculateAcceleration(track);
 %track.calculateDerivedQuantity(quantityNames{j}, false); 
 continue
 end
 if (MaggotTrack.validDQName(quantityNames{j}))
 track.calculateDerivedQuantity@MaggotTrack(quantityNames{j}, recalculate);
 continue
 end
 switch(quantityNames{j})
 case {'smoothVel', 'smoothSpeed'}
 calculateSmoothSpeed(track);
 case {'spmax', 'spmin', 'spamp'}
 calculateSpeedExtrema (track);
 otherwise
 disp (\['I don''t recognize the quantity: ' quantityNames{j}]);
 end%switch
 end%for
end %cdq


function calculateSmoothSpeed(track)
 il \= track.getDerivedQuantity('iloc');
 sl \= lowpass1D(il, 0\.5 / track.dr.interpTime);
 track.dq.smoothVel \= deriv(sl, 0\.25 / track.dr.interpTime)/track.dr.interpTime;
 track.dq.smoothSpeed \= sqrt(sum(track.dq.smoothVel.^2\));

end
function calculateVel\_DP(track)
 mh \= track.getDerivedQuantity('shead') \- track.getDerivedQuantity('smid');
 mhnorm \= sqrt(sum(mh.^2\));
 try 
 mh \= mh ./ \[mhnorm;mhnorm];
 catch me
 disp(me.getReport);
 sum(track.dq.ihtValid) 
 size(mh)
 size(mhnorm)
 size(\[mhnorm;mhnorm])
 track
 track.dq
 
 end
 %track.dq.mhdir \= mh;
 v \= track.getDerivedQuantity('smoothVel');
 s \= track.getDerivedQuantity('smoothSpeed');
 v \= v ./ \[s;s];
 track.dq.vel\_dp \= dot(v,mh);
end

 
function calculateAcceleration(track) 
 sigma \= 0\.25/track.dr.interpTime;
 track.calculateDerivedQuantity('smoothSpeed');
 vel \= track.getDerivedQuantity('smoothVel');
 th \= unwrap(atan2(vel(2,:), vel(1,:)));
 track.dq.deltatheta \= single (deriv(th, sigma))/track.dr.interpTime;
 track.dq.ddtheta \= single (deriv(track.dq.deltatheta, sigma))/track.dr.interpTime;
 track.dq.acc \= single(deriv(track.dq.smoothVel,sigma))/track.dr.interpTime;
 track.dq.curv \= single((track.dq.smoothVel(1,:).\*track.dq.acc(2,:) \- track.dq.smoothVel(2,:).\*track.dq.acc(1,:))./(track.dq.smoothSpeed.^3\));
end

function calculateSpeedExtrema(track)
 sp \= track.getDerivedQuantity('speed');
 len \= 1 / track.dr.interpTime;
 track.dq.spmax \= ordfilt2(sp, len, ones(\[1 len]));
 track.dq.spmin \= ordfilt2(sp, 1, ones(\[1 len]));
 track.dq.spamp \= track.dq.spmax \- track.dq.spmin;
end

\-\-\-

\#\#\# Folder: basic routines (ID: basic routines)

\-\-\-

\#\#\# File: cameraMatrix.m (ID: basic routines.1\)

function CM \= cameraMatrix (u,v,x,y,z)
%function CM \= cameraMatrix (u,v,x,y,z)
%
%calculates the camera matrix that transforms a point in x,y,z real space
%to a point on the ccd u,v . x,y,z are a list of real points while u,v are
%the locations of the corresponding points on the CCD sensor.
%
%The camera matrix operates using homogenous coordinates, thus 
%(tu,tv,t) \= CM\*(x,y,z,1\) for some value of t.

%solve P\*CM\=(u1,v1,u2,v2 . . .)
%where P \= \[(x1 y1 z1 1 0 0 0 0 \-u1x1 \-u1y1 \-u1z1\),(0 0 0 0 x1 y1 z1 1
%\-v1x1 \-v1y1 \-v1z1\), . . . ]
%and CM is \[c11 c12 c13 c14 c23 . . . c33]
%CM34 \= 1, using up 1 free scaling factor

P \= zeros(11,length(u)\*2\);
X \= zeros(length(u)\*2,1\);
for j \= 1:length(u)
 k \= 2\*j \- 1;
 P(:,k) \= \[x(j) y(j) z(j) 1 0 0 0 0 \-u(j)\*x(j) \-u(j)\*y(j) \-u(j)\*z(j)];
 P(:,k\+1\) \= \[0 0 0 0 x(j) y(j) z(j) 1 \-v(j)\*x(j) \-v(j)\*y(j) \-v(j)\*z(j)];
 X(k) \= u(j);
 X(k\+1\) \= v(j);
end
%size(X)
%size(P')
%size(pinv(P'))
CM \= pinv(P')\*X;
CM(end\+1\) \= 1;
CM \= reshape(CM,4,3\);
CM \= CM';
 


\-\-\-

\#\#\# File: rotateticklabel.m (ID: basic routines.2\)

function th\=rotateticklabel(h,rot,ontop)
%ROTATETICKLABEL rotates tick labels
% TH\=ROTATETICKLABEL(H,ROT) is the calling form where H is a handle to
% the axis that contains the XTickLabels that are to be rotated. ROT is
% an optional parameter that specifies the angle of rotation. The default
% angle is 90\. TH is a handle to the text objects created. For long
% strings such as those produced by datetick, you may have to adjust the
% position of the axes so the labels don't get cut off.
%
% Of course, GCA can be substituted for H if desired.
%
% TH\=ROTATETICKLABEL(\[],\[],'demo') shows a demo figure.
%
% Known deficiencies: if tick labels are raised to a power, the power
% will be lost after rotation.
%
% See also datetick.

% Written Oct 14, 2005 by Andy Bliss
% Copyright 2005 by Andy Bliss
% modified 2/11/2011 by MHG

%DEMO:
existsAndDefault('ontop', false);
%set the default rotation if user doesn't specify
if nargin\=\=1
 rot\=90;
end
%make sure the rotation is in the range 0:360 (brute force method)
while rot\>360
 rot\=rot\-360;
end
while rot\<0
 rot\=rot\+360;
end
%get current tick labels
a\=get(h,'XTickLabel');
%erase current tick labels from figure
set(h,'XTickLabel',\[]);
%get tick label positions
b\=get(h,'XTick');
c\=get(h,'YLim');
if (ontop)
 c \= c(\[2 1]);
end
%make new tick labels

if xor(ontop,rot\<180\)
 th\=text(b,repmat(c(1\)\-.02\*(c(2\)\-c(1\)),length(b),1\),a,'HorizontalAlignment','right','rotation',rot);
else
 th\=text(b,repmat(c(1\)\-.02\*(c(2\)\-c(1\)),length(b),1\),a,'HorizontalAlignment','left','rotation',rot);
end


\-\-\-

\#\#\# File: sortIntoBinsC.m (ID: basic routines.3\)

function inds \= sortIntoBinsC(Y, binEdges)
%function inds \= sortIntoBinsC(Y, binEdges)
%
%inds(j) \= k implies binEdges(k) \<\= Y(j) \< binEdges(k\+1\)
%inds(j) \= length(binEdges) implies Y(j) \= binEdges(end)
%inds(j) \= NaN implies Y(j) \< binEdges(1\) or Y(j) \> binEdges(end)

inds \= zeros(size(Y));
for j \= 1:length(binEdges)
 inds \= inds \+ (Y \>\= binEdges(j));
end

inds(inds \=\= 0\) \= NaN;
inds(Y \> binEdges(end)) \= NaN;


\-\-\-

\#\#\# File: xyfromuv.m (ID: basic routines.4\)

function \[x,y] \= xyfromuv (u, v, C)
%function \[x,y] \= xyfromuv (u, v, C)

%gets the x,y coordinate (assumes z \= 0\) in real space for a position x,y
%on the sensor. Camera matrix is given in C

M \= \[C(1,1\)\-C(3,1\)\*u, C(1,2\)\-C(3,2\)\*u; C(2,1\)\-C(3,1\)\*v, C(2,2\) \- C(3,2\)\*v];
Y \= \[\-C(1,4\)\+C(3,4\)\*u;\-C(2,4\)\+C(3,4\)\*v];
X \= inv(M)\*Y;
x\=X(1\);
y\=X(2\);

\-\-\-

\#\#\# File: findPositiveZeroCrossings.m (ID: basic routines.5\)

function \[wholeinds, fracinds] \= findPositiveZeroCrossings(x)
%function \[wholeinds, fracinds] \= findPositiveZeroCrossings(x)
%
%finds locations where x(i) \< 0 and x(i\+1\) \> 0; 
%wholeinds \-\- i
%fracinds \-\- fractional index where x(fracind) \= 0 by linear interpolation
%if x(i) \=\= 0, then there is a positive zero crossing iff
% x(i \- 1\) \< 0 and
% x(i \+ 1\) \> 0

s \= sign(x);
if (all (s \=\= 0\))
 wholeinds \= \[];
 fracinds \= \[];
 return;
end
if (s(end) \=\= 0\)
 s(end) \= s(find(s \~\= 0, 1, 'last'));
end
while any(s \=\= 0\)
 s(s \=\= 0\) \= s(find(s \=\= 0\) \+ 1\);
end

wholeinds \= find(diff(s) \> 0\);
a \= x(wholeinds);
b \= x(wholeinds \+ 1\);
fracinds \= wholeinds \- a./(b\-a);

\-\-\-

\#\#\# File: hist3D.m (ID: basic routines.6\)

function v \= hist3D (xpts,ypts,zpts,xaxis,yaxis,zaxis)
%function v \= hist3D (xpts,ypts,zpts,xaxis,yaxis,zaxis)
%
%makes a 3D histogram of xpts,ypts,zpts with bins defined by xaxis yaxis
%zaxis

v \= zeros(\[length(yaxis),length(xaxis),length(zaxis)]);
inds \= find (xpts \>\= min(xaxis) \& xpts \<\= max(xaxis) \& ypts \>\= min(yaxis) \& ypts \<\= max(yaxis) \& zpts \>\= min(zaxis) \& zpts \<\= max(zaxis));
for n \= inds
 j \= find(xaxis \< xpts(n),1,'last');
 k \= find(yaxis \< ypts(n),1,'last');
 l \= find(zaxis \< zpts(n),1,'last');
 v(k,j,l) \= v(k,j,l)\+1;
end


\-\-\-

\#\#\# File: myhandle2struct.m (ID: basic routines.7\)

function s \= handle2struct(obj, parents)
%function s \= handle2struct(obj, parents)
%
%converts all handles to a structure in order to get at true memory size
%to avoid infinite recursion, we won't call handle to struct on any handle 
%that has already been called
existsAndDefault('parents', repmat(handle, \[0 0]));
try
 warning('off', 'all');
 if (isa(obj, 'handle'))
 if (any(parents \=\= obj))
 s \= obj;
 return;
 end
 parents \= \[parents, obj];
 s \= struct(obj);
 else
 s \= obj;
 end
catch me
 me.getReport();
 obj
 parents
end
if (isa (s, 'struct'))
 f \= fieldnames(s);
 for j \= 1:length(f)
 for k \= 1:length(s.(f{j}))
 s.(f{j})(k) \= handle2struct(s.(f{j})(k),parents);
 end
 end
end

\-\-\-

\#\#\# File: realPtsToCamera.m (ID: basic routines.8\)

function u \= realPtsToCamera(x, camcalinfo)
%function u \= realPtsToCamera(x, camcalinfo)
%
%x is a 2 X N vector of points
%we assume z \= 0
%camera calibration is given in camcalinfo
%if camcalinfo is \[] or nonexistent, u \= x
%otherwise, u is the set of camera locations that corresponds to x in real
%space

if (\~exist('camcalinfo', 'var') \|\| isempty(camcalinfo))
 u \= x;
 return;
end

\[ux,uy] \= cameraPointFromRealPoint(x(1,:), x(2,:), zeros(size(x(1,:))), camcalinfo);
u \= \[ux;uy];

\-\-\-

\#\#\# File: cloneaxes.m (ID: basic routines.9\)

function axnew \= cloneaxes( axold )
%function axnew \= cloneaxes( axold )
% creates a new axes with all the properties of the old axes
%{
props \= set(axold);
fn \= fieldnames(props);

axnew \= axes();
inds \= cellfun(@(x)\~isempty(x), vals);
fn \= fn(inds);
vals \= vals(inds);
%}
axnew \= axes('Position',get(axold,'Position'),...
 'XAxisLocation','top',...
 'YAxisLocation','right');
fn \= {'XLim', 'YLim'};
invalid \= {'Children','Title','XLabel','YLabel','ZLabel'};
\[fn, \~] \= setdiff(fn, invalid);
vals \= get(axold, fn);

for j \= 1:length(fn)
 %fn{j}
 %vals{j}
 set(axnew, fn{j}, vals{j});
end
%linkaxes(\[axold,axnew]);


\-\-\-

\#\#\# File: figureForPrinting.m (ID: basic routines.10\)

function h \= figureForPrinting(h)
%function h \= figureForPrinting(h)

if (\~exist('h','var') \|\| isempty(h))
 h \= figure();
else
 figure(h);
end

clf(h);

ratio \= 4/3;

set(h,'units','inches');
p \= get(h,'position');
p(3\) \= 4;
p(4\) \= 4/ratio;
set(h,'position', p);
set(h, 'units','pixels');
set(h, 'PaperUnits', 'inches');
set(h,'PaperPosition', \[1 1 4 4/ratio]);
set(h,'PaperOrientation', 'portrait');

\-\-\-

\#\#\# File: barweb.m (ID: basic routines.11\)

function handles \= barweb(barvalues, errors, width, groupnames, bw\_title, bw\_xlabel, bw\_ylabel, bw\_colormap, gridstatus, bw\_legend, error\_sides, legend\_type)

%
% Usage: handles \= barweb(barvalues, errors, width, groupnames, bw\_title, bw\_xlabel, bw\_ylabel, bw\_colormap, gridstatus, bw\_legend, error\_sides, legend\_type)
%
% Ex: handles \= barweb(my\_barvalues, my\_errors, \[], \[], \[], \[], \[], bone, \[], bw\_legend, 1, 'axis')
%
% barweb is the m\-by\-n matrix of barvalues to be plotted.
% barweb calls the MATLAB bar function and plots m groups of n bars using the width and bw\_colormap parameters.
% If you want all the bars to be the same color, then set bw\_colormap equal to the RBG matrix value ie. (bw\_colormap \= \[1 0 0] for all red bars)
% barweb then calls the MATLAB errorbar function to draw barvalues with error bars of length error.
% groupnames is an m\-length cellstr vector of groupnames (i.e. groupnames \= {'group 1'; 'group 2'}). For no groupnames, enter \[] or {}
% The errors matrix is of the same form of the barvalues matrix, namely m group of n errors.
% Gridstatus is either 'x','xy', 'y', or 'none' for no grid.
% No legend will be shown if the legend paramter is not provided
% 'error\_sides \= 2' plots \+/\- std while 'error\_sides \= 1' plots just \+ std
% legend\_type \= 'axis' produces the legend along the x\-axis while legend\_type \= 'plot' produces the standard legend. See figure for more details
%
% The following default values are used if parameters are left out or skipped by using \[].
% width \= 1 (0 \< width \< 1; widths greater than 1 will produce overlapping bars)
% groupnames \= '1', '2', ... number\_of\_groups
% bw\_title, bw\_xlabel, bw\_ylabel \= \[]
% bw\_color\_map \= jet
% gridstatus \= 'none'
% bw\_legend \= \[]
% error\_sides \= 2;
% legend\_type \= 'plot';
%
% A list of handles are returned so that the user can change the properties of the plot
% handles.ax: handle to current axis
% handles.bars: handle to bar plot
% handles.errors: a vector of handles to the error plots, with each handle corresponding to a column in the error matrix
% handles.legend: handle to legend
%
%
% See the MATLAB functions bar and errorbar for more information
%
% Author: Bolu Ajiboye
% Created: October 18, 2005 (ver 1\.0\)
% Updated: Dec 07, 2006 (ver 2\.1\)
% Updated: July 21, 2008 (ver 2\.3\)

% Get function arguments
if nargin \< 2
 error('Must have at least the first two arguments: barweb(barvalues, errors, width, groupnames, bw\_title, bw\_xlabel, bw\_ylabel, bw\_colormap, gridstatus, bw\_legend, barwebtype)');
elseif nargin \=\= 2
 width \= 1;
 groupnames \= 1:size(barvalues,1\);
 bw\_title \= \[];
 bw\_xlabel \= \[];
 bw\_ylabel \= \[];
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
elseif nargin \=\= 3
 groupnames \= 1:size(barvalues,1\);
 bw\_title \= \[];
 bw\_xlabel \= \[];
 bw\_ylabel \= \[];
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
elseif nargin \=\= 4
 bw\_title \= \[];
 bw\_xlabel \= \[];
 bw\_ylabel \= \[];
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
elseif nargin \=\= 5
 bw\_xlabel \= \[];
 bw\_ylabel \= \[];
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
elseif nargin \=\= 6
 bw\_ylabel \= \[];
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
elseif nargin \=\= 7
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
elseif nargin \=\= 8
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
elseif nargin \=\= 9
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
elseif nargin \=\= 10
 error\_sides \= 2;
 legend\_type \= 'plot';
elseif nargin \=\= 11
 legend\_type \= 'plot';
end

change\_axis \= 0;
ymax \= 0;
ymin \= 0;
if size(barvalues,1\) \~\= size(errors,1\) \|\| size(barvalues,2\) \~\= size(errors,2\)
 error('barvalues and errors matrix must be of same dimension');
else
 if size(barvalues,2\) \=\= 1
 barvalues \= barvalues';
 errors \= errors';
 end
 if size(barvalues,1\) \=\= 1
 barvalues \= \[barvalues; zeros(1,length(barvalues))];
 errors \= \[errors; zeros(1,size(barvalues,2\))];
 change\_axis \= 1;
 end
 numgroups \= size(barvalues, 1\); % number of groups
 numbars \= size(barvalues, 2\); % number of bars in a group
 if isempty(width)
 width \= 1;
 end
 
 % Plot bars
 handles.bars \= bar(barvalues, width,'edgecolor','k', 'linewidth', 2\);
 hold on
 if \~isempty(bw\_colormap)
 colormap(bw\_colormap);
 else
 colormap(jet);
 end
 if \~isempty(bw\_legend) \&\& \~strcmp(legend\_type, 'axis')
 handles.legend \= legend(bw\_legend, 'location', 'best', 'fontsize',12\);
 legend boxoff;
 else
 handles.legend \= \[];
 end
 
 % Plot erros
 for i \= 1:numbars
 x \=get(get(handles.bars(i),'children'), 'xdata');
 x \= mean(x(\[1 3],:));
 handles.errors(i) \= errorbar(x, barvalues(:,i), errors(:,i), 'k', 'linestyle', 'none', 'linewidth', 2\);
 ymax \= max(\[ymax; barvalues(:,i)\+errors(:,i)]);
 ymin \= min(\[ymin; barvalues(:,i)\-errors(:,i)]);
 end
 
 if error\_sides \=\= 1
 set(gca,'children', flipud(get(gca,'children')));
 end
 
 ylim(\[1\.1\*ymin ymax\*1\.1]);
 xlim(\[0\.5 numgroups\-change\_axis\+0\.5]);
 
 if strcmp(legend\_type, 'axis')
 yl \= get(gca, 'YLim');
 
 yloc \= min(yl) \* 1\.002 \- max(yl)\*0\.002;
 for i \= 1:numbars
 xdata \= get(handles.errors(i),'xdata');
 for j \= 1:length(xdata)
 % try
 handles.leg(i,j) \= text(xdata(j), yloc, bw\_legend(i), 'Rotation', 60, 'fontsize', 12, 'HorizontalAlignment', 'right');
 % catch me
 % disp(me.getReport)
 % xdata
 % ymax
 % bw\_legend
 % end
 end
 end
 set(gca,'xaxislocation','top', 'box', 'on');
 end
 
 if \~isempty(bw\_title)
 title(bw\_title, 'fontsize',14\);
 end
 if \~isempty(bw\_xlabel)
 xlabel(bw\_xlabel, 'fontsize',14\);
 end
 if \~isempty(bw\_ylabel)
 ylabel(bw\_ylabel, 'fontsize',14\);
 end
 
 set(gca, 'xticklabel', groupnames, 'box', 'on', 'ticklength', \[0 0], 'fontsize', 12, 'xtick',1:numgroups, 'linewidth', 2,'xgrid','off','ygrid','off');
 if (change\_axis \=\= 1\)
 xx \= cell2mat(get(handles.errors, 'XData')');
 
 set(gca, 'XTick', xx(1,:));
 end
 if \~isempty(gridstatus) \&\& any(gridstatus \=\= 'x')
 set(gca,'xgrid','on');
 end
 if \~isempty(gridstatus) \&\& any(gridstatus \=\= 'y')
 set(gca,'ygrid','on');
 end
 
 handles.ax \= gca;
 
 hold off
end
\-\-\-

\#\#\# File: mypsd.m (ID: basic routines.12\)

function \[ps, k,fullps] \= mypsd (data, npoints)
%function \[ps, k, fullps] \= mypsd (data, npoints)
%

k \= (0:(npoints\-1\))/npoints;


paddata \= zeros(\[1 ceil(length(data)/npoints)\*npoints]);
paddata(1:length(data)) \= data;

paddata \= reshape (paddata, npoints, \[]);

ffdata \= fft(paddata,\[],1\) / (npoints/2\);

ps \= mean(abs(ffdata).^2, 2\);
fullps \= ps;
k \= k(1:(npoints/2\));
ps \= ps(1:(npoints/2\));
\-\-\-

\#\#\# File: imCov.m (ID: basic routines.13\)

function \[c,com] \= imCov(im, com)
%function \[c,com] \= imCov(im, com)
%
%c is the covariance matrix defined by 
%c(i,j) mean(Im(k) x(i,k) \* x(j,k))
%where x(i,k) \= pos(i,k) \- com(i)
%
%if com is not passed in, it is calculated by
%com \= mean(Im(k) pos(:,k))
im \= double(im);
\[x,y] \= meshgrid(1:size(im,2\), 1:size(im,1\));
if (\~exist('com', 'var'))
 com(1\) \= sum(x(:) .\* im(:))/sum(im(:));
 com(2\) \= sum(y(:) .\* im(:))/sum(im(:));
end;

x \= x(:) \- com(1\);
y \= y(:) \- com(2\);

c \= zeros(2,2\);
c(1,1\) \= sum(im(:) .\* x.^2\);
c(1,2\) \= sum(im(:) .\* x .\* y);
c(2,1\) \= c(1,2\);
c(2,2\) \= sum(im(:) .\* y.^2\);
c \= c/sum(im(:));

\-\-\-

\#\#\# File: myjet.m (ID: basic routines.14\)

function cmap \= myjet(n)
%function cmap \= myjet(n)

if (nargin \> 0\)
 cmap \= jet(n);
else
 cmap \= jet();
end

cmap(1,:) \= 1;
\-\-\-

\#\#\# File: mylocalmax.m (ID: basic routines.15\)

function inds \= mylocalmax (vec)
%function inds \= mylocalmax (vec)
%

inds \= find(diff(vec) \< 0 \& (\[0 diff(vec(1:(end\-1\)))] \> 0\));

\-\-\-

\#\#\# File: expandImage.m (ID: basic routines.16\)

function im2 \= expandImage (im, scale)
%function im2 \= expandImage (im, scale)
%
%takes an image im and stretches it by a factor scale 
%then returns the result in im2

x \= (0:(size(im,2\) \- 1\)) \* scale;
y \= (0:(size(im,1\) \- 1\)) \* scale;

x2 \= 0:x(end);
y2 \= 0:y(end);

\[x,y] \= meshgrid(x,y);
\[x2,y2] \= meshgrid(x2,y2\);

im2 \= interp2(x,y,im,x2,y2,'\*linear');



\-\-\-

\#\#\# File: testAssignApplicapleAndFixTypes.m (ID: basic routines.17\)

function testAssignApplicapleAndFixTypes

boolval \= false;
numval \= 10;
charval \= 'foobar';


assignApplicableAndFixTypes({'boolval', 'true'});
boolval
whos boolval

assignApplicableAndFixTypes({'boolval', '0'});
boolval
whos boolval

assignApplicableAndFixTypes({'numval', '147'});
numval
whos numval

assignApplicableAndFixTypes({'charval', 'true'});
charval
whos charval
\-\-\-

\#\#\# File: plotColorLine.m (ID: basic routines.18\)

function hh \= plotColorLine (x, y, z, cmap, zrange, varargin)
%function h \= plotColorLine (x, y, z, cmap, zrange, varargin)

showcolorbar \= false;
decimate \= length(x) \> 1E4;
decimateLength \= 1e4;
varargin \= assignApplicable(varargin);


x \= interp1(find(isfinite(x)), x(isfinite(x)), 1:length(x), 'nearest', 'extrap');
y \= interp1(find(isfinite(y)), y(isfinite(y)), 1:length(y), 'nearest', 'extrap');
z \= interp1(find(isfinite(z)), z(isfinite(z)), 1:length(z), 'nearest', 'extrap');


if decimate
 df \= round(length(x) / decimateLength);
 k \= ones(\[1 df]);
 d \= conv(ones(size(x)), k, 'same');
 x \= conv(x, k, 'same')./d;
 y \= conv(y, k, 'same')./d;
 z \= conv(z, k, 'same')./d;
 x \= x(1:df:end);
 y \= y(1:df:end);
 z \= z(1:df:end);
end
 

existsAndDefault('cmap', jet(256\));
if (\~exist('zrange','var') \|\| isempty(zrange))
 zrange \= \[min(z) max(z)];
end
ih \= ishold;
cx \= ((1:length(cmap)) \- 1\)\*(zrange(2\)\-zrange(1\))/length(cmap) \+ zrange(1\);



for j \= 1:length(x)
 if (isempty(varargin))
 h(j) \= plot(x(j),y(j),'b.'); hold on
 else
 h(j) \= plot(x(j),y(j),'b.',varargin{:}); hold on
 end
 set(h(j),'Color',interp1(cx,cmap,z(j),'nearest','extrap'));
end

if (showcolorbar)
 ch \= colorbar ('vert');%,'CLim',\[1 length(cmap)]); 
 yr \= get(ch, 'YLim');
 yt \= get(ch, 'YTick');

 m \= (diff(zrange))/diff(yr);
 b \= zrange(1\) \- m\*yr(1\);
 zt \= m\*yt \+ b;
 for j \= 1:length(yt)
 ztl{j} \= num2str(zt(j));
 end
 set (ch, 'YTickLabel', ztl);
 
end
if (\~ih)
 hold off;
end
if (nargout \> 0\)
 hh \= h;
end
\-\-\-

\#\#\# File: downsizeStruct.m (ID: basic routines.19\)

function str2 \= downsizeStruct (str)
%function str2 \= downsizeStruct (str)
%
%converts doubles to singles to save memory space


fn \= fieldnames (str);
for k \= 1:length(str)
 for j \= 1:length(fn)
 if (isa(str(k).(fn{j}), 'float'))
 str2(k).(fn{j}) \= single(str(k).(fn{j}));
 else
 if isa(str(k).(fn{j}), 'struct')
 str2(k).(fn{j}) \= downsizeStruct(str(k).(fn{j}));
 else
 str2(k).(fn{j}) \= str(k).(fn{j});
 end
 end
 end
end
\-\-\-

\#\#\# File: percentile.m (ID: basic routines.20\)

function pctls \= percentile (list, percentiles)
%function pctls \= percentile (list, percentiles)
%
%finds the values corresponding to the percentiles (expressed as a fraction
%between (0 and 1\) of list
%if list is 2D, list is flattened to 1D first

if (any (percentiles \< 0 \| percentiles \> 1\))
 disp ('percentiles must be expressed as a fraction between 0 and 1');
 pctls \= \[];
 return;
end
list \= sort(list(:));
inds \= round(percentiles\*length(list));
inds(inds \<\= 0\) \= 1;
inds(inds \> length(list)) \= length(list);
pctls \= list(inds);

\-\-\-

\#\#\# File: straightLineRatio.m (ID: basic routines.21\)

function \[slr,pl] \= straightLineRatio (pts, dn)
%function slr \= straightLineRatio (pts, dn)
%slr(j) \= distance between pts(j\+dn) and pts(j) divided by the path length
%distance between them

sz \= size(pts);
if (sz(1\) \> sz(2\))
 pts \= pts';
end

dl \= sqrt(sum(diff(pts,1,2\).^2,1\));
pl \= conv2(dl, ones(\[1 dn]));
dx \= sqrt(sum((pts(:,(1\+dn):end)\-pts(:,1:(end\-dn))).^2,1\));
%{
size(dl)
size(pl)
size(dx)
size(pl(dn:(end\-dn)))
%}
slr \= dx./(pl(dn:(end\-dn\+1\)));

\-\-\-

\#\#\# File: indexCrossingBox.m (ID: basic routines.22\)

function ind \= indexCrossingBox (ptlist, index, range, position)
%function ind \= indexCrossingBox (ptlist, index, range, position)
%
%finds either the beginning of the track given in ptlist (position \= start)
%or the end of the track that goes through ptlist(index) and remains
%entirely within the box defined by ptlist(index) \+/\- range/2 
%if range is 1D, it is used for both

st \= strcmpi(position, 'start');
if (st)
 ptlist \= ptlist(:,1:index);
else 
 ptlist \= ptlist(:,index:end);
end
range \= abs(range);
if size(range,1\) \=\= 1
 range \= range';
end
sz \= size(ptlist);
sz(1\) \= 1;
if (size(range \=\= 1\))
 range \= repmat (range, size(ptlist));
else
 range \= repmat (range, sz);
end
center \= repmat(ptlist(:,index), sz);
inrange \= all(ptlist \< (center \+ range/2\), 1\) \& all(ptlist \> (center \- range/2\), 1\);
if (st)
 ind \= find(\~inrange, 1, 'last');
 if (isempty(ind))
 ind \= 1;
 end
else
 ind \= find(\~inrange, 1, 'first');
 if (isempty(ind))
 ind \= length(ptlist);
 else
 ind \= index \+ ind;
 end
end


\-\-\-

\#\#\# File: assignApplicable.m (ID: basic routines.23\)

function x \= assignApplicable(x)
% PVPMOD \- evaluate parameter/value pairs
% pvpmod(x) assigns the value x(i\+1\) to the parameter defined by the
% string x(i) in the calling workspace if and only if the calling function
% already has a parameter by the name x{i} defined
% otherwise, does nothing
% unused parameter\-value pairs are returned in x
% This is useful to evaluate 
%  contents in an mfile, e.g. to change default settings 
% of any variable initialized before pvpmod(x) is called.
%
% modified by marc gershow from pvpmod by
% (c) U. Egert 1998

%\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#
% this loop is assigns the parameter/value pairs in x to the calling
% workspace.
if (nargin \=\= 0\)
 return;
end
used \= \[];
vars \= evalin('caller', 'who');
if \~isempty(x)
 skipnext \= false;
 for i \= 1:size(x,2\)
 if skipnext
 skipnext \= false;
 continue;
 end
 if (isstr(x{i}) \&\& any(strcmp(x{i},vars))) 
 assignin('caller', x{i}, x{i\+1});
 used \= \[used i];
 skipnext \= true;
 end
 end;
end;
if (\~isempty(used))
 used \= \[used used\+1];
 inds \= setdiff(1:length(x), used);
 x \= x(inds);
end

%\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#


\-\-\-

\#\#\# File: assignApplicableAndFixTypes.m (ID: basic routines.24\)

function x \= assignApplicableAndFixTypes(x)
% PVPMOD \- evaluate parameter/value pairs
% pvpmod(x) assigns the value x(i\+1\) to the parameter defined by the
% string x(i) in the calling workspace if and only if the calling function
% already has a parameter by the name x{i} defined
% otherwise, does nothing
% unused parameter\-value pairs are returned in x
% This is useful to evaluate 
%  contents in an mfile, e.g. to change default settings 
% of any variable initialized before pvpmod(x) is called.
%
% modified by marc gershow from pvpmod by
% (c) U. Egert 1998

%\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#
% this loop is assigns the parameter/value pairs in x to the calling
% workspace.
used \= \[];
vars \= evalin('caller', 'who');
%s \= evalin('caller', 'whos');
%vars \= {s.name}';
if \~isempty(x)
 skipnext \= false;
 for i \= 1:size(x,2\)
 if skipnext
 skipnext \= false;
 continue;
 end
 if (ischar(x{i}) \&\& any(strcmp(x{i},vars))) 
 % ind \= find(strcmp(x{i}, vars), 1, 'first');
 oldval \= evalin('caller', x{i});
 val \= fixType(x{i\+1}, oldval);
 assignin('caller', x{i}, val);
 used \= \[used i];
 skipnext \= true;
 end
 end;
end;
if (\~isempty(used))
 used \= \[used used\+1];
 inds \= setdiff(1:length(x), used);
 x \= x(inds);
end

%\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#

function val \= fixType(val, oldval)
if ((isnumeric(val) \&\& isnumeric(oldval)) \|\| isa(val, class(oldval)))
 return;
end
if(ischar(val)) 
 if (isnumeric(oldval))
 val \= str2double(val);
 return;
 end
 if (islogical(oldval))
 if (strcmpi(val, 'true'))
 val \= true;
 return;
 end
 if (strcmpi(val, 'false'))
 val \= false;
 return;
 end
 try
 v \= val;
 val \= logical(str2double(val));
 catch
 disp (\['could not update logical value to ' v]);
 val \= oldval;
 return;
 end
 return;
 end
 return
end

if (islogical(oldval))
 v \= val;
 try
 val \= logical(val);
 catch
 disp (\['could not update logical value to ' v]);
 val \= oldval;
 return
 end
end
 

\-\-\-

\#\#\# File: lowpass1D.m (ID: basic routines.25\)

function lpdata \= lowpass1D (data, sigma, varargin)
%function lpdata \= lowpass1D (data, sigma, varargin)
%lowpasses data with a gaussian filter of width sigma
%
%optional parameter/value pairs
%'padType', pt
%pt is one of 'zeros', 'ends', 'linear', 'mirror'
%
%if padType is zeros, pad ends with zeros
%if padType is 'ends', pad with the values at the end points
%if padType is 'linear', pad(1:kw) \= data(1:kw) \-
%data(kw) \+ data(1\)
%if padType is 'mirror', pad(1:kw) \= 2\*data(1\) \- data(kw:1\)
%where kw is kernel width
%if padType is 'circular', pad(1:kw) \= data((end\-kw\+1\):end)
%
%if data is a matrix, lowpass is done along the first dimension
%unless the first dimensions is smaller than the second AND also smaller
%than the maximum of (3,kernel size)
%(implying you probably meant to lowpass along the second dimension)
%
% this is a change from previous implementation, and could cause problems
% for some previous code, especially with large first dimensions that are
% meant to be transposed. EG size of the data is (15,2000\) and sigma \= 1;
% previously would have been transposed, now is not
padType \= 'ends';
varargin \= assignApplicable(varargin);
g \= gaussKernel(sigma);
kw \= floor(length(g)/2\);
%old code \-\- this is a bug!
% if (size(data,1\) \< size(data,2\))
% data \= data';
% transpose \= 1;
% else
% transpose \= 0;
% end
%only transpose if first dimension is smaller than second AND
%first dimension is smaller than convolution kernel size
if (size(data,1\) \< size(data,2\) \&\& size(data,1\) \< max(3,length(g))) 
 data \= data';
 transpose \= 1;
else
 transpose \= 0;
end
lpdata \= zeros(size(data));
for k \= 1:size(data,2\)
 paddeddata \= zeros(\[size(data,1\)\+2\*kw,1]);
 paddeddata((kw\+1\):end\-kw) \= data(:,k);
 switch (padType)
 case ('ends')
 paddeddata(1:kw)\=data(1, k);
 paddeddata((end\-kw\+1\):end) \= data(end,k);
 case ('linear')
 paddeddata(1:kw)\=data(1:kw, k) \+ data(1,k) \- data(kw,k);
 paddeddata((end \- kw \+ 1\):end) \= data(end \- kw \+ 1:end,k) \+ data(end,k) \- data(end \- kw \+ 1, k);
 case ('circular')
 paddeddata(1:kw)\=data((end\-kw\+1\):end, k);
 paddeddata((end \- kw \+ 1\):end) \= data(1:kw,k);
 case ('mirror')
 paddeddata(1:kw)\=2\*data(1,k) \- data(kw:\-1:1, k);
 paddeddata((end \- kw \+ 1\):end) \= 2\*data(end,k) \- data(end:\-1:(end \- kw \+ 1\),k);
 end
 lpdata(:,k) \= conv2(paddeddata,g','valid');
end
if (transpose)
 lpdata \= lpdata';
end
\-\-\-

\#\#\# File: binomialpval.m (ID: basic routines.26\)

function pval \= binomialpval (m,n,p)
%function pval \= binomialpval (m,n,p)
%
%if the null hypothesis is that the p fraction of the time, the result is
%true, then
%pval is the probability at least m out of n trials are true

sigma \= sqrt(n\*p.\*(1\-p));
mn \= n\*p;
pval \= 1/2\*(erfc((m\-mn)./(sqrt(2\)\*sigma)));

\-\-\-

\#\#\# File: plotColorLine3\.m (ID: basic routines.27\)

function hh \= plotColorLine3 (x, y, z, u, cmap, urange, varargin)
%function h \= plotColorLine (x, y, z, u, cmap, urange, varargin)

showcolorbar \= false;
decimate \= length(x) \> 1E4;
decimateLength \= 1e4;
varargin \= assignApplicable(varargin);


x \= interp1(find(isfinite(x)), x(isfinite(x)), 1:length(x), 'nearest', 'extrap');
y \= interp1(find(isfinite(y)), y(isfinite(y)), 1:length(y), 'nearest', 'extrap');
z \= interp1(find(isfinite(z)), z(isfinite(z)), 1:length(z), 'nearest', 'extrap');
u \= interp1(find(isfinite(u)), u(isfinite(u)), 1:length(u), 'nearest', 'extrap');


if decimate
 df \= round(length(x) / decimateLength);
 k \= ones(\[1 df]);
 d \= conv(ones(size(x)), k, 'same');
 x \= conv(x, k, 'same')./d;
 y \= conv(y, k, 'same')./d;
 z \= conv(z, k, 'same')./d;
 u \= conv(z, k, 'same')./d;
 x \= x(1:df:end);
 y \= y(1:df:end);
 z \= z(1:df:end);
 u \= u(1:df:end);
end
 

existsAndDefault('cmap', jet(256\));
if (\~exist('urange','var') \|\| isempty(urange))
 urange \= \[min(u) max(u)];
end
ih \= ishold;
cx \= ((1:length(cmap)) \- 1\)\*(urange(2\)\-urange(1\))/length(cmap) \+ urange(1\);



for j \= 1:length(x)
 if (isempty(varargin))
 h(j) \= plot3(x(j),y(j),z(j), 'b.'); hold on
 else
 h(j) \= plot(x(j),y(j),z(j), 'b.',varargin{:}); hold on
 end
 set(h(j),'Color',interp1(cx,cmap,u(j),'nearest','extrap'));
end

if (showcolorbar)
 ch \= colorbar ('vert');%,'CLim',\[1 length(cmap)]); 
 yr \= get(ch, 'YLim');
 yt \= get(ch, 'YTick');

 m \= (diff(urange))/diff(yr);
 b \= urange(1\) \- m\*yr(1\);
 zt \= m\*yt \+ b;
 for j \= 1:length(yt)
 utl{j} \= num2str(ut(j));
 end
 set (ch, 'YTickLabel', utl);
 
end
if (\~ih)
 hold off;
end
if (nargout \> 0\)
 hh \= h;
end
\-\-\-

\#\#\# File: embiggen.m (ID: basic routines.28\)

function embiggen (ax,fs)
if (nargin \< 1\)
 ax \= gca;
end
existsAndDefault('fs', 16\);

set(ax,'FontSize', fs);
elems \= {'XLabel', 'YLabel', 'Title'};
for j \= 1:length(elems)
 set (get(ax,elems{j}), 'FontSize', fs);
end
\-\-\-

\#\#\# File: imgradient.m (ID: basic routines.29\)

function \[xderiv,yderiv, tderiv] \= imgradient (im, sigma)
%function \[xderiv,yderiv] \= imgradient (im, sigma)
if (size(im, 3\) \> 1\)
 xderiv \= zeros(size(im));
 yderiv \= xderiv;
 for j \= 1:size(im,3\)
 \[xderiv(:,:,j), yderiv(:,:,j)] \= imgradient(im(:,:,j), sigma);
 end
 if (nargout \> 2\)
 tderiv \= zeros(size(xderiv));
 for j \= 1:size(im,1\)
 tderiv(j,:,:) \= imgradient(squeeze(im(j,:,:)), sigma);
 end
 end
 return;
end
gk \= gaussKernel(sigma);
dg \= dgausskernel(sigma);
padsize \= floor(length(gk)/2\);
padim \= padarray(im, \[padsize padsize], 'replicate');

xderiv \= conv2(gk, dg, double(padim), 'valid');
if (nargout \> 1\)
 yderiv \= conv2(dg, gk, double(padim), 'valid');
end
\-\-\-

\#\#\# File: readPointsFromFile.m (ID: basic routines.30\)

function pts \= readPointsFromFile (fid, npts, type, camcalinfo)
%function pts \= readPointsFromFile (fid, npts, type, camcalinfo)
%
%reads in a set of points (2 x npts of type) from a file then transforms
%them into real coordinates using camcalinfo
%npts
%type
if (npts \< 1\)
 pts \= \[];
 return
end
if (npts \> 1\)
 pts \= fread (fid,\[2 double(npts)], type);
else
 pts \= fread(fid, 2, type);
end
if \~isempty(camcalinfo)
 if (isa (camcalinfo, 'CameraCalibration'))
 pts \= camcalinfo.realPtsFromCamPts(pts);
 else
 %legacy code
 for j \= 1:npts
 \[xx,yy] \= realPointFromCameraPoint(pts(1,j)\-camcalinfo.xc,pts(2,j)\-camcalinfo.yc,camcalinfo.CM, camcalinfo.K);
 pts(1,j) \= xx;
 pts(2,j) \= yy;
 end
 end
end
%{
for j \= 1:npts
 if (\~isempty(camcalinfo)) 
 \[xx,yy] \= realPointFromCameraPoint(pts(1,j)\-camcalinfo.xc,pts(2,j)\-camcalinfo.yc,camcalinfo.CM, camcalinfo.K);
 else
 xx \= pts(1,j);
 yy \= pts(2,j);
 end
 pts(1,j) \= xx;
 pts(2,j) \= yy;
end
%}
\-\-\-

\#\#\# File: barweb\_marc.m (ID: basic routines.31\)

function handles \= barweb\_marc(barvalues, errors, width, groupnames, bw\_title, bw\_xlabel, bw\_ylabel, bw\_colormap, gridstatus, bw\_legend, error\_sides, legend\_type, barx)

%
% Usage: handles \= barweb(barvalues, errors, width, groupnames, bw\_title, bw\_xlabel, bw\_ylabel, bw\_colormap, gridstatus, bw\_legend, error\_sides, legend\_type)
%
% Ex: handles \= barweb(my\_barvalues, my\_errors, \[], \[], \[], \[], \[], bone,
% \[], bw\_legend, 1, 'axis')
%
% barweb is the m\-by\-n matrix of barvalues to be plotted.
% barweb calls the MATLAB bar function and plots m groups of n bars using the width and bw\_colormap parameters.
% If you want all the bars to be the same color, then set bw\_colormap equal to the RBG matrix value ie. (bw\_colormap \= \[1 0 0] for all red bars)
% barweb then calls the MATLAB errorbar function to draw barvalues with error bars of length error.
% groupnames is an m\-length cellstr vector of groupnames (i.e. groupnames \= {'group 1'; 'group 2'}). For no groupnames, enter \[] or {}
% The errors matrix is of the same form of the barvalues matrix, namely m group of n errors.
% Gridstatus is either 'x','xy', 'y', or 'none' for no grid.
% No legend will be shown if the legend paramter is not provided
% 'error\_sides \= 2' plots \+/\- std while 'error\_sides \= 1' plots just \+ std
% legend\_type \= 'axis' produces the legend along the x\-axis while legend\_type \= 'plot' produces the standard legend. See figure for more details
%
% The following default values are used if parameters are left out or skipped by using \[].
% width \= 1 (0 \< width \< 1; widths greater than 1 will produce overlapping bars)
% groupnames \= '1', '2', ... number\_of\_groups
% bw\_title, bw\_xlabel, bw\_ylabel \= \[]
% bw\_color\_map \= jet
% gridstatus \= 'none'
% bw\_legend \= \[]
% error\_sides \= 2;
% legend\_type \= 'plot';
%
% A list of handles are returned so that the user can change the properties of the plot
% handles.ax: handle to current axis
% handles.bars: handle to bar plot
% handles.errors: a vector of handles to the error plots, with each handle corresponding to a column in the error matrix
% handles.legend: handle to legend
%
%
% See the MATLAB functions bar and errorbar for more information
%
% Author: Bolu Ajiboye
% Created: October 18, 2005 (ver 1\.0\)
% Updated: Dec 07, 2006 (ver 2\.1\)
% Updated: July 21, 2008 (ver 2\.3\)

% Get function arguments
% Get function arguments
if nargin \< 2
 error('Must have at least the first two arguments: barweb(barvalues, errors, width, groupnames, bw\_title, bw\_xlabel, bw\_ylabel, bw\_colormap, gridstatus, bw\_legend, barwebtype)');
elseif nargin \=\= 2
 width \= 1;
 groupnames \= 1:size(barvalues,1\);
 bw\_title \= \[];
 bw\_xlabel \= \[];
 bw\_ylabel \= \[];
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
 barx \= 1:size(barvalues, 1\);
elseif nargin \=\= 3
 groupnames \= 1:size(barvalues,1\);
 bw\_title \= \[];
 bw\_xlabel \= \[];
 bw\_ylabel \= \[];
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
 barx \= 1:size(barvalues, 1\);
elseif nargin \=\= 4
 bw\_title \= \[];
 bw\_xlabel \= \[];
 bw\_ylabel \= \[];
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
 barx \= 1:size(barvalues, 1\);
elseif nargin \=\= 5
 bw\_xlabel \= \[];
 bw\_ylabel \= \[];
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
 barx \= 1:size(barvalues, 1\);
elseif nargin \=\= 6
 bw\_ylabel \= \[];
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
 barx \= 1:size(barvalues, 1\);
elseif nargin \=\= 7
 bw\_colormap \= jet;
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
 barx \= 1:size(barvalues, 1\);
elseif nargin \=\= 8
 gridstatus \= 'none';
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
 barx \= 1:size(barvalues, 1\);
elseif nargin \=\= 9
 bw\_legend \= \[];
 error\_sides \= 2;
 legend\_type \= 'plot';
 barx \= 1:size(barvalues, 1\);
elseif nargin \=\= 10
 error\_sides \= 2;
 legend\_type \= 'plot';
 barx \= 1:size(barvalues, 1\);
elseif nargin \=\= 11
 legend\_type \= 'plot';
 barx \= 1:size(barvalues, 1\);
elseif nargin \=\= 12
 barx \= 1:size(barvalues, 1\);
end
if (size(barvalues, 1\) \=\= 1\)
 barvalues \= \[barvalues;barvalues];
 barvalues(2,:) \= NaN;
 errors \= \[errors;errors];
 errors(2,:) \= NaN;
 onegroup \= true;
 barx \= 1:2;
else
 onegroup \= false;
end
%xdata \= 1:size(barvalues, 1\);
xdata \= barx;

change\_axis \= 0;
ymax \= 0;
ymin \= 0;
if size(barvalues,1\) \~\= size(errors,1\) \|\| size(barvalues,2\) \~\= size(errors,2\)
 error('barvalues and errors matrix must be of same dimension');
end

if (\~isempty(xdata) \&\& size(barvalues,1\) \~\= length(xdata))
 barvalues \= barvalues';
 errors \= errors';
end

numgroups \= size(barvalues, 1\); % number of groups
numbars \= size(barvalues, 2\); % number of bars in a group

if isempty(width)
 width \= 1;
end

% Plot bars
for j \= 1:numgroups
 data \= NaN(size(barvalues)); %was zeros
 data(j,:) \= barvalues(j,:);
 handles.bars(j,:) \= bar(xdata, data, width, 'edgecolor','k', 'linewidth', get(gca,'LineWidth')); hold on
end
% 
% data \= NaN(size(barvalues));
% handles.bars(j\+1,:) \= bar(xdata, data, width, 'edgecolor','k', 'linewidth', 2\); hold on

if \~isempty(bw\_colormap)
 colormap(bw\_colormap);
else
 colormap(jet);
end
if \~isempty(bw\_legend) \&\& \~strcmp(legend\_type, 'axis')
 handles.legend \= legend(bw\_legend, 'location', 'best', 'fontsize',12\);
 legend boxoff;
else
 handles.legend \= \[];
end

% Plot erros
for i \= 1:numbars
 for j \= 1:numgroups
 xx \= handles.bars(j,i).XData; %changed 3/21/2018
 x(j) \= mean(xx(:,j));
% xx \=get(get(handles.bars(j,i),'children'), 'xdata');
% if (isempty(xx))
% continue;
% end
% x(j) \= mean(xx(\[1 3],j));
 end
 if (exist('x', 'var') \&\& \~isempty(x))
 handles.errors(i) \= errorbar(x, barvalues(:,i), errors(:,i), 'k', 'linestyle', 'none', 'LineWidth', get(gca, 'LineWidth'));
 ymax \= max(\[ymax; barvalues(:,i)\+errors(:,i)]);
 ymin \= min(\[ymin; barvalues(:,i)\-errors(:,i)]);
 end
 
end

if error\_sides \=\= 1
 set(gca,'children', flipud(get(gca,'children')));
end
if (ymin \~\= ymax)
 ylim(\[1\.1\*ymin ymax\*1\.1]);
end
if (onegroup)
 xlim (\[0\.5 1\.5]);
else 
% numgroups
% xdata(1\)
% xdata(2\)
% xdata(end)
% xdata(end\-1\)
% 1\.5\*xdata(1\)\-xdata(2\)
% xdata(end)\*1\.5\-xdata(end\-1\)
 xlim(\[1\.5\*xdata(1\)\-0\.5\*xdata(2\) xdata(end)\*1\.5\-0\.5\*xdata(end\-1\)]);
 %xlim(\[0\.5 numgroups\+0\.5]);
end

if strcmp(legend\_type, 'axis')
 yl \= get(gca, 'YLim');
 
 yloc \= min(yl) \* 1\.002 \- max(yl)\*0\.002;
 for i \= 1:numbars
 xdata \= get(handles.errors(i),'xdata');
 if (onegroup)
 ul \= 1;
 else 
 ul \= length(xdata);
 end
 for j \= 1:ul
 % try
 handles.leg(i,j) \= text(xdata(j), yloc, bw\_legend(i), 'Rotation', 60, 'fontsize', 12, 'HorizontalAlignment', 'right');
 % catch me
 % disp(me.getReport)
 % xdata
 % ymax
 % bw\_legend
 % end
 end
 end
 set(gca,'xaxislocation','top', 'box', 'on');
end

if \~isempty(bw\_title)
 title(bw\_title, 'fontsize',14\);
end
if \~isempty(bw\_xlabel)
 xlabel(bw\_xlabel, 'fontsize',14\);
end
if \~isempty(bw\_ylabel)
 ylabel(bw\_ylabel, 'fontsize',14\);
end
set(gca, 'xticklabel', groupnames, 'box', 'on', 'ticklength', \[0 0], 'xtick',1:numgroups, 'xgrid','off','ygrid','off');
if (onegroup)
 set(gca, 'XTick', 1\);
end

if (change\_axis \=\= 1\)
 xx \= cell2mat(get(handles.errors, 'XData')');
 
 set(gca, 'XTick', xx(1,:));
end
if \~isempty(gridstatus) \&\& any(gridstatus \=\= 'x')
 set(gca,'xgrid','on');
end
if \~isempty(gridstatus) \&\& any(gridstatus \=\= 'y')
 set(gca,'ygrid','on');
end

handles.baseline \= plot (get(gca, 'XLim'), \[0 0], 'k\-', 'LineWidth', get(gca, 'LineWidth'), 'Color', get(gca, 'XColor'));

handles.ax \= gca;

% bz \= handles.bars(:);
% for j \= 1:length(bz)
% xd \= get(bz(j), 'XData');
% yd \= get(bz(j), 'YData');
% xd \= xd(isfinite(yd));
% yd \= yd(isfinite(yd));
% set(bz(j), 'XData', xd, 'YData', yd);
% end

hold off

\-\-\-

\#\#\# File: getSubDirectories.m (ID: basic routines.32\)

function dirlist \= getSubDirectories(fn)
%function dirlist \= getSubDirectories(fn)

d \= dir(fn);
d \= d(3:end); %get rid of . and ..

d \= d(\[d.isdir]);

if (fn(end) \~\= '\\')
 fn \= \[fn '\\'];
end
for j \= 1:length(d)
 dirlist{j} \= \[fn d(j).name];
end


\-\-\-

\#\#\# File: gaussKernel.m (ID: basic routines.33\)

function g \= gaussKernel (sigma)
%function g \= gaussKernel (sigma)
%
%returns a normalized gaussian 6 sigma in total width, with standard
%deviation sigma
if (sigma \<\= 0\)
 g \= 1;
 return;
end
x \= floor(\-3\*sigma):ceil(3\*sigma);
g \= exp(\-x.^2/(2 \* sigma.^2\));
g \= g./sum(g);


\-\-\-

\#\#\# File: assignFromStruct.m (ID: basic routines.34\)

function y \= assignFromStruct(x)
% PVPMOD \- evaluate parameter/value pairs
% pvpmod(x) assigns the value x(i\+1\) to the parameter defined by the
% string x(i) in the calling workspace if and only if the calling function
% already has a parameter by the name x{i} defined
% otherwise, does nothing
% unused parameter\-value pairs are returned in x
% This is useful to evaluate 
%  contents in an mfile, e.g. to change default settings 
% of any variable initialized before pvpmod(x) is called.
%
% modified by marc gershow from pvpmod by
% (c) U. Egert 1998

%\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#
% this loop is assigns the parameter/value pairs in x to the calling
% workspace.
used \= \[];
vars \= evalin('caller', 'who');
fn \= fieldnames(x);

for i \= 1:length(fn)
 if (any(strcmp(fn{i},vars)))
 assignin('caller', fn{i}, x.(fn{i}));
 used \= \[used i]; %\#ok
 end
 
end
if (\~isempty(used))
 inds \= setdiff(1:length(fn), used);
 for j \= inds
 y.(fn{inds{j}}) \= x.(fn{inds(j)});
 end
end

%\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#


\-\-\-

\#\#\# File: thresholdToTargetArea.m (ID: basic routines.35\)

function \[bwim,thresh] \= thresholdToTargetArea (im, targetArea, centerLoc)
%function \[bwim,thresh] \= thresholdToTargetArea (im, targetArea, centerLoc)
%
%finds a threshold thresh, s.t. the area of the region containing centerLoc
%is approx startThresh

low \= double(min(im(:)));
high \= double(max(im(:)));
startThresh \= (double(high) \+ double(low))/2;

%existsAndDefault('startThresh', 
%gv \= sort(im(:),'descend');
%startThresh \= interp1(double(gv), targetArea);
%startThresh
existsAndDefault('centerLoc', (size(im'))/2\);
if (size(centerLoc,2\) \=\= 1\)
 centerLoc \= centerLoc';
end
if (im(round(centerLoc(2\)), round(centerLoc(1\))) \< startThresh)
 % warning('TTA:SECONDREG', 'a brighter off\-center region appears in this image');
 startThresh \= im(round(centerLoc(2\)), round(centerLoc(1\)))\-1;
end

%existsAndDefault('startThresh', (low \+ high) / 2\);


thresh \= double(startThresh);
ncalls \= 0;
while (low \< (high\-1\))
 props \= regionprops(im \>\= thresh, 'Centroid', 'Area', 'PixelIdxList');
 %area \= sum(im1d \>\= thresh);
 %area \= nnz(im1d \>\= thresh);
 ind \= 1;
 %area \= props(1\).Area;
 for j \= 2:length(props)
 %props(j).Centroid
 %centerLoc
 if (sum((props(j).Centroid \- centerLoc).^2\) \< sum((props(ind).Centroid \- centerLoc).^2\))
 ind \= j;
 end
 end
 area \= props(ind).Area;
 if (area \=\= targetArea) 
 break
 end
 if (area \< targetArea)
 high \= thresh;
 else
 low \= thresh;
 end
 thresh \= round((low \+ high) / 2\);
 ncalls \= ncalls \+ 1;
end
if (ncalls \> 8\)
 disp(\['called ' num2str(ncalls) 'times']);
end
bwim \= false(size(im));
bwim(props(ind).PixelIdxList) \= true;
%bwim \= im \>\= thresh;

\-\-\-

\#\#\# File: nearestNPoints.m (ID: basic routines.36\)

function \[xout, yout, inds] \= nearestNPoints (x0, y0, x, y, npts)
%function \[xout, yout] \= nearestNPoints (x0, y0, x, y, npts)

d \= (x\-x0\).^2 \+ (y \- y0\).^2;
\[\~,I] \= sort(d);
xout \= x(I(1:npts));
yout \= y(I(1:npts));
inds \= I(1:npts);
\-\-\-

\#\#\# File: gaussian.m (ID: basic routines.37\)

function g \= gaussian (x, m, s)
%function g \= gaussian (x, m, s)
g \= (1/sqrt(2\*pi\*s^2\))\*exp(\-(x\-m).^2/(2\*s^2\));
dx \= diff(x);
dx(end\+1\) \= dx(end);
g \= g.\*dx;

\-\-\-

\#\#\# File: meanyvsx.m (ID: basic routines.38\)

function \[x,meany,standarderror,standarddeviation,sumy, numx] \= meanyvsx (xdata, ydata, xaxis)
%function \[x,meany,standarderror,standarddeviation, sumy, numx] \= meanyvsx (xdata, ydata, xaxis)
%
%(xdata, ydata) form pairs, e.g. speed vs. angle
%
%for each interval in xaxis (xdata \>\= xaxis(j), \<\= xaxis(j\+1\)), 
%meany is the mean of all ydata with xdata in
%that interval
%
%standard error is the standard deviation of the data in the bin divided by
%the square root of the number of elements

%meany \= zeros(\[size(ydata,1\) (length(xaxis)\-1\)]);
%sumy \= meany;
%standarddeviation \= meany;
%x \= meany;

xdata \= double(xdata); ydata \= double(ydata);

if (size(xdata, 2\) \=\= 1\)
 xdata \= xdata';
end
if (size(ydata, 2\) \~\= size(xdata,2\))
 ydata \= ydata';
end
\[numx,bin] \= histc(xdata, xaxis);

if (length(xdata) \~\= length(ydata))
 error ('data must be same length');
end

meany \= zeros(\[size(ydata,1\) (length(xaxis)\-1\)]);

standarddeviation \= meany;

for k \= 1:size(ydata, 1\)
 meany(k,:) \= accumarray(bin(bin \> 0 \& bin \< length(xaxis))',ydata(k,bin \> 0 \& bin \< length(xaxis))',\[size(meany,2\) 1],@mean)';
 if (nargout \> 2\)
 standarddeviation(k,:) \= accumarray(bin(bin \> 0 \& bin \< length(xaxis))',ydata(k,bin \> 0 \& bin \< length(xaxis))',\[size(meany,2\) 1],@std)';
 end
end
% A \= accumarray(SUBS,VAL,SZ,FUN,FILLVAL)
x \= accumarray(bin(bin \> 0 \& bin \< length(xaxis))',xdata(bin \> 0 \& bin \< length(xaxis))',\[size(meany,2\) 1],@mean, NaN)';
numx \= repmat(numx(1:(end\-1\)), size(ydata,1\), 1\);
sumy \= meany.\*numx;

if (nargout \> 2\)
 standarderror \= standarddeviation./sqrt(numx);
end
\-\-\-

\#\#\# File: ellipse.m (ID: basic routines.39\)

function h\=ellipse(ra,rb,ang,x0,y0,C,Nb)
% Ellipse adds ellipses to the current plot
%
% ELLIPSE(ra,rb,ang,x0,y0\) adds an ellipse with semimajor axis of ra,
% a semimajor axis of radius rb, a semimajor axis of ang, centered at
% the point x0,y0\.
%
% The length of ra, rb, and ang should be the same. 
% If ra is a vector of length L and x0,y0 scalars, L ellipses
% are added at point x0,y0\.
% If ra is a scalar and x0,y0 vectors of length M, M ellipse are with the same 
% radii are added at the points x0,y0\.
% If ra, x0, y0 are vectors of the same length L\=M, M ellipses are added.
% If ra is a vector of length L and x0, y0 are vectors of length
% M\~\=L, L\*M ellipses are added, at each point x0,y0, L ellipses of radius ra.
%
% ELLIPSE(ra,rb,ang,x0,y0,C)
% adds ellipses of color C. C may be a string ('r','b',...) or the RGB value. 
% If no color is specified, it makes automatic use of the colors specified by 
% the axes ColorOrder property. For several circles C may be a vector.
%
% ELLIPSE(ra,rb,ang,x0,y0,C,Nb), Nb specifies the number of points
% used to draw the ellipse. The default value is 300\. Nb may be used
% for each ellipse individually.
%
% h\=ELLIPSE(...) returns the handles to the ellipses.
%
% as a sample of how ellipse works, the following produces a red ellipse
% tipped up at a 45 deg axis from the x axis
% ellipse(1,2,pi/8,1,1,'r')
%
% note that if ra\=rb, ELLIPSE plots a circle
%

% written by D.G. Long, Brigham Young University, based on the
% CIRCLES.m original 
% written by Peter Blattner, Institute of Microtechnology, University of 
% Neuchatel, Switzerland, blattner@imt.unine.ch


% Check the number of input arguments 

if nargin\<1,
 ra\=\[];
end;
if nargin\<2,
 rb\=\[];
end;
if nargin\<3,
 ang\=\[];
end;

%if nargin\=\=1,
% error('Not enough arguments');
%end;

if nargin\<5,
 x0\=\[];
 y0\=\[];
end;
 
if nargin\<6,
 C\=\[];
end

if nargin\<7,
 Nb\=\[];
end

% set up the default values

if isempty(ra),ra\=1;end;
if isempty(rb),rb\=1;end;
if isempty(ang),ang\=0;end;
if isempty(x0\),x0\=0;end;
if isempty(y0\),y0\=0;end;
if isempty(Nb),Nb\=300;end;
if isempty(C),C\=get(gca,'colororder');end;

% work on the variable sizes

x0\=x0(:);
y0\=y0(:);
ra\=ra(:);
rb\=rb(:);
ang\=ang(:);
Nb\=Nb(:);

if isstr(C),C\=C(:);end;

if length(ra)\~\=length(rb),
 error('length(ra)\~\=length(rb)');
end;
if length(x0\)\~\=length(y0\),
 error('length(x0\)\~\=length(y0\)');
end;

% how many inscribed elllipses are plotted

if length(ra)\~\=length(x0\)
 maxk\=length(ra)\*length(x0\);
else
 maxk\=length(ra);
end;

% drawing loop

for k\=1:maxk
 
 if length(x0\)\=\=1
 xpos\=x0;
 ypos\=y0;
 radm\=ra(k);
 radn\=rb(k);
 if length(ang)\=\=1
 an\=ang;
 else
 an\=ang(k);
 end;
 elseif length(ra)\=\=1
 xpos\=x0(k);
 ypos\=y0(k);
 radm\=ra;
 radn\=rb;
 an\=ang;
 elseif length(x0\)\=\=length(ra)
 xpos\=x0(k);
 ypos\=y0(k);
 radm\=ra(k);
 radn\=rb(k);
 an\=ang(k)
 else
 rada\=ra(fix((k\-1\)/size(x0,1\))\+1\);
 radb\=rb(fix((k\-1\)/size(x0,1\))\+1\);
 an\=ang(fix((k\-1\)/size(x0,1\))\+1\);
 xpos\=x0(rem(k\-1,size(x0,1\))\+1\);
 ypos\=y0(rem(k\-1,size(y0,1\))\+1\);
 end;

 co\=cos(an);
 si\=sin(an);
 the\=linspace(0,2\*pi,Nb(rem(k\-1,size(Nb,1\))\+1,:)\+1\);
% x\=radm\*cos(the)\*co\-si\*radn\*sin(the)\+xpos;
% y\=radm\*cos(the)\*si\+co\*radn\*sin(the)\+ypos;
 h(k)\=line(radm\*cos(the)\*co\-si\*radn\*sin(the)\+xpos,radm\*cos(the)\*si\+co\*radn\*sin(the)\+ypos);
 set(h(k),'color',C(rem(k\-1,size(C,1\))\+1,:));

end;


\-\-\-

\#\#\# File: objNargout.m (ID: basic routines.40\)

function n \= objNargout (obj, func)
%function n \= objNargout (obj, func)

%get metaclass information
if (ischar(obj))
 mc \= eval(\['? ' obj]);
else
 mc \= metaclass(obj);
end

%get all methods
meth \= \[mc.Methods{:}];

ind \= find(strcmp(func, {meth.Name}), 1\);

if (isempty(ind))
 n \= \[];
 return;
end

if (isempty(meth(ind).OutputNames))
 n \= 0;
 return;
end

if any(strcmp('varargout', meth(ind).OutputNames))
 n \= \-1;
 return;
end

n \= length(meth(ind).OutputNames);
\-\-\-

\#\#\# File: shadedErrorPlot.m (ID: basic routines.41\)

function h \= shadedErrorPlot (xdata, ydata, eup, edown, c, varargin)
%function h \= shadedErrorPlot (xdata, ydata, eup, edown, c, varargin) or
%c is the color; 
%h(1:j) is the patch; h(j\+1:2\*j) is the line
%
%optional param/value pairs, lineOptions, faceOptions 
%shadeColor \- which color to mix with the face (default background color)
lineOptions \= {};
faceOptions \= {};
shadeColor \= \[];
ax \= gca;
varargin \= assignApplicable(varargin);
if (isempty(shadeColor))
 shadeColor \= get(ax, 'Color');
 if strcmpi(shadeColor, 'none')
 shadeColor \= get(gcf, 'Color');
 end
 if strcmpi(shadeColor, 'none')
 shadeColor \= \[1 1 1];
 end
end
shadeColor \= char2rgb(shadeColor);
existsAndDefault('c', 'b');
existsAndDefault('leg', {});
existsAndDefault('edown', \[]);
if (iscell(c))
 cc \= c;
else
 cc \= {c};
end
if (iscell(xdata))
 xd \= xdata;
else
 xd \= {xdata};
end
if (iscell(ydata))
 yd \= ydata;
else
 yd \= {ydata};
end
if (iscell(eup))
 ep \= eup;
else
 ep \= {eup};
end
if (iscell(edown))
 ed \= edown;
else
 if (\~isempty(edown))
 ed \= {edown};
 else
 ed \= ep;
 end
end
xmax \= max(\[xd{:}]);
xmin \= min(\[xd{:}]);
ymax \= max(\[yd{:}] \+ \[ep{:}]);
ymin \= min(\[yd{:}] \- \[ed{:}]);

cla
set(ax, 'NextPlot', 'replace');
for j \= 1:length(xd)
 c \= cc{min(j, length(cc))};
 xdata \= xd{j};
 ydata \= yd{j};
 eup \= ep{j};
 edown \= ed{j};
 xdata \= xdata(:)';
 ydata \= ydata(:)';
 eup \= eup(:)';
 edown \= edown(:)';
 
 inds \= isfinite(xdata) \& isfinite(ydata) \&isfinite(eup) \& isfinite(edown);
 xdata \= xdata(inds);
 ydata \= ydata(inds);
 eup \= eup(inds);
 edown \= edown(inds);

 if (ischar(c))
 c \= char2rgb(c);
 end

%existsAndDefault('edown', eup);
 xdata \= xdata(:)';
 ydata \= ydata(:)';
 eup \= eup(:)';
 edown \= edown(:)';
 \[xdata,I] \= sort(xdata);
 ydata \= ydata(I);
 eup \= eup(I);
 edown \= edown(I);


 h(j) \= plot (ax, xdata, ydata, 'Color', c, lineOptions{:}, varargin{:}); hold on;
end
hold off;
set(ax, 'XLim', \[xmin xmax], 'YLim', \[ymin ymax]);
if (\~isempty(leg))
 legend(h, leg, legendOptions{:});
end
for j \= 1:length(xd)
 c \= cc{min(j, length(cc))};
 xdata \= xd{j};
 ydata \= yd{j};
 eup \= ep{j};
 edown \= ed{j};
 xdata \= xdata(:)';
 ydata \= ydata(:)';
 eup \= eup(:)';
 edown \= edown(:)';
 inds \= isfinite(xdata) \& isfinite(ydata) \&isfinite(eup) \& isfinite(edown);
 xdata \= xdata(inds);
 ydata \= ydata(inds);
 eup \= eup(inds);
 edown \= edown(inds);
 

 if (ischar(c))
 c \= char2rgb(c);
 end

%existsAndDefault('edown', eup);
 xdata \= xdata(:)';
 ydata \= ydata(:)';
 eup \= eup(:)';
 edown \= edown(:)';
 \[xdata,I] \= sort(xdata);
 ydata \= ydata(I);
 eup \= eup(I);
 edown \= edown(I);
 ccc \= shadeColor; %get(ax, 'Color');
 hh(j) \= patch(\[xdata xdata(end:\-1:1\)], \[ydata\+eup ydata(end:\-1:1\)\-edown(end:\-1:1\)], 0\.6\*ccc \+ 0\.4\*c, 'LineStyle', 'none', 'Parent', ax, faceOptions{:}, varargin{:});
end
%set(hh)
set(ax, 'Children', \[h hh]);
h \= \[hh h];
%{
ih \= ishold(get(h(1\), 'Parent'));
hold (get(h(1\), 'Parent'), 'on');
%plot (xdata, ydata\+eup, 'r\-', xdata(end:\-1:1\), ydata(end:\-1:1\)\-edown(end:\-1:1\), 'g\-');
%pause

if (\~ih)
 hold (ax, 'off');
end
%}
end


\-\-\-

\#\#\# File: playMovie.m (ID: basic routines.42\)

function playMovie (fn,start,stop)

blocksize \= 1000;
inf \= aviinfo(fn);

if (\~exist('start','var') \|\| isempty(start))
 start \= 1;
end
if (\~exist('stop','var') \|\| isempty(stop))
 stop \= inf.NumFrames;
end

ind1 \= start;
ind2 \= ind1\+blocksize\-1;
mov \= aviread(fn,ind1:ind2\);

for j \= start:stop
 if (mod((j),blocksize) \=\= 0\)
 ind1 \= j;
 ind2 \= ind1\+blocksize;
 if (ind2 \> stop)
 ind2 \= stop;
 end
 mov \= aviread(fn,ind1:ind2\);
 end
 imagesc(double(mov(mod(j\-1,blocksize)\+1\).cdata));
 title (\['Frame ' num2str(j)]);
 colormap gray
 pause (0\.02\);
end
\-\-\-

\#\#\# File: pvpmod.m (ID: basic routines.43\)

function pvpmod(x)
% PVPMOD \- evaluate parameter/value pairs
% pvpmod(x) assigns the value x(i\+1\) to the parameter defined by the
% string x(i) in the calling workspace. This is useful to evaluate 
%  contents in an mfile, e.g. to change default settings 
% of any variable initialized before pvpmod(x) is called.
%
% (c) U. Egert 1998

%\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#
% this loop is assigns the parameter/value pairs in x to the calling
% workspace.

if \~isempty(x)
 for i \= 1:2:size(x,2\)
 assignin('caller', x{i}, x{i\+1});
 end;
end;

%\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#


\-\-\-

\#\#\# File: setNonFiniteToZero.m (ID: basic routines.44\)

function x \= setNonFiniteToZero(x)
%function x \= setNonFiniteToZero(x)
%x(\~isfinite(x)) \= 0;

x(\~isfinite(x)) \= 0;
\-\-\-

\#\#\# File: dgausskernel.m (ID: basic routines.45\)

function dg \= dgausskernel (sigma)
%function dg \= dgausskernel (sigma)
gK \= gaussKernel(sigma);
dg \= zeros(size(gK));
dgd \= diff(gK);
dg(1:(end\-1\)) \= dgd;
dg(2:end) \= dg(2:end) \+ dgd;
dg \= dg/2;
%dg1 \= diff(gaussKernel(sigma));
%dg \= diff(gaussKernel(sigma));

\-\-\-

\#\#\# File: structvar2grid.m (ID: basic routines.46\)

function \[xim,yim,igrid,jgrid] \= structvar2grid(structvar)
%function \[xim,yim,igrid,jgrid] \= structvar2grid(structvar)
%converts one of Ashely's famous structvars into a grid of points
%igrid,jgird \<\-\-\-\> xim,yim

c1 \= structvar(1:4:end,:);
c2 \= structvar(2:4:end,:);
c3 \= structvar(3:4:end,:);
c4 \= structvar(4:4:end,:);

dy \= mean(\[c4(:,2\) \- c1(:,2\); c3(:,2\) \- c2(:,2\)]);
dx \= mean(\[c2(:,1\) \- c1(:,1\); c3(:,1\) \- c4(:,1\)]);

%min dist squared
mds \= (0\.25\*dy).^2 \+ (0\.25\*dx).^2;

%iterate through and merge points close together to a single point
newsv \= structvar;
keep \= true(\[1 length(structvar)]);
for j \= 1:length(structvar)
 if (keep(j))
 ds \= structvar \- repmat(structvar(j,:), \[length(structvar), 1]);
 ds \= sum(ds.^2, 2\);
 close \= find(ds \< mds);
 
 % plot (structvar(\~keep,1\), structvar(\~keep,2\), 'r.', structvar(keep,1\), structvar(keep,2\), 'b.', ...
 % structvar(close,1\), structvar(close,2\), 'go', structvar(j,1\), structvar(j,2\), 'm\*',...
 % newsv(keep(1:j),1\), newsv(keep(1:j), 2\), 'y\*');
 
 
 
 newsv(j,:) \= mean(structvar(close,:),1\);
 keep(close) \= false;
 keep(j) \= true;
 end
end
newsv \= newsv(keep,:);
x0 \= min(newsv(:,1\));
y0 \= min(newsv(:,2\));

xim \= newsv(:,1\);
yim \= newsv(:,2\);
igrid \= round((xim\-x0\)/dx);
jgrid \= round((yim\-y0\)/dy);

%sort into rows and columns

\[igrid,I] \= sort(igrid);
jgrid \= jgrid(I);
xim \= xim(I);
yim \= yim(I);

\[jgrid,I] \= sort(jgrid);
igrid \= igrid(I);
xim \= xim(I);
yim \= yim(I);

 
\-\-\-

\#\#\# File: figureForPresentation.m (ID: basic routines.47\)

function h \= figureForPresentation(h)
%function h \= figureForPrinting(h)

if (\~exist('h','var') \|\| isempty(h))
 h \= figure();
else
 figure(h);
end

clf(h);

xdim \= 1024;
ydim \= 768;

set(h,'units','pixels');
p \= get(h,'position');
p(3\) \= xdim;
p(4\) \= ydim;
set(h,'position', p);
set(h, 'units','pixels');
set(h, 'PaperUnits', 'inches');
set(h,'PaperPosition', \[1 1 4 4/ratio]);
set(h,'PaperOrientation', 'portrait');

\-\-\-

\#\#\# File: mytriangle.m (ID: basic routines.48\)

function tri \= mytriangle(x)
%function mytriangle(x)
%
%produces a triangle wave with amplitude 1 and angular frequency 1
xi \= linspace(x(1\)\-2\*pi, x(end)\+2\*pi, 10\*length(x)\+100\);
square \= sign(sin(xi));
inds \= find(diff(square) \~\= 0\);
tri \= interp1(xi(inds), square(inds), x, 'linear');
\-\-\-

\#\#\# File: surveyorFormula.m (ID: basic routines.49\)

function a \= surveyorFormula (pts)
%function a \= surveyorFormula (pts)

a \= 0;
for k \= 1:(length(pts)\-1\)
 a \= a \+ det(\[pts(:,k) pts(:,k\+1\)]);
end
a \= a \+ det(\[pts(:,end) pts(:,1\)]);

\-\-\-

\#\#\# File: weightedhist\_slidingwindow.m (ID: basic routines.50\)

function \[npts, weightedmean] \= weightedhist\_slidingwindow (xdata, xcenter, bindim, windowType, varargin)
%function \[npts,weightedmean] \= meanyvsx (xdata, ydata, xaxis, xcenter, bindim, windowType, polar, varargin)
%
% returns the sum of the weight (npts)
% and the weighted mean sum(weight.\*xdata)/npts
%
%if windowType is 'gaussian' (default), the weighting w\_j is exp(\-4\*log(2\)\*(x\_j \-
%xc)^2/(bindim^2\)) \[bindim \= FWHM]
%if windowType is 'step', the weighting w\_j is 1 if abs(x\_j \- xc) \< bindim/2
%and 0 otherwise \[bindim \= bin width]
%
%if windowType is 'halfgaussian', the weighting w\_j is exp(\-4\*log(2\)\*(x\_j \-
%xc)^2/(bindim^2\)) \* (sign(x\_j \- xc) \=\= sign(bindim)) : in other words, if
%bindim \> 0 we only consider xj \> xc, and if bindim is \< 0 we only consider
%xj \< xc
%
%windowType may also be a function handle to the weighting function
%weight \= windowType(xdata, xcenter, bindim)
%
%passing 'period', period will add or subtract multiples of period to the
%xdata to lie within \+/\- period/2 of the given center: for polar data, pass 'period', 2\*pi
%


period \= \[];

varargin \= assignApplicable(varargin); %\#ok

npts \= zeros(1, length(xcenter));
weightedmean \= npts;

if ischar(windowType)

 switch(lower(windowType))
 case 'gaussian'
 weightFun \= @(xd,xc) exp(\-4\*log(2\)\*(xd\-xc).^2\./bindim^2\);
 case 'halfgaussian'
 weightFun \= @(xd,xc) exp(\-4\*log(2\)\*(xd\-xc).^2\./bindim^2\).\*(sign(xd\-xc) \=\= sign(bindim));
 case 'step'
 weightFun \= @(xd,xc) heavisideStep(bindim/2 \- abs(xd\-xc));
 case 'none'
 return;
 otherwise
 disp('windowType must be gaussian or step');
 return;

 end
else
 weightFun \= @(xd, xc) windowType(xd, xc, bindim);
end

valid \= isfinite(xdata);% \& all(isfinite(ydata),1\);
xdata \= xdata(valid);

for j \= 1:length(xcenter)
 if (\~isempty(period))
 xdata \= mod(xdata \- xcenter(j) \+ period/2, period) \- period/2 \+ xcenter(j);
 end
 
 w \= weightFun(xdata,xcenter(j));
 npts(j) \= sum(w);
 weightedmean(j) \= sum(w.\*xdata)/npts(j); 
 
end



\-\-\-

\#\#\# File: difference.m (ID: basic routines.51\)

function dv \= difference (vector, spacing)
%function dv \= difference (vector, spacing)
%
%dv(j) \= vector(j\+spacing)\-vector(j) if j \<\= length(vector) \- spacing
%otherwise dv(j) \= (vector(end)\-vector(j))\*spacing/(length(vector) \- j)
%dv(end) \=\= dv(end\-1\);
dv \= zeros(size(vector));
n \= length(vector) \- spacing;
dv(1:n) \= vector(1\+spacing:end) \- vector(1:n);
for k \= (n\+1\):(length(vector)\-1\)
 dv(k) \= (vector(end) \- vector(k))\*spacing/(length(vector)\-k);
end
dv(end) \= dv(end\-1\);
 
\-\-\-

\#\#\# File: nthcolor.m (ID: basic routines.52\)

function c \= nthcolor (n)
%function c \= nthcolor (n)

clist \= colorList;
c \= clist{mod(n\-1,length(clist))\+1};


\-\-\-

\#\#\# File: existsAndDefault.m (ID: basic routines.53\)

function ex \= existsAndDefault(varname, defaultvalue)
%function ex \= existsAndDefault(varname, defaultvalue)
%
%returns true if a variable called varname exists in caller and is not
%empty
%if variable does not exist or is empty, returns false and sets the
%variable to defaultvalue (if provided) in the caller workspace
%if defaultvalue is \[], this is still assigned to varname

if (evalin('caller', \['exist(''' varname ''',''var'')']) \&\& \~isempty(evalin('caller', varname)))
 ex \= true;
else
 if (exist('defaultvalue','var'))
 assignin('caller', varname, defaultvalue)
 end
 ex \= false;
end

\-\-\-

\#\#\# File: emsmallen.m (ID: basic routines.54\)

function emsmallen (ax,varargin)
if (nargin \< 1\)
 ax \= gca;
end
FontSize \= 10;
FontName \= 'Arial';
elems \= {'XLabel', 'YLabel', 'Title'};
varargin \= assignApplicable(varargin);

set(ax,'FontSize', FontSize, 'FontName', FontName);
for j \= 1:length(elems)
 set (get(ax,elems{j}),'FontSize', FontSize, 'FontName', FontName, varargin{:});
end
\-\-\-

\#\#\# File: cameraCalibration.m (ID: basic routines.55\)

function camcalinfo \= cameraCalibration(realPoints, imagePoints, centerPoint, camcalinfoStart, z)
%function camcalinfo \= cameraCalibration(realPoints, imagePoints, centerPoint, camcalinfoStart, z)
%
%REALPOINTS is either a 2xN array of points representing the location of
%corresponding imagePoints or
%a 3xN array of points representing the x,y,z locations of image points or
%a 4x1 (or 1x4\) array \[nrows ncols rowspacing colspacing]
%
%in the second case, we arrange the imagePoints into an array of
%nrowsxncols
%then we set the real value of the lower left corner to 0,0 and every other
%point is at x \= i\*colspacing; y \= j\*rowspacing
%
%
%IMAGEPOINTS is a 2xN or 2x(nrows\*ncols) array
%
%centerPoint is the x,y location of the central pixel of the camera CCD 
%our 5 MP cameras are 2592x1944, so the central pixel is 1296, 972
%
%
%CAMCALINFO contains CM, the camera matrix, and K, a measure of radial
%distortion
%CAMCALINFOSTART is an optional parameter that gives a starting point for
%iteration; only camcalinfoStart.K is used.
%
%Z optional param: defaults to 0; z location of coplanar real points

if (size(imagePoints,1\) \~\= 2\)
 imagePoints \= imagePoints';
end
existsAndDefault('z', 0\);

xi \= imagePoints(1,:) \- centerPoint(1\);
yi \= imagePoints(2,:) \- centerPoint(2\);

if (length(realPoints) \=\= 4\)
 nrows \= realPoints(1\);
 ncols \= realPoints(2\);
 rs \= realPoints(3\);
 cs \= realPoints(4\);
 \[yi,I] \= sort(yi);
 xi \= xi(I);
 for j \= 1:nrows
 inds \= (j\-1\)\*ncols \+ (1:ncols);
 \[x,I] \= sort(xi(inds));
 rowi(j).x \= x;
 rowi(j).y \= yi(inds(I));
 rowr(j).x \= (0:(ncols\-1\)) \* cs;
 rowr(j).y \= repmat((j\-1\)\*rs,size(x));
 end
 xi \= \[rowi.x];
 yi \= \[rowi.y];
 xr \= \[rowr.x];
 yr \= \[rowr.y];
 z \= repmat(z,size(xr));
 
 
else
 if (size(realPoints,1\) \~\= 2 \&\& size(realPoints,1\) \~\= 3\)
 realPoints \= realPoints';
 end
 xr \= realPoints(1,:);
 yr \= realPoints(2,:);
 if (size(realPoints,1\) \=\= 3\)
 z \= realPoints(3,:);
 else
 z \= repmat(z, size(xr));
 end
end

cmd.K \= \[0 0 0];
existsAndDefault('camcalinfoStart', cmd);

\[CM,K] \= cameraMatrixPlusDistortion(xi, yi, xr, yr, z, camcalinfoStart.K);

camcalinfo.CM \= CM;
camcalinfo.K \= K;
camcalinfo.xc \= centerPoint(1\);
camcalinfo.yc \= centerPoint(2\);

\-\-\-

\#\#\# File: infertime.m (ID: basic routines.56\)

function timeinsecs \= infertime (fstub, ext)
%function timeinsecs \= infertime (fstub, ext)
%
%infers time picture was taken from timestamp on files

d \= dir (\[fstub '\*.' ext]);
t \= \[d.datenum];
t \= sort(t);
t \= t \- t(1\);
timeinsecs \= t\*3600\*24;
%timeinsecs \= lowpass1D(t\*3600\*24,10\);


\-\-\-

\#\#\# File: flattenMovie.m (ID: basic routines.57\)

function data \= flattenMovie (mov)
%function data \= flattenMovie (mov)
%changes the movie mov into a hxwxNframes stack of data scaled from 0 to 1
%first converts each colormap to gray using rgb2gray, then maps the image
%to the colormap
%mov should have the fields cdata \[hxw uint8] and colormap \[256x3 double]
sz \= size(mov(1\).cdata);
data \= zeros(sz(1\),sz(2\),length(mov),'uint8');

for j \= 1:length(mov)
 %convert the colormap to grayscale
 gm \= rgb2gray(mov(j).colormap);
 %convert the colormap to uint8
 gm \= uint8 (255\*gm(:,1\)/max(gm(:,1\)));
 %the values in the image range from 0 to 255; we need them to go from 1
 %to 256 so we add 1, but first convert to a 16 bit integer to make room
 data(:,:,j) \= gm(uint16(mov(j).cdata)\+1\);
end

\-\-\-

\#\#\# File: wrapTheta.m (ID: basic routines.58\)

function theta2 \= wrapTheta (theta)
%function theta2 \= wrapTheta (theta)
%
%adds factors of 2\*pi to eliminate large jumps in theta

theta2 \= theta;
dt \= diff(\[theta(1\) theta]);
%size(dt)
indsup \= find(dt \< \-3/2\*pi);
indsdown \= find(dt \> 3/2\*pi);

%plot(1:length(theta),theta,'b\-',indsup,theta(indsup),'r.',indsdown,theta(indsdown),'g.');

for j \= indsup
 theta2(j:end) \= theta2(j:end) \+ 2\*pi;
end

for j \= indsdown
 theta2(j:end) \= theta2(j:end) \- 2\*pi;
end

%plot(1:length(theta),theta2,'b\-',indsup,theta2(indsup),'r.',indsdown,theta2(indsdown),'g.');



\-\-\-

\#\#\# File: cameraMatrixPlusDistortion.m (ID: basic routines.59\)

function \[CM, k] \= cameraMatrixPlusDistortion(u,v,x,y,z,kstart)
%function \[CM, k] \= cameraMatrixPlusDistortion(u,v,x,y,z,kstart)
%x,y,z are actual physical locations
%u,v are measured pixel locations relative to the center point of the
%camera
%
%tup,tvp,t \= CM\*(x,y,z,1\) 
%u,v \= (up,vp) / (1 \+ k(1\)\*r^2 \+ k(2\)\*r^4 \+ k(3\)\*r^6\)

niter \= 1000;

if (\~exist('kstart','var') \|\| isempty(kstart))
 k \= \[0 0 0];
else
 k \= kstart;
end
for nn \= 1:niter
 r \= u.^2 \+ v.^2;
 a \= (1 \+ k(1\)\*r \+ k(2\)\*r.^2 \+ k(3\)\*r.^3\);
 CM \= cameraMatrix(u.\*a,v.\*a,x,y,z);
 for j \= 1:length(x)
 \[uu,vv] \= projectPt (x(j),y(j),z(j), CM);
 up(j) \= uu;
 vp(j) \= vv;
 end
 k \= radialDistortion (up, vp, u, v);
 
end


end

function \[u,v] \= projectPt (x,y,z,CM)

z \= CM\*(\[x;y;z;1]);
u \= z(1\)/z(3\);
v \= z(2\)/z(3\);

end

\-\-\-

\#\#\# File: char2rgb.m (ID: basic routines.60\)

function rgbvec \= char2rgb (charcolor)
%function rgbvec \= char2rgb (charcolor)
%
%converts a character color (one of 'r','g','b','c','m','y','k','w') to a 3
%value RGB vector
%if charcolor is a string (vector of chars), the result is a Nx3 matrix of
%color values, where N is the length of charcolor


if (\~exist('charcolor','var'))
 warning('RGB2VEC:NOTC', 'You must pass a character (rgbcmykw)');
 rgbvec \= \[];
 return;
end

if (\~ischar(charcolor))
 rgbvec \= charcolor;
 return;
end

rgbvec \= zeros(length(charcolor), 3\);
charwarning \= false;
for j \= 1:length(charcolor)
 switch(lower(charcolor(j)))
 case 'r'
 rgbvec(j,:) \= \[1 0 0];
 case 'g'
 rgbvec(j,:) \= \[0 1 0];
 case 'b'
 rgbvec(j,:) \= \[0 0 1];
 case 'c'
 rgbvec(j,:) \= \[0 1 1];
 case 'm'
 rgbvec(j,:) \= \[1 0 1];
 case 'y'
 rgbvec(j,:) \= \[1 1 0];
 case 'w'
 rgbvec(j,:) \= \[1 1 1];
 case 'k'
 rgbvec(j,:) \= \[0 0 0];
 otherwise
 charwarning \= true;
 end
end

if (charwarning)
 warning('RGB2VEC:BADC', 'Only r,g,b,c,m,y,k,and w are recognized colors');
end
 
\-\-\-

\#\#\# File: thetaAxis.m (ID: basic routines.61\)

function tx \= thetaAxis(binsize, type, outputtype)
%function tx \= thetaAxis(binsize, type, outputtype)
%
%creates a vector with evenly spaced bin centers from \-180 to 180 degrees
%(or \-pi to pi radians)
%type is either 'd'(egrees) or 'r'(adians)
%outputtype is either 'd' or 'r'
%both are optional and default to degrees
%examples
%thetaaxis(90, 'degrees', 'degrees') gives \[\-135 \-45 45 135]
%thetaaxis(90, 'degrees', 'radians') gives \[\-3\*pi/4 \-pi/4 pi/4 3\*pi/4]
%thetaaxis(pi/2, 'radians') gives \[\-135 \-45 45 135]
%
%if the binsize is not a divisor of 180 degrees, the last bin will be
%a different size than all other bins
existsAndDefault('type', 'd');
existsAndDefault('outputtype', 'd');

if (lower(type(1\)) \=\= 'd')
 low \= \-180;
 high \= 180;
else
 low \= \-pi;
 high \= pi;
end

tx \= (low \+ binsize/2\):binsize:high;

if (lower(type(1\)) \=\= 'd' \&\& lower(outputtype(1\)) \=\= 'r')
 tx \= deg2rad(tx);
end
if (lower(outputtype(1\)) \=\= 'd' \&\& lower(type(1\)) \=\= 'r')
 tx \= rad2deg(tx);
end
\-\-\-

\#\#\# File: binCentersFromEdges.m (ID: basic routines.62\)

function centers \= binCentersFromEdges (edges)
%function centers \= binCentersFromEdges (edges)
%
%creates bin centers s.t. centers(j) is midway between (edges(j) and
%edges(j\+1\))
%

centers \= 0\.5 \* (edges(1:end\-1\)\+edges(2:end));
\-\-\-

\#\#\# File: derivOld.m (ID: basic routines.63\)

function \[dx,validinds] \= deriv(x,sigma)
%function \[dx,validinds] \= deriv(x,sigma)

xx \= reshape(x,\[],1\);
dg \= reshape(dgausskernel(sigma),\[],1\);

dx \= reshape(conv2(xx,dg,'same'),size(x));

len \= ceil(length(dg)/2\);
if (2 \* len \> length(dx))
 validinds \= \[];
else
 validinds \= (len:length(dx)\-len);
end
\-\-\-

\#\#\# File: makecolumn.m (ID: basic routines.64\)

function x \= makecolumn(x)
%function x \= makecolumn(x)

if (size(x,1\) \=\= 1\)
 x \= x';
end
\-\-\-

\#\#\# File: colorList.m (ID: basic routines.65\)

function clist \= colorList()
%function clist \= colorList()

c \= 'bgrcmyk';
s \= {'\-',':', '\-.', '\-\-'};

for j \= 1:length(c)\*length(s)
 ci \= mod(j\-1,length(c)) \+ 1;
 si \= ceil(j/length(c));
 clist{j} \= \[c(ci) s{si}];
end
 

\-\-\-

\#\#\# File: meanyvsxFast.m (ID: basic routines.66\)

function \[x,meany,sumy, numx] \= meanyvsxFast (xdata, ydata, xaxis)
%function \[x,meany, sumy, numx] \= meanyvsxFast (xdata, ydata, xaxis)
%
%(xdata, ydata) form pairs, e.g. speed vs. angle
%
%for each interval in xaxis (xdata \>\= xaxis(j), \<\= xaxis(j\+1\)), 
%meany is the mean of all ydata with xdata in
%that interval
%

%meany \= zeros(\[size(ydata,1\) (length(xaxis)\-1\)]);
%sumy \= meany;
%standarddeviation \= meany;
%x \= meany;

xdata \= double(xdata); ydata \= double(ydata);
if (size(ydata, 2\) \=\= 1\)
 ydata \= ydata';
end
if (size(xdata, 2\) \=\= 1\)
 xdata \= xdata';
end
\[numx,bin] \= histc(xdata, xaxis);
% %tic
% for j \= 1:(length(xaxis) \- 1\)
% % inds \= find(xdata \>\= xaxis(j) \& xdata \< xaxis(j\+1\));
% inds \= bin \=\= j;
% sumy(:,j) \= sum(ydata(:,inds),2\);
% x(j) \= mean(xdata(inds));
% meany(:,j) \= mean(ydata(:,inds),2\);
% standarddeviation(:,j) \= std(ydata(:,inds),0,2\);
% end
% toc
% tic
meany \= zeros(\[size(ydata,1\) (length(xaxis)\-1\)]);


for k \= 1:size(ydata, 1\)
 meany(k,:) \= accumarray(bin(bin \> 0 \& bin \< length(xaxis))',ydata(k,bin \> 0 \& bin \< length(xaxis))',\[size(meany,2\) 1],@mean)';
 
end
% A \= accumarray(SUBS,VAL,SZ,FUN,FILLVAL)
%x \= accumarray(bin(bin \> 0 \& bin \< length(xaxis))',xdata(bin \> 0 \& bin \< length(xaxis))',\[size(meany,2\) 1],@mean, NaN)';
%less accurate determination of bin center:
x \= 0\.5 \* (xaxis(1:(end\-1\)) \+ xaxis(2:end));



numx \= repmat(numx(1:(end\-1\)), size(ydata,1\), 1\);
sumy \= meany.\*numx;

\-\-\-

\#\#\# File: meanyvsx\_slidingwindow.m (ID: basic routines.67\)

function \[x,meany,standarderror,standarddeviation,sumy, numy] \= meanyvsx\_slidingwindow (xdata, ydata, xcenter, bindim, windowType, polar, varargin)
%function \[x,meany,standarderror,standarddeviation, sumy, numy] \= meanyvsx (xdata, ydata, xaxis, xcenter, bindim, windowType, polar, varargin)
%
%(xdata, ydata) form pairs, e.g. speed vs. angle
%
%for each point in xcenter, we take the weighted average of ydata with
%weighting determined by windowType and bindim
%
%if windowType is 'gaussian' (default), the weighting w\_j is exp(\-4\*log(2\)\*(x\_j \-
%xc)^2/(bindim^2\)) \[bindim \= FWHM]
%
%if windowType is 'step', the weighting w\_j is 1 if abs(x\_j \- xc) \< bindim/2
%and 0 otherwise \[bindim \= bin width]
%
%if windowType is 'halfgaussian', the weighting w\_j is exp(\-4\*log(2\)\*(x\_j \-
%xc)^2/(bindim^2\)) \* (sign(x\_j \- xc) \=\= sign(bindim)) : in other words, if
%bindim \> 0 we only consider xj \> xc, and if bindim is \< 0 we only consider
%xj \< xc
%
% if windowType is 'none', we abort evaluation and return 0s for all values
%
%if polar is true, we add or sutbract multiples of 2\*pi to the xdata to lie
%within \+/\-pi of the given center
%meany is the mean of all ydata with xdata in
%that interval
%
%passing 'period', period will add or subtract multiples of period to the
%xdata to lie within \+/\- period/2 of the given center: polar \= true is
%the same as passing 'period', 2\*pi
%
%
%standard error is the standard deviation of the data in the bin divided by
%the square root of the number of elements
%
%'clipNaN', true/\[false] \-\- if true \[x,meany,...] are clipped to
% the range for which isfinite(x) is true (aka, where some x data exists).
% this new option implemented 7/31/2012 may change behavior of other
% scripts

existsAndDefault('polar', false);
if (polar)
 period \= 2\*pi;
else
 period \= \[];
end
clipNaN \= false;
varargin \= assignApplicable(varargin);
sumy \= zeros(\[size(ydata,1\) length(xcenter)]);
meany \= sumy;
numy \= zeros(1, length(xcenter));
x \= numy;
standarddeviation \= meany;
standarderror \= meany;

switch(lower(windowType))
 case 'gaussian'
 weightFun \= @(xd,xc) exp(\-4\*log(2\)\*(xd\-xc).^2\./bindim^2\);
 maxval \= abs(2\*bindim); %about 4\.5 sigma
 minval \= \-abs(2\*bindim);
 case 'halfgaussian'
 weightFun \= @(xd,xc) exp(\-4\*log(2\)\*(xd\-xc).^2\./bindim^2\).\*(sign(xd\-xc) \=\= sign(bindim));
 maxval \= 2\*abs(bindim)\*(bindim \> 0\);
 minval \= \-2\*abs(bindim)\*(bindim \< 0\);
 case 'step'
 weightFun \= @(xd,xc) heavisideStep(bindim/2 \- abs(xd\-xc)); % We replace heaviside with heavisideStep so that the code can be compiled (B 2012/01/25\)
 maxval \= abs(bindim/2\);
 minval \= \-abs(bindim/2\);
 case 'none'
 return;
 otherwise
 disp('windowType must be gaussian or step');
 return;
 
end
valid \= isfinite(xdata) \& all(isfinite(ydata),1\);
xdata \= xdata(valid);
ydata \= ydata(:,valid);

if (size(ydata, 1\) \> 1\)

 for j \= 1:length(xcenter)
 if (\~isempty(period))
 xdata \= mod(xdata \- xcenter(j) \+ period/2, period) \- period/2 \+ xcenter(j);
 end
 goodinds \= (xdata \- xcenter(j)) \> minval \& (xdata \- xcenter(j)) \< maxval;
 %goodinds \= true(size(xdata));
 w \= weightFun(xdata(goodinds),xcenter(j));

 numy(j) \= sum(w);
 x(j) \= sum(w.\*xdata(goodinds))/numy(j);
 % w \= repmat(w, size(ydata, 1\), 1\);
 for k \= 1:size(ydata, 1\)
 sumy(k,j) \= sum(w.\*ydata(k,goodinds), 2\);
 meany(k,j) \= sumy(k,j) / numy(j);
 standarddeviation(k,j) \= sqrt(sum(w.\*(ydata(k,goodinds) \- meany(k,j)).^2\)/numy(j));
 standarderror(k,j) \= standarddeviation(k,j)/sqrt(numy(j));
 end
 end
else
 for j \= 1:length(xcenter)
 if (\~isempty(period))
 xdata \= mod(xdata \- xcenter(j) \+ period/2, period) \- period/2 \+ xcenter(j);
 end

 goodinds \= (xdata \- xcenter(j)) \> minval \& (xdata \- xcenter(j)) \< maxval;
 % goodinds \= true(size(xdata));
 w \= weightFun(xdata(goodinds),xcenter(j));

 numy(j) \= sum(w);
 x(j) \= sum(w.\*xdata(goodinds))/numy(j);
 
 sumy(1,j) \= sum(w.\*ydata(goodinds));
 meany(1,j) \= sumy(j) / numy(j);
 standarddeviation(:,j) \= sqrt(sum(w.\*(ydata(goodinds) \- meany(1,j)).^2\)/numy(j));
 standarderror(:,j) \= standarddeviation(:,j)/sqrt(numy(j));
 end
end

if (clipNaN)
 inds \= isfinite(x);
 x \= x(inds);
 meany \= meany(:,inds);
 standarderror \= standarderror(:,inds);
 standarddeviation \= standarddeviation(:,inds);
 sumy \= sumy(:,inds);
 numy \= numy(inds);
end

\-\-\-

\#\#\# File: insideRect.m (ID: basic routines.68\)

function tf \= insideRect (rect, ptlist)
%rect is a 4 element vector with \[x0 x1 y0 y1]
%ptlist is a 2XN list of points
%tf(j) \= x0 \<\= x(1,j) \<\= x1 \&\& y0 \< x(2,j) \< y1

tf \= (rect(1\) \<\= ptlist(1,:)) \& (rect(2\) \>\= ptlist(1,:)) \&...
 (rect(3\) \<\= ptlist(2,:)) \& (rect(4\) \>\= ptlist(2,:));
 
\-\-\-

\#\#\# File: msNoOutliers.m (ID: basic routines.69\)

function \[m, s] \= msNoOutliers (y, sigscale)
%function \[m, s] \= msNoOutliers (y, sigscale)

m \= mean(y);
s \= std(y);
j \= 0;
dm \= m;
ds \= s;
if (nargin \< 2\)
 sigscale \= 1\.5;
end
while (j \< 100 \&\& (abs(dm/m) \> 0\.001\) \&\& (abs(ds/s) \> 0\.001\))
 inds \= find(abs(y \- m) \< sigscale\*s);
 oldm \= m;
 olds \= s;
 m \= mean(y(inds));
 s \= std(y(inds));
 dm \= m \- oldm;
 ds \= s \- olds;
 j \= j\+1;
end


\-\-\-

\#\#\# File: medianyvsx.m (ID: basic routines.70\)

function \[x,mediany] \= medianyvsx (xdata, ydata, xaxis)
%function \[x,mediany] \= medianyvsx (xdata, ydata, xaxis)
%
%(xdata, ydata) form pairs, e.g. speed vs. angle
%
%for each interval in xaxis, mediany is the median of all ydata with xdata in
%that interval

for j \= 1:(length(xaxis) \- 1\)
 inds \= find(xdata \>\= xaxis(j) \& xdata \< xaxis(j\+1\));
 x(j) \= mean(xdata(inds));
 mediany(j) \= median(ydata(inds));
end
\-\-\-

\#\#\# File: drawLineOnImage.m (ID: basic routines.71\)

function im \= drawLineOnImage(im, pt1, pt2, thickness, value)
%sets all points within (thickness/2\) pixels on the line between pt1 and pt2 
%to value
%
%note that the x,y point of im is found in im(y,x)
%while pt1,pt2 should have form \[x y]
%
%pt1,pt2 can be a vector of points, in which case we will draw lines
%between all sets of pt1 and pt2
%if value is also a vector, then we draw value(k) between pt1(k) \& pt2(k)


if (size(pt1,1\) \~\= 2\)
 pt1 \= pt1';
end
if (size(pt2,1\) \~\= 2\)
 pt2 \= pt2';
end

if (length(value) \=\= 1\)
 value \= repmat(value, 1, length(pt1\));
end

v \= pt2\-pt1;
l \= sqrt(sum(v.^2\));
v \= single(v./\[l;l]);
n \= single(\[\-v(2,:);v(1,:)]);


\[x,y] \= meshgrid(1:size(im,2\),1:size(im,1\));

xlim \= round(sort(\[pt1(1,:);pt2(1,:)],1\) \+ repmat(\[\-thickness;thickness],1,length(pt1\)));
ylim \= round(sort(\[pt1(2,:);pt2(2,:)],1\)\+ repmat(\[\-thickness;thickness],1,length(pt1\)));

xlim(xlim\<1\) \= 1;
xlim(xlim\>size(x,2\)) \= size(x,2\);
ylim(ylim\<1\) \= 1;
ylim(ylim\>size(x,1\)) \= size(x,1\);



for j \= 1:size(pt1,2\)

 %try
 xx \= x(ylim(1,j):ylim(2,j), xlim(1,j):xlim(2,j));
 yy \= y(ylim(1,j):ylim(2,j), xlim(1,j):xlim(2,j));
 %catch me
 % disp(me.getReport);
 % size(x)
 % xlim(1,j)
 % xlim(2,j)
 % ylim(1,j)
 
 %ylim(2,j)
 %end
 sz \= size(xx);
 
 xx \= reshape(xx,1,\[]);
 yy \= reshape(yy,1,\[]);
 

 frompt1 \= single(\[xx\-pt1(1,j);yy\-pt1(2,j)]);
 frompt2 \= single(\[xx\-pt2(1,j);yy\-pt2(2,j)]);
 
 vv \= repmat(v(:,j), 1, length(xx));
 nn \= repmat(n(:,j), 1, length(xx));
 
 online \= dot(vv, frompt1\) \> 0 \& dot(vv,frompt2\) \< 0 \& abs(dot(frompt1,nn)) \< thickness/2;
 
 \[I,J] \= ind2sub(sz, find(online));
 inds \= sub2ind(size(im), I\+ylim(1,j)\-1, J \+ xlim(1,j) \- 1\);
 
 
 im(inds) \= value(j);

end


\-\-\-

\#\#\# File: meanzvsxandy.m (ID: basic routines.72\)

function \[meanz, numpts, sumz] \= meanzvsxandy (xpts,ypts,zpts,xcenters,ycenters)
%function \[meanz, numpts, sumz] \= meanzvsxandy (xpts,ypts,zpts,xcenters,ycenters)

xcf \= \[xcenters 2\*xcenters(end)\-xcenters(end\-1\)];
xcr \= \[2\*xcenters(1\)\-xcenters(2\) xcenters];
xe \= 0\.5\*(xcf \+ xcr);

ycf \= \[ycenters 2\*ycenters(end)\-ycenters(end\-1\)];
ycr \= \[2\*ycenters(1\)\-ycenters(2\) ycenters];
ye \= 0\.5\*(ycf \+ ycr);

\[\~,jv] \= histc(xpts, xe);
\[\~,iv] \= histc(ypts, ye);

inds \= (jv \> 0 \& jv \< length(xe) \& iv \> 0 \& iv \< length(ye));

xpts \= xpts(inds);
ypts \= ypts(inds);
jv \= jv(inds);
iv \= iv(inds);
zpts \= zpts(inds);

sumz \= zeros(length(ycenters), length(xcenters));
numpts \= sumz;
for j \= 1:length(zpts)
 sumz(iv(j),jv(j)) \= sumz(iv(j),jv(j)) \+ zpts(j);
 numpts(iv(j),jv(j)) \= numpts(iv(j),jv(j)) \+ 1;
end
meanz \= sumz./numpts;
meanz(numpts \=\= 0\) \= 0;
\-\-\-

\#\#\# File: columnSort.m (ID: basic routines.73\)

function \[x,y] \= columnSort (x,y, ncols, rorder)
%function \[x,y] \= columnSort (x,y, ncols, rorder)
%
%sorts a set of x,y points into row, column order
%rorder is either 'ascend' in which case the first row is low y values
%or 'descend' in which case the first row has high y values
%(default 'ascend')

existsAndDefault('rorder', 'ascend');
\[y,I] \= sort(y, rorder);
x \= x(I);

nrows \= length(x)/ncols;

 for j \= 1:nrows
 inds \= (j\-1\)\*ncols \+ (1:ncols);
 \[xt,I] \= sort(x(inds));
 row(j).x \= xt;
 row(j).y \= y(inds(I));
 end
 x \= \[row.x];
 y \= \[row.y];
\-\-\-

\#\#\# File: chooseFromPDF.m (ID: basic routines.74\)

function x \= chooseFromPDF (xaxis, pdf, n)
%function x \= chooseFromPDF (xaxis, pdf, n)
%given a probability density function p \= pdf(x) defined on xaxis, chooses
%an x within xaxis s.t. x is distributed according to pdf(x)
%returns n values
if (\~exist('n', 'var') \|\| isempty(n))
 n \= 1;
end

pdf \= pdf ./ sum(pdf);
%pdf(pdf \<\= 0\) \= 1E\-6; %eliminate zero (should not have negative but get rid of those two) probabilities, so that cdf is strictly increasing

%pdf \= pdf ./ sum(pdf);
cdf \= cumsum(pdf);
\[cdf,I] \= unique(cdf);

x \= interp1 (cdf, xaxis(I), rand(\[1 n]),'linear','extrap');




\-\-\-

\#\#\# File: normalizedCoordinates.m (ID: basic routines.75\)

function \[nx,ny] \= normalizedCoordinates(x,y,ax)

if \~existsAndDefault('ax', \[])
 ax \= gca;
end


xl \= get(ax, 'XLim');
yl \= get(ax, 'YLim');

units \= get(ax, 'Units');
set(ax,'Units', 'normalized');
pos \= get(ax, 'Position');
set(ax, 'Units', units);
nx \= (x\-xl(1\))/(xl(2\)\-xl(1\)) \* pos(3\) \+ pos(1\);
ny \= (y\-yl(1\))/(yl(2\)\-yl(1\)) \* pos(4\) \+ pos(2\);



\-\-\-

\#\#\# File: makerow.m (ID: basic routines.76\)

function x \= makerow(x)
%function x \= makerow(x)

if (size(x,1\) \> 1\)
 x \= x';
end
\-\-\-

\#\#\# File: assignToStruct.m (ID: basic routines.77\)

function \[s,x] \= assignToStruct(s, x)
%function \[s,x] \= assignToStruct(s, x)
%
%if x{i} is a field in s, 
%s.(x{i}) \= x{i\+1}
%
%removes any parameter, value pairs from x and returns
% modified by marc gershow from pvpmod by
% (c) U. Egert 1998

%\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#
% this loop is assigns the parameter/value pairs in x to the calling
% workspace.
used \= \[];
if \~isempty(x)
 skipnext \= false;
 for i \= 1:size(x,2\)
 if skipnext
 skipnext \= false;
 continue;
 end
 if (ischar(x{i}) \&\& isfield(s,x{i})) 
 s.(x{i}) \= x{i\+1};
 used \= \[used i];
 skipnext \= true;
 end
 end;
end;
if (\~isempty(used))
 used \= \[used used\+1];
 inds \= setdiff(1:length(x), used);
 x \= x(inds);
end

%\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#


\-\-\-

\#\#\# File: approxeq.m (ID: basic routines.78\)

function p \= approxeq(a, b, tol, rel)
% APPROXEQ Are a and b approximately equal (to within a specified tolerance)?
% p \= approxeq(a, b, thresh)
% 'tol' defaults to 1e\-3\.
% p(i) \= 1 iff abs(a(i) \- b(i)) \< thresh
%
% p \= approxeq(a, b, thresh, 1\)
% p(i) \= 1 iff abs(a(i)\-b(i))/abs(a(i)) \< thresh

if nargin \< 3, tol \= 1e\-2; end
if nargin \< 4, rel \= 0; end

a \= a(:);
b \= b(:);
d \= abs(a\-b);
if rel
 p \= \~any( (d ./ (abs(a)\+eps)) \> tol);
else
 p \= \~any(d \> tol);
end


\-\-\-

\#\#\# File: binomialpval\_exact.m (ID: basic routines.79\)

function pval \= binomialpval\_exact (m,n,p)
%function pval \= binomialpval\_exact (m,n,p)
%
%if the null hypothesis is that the p fraction of the time, the result is
%true, then
%pval is the probability at least m out of n trials are true


pval \= zeros(size(m));
if (length(p) \=\= 1\)
 p \= repmat(p,size(m));
end
for j \= 1:length(m)
 for k \= m(j):n(j)
 pval(j) \= pval(j) \+ nchoosek(n(j),k)\*p(j)^(k)\*(1\-p(j))^(n(j)\-k);
 end
end
\-\-\-

\#\#\# File: realPointFromCameraPoint.m (ID: basic routines.80\)

function \[x,y] \= realPointFromCameraPoint (u, v, CM, K)
%function \[x,y] \= realPointFromCameraPoint (u, v, CM, K)
%
%finds the point (x,y,z\=0\) that corresponds to the camera point u, v given
%a camera projection matrix CM and distortion parameters in K

A \= inv(CM(:,\[1 2 4]));
r \= u.^2 \+ v.^2;
a \= (1 \+ K(1\)\*r \+ K(2\)\*r.^2 \+ K(3\) \* r.^3\);
%{
size(u)
size(v)
size(a)
size(A)
size(\[a.\*u;a.\*v;ones(size(u))])
%}
z \= A\*\[a.\*u;a.\*v;ones(size(u))];
x \= z(1,:)./z(3,:);
y \= z(2,:)./z(3,:);
\-\-\-

\#\#\# File: laplaceDoubleGauss.m (ID: basic routines.81\)

function k \= laplaceDoubleGauss (sigma1, sigma2\)
%function k \= laplaceDoubleGauss (sigma1, sigma2\)
%creates a 2D laplacian kernel by subtracting a regional gaussian (sigma2\)
%from a local gaussian (sigma1\). 

sigma \= max(sigma1,sigma2\);

x \= floor(\-3\*sigma):ceil(3\*sigma);
g \= exp(\-x.^2/(2 \* sigma1\));
g \= g'\*g;
g1 \= g / (sum(sum(g)));

g \= exp(\-x.^2/(2 \* sigma2\));
g \= g'\*g;
g2 \= g / (sum(sum(g)));

k \= g1 \- g2;

\-\-\-

\#\#\# File: mysawtooth.m (ID: basic routines.82\)

function saw \= mysawtooth(x, a, low, high)
%function saw(x)
%
%produces a saw wave with angular frequency 1 and upward duty cycle a
% optional args, low and high provide the min and max values
if (nargin \< 2\)
 a \= 1;
end
if (nargin \< 3\)
 low \= \-1;
end
if (nargin \< 4\)
 high \= \-low;
end

saw \= mod(x, 2\*pi)/(2\*pi);
up \= logical(saw \<\= a\+eps);
saw(up) \= saw(up)/a;
saw(\~up) \= (1 \-saw(\~up))/(1 \- a);

saw \= saw\*(high \- low) \+ low;


\-\-\-

\#\#\# File: avgfft.m (ID: basic routines.83\)

function \[f,v] \= avgfft (data, blocksize)
%function \[f,v] \= avgfft (data, blocksize)


f \= zeros(\[1 blocksize]);
%n \= 0;
for j \= 1:blocksize:length(data)
 nextind \= min(j \+ blocksize \- 1, length(data));
 f \= f \+ fft(data(j:nextind), blocksize);
 % n \= n\+1;
end

f \= f / length(data);
v \= ifftshift(linspace(\-1,1,blocksize)/2\);
 
\-\-\-

\#\#\# File: findPeriodicMaxima.m (ID: basic routines.84\)

function inds \= findPeriodicMaxima(ydata, varargin)
%function inds \= findPeriodicMaxima(ydata, varargin)
%
%finds maxima of the quasi\-periodic function ydata, looking for robust
%maxima spaced somewhat evenly apart
debug \= false;
varargin \= assignApplicable(varargin);
ydata \= ydata \- mean(ydata);


%determine the period using autocorrelation
\[xc,lags] \= xcorr(ydata,ydata);
xc \= xc(lags \> 0\);
lags \= lags(lags \> 0\);

dxc \= deriv(xc, 3\);
firstmin \= find(diff(sign(dxc)) \> 0, 1, 'first');
allmax \= find(diff(sign(dxc)) \< 0\);

firstmax \= allmax(find(allmax \> firstmin, 1, 'first'));

period \= lags(firstmax);

%determine the phase

maxlen \= period\*floor(length(ydata) / period);
periodicmean \= mean(reshape(ydata(1:maxlen), period, \[]),2\);

\[\~,phase] \= max(periodicmean);

%find low\-passed local maxima within 0\.1 period of the periodic maxima

yd \= deriv(ydata, max(3,period/300\));
zcr \= find(diff(sign(yd)) \< 0\);
zcr \= zcr(abs((zcr \- phase)/period \- round((zcr\-phase)/period)) \< 0\.1\);

if (debug)
 phase 
 period
 x \= 1:length(yd);
 iv \= (abs((x \- phase)/period \- round((x\-phase)/period)) \< 0\.1\);
 % plot (x, (x\-phase)/period, x, round((x\-phase)/period), x, abs((x \- phase)/period \- round((x\-phase)/period)));
 plot (1:length(yd), yd, x(iv), yd(iv), 'g\-', x(zcr), yd(zcr), 'r.');
end


valid \= true(size(zcr));

for j \= 1:length(zcr)
 if (nnz(abs(zcr \- zcr(j)) \< period/4\) \> 1\)
 inds \= find(abs(zcr \- zcr(j)) \< period/4\);
 valid(inds) \= false;
 \[\~,I] \= max(ydata(zcr(inds)));
 valid(inds(I)) \= true;
 end
end

zcr \= zcr(valid);
 

inds \= zcr;

\-\-\-

\#\#\# File: theta\_gaussian.m (ID: basic routines.85\)

function g \= theta\_gaussian (x, m, s)
%function g \= theta\_gaussian (x, m, s)
%calculates gaussian using theta math

td \= mod(x \- m, 2\*pi);

td \= min(abs(td), abs(2\*pi \- td));

g \= (1/sqrt(2\*pi\*s))\*exp(\-td.^2/(2\*s));
dx \= diff(x);
dx(end\+1\) \= dx(end);
g \= g.\*dx;

\-\-\-

\#\#\# File: shadedErrorPlotPolar.m (ID: basic routines.86\)

function h \= shadedErrorPlotPolar (thdata, rdata, eup, edown, c, varargin)
%function h \= shadedErrorPlotPolar (thdata, rdata, eup, edown, c, varargin) or
%c is the color; 
%h(1:j) is the patch; h(j\+1:2\*j) is the line
%
%optional param/value pairs, lineOptions, faceOptions 
lineOptions \= {};
faceOptions \= {};
varargin \= assignApplicable(varargin);

existsAndDefault('c', 'b');
existsAndDefault('leg', {});
existsAndDefault('edown', \[]);
if (iscell(c))
 cc \= c;
else
 cc \= {c};
end
if (iscell(thdata))
 td \= thdata;
else
 td \= {thdata};
end
if (iscell(rdata))
 rd \= rdata;
else
 rd \= {rdata};
end
if (iscell(eup))
 ep \= eup;
else
 ep \= {eup};
end
if (iscell(edown))
 ed \= edown;
else
 if (\~isempty(edown))
 ed \= {edown};
 else
 ed \= ep;
 end
end
% 
% xmax \= max(\[xd{:}]);
% xmin \= min(\[xd{:}]);
% ymax \= max(\[yd{:}] \+ \[ep{:}]);
% ymin \= min(\[yd{:}] \- \[ed{:}]);

rmax \= max(rd{:} \+ ep{:});
cla
set(gca, 'NextPlot', 'replace');
\[caxunder,cax] \= polarBackground(rmax);
hold(cax, 'on');
for j \= 1:length(td)
 c \= cc{min(j, length(cc))};
 tdata \= td{j};
 rdata \= rd{j};
 eup \= ep{j};
 edown \= ed{j};
 
 tdata \= tdata(:)';
 rdata \= rdata(:)';
 eup \= eup(:)';
 edown \= edown(:)';
 
 \[tdata,I] \= sort(tdata);
 rdata \= rdata(I);
 eup \= eup(I);
 edown \= edown(I);
 
 tdata \= tdata(\[1:end 1]);
 rdata \= rdata(\[1:end 1]);
 eup \= eup(\[1:end 1]);
 edown \= edown(\[1:end 1]);
 
 
 if (ischar(c))
 c \= char2rgb(c);
 end
 
 xx \= rdata.\*cos(tdata);
 yy \= rdata.\*sin(tdata);
 
 
 h(j) \= plot (cax, xx, yy, 'Color', c, lineOptions{:}, varargin{:}); 
 xx \= \[rdata \+ eup, rdata(end:\-1:1\)\-edown(end:\-1:1\)].\*cos(\[tdata tdata(end:\-1:1\)]);
 yy \= \[rdata \+ eup, rdata(end:\-1:1\)\-edown(end:\-1:1\)].\*sin(\[tdata tdata(end:\-1:1\)]);

 ccc \= get(caxunder, 'Color');
 hh(j) \= patch(xx, yy, 0\.75\*ccc \+ 0\.25\*c, 'LineStyle', 'none', faceOptions{:}, varargin{:}, 'Parent', cax);
end
if (\~isempty(leg))
 legend(h, leg, legendOptions{:});
end
%set(hh)
set(cax, 'Children', \[h hh]);
h \= \[hh h];

end


\-\-\-

\#\#\# File: blurim.m (ID: basic routines.87\)

function im \= blurim (im, sigma)
%function im \= blurim (im, sigma)
gk \= gaussKernel(sigma);
padsize \= floor(length(gk)/2\);
padim \= padarray(im, \[padsize padsize], 'replicate');

im \= conv2(gk, gk, padim, 'valid');
\-\-\-

\#\#\# File: fitWave.m (ID: basic routines.88\)

function \[freq, phase, ampl, yfit] \= fitWave(xd, ydata, ramptype, varargin)
% function \[freq, phase, ampl] \= fitWave(xdata, ydata, ramptype, varargin)
%
% finds parameters of a wave that best describes the data
% ramptype is one of 'square', 'triangle', 'sine'
%
% varargin: 'fixedPeriod', t \- if the period is known, input it here.

fixedPeriod \= \[];
varargin \= assignApplicable(varargin);

\[xd, I] \= sort(xd);
ydata \= ydata(I);

dx \= diff(\[(2\*xd(1\) \- xd(2\)) xd]);
ydm \= sum(ydata.\*dx)/sum(dx);

yd \= ydata \- ydm;

switch (lower(ramptype))
 case 'square'
 yfn \= @(x, xdata) sign(sin(x(1\)\*xdata \+ x(2\)));
 case 'sine'
 yfn \= @(x, xdata) sin(x(1\)\*xdata \+ x(2\));
 case 'triangle'
% if (exist('sawtooth', 'file'))
% yfn \= @(x, xdata)sawtooth(x(1\)\*xdata \+ x(2\), 0\.5\);
% else
% warning ('signal processing toolbox not installed? using sine for triangle wave');
 yfn \= @(x, xdata) mytriangle(x(1\)\*xdata \+ x(2\));
 %end
 otherwise
 yfn \= @(x, xdata) sin(x(1\)\*xdata \+ x(2\));
end

%testfun \= @(x) \-sum(yfn(x,xd).\*yd.\*dx);

xi \= linspace(xd(1\), xd(end), length(xd));
yi \= interp1(xd, yd, xi);
fs \= 2\*pi/mean(diff(xi));
%adapted from matlab help doc

NFFT \= 2^nextpow2(length(yi)); % Next power of 2 from length of y
Y \= fft(yi,NFFT)/length(yi);
f \= fs/2\*linspace(0,1,NFFT/2\+1\);
\[\~,I] \= max(abs(Y(1:(NFFT/2\+1\))));
x(1\) \= f(I); %initial guess for the frequency \- highest power in spectrum
%initial guess for phase \- find minimum to within 1%
pp \= linspace(0,2\*pi,100\); tf \= zeros(size(pp));
testfun \= @(x) \-sum(yfn(x,xd).\*yd.\*dx);
if (\~isempty(fixedPeriod))
 x(1\) \= 2\*pi/fixedPeriod;
end
% for j \= 1:length(pp), tf(j) \= testfun(\[x(1\), pp(j)]); end
% \[\~,II] \= min(tf);
% x(2\) \= pp(II)
% 
x(2\) \= fminbnd(@(y) testfun(\[x(1\) y]), 0, 2\*pi);
xinit \= x;
if (isempty(fixedPeriod))
 x \= fminsearch(testfun, xinit); %keeping xinit around for debugging purposes \- note fminsearch succeeds where fmincon fminunc fail
end
freq \= x(1\);
phase \= x(2\);
ampl \= regress(yd',yfn(x, xd)');
yfit \= ampl \* yfn(x,xd) \+ ydm;



 
\-\-\-

\#\#\# File: makeIm.m (ID: basic routines.89\)

function \[im, xc, yc] \= makeIm (xpts,ypts,xedges,yedges)
%function im \= makeIm (xpts,ypts,xedges,yedges)
%
%makes a 2D histogram of xpts,ypts with bins defined by xedges yedges

%this code section modified
% from ndhist.m by by Jonathan C. Lansey
% 30 Jan 2014 (Updated 15 Jul 2014\) 
% 2D histogram which is actually kind of fast making use of matlab's histc

im \= zeros(length(yedges),length(xedges));
\[\~,binX] \= histc(xpts,xedges);
for ii\=1:length(xedges)
 I \= (binX\=\=ii);
 N \= histc(ypts(I),yedges);
 im(:,ii) \= N';
end
%end snippet

im \= im(1:(end\-1\), 1:(end\-1\));
xc \= 0\.5\*(xedges(1:(end\-1\)) \+ xedges(2:end));
yc \= 0\.5\*(yedges(1:(end\-1\)) \+ yedges(2:end));


%{
im \= zeros(\[length(yaxis),length(xaxis)]);
inds \= find (xpts \>\= min(xaxis) \& xpts \<\= max(xaxis) \& ypts \>\= min(yaxis) \& ypts \<\= max(yaxis));
for n \= inds'
 j \= find(xaxis \<\= xpts(n),1,'last');
 k \= find(yaxis \<\= ypts(n),1,'last');
 
 im(k,j) \= im(k,j)\+1;
end

%}
\-\-\-

\#\#\# File: deriv.m (ID: basic routines.90\)

function \[dx,validinds] \= deriv(x,sigma,varargin)
%function \[dx,validinds] \= deriv(x,sigma,varargin)
%
%optional args:
%padtype: 'linear' (default) or 'circular' (connects ends)

padtype \= 'linear';
padType \= \[];
varargin \= assignApplicable(varargin);
if (\~isempty(padType))
 padtype \= padType;
end
if (size(x,1\) \> size(x,2\))
 xx \= x';
 t \= 1;
else
 xx \= x;
 t \= 0;
end
dg \= reshape(dgausskernel(sigma),1,\[]);

padfront \= ceil ((length(dg)\-1\) / 2\);
padback \= length(dg) \- padfront \- 1;
if (padfront \>\= size(xx,2\) \|\| padback \>\= size(xx,2\))
 warning ('deriv:sigtoobig', 'deriv called on data set too short to support sigma');
 ks \= floor((size(xx(:,2\)) \- 1\)/2\);
 inds \= ceil(length(dg)/2 \+ \-ks:ks);
 dg \= dg(:,inds);
 padfront \= ceil ((length(dg)\-1\) / 2\);
 padback \= length(dg) \- padfront \- 1;
end

 
if (strcmpi(padtype, 'circular'))
 frontpad \= xx(:,(end\-padfront\+1\):end);
 backpad \= xx(:,1:padback);
else
 frontpad \= 2\*repmat(xx(:,1\), 1, padfront) \- xx(:,(padfront\+1\):\-1:2\);
 backpad \= 2\*repmat(xx(:,end), 1, padback) \- xx(:,(end\-1\):\-1:(end\-padback));
end
%xx \= \[repmat(xx(:,1\), 1, padfront) xx repmat(xx(:,end), 1, padback)];
xx \= \[frontpad xx backpad];
dx \= conv2(1,dg,xx,'valid');

if (t)
 dx \= dx';
end
len \= ceil(length(dg)/2\);
if (2 \* len \> length(dx))
 validinds \= \[];
else
 validinds \= (len:length(dx)\-len);
end
\-\-\-

\#\#\# File: xcorrVec.m (ID: basic routines.91\)

function \[cunb,c, np] \= xcorrVec (a, b)
%a,b are m x N matrices (or N x m), where m is the dimension
%and N is the number of vectors in the time series and m \< N
%for instance, a sequence of 1000 x,y points would be a 2x1000 vector
%
%%if a and b are different lengths, the shorter vector is 
%zero padded (at the end?)
%
%we define the cross\-correlation to be
%xc(T) \= ; \-N denotes the average
%c is the return 1x(2N\-1\) vector c(j) \= xc(j\-N);
%
%the autocorrelation for T \= 0 to N is given by c \= xcorrVec(a,a); ac \= c(N:end);
%cunb is the unbiased (normalized) correlation
%c is the unnormalized correlation
%np is the number of points used to calculate c or cunb; cunb \= c./np
na \= length(a);
nb \= length(b);
n \= max(na, nb);
c \= zeros(\[1 2\*n\-1]);

if (size(a,1\) \> size(a,2\))
 a \= a';
end
if (size(b,1\) \> size(b,2\))
 b \= b';
end

for k \= 1:size(a,1\)
 c \= c\+xcorr(a(k,:),b(k,:));
end
np \= (\[(1:n) ((n\-1\):\-1:1\)]);
cunb \= c./np;


\-\-\-

\#\#\# File: radialDistortion.m (ID: basic routines.92\)

function k \= radialDistortion (xp, yp, xd, yd)
%function k \= radialDistortion (xp, yp, xd, yd)
%
%xp and yp are the projected points without distortion
%xd and yd are the actual distorted points
%
%we solve for k, s.t. (xp,yp) \= (1 \+ k(1\)r^2 \+ k(2\)r^4 \+ k(3\)r^6\)\*(xd,yd)

x \= xp./xd \- 1;
y \= yp./yd \- 1;
r \= xp.^2 \+ yp.^2;

A \= \[r;r.^2;r.^3];
%size(A)

X \= \[x y];
%size(X)
AA \= \[A A];
%size(AA)
%size(pinv(AA))
k \= X\*pinv(AA);
\-\-\-

\#\#\# File: binomialpval\_twogroups.m (ID: basic routines.93\)

function \[pval, pcommon] \= binomialpval\_twogroups (na, ka, nb, kb)
%function \[pval, pcommon] \= binomialpval\_twogroups (na, ka, nb, kb)
%
%group a has na trials with ka successes
%group b has nb trials with kb successes
%assume (ka/na) \> (kb/nb)
%
%pval is the probability that na trials with a pcommon probability of
%success produces AT LEAST ka successes AND that nb trials with pcommon
%probability of success produces AT MOST kb successes. 
if (ka \> na \|\| kb \> nb)
 error ('BPV:badval', 'number of successes cannot be greater than number of trials');
end

if (ka/na \< kb/nb)
 ktemp \= ka;
 ntemp \= na;
 ka \= kb;
 na \= nb;
 kb \= ktemp;
 nb \= ntemp;
end

pvfun \= @(p) \-((1\-binocdf(ka\-1, na, p))\*binocdf(kb,nb,p));

%pcommon \= (ka\+kb)/(na\+nb);

\[pcommon,pval] \= fminbnd(pvfun, 0, 1\);
pval \= \-pval;
\-\-\-

\#\#\# File: vsize.m (ID: basic routines.94\)

%VSIZE disect a variable and show the size of its members
% VSIZE shows the size of the contents of a ML variable
% and all of its containers/members
% see also: who, whos, ndims, size, numel, length
%
%SYNTAX
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% VSIZE(VAR1,VAR2,...,VARn)
% VSIZE(OPT,VAR1,VAR2,...,VARn)
% P \= VSIZE(...)
%
%INPUT
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% VARx : a valid, named or an unnamed ML variable
% OPT processing mode (MUST be first arg!)
% \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% \-c : show container classes only
% \-r : show top\-level variable(s) only
%
%OUTPUT
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% P : a cell matrix with all information gathered during processing
% col 1 : field descriptor
% col 2 : size
% col 3 : class
% col 4 : member descriptor NDIM:SIZE:CLASS
% col 5 : depth level of container(s)/member(s)
% col 6 : number of input argument(s)
% col 7 : number of container(s) cell\|struct
% col 8 : number of member(s) all other objects
%
%EXAMPLE
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% clear v;
% v(1\).a{1}\=sparse(magic(3\)\+2i\*magic(3\));
% v(2\).a{2}\={struct('FA',{'a','bb'},'FB',{magic(5\),{}})};
% v(2\).b{2}\=@(x) sind(x);
% e\=vsize(v,v(1\).a{1});
% \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% 1346 1346\* v \= 2:1x2:struct
% CELL \-\-\-\-\- 256 v\[].a \= 2:1x1:cell
% 1150 196\- v\[].a{} \= 2:3x3:double.sparse.complex
% CELL \-\-\-\-\- 698 v\[].a \= 2:1x2:cell
% 1150 0\- v\[].a{} \= 2:0x0:double
% CELL \-\-\-\-\- 634 v\[].a{} \= 2:1x1:cell
% STRUCT \-\-\- 574 v\[].a{}{} \= 2:1x2:struct
% 1148 2\- v\[].a{}{}\[].FA \= 2:1x1:char
% 1144 4\- v\[].a{}{}\[].FA \= 2:1x2:char
% 944 200\- v\[].a{}{}\[].FB \= 2:5x5:double
% CELL \-\-\-\-\- 0 v\[].a{}{}\[].FB \= 2:0x0:cell
% 944 0\- v\[].b \= 2:0x0:double
% CELL \-\-\-\-\- 80 v\[].b \= 2:1x2:cell
% 944 0\- v\[].b{} \= 2:0x0:double
% 928 16\- v\[].b{} \= 2:1x1:function\_handle
% \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% 196 196\* \* \= 2:3x3:double.sparse.complex
%
% col 1: top\-level size \- member size \[bytes]
% \- container sizes are NOT subtracted
% \- the last number shows the overhead of the containers
% argument 1: 928
% argument 2: has no containers\|members
% col 2: size of the member \[bytes]
% \#\#\#\* \= top\-level
% \#\#\#\- \= member
% col 3: field descriptor \= member dimension:size:class
% \- \* \= unnamed input
%
% vsize('\-c',v,1i);
% \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% 1346 1346\* v \= 2:1x2:struct
% CELL \-\-\-\-\- 256 v\[].a \= 2:1x1:cell
% CELL \-\-\-\-\- 698 v\[].a \= 2:1x2:cell
% CELL \-\-\-\-\- 634 v\[].a{} \= 2:1x1:cell
% STRUCT \-\-\- 574 v\[].a{}{} \= 2:1x2:struct
% CELL \-\-\-\-\- 0 v\[].a{}{}\[].FB \= 2:0x0:cell
% CELL \-\-\-\-\- 80 v\[].b \= 2:1x2:cell
% \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% 16 16\* \* \= 2:1x1:double.complex

% created:
% us 08\-Aug\-2006
% modified:
% us 25\-Feb\-2009 00:40:39
% localid: us@USZ\|ws\-nos\-36362\|x86\|Windows XP\|7\.7\.0\.471\.R2008b

function \[p,par]\=vsize(varargin)

 earg\={
 '\-r' % top\-level only
 '\-c' % containers only
 };
 cc\={
 'cell'
 'struct'
 };

 if nargout
 p\=\[];
 end
 if nargin \< 1
 help(mfilename);
 return;
 end

% initialize engine
 \[p,par]\=set\_par(\-1,{earg,cc},nargin,\[],varargin{:});
 for i\=par.nb:nargin
% tokenize input arguments
 inam\=inputname(i);
 \[p,par]\=run\_vsize(0,inam,p,par,varargin{i});
 end
 p\=par.r;
 if \~nargout
 clear p;
 end
end
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
function \[p,par]\=run\_vsize(isrec,inam,p,par,varargin)

 \[p,par]\=set\_par(isrec,inam,p,par,varargin{:});
 if isempty(p)
 return;
 end
 \[p,par]\=get\_tok(p,par);
end
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
function \[p,par]\=set\_par(isrec,inam,p,par,varargin)
% create common parameter list

 par.darg\=4;
 par.narg\=0;
 par.hasvar\=false;
 par.hasanomaly\=false;
 par.fnam\=\[];

 switch isrec
% recursion
 case 1
 par.cflg\=true;
 par.rflg\=true;
 par.level\=varargin{1};
 par.vnam\=varargin{2};
 par.arg\=varargin(3:end);
 par.narg\=numel(par.arg);
 par.inam\=par.vnam;
 if par.level \>\= par.rlim
 disp(sprintf('VSIZE\> recursion limit reached %5d',par.rlim));
 p\=\[];
 end
 return;

% input argument
 case 0
 par.cflg\=false;
 par.sflg\=0;
 par.noname\='\*';
 par.level\=0;
 par.b\=0;
 par.inam\=par.noname;
 if \~isempty(inam)
 par.inam\=inam;
 end
 par.vnam\=par.inam;
 par.arg\=varargin;
 par.narg\=numel(par.arg);
 par.na\=par.na\+1;
 par.ne\=1;
 par.nm\=0;

% initialize engine
 case \-1
 par.opt\=inam{1};
 par.cc\=inam{2};

 narg\=p;
 p\=\[];
 p.narg\=narg;
 par.cflg\=false;
 par.rflg\=true;
 par.Cflg\=false;
 par.nb\=1;
 if ischar(varargin{1}) \&\&...
 varargin{1}(1\)\=\='\-'
 if strcmp(par.opt{1},varargin{1}) % \-r
 par.rflg\=false;
 par.nb\=2;
 end
 if strcmp(par.opt{2},varargin{1}) % \-c
 par.Cflg\=true;
 par.nb\=2;
 end
 end
 par.sflg\=0;
 par.rlim\=get(0,'recursionlimit');
 par.argn\=nargin\-par.darg;
 par.na\=0;
 par.ne\=0;
 par.nm\=0;
 par.r\={};

% \- output format
 nf\=3\-par.rflg;
 fmt\={
 '%3d\>%5d/%5d/%5d: %10s %10d%s %s \= %s' 1 45
 '%% %10s %10d%s %s \= %s' 5 22
 '%10d%s %s \= %s' 6 12
 };
 par.fmt\=fmt{nf,1};
 par.fmtb\=fmt{nf,2};
 par.d\=\['% ',repmat('\-',1,fmt{nf,3})];

% \- get current  entries
% 7\.2\.0\.232 (R2006a)
% 7\.3\.0\.32269 (R2006b)
% 7\.7\.0\.471 (R2008b)
 wn\={
 'name'
 'size'
 'bytes'
 'class'
% 'global'
% 'sparse'
% 'complex'
 'nesting'
% 'persistent'
 };
 w\=whos('nan');
 wf\=fieldnames(w);
 par.wf\=wf(\~ismember(wf,wn));
 par.anomaly\='2:0x0:anomaly (struct)';
 end
end
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
function \[p,par]\=get\_tok(p,par)
% tokenize input arguments

 for n\=1:par.narg
 arg\=par.arg{n};
 \[p,par]\=get\_arg(p,par,arg);
 \[p,par]\=get\_fld(p,par,arg);
 \[p,par]\=get\_ent(p,par,arg);
 end
end
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
function \[p,par]\=get\_arg(p,par,arg)

 par.hasvar\=false;
 if isstruct(arg)
 par.fnam\=fieldnames(arg);
 par.sflg\=par.sflg\+1;
 if par.cflg \&\&...
 par.sflg \~\= 1
 par.hasvar\=true;
 par.sflg\=0;
 end
 if par.sflg\=\=1
 par.hasvar\=false;
 par.sflg\=par.sflg\+1;
 end
 else
 par.sflg\=0;
 end

 a\=whos('arg');
 if \~par.level
 par.b\=a.bytes;
 end

 if par.hasvar
 p.nv\=numel(arg);
 p.nf\=numel(par.fnam);
 p.n\=p.nv\*p.nf;
 p.as\=size(arg);
 p.fr\=cell(p.n,1\);
 p.fn\=cell(p.n,4\);
 ix\=0;
 for j\=1:p.nf
 for i\=1:p.nv
 ix\=ix\+1;
 p.fr(ix,1\)\=par.fnam(j);
 p.fn(ix,1\)\=par.fnam(j);
 end
 end
 else
 p.nv\=1;
 p.nf\=numel(par.fnam);
 p.n\=1;
 p.as\=size(arg);
 p.fn\=cell(1,4\);
 p.fr\={\[]};
 end
end
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
function \[p,par]\=get\_fld(p,par,arg)

 for i\=1:p.n
 vx\=rem(i\-1,p.nv)\+1;
 if par.hasvar
 cf\=p.fn{i,1};
 try
 t\=arg(vx).(cf);
 catch %\#ok
 disp('VSIZE\> unexpected assignment error!');
 keyboard
 end
 p.fn{i}\=sprintf('%s.%s',par.inam,p.fn{i});
 else
 t\=arg;
 p.fn{i}\=sprintf('%s',par.inam);
 end

 w\=whos('t');
 c\=w.class;
 for j\=1:numel(par.wf)
 if w.(par.wf{j})
 c\=\[c,'.',par.wf{j}]; %\#ok
 end
 end
 spc\=sprintf('%\-1dx',w.size);
 spc\=sprintf('%\-1d:%s',ndims(t),spc);
 spc\=sprintf('%s:%s',spc(1:end\-1\),c);
 p.fn{i,2}\=w.bytes;
 p.fn{i,3}\=w.class;
 p.fn{i,4}\=spc;

 if isnumeric(p.as) \&\&...
 \~sum(p.as)
 par.hasanomaly\=true;
 p.fn{i,3}\=class(arg);
 end
 end
 if isempty(p) \|\|...
 \~p.n
 par.hasanomaly\=true;
 p.n\=numel(par.fnam);
 p.fr\={\[]};
 for i\=1:p.n
 p.fn(i,:)\={\[par.inam,'.',par.fnam{i}],0,'anomaly',par.anomaly};
 end
 end
end
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
function \[p,par]\=get\_ent(p,par,arg)

 for i\=1:p.n
 sflg\=true;
 if par.level
% a member
 if \~any(ismember(par.cc,p.fn{i,3}))
 par.b\=par.b\-p.fn{i,2};
 par.db\=sprintf('%\-1d',par.b);
 par.dlevel\='\-';
 par.nm\=par.nm\+1;
 if par.Cflg
 sflg\=false;
 end
 else
% a container
 cc\=p.fn{i,3};
 par.db\='container';
 par.db\=sprintf('%\-9\.9s',upper(cc));
 par.db(numel(cc)\+2:10\)\='\-';
 par.dlevel\=' ';
 par.ne\=par.ne\+1;
 par.nm\=0;
 end
 else
% top\-level variable
 par.db\=sprintf('%\-1d',par.b);
 par.dlevel\='\*';
 if par.rflg
 disp(par.d);
 end
 end

% update/display current structure
 par\=show\_ent(sflg,p,par,i,par.level,par.na,par.ne,par.nm,par.db,p.fn{i,2},par.dlevel,p.fn{i,1},p.fn{i,4});
 par.hasanomaly\=false;
 \[p,par]\=get\_rec(p,par,arg,i);
 end
end
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
function \[p,par]\=get\_rec(p,par,arg,ix)
% resolve recursion

 if par.rflg \&\&...
 p.fn{ix,2}

 par.level\=par.level\+1;
 vx\=rem(ix\-1,p.nv)\+1;
 switch p.fn{ix,3}
% \- struct
 case 'struct'
 par.sflg\=\-1;
 sb\='';
 if \~isempty(p.fr{ix})
 val\=arg(vx).(p.fr{ix});
 else
 val\=arg;
 end
 if numel(val) \> 1
 sb\='\[]';
 end
 val\={val};
% \- cell
 case 'cell'
 sb\='{}';
 if par.hasvar
 val\=arg(vx).(p.fr{ix});
 else
 val\=arg;
 end

% \- member
 otherwise
 par.level\=par.level\-1;
 return;

 end % SWITCH

 \[tpar,tpar]\=run\_vsize(1,p.fn{ix,3},p,par,...
 par.level,\[p.fn{ix},sb],val{:}); %\#ok
 par.ne\=tpar.ne;
 par.b\=tpar.b;
 par.r\=tpar.r;
 par.level\=par.level\-1;

 end % IF
end
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
function par\=show\_ent(sflg,p,par,ix,varargin)
% general purpose print routine

 v\=\[p.fn(ix,:),varargin(1:4\)];
 par.r\=\[par.r;v];
%D disp(sprintf('SHOW\> %5d %10s %s',sflg,varargin{\[7,5]}));
 if sflg
 s\=sprintf(par.fmt,varargin{par.fmtb:end});
 disp(s);
 end
end
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\-\-\-

\#\#\# File: guessOutsideHull.m (ID: basic routines.95\)

function \[srcx, srcy, dstx, dsty] \= guessOutsideHull (srcx, srcy, dstx, dsty, dstxaxis, dstyaxis)
%function \[srcx, srcy, dstx, dsty] \= guessOutsideHull (srcx, srcy, dstx, dsty, dstxaxis, dstyaxis)
if (size(srcx, 1\) \=\= 1\)
 srcx \= srcx';
end
if (size(srcy, 1\) \=\= 1\)
 srcy \= srcy';
end
if (size(dstx, 1\) \=\= 1\)
 dstx \= dstx';
end
if (size(dsty, 1\) \=\= 1\)
 dsty \= dsty';
end

\[dx,dy] \= avggridspacing(dstx', dsty');
dstxaxis \= linspace(min(dstxaxis),max(dstxaxis), ceil((max(dstxaxis) \- min(dstxaxis))/dx));
dstyaxis \= linspace(min(dstyaxis),max(dstyaxis), ceil((max(dstyaxis) \- min(dstyaxis))/dy));
\[x,y] \= meshgrid(dstxaxis, dstyaxis);
x \= x(:);
y \= y(:);
npts \= ceil(max((max(dstx) \- min(dstx))/dx, (max(dsty) \- min(dsty))/dy)) \+ 3;

chull \= convhull(dstx, dsty);
inp \= inpolygon(x,y,dstx(chull), dsty(chull));
x \= x(\~inp);
y \= y(\~inp);
if (isempty(x))
 %no points outside convex hull
 return;
end

new\_srcx \= zeros(size(x));
new\_srcy \= new\_srcx;
for j \= 1:length(x)
 \[xd, yd, I] \= nearestNPoints (x(j), y(j), dstx, dsty, npts);
 \[xg,yg] \= affineGuess (x(j), y(j), xd, yd, srcx(I), srcy(I));
 new\_srcx(j) \= xg;
 new\_srcy(j) \= yg;
 %{ 
 if (any(\~isfinite(xd) \| \~isfinite(yd) \| \~isfinite(xg) \| \~isfinite(yg)))
 xd
 yd
 xg
 yg
 x(j)
 y(j)
 npts
 end
 %}
end
srcx \= \[srcx;new\_srcx];
srcy \= \[srcy;new\_srcy];
dstx \= \[dstx;x];
dsty \= \[dsty;y];

function \[x2g, y2g] \= affineGuess (x0, y0, x1, y1, x2, y2\)
%function \[x2g, y2g] \= affineGuess (x0, y0, x1, y1, x2, y2\)
%
%find the affine transformation between x1,y1 and x2,y2, then apply it to
%x0,y0
if (size(x1,1\) \> 1\)
 x1 \= x1';
end
if (size(x2,1\) \> 1\)
 x2 \= x2';
end
if (size(y1,1\) \> 1\)
 y1 \= y1';
end
if (size(y2,1\) \> 1\)
 y2 \= y2';
end

R \= cp2tform(\[x1;y1]',\[x2;y2]', 'projective');

\[x2g, y2g] \= tformfwd(R, x0, y0\);
% 
% x \= \[x1; y1; ones(size(x1\))];
% y \= \[x2; y2; ones(size(x1\))];
% %y \= A x
% %A \= y \* pinv(x)
% A \= y \* pinv(x);
% z \= A \* \[x0;y0;1];
% x2g \= z(1\)/(z(3\)\+eps);
% y2g \= z(2\)/(z(3\)\+eps);
% 

\-\-\-

\#\#\# File: gaussianND.m (ID: basic routines.96\)

function g \= gaussianND (x, x0, c)
%function g \= gaussianND (x, x0, c)
%
%x is a NDxMpts vector
%x0 is a NDx1 center 
%c \= is a NDxND covariance matrix

%dx \= diff(x,1,2\);
%area \= prod(dx);
%area(end\+1\) \= area(end);
%area(1\)

x \= x \- repmat(x0, \[1, size(x,2\)]);
max(x,\[],2\)
min(x,\[],2\)
min(abs(x),\[],2\)
nd \= size(c,1\);
g \= (1 / sqrt(2\*pi\*det(c)))^(nd) \* exp(\-0\.5 \* dot (x, c\\x));
max(g)
%g \= g.\*area;

\-\-\-

\#\#\# File: binEdgesFromCenters.m (ID: basic routines.97\)

function edges \= binEdgesFromCenters (centers)
%function edges \= binEdgesFromCenters (centers)
%
%creates bin edges s.t. centers(j) is midway between (edges(j) and
%edges(j\+1\))
%
%modified from MATLAB's built in hist code

%matlabs code, which doesn't actually produce bins centered between edges,
%if bin centers are non uniform
 xx \= centers(:)';
 binwidth \= diff(xx); binwidth(end \+ 1\) \= binwidth(end);
 xx \= \[xx(1\)\-binwidth(1\)/2 xx\+binwidth/2];
% xx(1\) \= \-Inf;
% xx(end) \= Inf;
 edges \= xx;
\-\-\-

\#\#\# File: circleFromThreePts.m (ID: basic routines.98\)

function \[xc, r] \= circleFromThreePts (x1,x2,x3\)
%function \[xc, r] \= circleFromThreePts (x1,x2,x3\)
%
%finds the center and radius of a circle going through the points x1, x2,
%and x3
x1 \= reshape(x1,\[1 2]);
x2 \= reshape(x2,\[1 2]);
x3 \= reshape(x3,\[1 2]);

M \= \[x1(1\) x1(2\) 1; x2(1\) x2(2\) 1; x3(1\) x3(2\) 1];
pf \= \-1/det(M);

v \= \[x1\*x1', x2\*x2', x3\*x3'];

N \= M;
N(:,1\) \= v';
D \= pf \* det(N);

N \= M;
N(:,2\) \= v';
E \= pf \* det(N);

N \= M;
N(:,3\) \= v';
F \= pf \* det(N);
xc \= \-\[D,E]/2;
r \= sqrt(\-F \+ D^2/4 \+ E^2/4\);
\-\-\-

\#\#\# File: meanyvsxVarEst.m (ID: basic routines.99\)

function \[x,meany,v,numx] \= meanyvsxVarEst (xdata, ydata, yvar, xaxis)
%function \[x,meany,v,numx] \= meanyvsxVarEst (xdata, ydata, yvar, xaxis)
%
%(xdata, ydata) form pairs, e.g. speed vs. angle
%
%for each interval in xaxis (xdata \>\= xaxis(j), \<\= xaxis(j\+1\)), 
%meany is the mean of all ydata with xdata in
%that interval
%
%standard error is the standard deviation of the data in the bin divided by
%the square root of the number of elements

%meany \= zeros(\[size(ydata,1\) (length(xaxis)\-1\)]);
%sumy \= meany;
%standarddeviation \= meany;
%x \= meany;

xdata \= double(xdata); ydata \= double(ydata);

if (size(xdata, 2\) \=\= 1\)
 xdata \= xdata';
end
if (size(ydata, 2\) \~\= size(xdata,2\))
 ydata \= ydata';
end
\[numx,bin] \= histc(xdata, xaxis);
% %tic
% for j \= 1:(length(xaxis) \- 1\)
% % inds \= find(xdata \>\= xaxis(j) \& xdata \< xaxis(j\+1\));
% inds \= bin \=\= j;
% sumy(:,j) \= sum(ydata(:,inds),2\);
% x(j) \= mean(xdata(inds));
% meany(:,j) \= mean(ydata(:,inds),2\);
% standarddeviation(:,j) \= std(ydata(:,inds),0,2\);
% end
% toc
% tic
if (length(xdata) \~\= length(ydata))
 error ('data must be same length');
end

if (size(ydata, 1\) \> 1\)
 if (size(ydata, 2\) \> 1\)
 error ('multi d not written yet \- time constraints');
 else
 ydata \= ydata';
 end
end
if (size(yvar, 1\) \> 1\)
 yvar \= yvar';
end

meany \= zeros(\[size(ydata,1\) (length(xaxis)\-1\)]);
v \= meany;

vi \= 1\./yvar;

yvi \= vi.\*ydata;

v(1,:) \= accumarray(bin(bin \> 0 \& bin \< length(xaxis))', vi(1,bin \> 0 \& bin \< length(xaxis))',\[size(meany,2\) 1], @sum);
v \= 1\./v;
meany \= accumarray(bin(bin \> 0 \& bin \< length(xaxis))',yvi(1,bin \> 0 \& bin \< length(xaxis))',\[size(meany,2\) 1],@sum)';
meany \= v.\*meany;
% 
% for k \= 1:size(ydata, 1\)
% v(k,:) \= accumarray
% meany(k,:) \= accumarray(bin(bin \> 0 \& bin \< length(xaxis))',ydata(k,bin \> 0 \& bin \< length(xaxis))',\[size(meany,2\) 1],@mean)';
% if (nargout \> 2\)
% standarddeviation(k,:) \= accumarray(bin(bin \> 0 \& bin \< length(xaxis))',ydata(k,bin \> 0 \& bin \< length(xaxis))',\[size(meany,2\) 1],@std)';
% end
% end
% A \= accumarray(SUBS,VAL,SZ,FUN,FILLVAL)
x \= accumarray(bin(bin \> 0 \& bin \< length(xaxis))',xdata(bin \> 0 \& bin \< length(xaxis))',\[size(meany,2\) 1],@mean, NaN)';
numx \= repmat(numx(1:(end\-1\)), size(ydata,1\), 1\);
% sumy \= meany.\*numx;
% 
% if (nargout \> 2\)
% standarderror \= standarddeviation./sqrt(numx);
% end
\-\-\-

\#\#\# File: avggridspacing.m (ID: basic routines.100\)

function \[dx, dy] \= avggridspacing(x,y)
%average spacing between grid points, given points in grid, in no
%particular order
\[y,I] \= sort(y); x \= x(I);
jmag \= mean(diff(y)) \+ std(diff(y));
jump \= \[0 find(diff(y) \> jmag)];
for j \= 1:(length(jump) \- 1\)
 xx \= x((jump(j) \+ 1\):(jump(j\+1\)));
 yy \= y((jump(j) \+ 1\):(jump(j\+1\)));
 \[xx,I] \= sort(xx);
 yy \= yy(I);
 row(j).xc \= xx; %\#ok
 row(j).yc \= yy; %\#ok
 dx(j) \= median(diff(row(j).xc));
 yavg(j) \= mean(row(j).yc);
end

dx \= median(dx(isfinite(dx)));
dy \= median(diff(yavg(isfinite(yavg))));
\-\-\-

\#\#\# File: drawLineDistanceOnImage.m (ID: basic routines.101\)

function \[im,valueim] \= drawLineDistanceOnImage(im, pt1, pt2, valueim, value)
%sets all points that are on a line running
%perpendicular to the line pt1\-pt2 that passes through the segment 
%between pt1\&pt2 to the value of the distance to that line segment
%
%note that the x,y point of im is found in im(y,x)
%while pt1,pt2 should have form \[x y]
%
%pt1,pt2 can be a vector of points, in which case we will draw the minimum
%of all distances
%
%optional parameter valueim, value
%if valueim is non\-empty, then we put value(j) in valueim wherever the
%distance between the point and the segment btw pt1(j) \& pt2(j) is the
%minimum distance between the point and all other segments
%
%to speed things up, we only consider points within a reasonable range of
%the line segment

if (size(pt1,1\) \~\= 2\)
 pt1 \= pt1';
end
if (size(pt2,1\) \~\= 2\)
 pt2 \= pt2';
end

v \= pt2\-pt1;
l \= sqrt(sum(v.^2\));
v \= single(v./\[l;l]);
n \= single(\[\-v(2,:);v(1,:)]);

if (existsAndDefault('valueim', \[]))
 existsAndDefault('value', 1:length(pt1\));
 if (length(value) \=\= 1\)
 value \= repmat(value, 1, length(pt1\));
 end
end


\[x,y] \= meshgrid(1:size(im,2\),1:size(im,1\));

d \= (sqrt(sum((pt2\-pt1\).^2, 1\))); %distance between each set of points

xlim \= round(sort(\[pt1(1,:);pt2(1,:)],1\) \+ 2\*\[\-abs(d.\*n(1,:));abs(d.\*n(1,:))]);
ylim \= round(sort(\[pt1(2,:);pt2(2,:)],1\) \+ 2\*\[\-abs(d.\*n(2,:));abs(d.\*n(2,:))]);

xlim(xlim\<1\) \= 1;
xlim(xlim\>size(x,2\)) \= size(x,2\);
ylim(ylim\<1\) \= 1;
ylim(ylim\>size(x,1\)) \= size(x,1\);



for j \= 1:size(pt1,2\)

 %try
 xx \= x(ylim(1,j):ylim(2,j), xlim(1,j):xlim(2,j));
 yy \= y(ylim(1,j):ylim(2,j), xlim(1,j):xlim(2,j));
 %catch me
 % disp(me.getReport);
 % size(x)
 % xlim(1,j)
 % xlim(2,j)
 % ylim(1,j)
 
 %ylim(2,j)
 %end
 sz \= size(xx);
 
 xx \= reshape(xx,1,\[]);
 yy \= reshape(yy,1,\[]);
 

 frompt1 \= single(\[xx\-pt1(1,j);yy\-pt1(2,j)]);
 frompt2 \= single(\[xx\-pt2(1,j);yy\-pt2(2,j)]);
 
 vv \= repmat(v(:,j), 1, length(xx));
 nn \= repmat(n(:,j), 1, length(xx));
 dist \= abs(dot(frompt1,nn));
 
 online \= dot(vv, frompt1\) \>\= 0 \& dot(vv,frompt2\) \<\= 0; 
 \[I,J] \= ind2sub(sz, find(online));
 inds \= sub2ind(size(im), I\+ylim(1,j)\-1, J \+ xlim(1,j) \- 1\);
 
 if (\~isempty(valueim))
 valueim(inds(dist(online) \< im(inds))) \= value(j);
 end
 im(inds) \= min(im(inds), dist(online));
 
end


\-\-\-

\#\#\# File: cameraPointFromRealPoint.m (ID: basic routines.102\)

function \[u,v] \= cameraPointFromRealPoint (x,y,z,camcalinfo)
%function \[u,v] \= cameraPointFromRealPoint (x,y,z,camcalinfo)
%


%first calculate the new positions without taking into account barrel
%distortion
%homogenous coords:
%t\*\[u v 1] \= CM \* \[x y z 1]
x \= reshape(x,1,\[]);
y \= reshape(y,1,\[]);
if (isempty(z))
 z \= zeros(size(x));
end
t \= ones(size(x));
temp \= camcalinfo.CM \* \[x;y;z;t];
u \= temp(1,:)./temp(3,:);
v \= temp(2,:)./temp(3,:);

%now calculate barrel distortion
%\[u',v'] \= (1 \+ k(1\)r^2 \+ k(2\)r^4 \+ k(3\)r^6\) \* \[u,v];
r \= u.^2 \+ v.^2;
m \= 1\./(1 \+ camcalinfo.K(1\)\*r \+ camcalinfo.K(2\)\*r.^2 \+ camcalinfo.K(3\)\*r.^3\);

%finally, offset image by center point
u \= m.\*u \+ camcalinfo.xc;
v \= m.\*v \+ camcalinfo.yc;


%camera \-\> real
%first offset, then barrel, then inv(CM)

%
%function \[x,y] \= realPointFromCameraPoint (u, v, CM, K)
%function \[x,y] \= realPointFromCameraPoint (u, v, CM, K)
%
%finds the point (x,y,z\=0\) that corresponds to the camera point u, v given
%a camera projection matrix CM and distortion parameters in K

%A \= inv(CM(:,\[1 2 4]));
%r \= u.^2 \+ v.^2;
%a \= (1 \+ K(1\)\*r \+ K(2\)\*r.^2 \+ K(3\) \* r.^3\);

%z \= A\*\[a.\*u;a.\*v;ones(size(u))];
%x \= z(1,:)./z(3,:);
%y \= z(2,:)./z(3,:);
\-\-\-

\#\#\# Folder: @HeadSwing (ID: @HeadSwing)

\-\-\-

\#\#\# File: draw.m (ID: @HeadSwing.1\)

function draw(headSwing, varargin)
Colors.accepted \= 'g\-';
Colors.rejected \= 'r\-';
varargin \= assignApplicable(varargin);

if (headSwing.accepted)
 c \= Colors.accepted;
else
 c \= Colors.rejected;
end

plot (headSwing.track.dq.shead(1,headSwing.inds), headSwing.track.dq.shead(2,headSwing.inds), c);
\-\-\-

\#\#\# File: calculateMetrics.m (ID: @HeadSwing.2\)

function calculateMetrics(hs)
 if (length(hs) \> 1\)
 for j \= 1:length(hs)
 hs(j).calculateMetrics;
 end
 return;
 end

 hs.track.calculateDerivedQuantity({'sbodytheta', 'shead', 'stail', 'smid', 'dbodytheta'});
 btheta \= hs.track.dq.sbodytheta(hs.startInd:hs.endInd);
 
 \[\~,I] \= max(abs(btheta));
 last \= find(sign(hs.track.dq.sbodytheta(hs.startInd:hs.endInd)) \=\= sign(btheta(I)), 1, 'last');
 if (\~isempty(last))
 hs.endInd \= hs.startInd \+ last \- 1;
 end
 
 last \= find(\~hs.track.isrun(hs.startInd:hs.endInd),1, 'last');
 if (\~isempty(last))
 hs.endInd \= min(hs.endInd, hs.startInd \+ last);
 end
 if (hs.startInd \> hs.endInd)
 disp('start \> end')
 hs.startInd
 hs.endInd
 end
 %back up the start of the headswing to the point at which we passed the
 %head sweep start cutoff
 
 %first \= find(abs(hs.track.dq.sbodytheta(1:hs.startInd)) \< abs(hs.track.dq.sbodytheta(hs.startInd)) \& sign(hs.track.dq.dbodytheta(1:hs.startInd)) \=\= sign(hs.track.dq.sbodytheta(hs.startInd)), 1, 'last');
 first \= find((abs(hs.track.dq.sbodytheta(1:hs.startInd)) \< hs.track.so.headswing\_start \& sign(hs.track.dq.dbodytheta(1:hs.startInd)) \=\= sign(hs.track.dq.sbodytheta(hs.startInd))) \| sign(hs.track.dq.sbodytheta(1:hs.startInd)) \~\= sign(hs.track.dq.sbodytheta(hs.startInd)), 1, 'last');
 if (\~isempty(first))
 first \= first \+ 1;
 %if we changed the start index, back up the previous run ending to
 %before the starting index as well
 if (first \< hs.startInd \&\& \~isempty(hs.prevRun)) %only back up the head swing start, do not move it forward
 %make sure the first head swing doesn't make the previous run too
 %short 
 first \= max(first, ceil(hs.prevRun.startInd \+ hs.track.so.minRunTime/hs.track.dr.interpTime));
 first \= min(first, hs.startInd);
 ei \= min(hs.prevRun.endInd, first \- 1\);
 if (ei \~\= hs.prevRun.endInd)
 hs.prevRun.endInd \= ei;
 hs.prevRun.calculateMetrics(false);
 end
 hs.startInd \= first;
 end
 end
 if (hs.startInd \> hs.endInd)
 disp('2 start \> end')
 hs.startInd
 hs.endInd
 end
 hs.inds \= hs.startInd:hs.endInd;
 % btheta \= hs.track.dq.sspineTheta(hs.inds); %changed from sbodytheta 7/2 by marc
 btheta \= hs.track.dq.spineTheta(hs.inds); %changed from sspineTheta 12/10/2013 by marc
 
 mh \= hs.track.dq.shead(:,hs.inds) \- hs.track.dq.smid(:,hs.inds);
 tm \= hs.track.dq.smid(:,hs.inds) \- hs.track.dq.stail(:,hs.inds);
 
 
 \[\~,I] \= max(abs(btheta));
 hs.maxInd \= hs.inds(I);
 hs.maxTheta \= btheta(I);
 hs.sign \= sign(hs.maxTheta);
 hs.headDir \= atan2(mh(2,I), mh(1,I));
 hs.tailDir \= atan2(tm(2,I), tm(1,I));
 hs.accepted \= hs.track.isrun(hs.endInd);
 hs.valid \= all(hs.track.getDerivedQuantity('ihtValid', false, 'inds', hs.inds));
 if (\~isempty(hs.nextRun))
 hs.nextDir \= hs.nextRun.startTheta;
 end
 if (\~isempty(hs.prevRun))
 hs.prevDir \= hs.prevRun.endTheta;
 end
 %{
 hs.prevRun \= hs.track.run(find(\[hs.track.run.stop] \< hs.endInd, 1, 'last'));
 hs.nextRun \= hs.track.run(find(\[hs.track.run.start] \< hs.startInd, 1, 'first'));
 if (\~isempty(hs.prevRun))
 hs.prevDir \= hs.prevRun.endTheta;
 end 
 hs.nextDir
 %}
end
\-\-\-

\#\#\# File: illustrateHeadSwing.m (ID: @HeadSwing.3\)

function illustrateHeadSwing (hs, varargin)
%function illustrateHeadSwing (hs, varargin)

position \= \[];

varargin \= assignApplicable(varargin);


theta \= hs.track.getDerivedQuantity('sbodytheta', false, 1:(hs.endInd\-1\));
startInd \= find(abs(theta) \< hs.track.so.headswing\_stop \| sign(theta) \~\= hs.sign, 1, 'last');
if isempty(startInd)
 startInd \= hs.startInd;
end
\[blah,maxInd] \= max(abs(theta(startInd:(hs.endInd\-1\))));
if(isempty(maxInd))
 maxInd \= hs.endInd \- startInd \+ 1;
end
sind \= hs.track.getDerivedQuantity('mapInterpedToPts', false, startInd \- 1 \+ \[1 maxInd]);

if (\~isempty(position))
 offset \= position \- mean(\[hs.track.pt(sind).loc],2\);
else
 offset \= \[0;0];
end

ih \= ishold;
trackinds \= (hs.startInd \- 15\):(hs.endInd \+ 15\);
trackinds \= trackinds(trackinds \> 0 \& trackinds \< hs.track.npts);
loc \= hs.track.getDerivedQuantity('sloc');

loc \= loc \+ repmat(offset, \[1 length(loc)]);
plot (loc(1,trackinds), loc(2,trackinds), 'k.','MarkerSize',3\);hold on

drawContourAndHead(hs.track.pt(sind(1\)), 'offset', offset, 'contourColor', 'k\-', varargin{:}); 
if (hs.accepted)
 color \= 'g\-';
else
 color \= 'r\-';
end
plot (loc(1,trackinds(trackinds\>hs.endInd)), loc(2,trackinds(trackinds\>hs.endInd)), \[color(1\) '.'],'MarkerSize',4\);hold on
drawContourAndHead(hs.track.pt(sind(2\)), 'offset', offset, 'contourColor', color, varargin{:});

if(\~ih)
 hold off
end
\-\-\-

\#\#\# File: HeadSwing.m (ID: @HeadSwing.4\)

classdef HeadSwing \< TrackPart
 %what happens when a Maggot swings its head
 %it's a party, that's what!
 
 properties
 maxInd; %index where maxTheta is found; i.e. the peak of the headsweep
 maxTheta \= 0;
 headDir \= 0; 
 prevDir \= NaN;
 nextDir \= NaN;
 tailDir;
 sign;
 accepted;
 num \= 0; %which head sweep of the reorientation
 end
 properties (Dependent \= true)
 prevRun;
 nextRun;
 end
 methods
 function nr \= get.nextRun(obj)
 nr \= obj.getAdjacent('next', 'run');
 end
 function pr \= get.prevRun(obj)
 pr \= obj.getAdjacent('prev', 'run');
 end
 end
 
 methods %constructor
 function hs \= HeadSwing(varargin)
 %run \= Run(track, startInd, endInd)
 arglist \= {'track', 'startInd', 'endInd'};
 if (nargin \> 0\)
 for j \= 1:min(nargin, length(arglist))
 hs.(arglist{j}) \= varargin{j};
 end
 if (nargin \>\= length(arglist))
 %got everything we wanted, so calculate away
 hs.calculateMetrics();
 end
 end
 end
 end %constructor
 methods
 calculateMetrics(headSwing);
 draw(headSwing, varargin)
 illustrateHeadSwing (hs, varargin);
 end
end


\-\-\-

\#\#\# Folder: MAGATAnalyzer Example Scripts (ID: MAGATAnalyzer Example Scripts)

\-\-\-

\#\#\# File: processBinFilesToMatfiles.m (ID: MAGATAnalyzer Example Scripts.1\)

function \[eset, success] \= processBinFilesToMatfiles (basedir, esetname, varargin)
%function eset \= loadTrimStitchAndSave(basedir, esetname, ecl, camcalinfo, varargin)
%loads, stitches, trims, cleans, etc. then saves to mat files in a
%'matfiles' subdirectory 
%varargin: parameter \= defaultvalue
% to change, pass 'parameter', value after basedir, esetname
% checkerboardfname \= 'checkerboard.png';
% checkeroptions \= {'xinds', 310:2170, 'yinds', 220:1640, 'flipy', true, 'flipx', false, 'flatten', true};
% minptsToLoad \= 50;
% frameDiff \= 4;
% maxDist \= 0\.1;
% buffer \= \[\-0\.1 0\.2 0\.1 0\.1];
% trimrect \= \[];
% fieldsToDerive \= {};
%
% explanation of parameters 
%
% checkboardfname \- specifies the name of the picture of the 1cm checkerboard that we
% will use to calibrate the camera; place the
% checkerboard inside basedir
% checkeroptions \- options to pass to the checkerboard calibration routine
% 
% minPtsToLoad \- the minimum length a track must be before we will even
% load it from disk
%
% frameDiff \- stitch together tracks if first ended frameDiff or fewer frames before second started
% maxDist \- stitch together tracks if first ended within maxDist (in cm) of second's start
% buffer \- distance from leftmost, rightmost, bottommost, topmost point to trim 
% (to eliminate border region)
% trimrect \- you can specify an actual trim rectangle here
% if both buffer \& trimrect are specified, trimrect is used \& buffer is
% ignored; if buffer \= \[] and trimrect \= \[], trimming is disabled
% fieldsToDerive \- extra data fields to derive before saving to save time
% later


%% this section sets the parameters that will be used throughout the script
% you can change any of these parameters by passing 
%'parameter\_name', parameter value after basedir, esetname in the
% arguments to the function

%this specifies the name of the picture of the 1cm checkerboard that we
%will use to calibrate the camera \-\- using the checkerboard lets us analyze
%the data \- maggot lengths, run speeds, run lengths, etc. in real units
%(cm) that we can compare between experiments and labs
%
%it also takes out any lens distortion 
%
%place the checkerboard inside basedir 
%optionally you can rewrite this script to use a checkerboard you are
%storing somewhere else, but it's probably easiest just to store it with
%the extracted data anyway

checkerboardfname \= '1cm\_checkerboard.bmp';


%these are options to pass to the checkerboard calibration routine. xinds,
%yinds specify the region of the image that contains the checkerboard (if
%we are zoomed out enough to see the beyond the edge of the checkerboard)
%'flipy' is true (for cold\_arrows) because when we put 0,0 in the lower
%left corner, the image is upside down
%'flipx' is false (for cold\_arrows) because when we put 0,0 in the lower
%left corner, warm is to \+x
%'flatten', true evens out the illumination over the checkerboard, and is
%generally worth doing
checkeroptions \= {'flipy', true, 'flipx', false, 'flatten', true};


% minPtsToLoad is the minimum length a track must be before we will even
% load it from disk
minptsToLoad \= 50;


%these are options to use when stitching together tracks \-\- we do this in
%case the track extraction software dropped a frame or two in the middle of
%an otherwise good track. . . note that if the track is in
%collision with another track in the experiment, we don't stitch 

frameDiff \= 4; % stitch together tracks if first ended 4 or fewer frames before second started
maxDist \= 0\.1; % stitch together tracks if first ended within 1 mm of second's start

buffer \= \[\-0\.1 0\.2 0\.1 0\.1]; % \[left, right, top, bottom]
 % don't trim left (no tracks leave the left
 % edge). trim right by 2mm, top bottom by 1
 % mm
trimrect \= \[]; % you can specify an actual trim rectangle here, which will mean buffer is ignored
 % note that the window should be specified in cm, not pixels


%we derive all the fields necessary to segment the tracks and generate navigation figures before saving
%if there are other fields you want derived and saved, place them here
fieldsToDerive \= {};
varargin \= assignApplicable(varargin);

%we clean the experiment set twice \-\- once before stitching and once after
%stitching; the cleaner (eclnukespots) before stitching just looks for spots that are
%clearly not maggot tracks \-\- head tail is largely invalid; does not move
%more than 2 mm
%
%after stitching we are more selective, insisting on a minimum number of
%points, a fairly high number of valid head tail determinations, a minimum
%distance travelled, and a requirement that the larva not continuously
%circle in one direction

eclnukespots \= ESetCleaner();
eclnukespots.minHTValid \= 0\.6;
eclnukespots.minDist \= 0\.2;
eclnukespots.askFirst \= false;


ecl \= ESetCleaner();
ecl.minDist \= 1; % track must be more than 1 cm long
mintime \= 60; % tracks must be at least 60 seconds \-\- we will convert this into a minimum number of points later
ecl.minHTValid \= 0\.9; % discard any track where we couldn't determine a head tail properly at least 90% of the time

ecl.rpmCut \= 2; % get rid of any track that circles in one direction with a frequency of at least 2 rev/min
ecl.minRevCut \= 3; % provided that track does at least 3 complete circles

varargin \= assignApplicable(varargin);
success \= false;
ts1 \= tic();

%% this section carries out the camera calibration if needed and saves it
% to disk

if (\~exist(fullfile(basedir, 'camcalinfo.mat'), 'file'))
 try 
 im \= imread(fullfile(basedir, checkerboardfname));
 catch me
 disp ('could not read in checkerboard from: ');
 disp (fullfile(basedir, checkerboardfname));
 disp ('error was: ')
 disp (me.getReport());
 disp ('');
 error ('cannot proceed without camera calibration \-\- aborting');
 return; %\#ok
 end
 
 disp ('calibrating checkerboard');
 
 camcalinfo \= CameraCalibration(im, checkeroptions{:});
 if (isempty(camcalinfo))
 error ('camera calibration failed \- check options');
 end
 % make sure that the checkerboard that displays here is correct \-\- I am
 % not putting a checkoff in the script because you want to run it automatically, but this is a potential place for errors
 
 
 save(fullfile(basedir, 'camcalinfo.mat'), 'camcalinfo');
else
 load(fullfile(basedir, 'camcalinfo.mat'), 'camcalinfo');
end
 
%% this section will look through the directory for .bin files and verify
% that we have the appropriate .mdat files as well
d \= dir(fullfile(basedir, '\*.bin'));
for j \= 1:length(d)
 fname{j} \= fullfile(basedir, d(j).name); %\#ok\<\*AGROW\>
 \[ps,nm] \= fileparts(fname{j});
 mdatname{j} \= fullfile(ps,\[nm '.mdat']);
 if (\~exist(mdatname{j}, 'file'))
 disp ('cannot find metadata file');
 disp (\['bin file name \= ' fname{j}]);
 disp (\['metadata file name \= ' mdatname{j}]);
 error ('must have metadata file to proceed');
 return %\#ok
 end
end

% now we will load each mdat file and see if there is an ROI offset we need
% to take into account for the camera calibration

rx \= camcalinfo.realx;
ry \= camcalinfo.realy;
for j \= 1:length(mdatname)
 cx \= camcalinfo.camx;
 cy \= camcalinfo.camy;
 data \= importdata(mdatname{j});
 xcol \= find(strcmpi(data.colheaders, 'ROIX'));
 if (\~isempty(xcol))
 roix \= median(data.data(isfinite(data.data(:,xcol)),xcol)); % we should be able just to take the first value, but this should be more robust
 else
 roix \= 0;
 end
 ycol \= find(strcmpi(data.colheaders, 'ROIY'));
 if (\~isempty(ycol))
 roiy \= median(data.data(isfinite(data.data(:,ycol)),ycol)); % we should be able just to take the first value, but this should be more robust
 else
 roiy \= 0;
 end
 
 cc(j) \= CameraCalibration(rx, ry, cx\-roix, cy\-roiy);
end

%% this command actually loads the experiments from disk \-\- so short!

eset \= ExperimentSet.fromFiles(fname{:}, 'minpts', minptsToLoad, 'camcalinfo', cc, 'parallel', false);

%% we are going to put the rest of the file in try/catch blocks \-\- that way
% if there's a failure, you don't have to reload the tracks from disk to
% see what the problem is because the function will still return a value

% get rid of obviously bad tracks (dust, crap) before stitching
try
 disp ('cleaning bad spots');
 eclnukespots.clean(eset);
catch me
 disp(me.getReport);
 return;
end

%stitch tracks together
try 
 disp ('stitching tracks');
 eset.executeExperimentFunction('stitchTracks', frameDiff, maxDist, 'interactive', false);
catch me
 disp(me.getReport);
 return;
end
 
%trim the region near the edge of the experiment
try
 if (isempty(trimrect))
 if (\~isempty(buffer))
 il \= eset.gatherField('iloc');
 ll \= min(il,\[],2\);
 ur \= max(il,\[],2\);
 trimrect \= \[ll(1\) ll(2\) ur(1\) ur(2\)] \- buffer;
 end
 end
 if (\~isempty(trimrect))
 disp ('trimming tracks');
 eset.executeExperimentFunction('trimTracks', \[], trimrect);
 else
 disp ('skipping trimming');
 end
catch me
 disp(me.getReport);
 return;
end

%clean out marginal tracks that will not contribute to analysis
ecl.minPts \= ceil(mintime / eset.expt(1\).dr.interpTime);
ecl.askFirst \= false; 
ecl.showFigsInReport \= false;
\[\~,rpt] \= ecl.getReport(eset);
try
 fid \= fopen (fullfile (basedir, 'cleaning report.txt'), 'wt');
 for j \= 1:length(rpt)
 fprintf(fid, '%s\\n', rpt{j});
 end
catch me
 disp ('trouble writing cleaning report to disk, continuing anyway');
 disp (me.getReport);
end

disp ('cleaning eset');
try
 ecl.clean(eset);
 valid \= true(size(eset.expt));
 for j \= 1:length(eset.expt)
 if (isempty(eset.expt(j).track))
 disp (\[eset.expt(j).fname ' \- after cleaning no valid tracks']);
 valid(j) \= false;
 end
 end
 eset.expt \= eset.expt(valid);
catch me
 disp(me.getReport);
 return;
end


%calculate derived quantities used in segmentation; set segmentation speeds

try
 eset.executeTrackFunction('setSegmentSpeeds');
 dvfields \= {'sspineTheta', 'vel\_dp', 'spineLength'};
 for j \= 1:length(dvfields)
 disp (\['calculating ' dvfields{j}]);
 eset.gatherField(dvfields{j});
 end
 eset.gatherField('sspineTheta');
 eset.gatherField('vel\_dp');
 eset.gatherField('spineLength');
 for j \= 1:length(fieldsToDerive) 
 disp (\['calculating ' fieldsToDerive{j}]);
 eset.gatherField(fieldsToDerive{j});
 end
catch me
 disp(me.getReport);
 return;
end
disp('done with loading, stitching and cleaning');
toc(ts1\)

%finally, save the eset to disk as matfiles, so it can be loaded quickly later
try
 if (\~exist(fullfile(basedir, 'matfiles'), 'dir'))
 mkdir (fullfile(basedir, 'matfiles'));
 end
 eset.toMatFiles(fullfile(basedir, 'matfiles',esetname));
 disp('saved file');
 toc(ts1\)
catch me
 disp(me.getReport);
 return;
end

success \= true;

\-\-\-

\#\#\# File: ExtractTracksFromRawData.m (ID: MAGATAnalyzer Example Scripts.2\)

datadirectory \= fullfile ('..', 'Example Data');
imagedirectory \= fullfile (datadirectory, 'Image Data');
extracteddirectory \= fullfile(datadirectory, 'Extracted Tracks');
dataname \= 'CS EtAc 2ppm per cm spatial gradient';
zippeddata \= fullfile (datadirectory, \[dataname '.zip']);


%This section unzips the raw data so it can be extracted by the track
%extraction software
if (\~exist (imagedirectory, 'dir'))
 disp ('extracting example mmf data files from compressed zip archive');
 disp ('you should only see this message once');
 
 disp ('on completion, there should be 3 mmf files in ' );
 try
 file \= java.io.File(fullfile(cd, imagedirectory));
 disp (char(file.getCanonicalPath));
 catch me
 disp (imagedirectory);
 end
 try
 unzip (zippeddata, imagedirectory);
 catch me
 disp ('unzipping files failed, with error: ');
 disp(me.getReport());
 disp ('');
 disp (\['please delete the image directory ' imagedirectory ' and try again']);
 return;
 end
 disp ('unzipping finished!');
end

%This section creates the extraction settings prior to calling the track
%extractor

be \= defaultExtractionProcessingParams;
f2p \= be.files\_to\_process;
pp \= f2p.processing\_params;

% these are fields you may need to adjust when using the track extractor on
% your own data

pp.verbosity\_level \= 1; %only show errors in log file
pp.analysis\_rectangle \= \[0 0 2592 1944]; %region of the image to analyze \-\- set to exclude edges etc.

% these parameters determine whether a spot that is brighter than the
% background might represent a larva and therefore should be added to a
% track
pp.minArea \= 20; %minimum area (in pixels) a spot must be in order to be added to a track
pp.maxArea \= 1600; %maximum area (in pixels) a spot may be in order to be added to a track
pp.overallThreshold \= 30; %threshold above background for a spot to be added to a track

% as we select bright moving spots from the background and add them to
% tracks, we save a square window of the image around that spot. winSize
% must be \>\= the longest maggot in the data set. with that constraint,
% winSize should be as small as possible 
pp.winSize \= 40;

% these parameters determine how the background is determined
% the background is the minimum of at least nBackgroundFrames 
% (when extracting from mmfs, the background computation is different,
% resulting in the inclusion of more than just nBackgroundFrames)
% the nBackgroundFrames evenly span the background\_resampleInterval
% the frame being examined will be somewhere within the
% background\_resampleInterval, but not necessarily in its center
pp.nBackgroundFrames \= 5;
pp.background\_resampleInterval \= 500;

% maxExtractDist \- the maximum distance between the centers of mass (in
% pixels) of spots in two successive frames that will allow those spots to
% be considered part of the same track. 
pp.maxExtractDist \= 15;

% showExtraction \- whether to show a window displaying the track extraction
% in progress. if true (1\), a window shows the background subtracted
% image; blue lines indicate active tracks; red lines indicate tracks that
% have ended (due to collisions, maggot leaving the analysis rectangle, dropping below
% threshold intensity etc.)
%
% after all the tracks are extracted, a window will pop up showing selected
% maggots with the head tail midline and contour overlaid. 

pp.showExtraction \= true;
pp.extension \= 'mmf'; %verify that we are set to process mmf files


% this code section finds the raw data files, creates an output
% directory to store the extracted tracks, sets the batch extraction
% settings, and saves the batch extraction settings to disk

srcdir \= fullfile(imagedirectory, dataname);
d \= dir (fullfile(srcdir, '\*.mmf'));
if (isempty(d))
 disp ('expected to find mmf files in:')
 file \= java.io.File(fullfile(cd, srcdir));
 disp (char(file.getCanonicalPath));
 disp ('but they were not found');
 return;
end

dstdir \= fullfile(extracteddirectory, dataname);
if (\~exist(dstdir, 'dir'))
 mkdir(dstdir);
end


f2p.processing\_params \= pp;

f2p \= repmat(f2p, size(d));
for j \= 1:length(d)
 \[\~,fn] \= fileparts(d(j).name);
 
 file \= java.io.File(fullfile(cd, srcdir, fn));
 f2p(j).file\_stub \= char(file.getCanonicalPath);
 fn \= regexprep(fn, '\_stack$', '');
 file \= java.io.File(fullfile(cd, dstdir, \[fn '.bin']));
 f2p(j).output\_file \= char(file.getCanonicalPath);
 
end

be.files\_to\_process \= f2p;
str \= batchExtractorToString(be);

file \= java.io.File(fullfile(cd,'..', 'Track\-Extraction\-Software', 'Command Line Program', 'Command Line Extractor', 'extract\-stack.exe'));
progname \= char(file.getCanonicalPath);

file \= java.io.File(fullfile(cd, dstdir, 'extraction\_settings.bxx'));
bxxname \= char(file.getCanonicalPath);
fid \= fopen(bxxname, 'wt');
fprintf(fid, '%s', str);
fclose(fid);

% copy the checkerboard image into the extracted directory
copyfile(fullfile(datadirectory, '1cm\_checkerboard.bmp'), fullfile(dstdir, '1cm\_checkerboard.bmp'));


disp ('running the track extraction. this will take about 45 minutes');
disp ('when the extractor has finished, there will be 5 files for each experiment in this directory:')
file \= java.io.File(fullfile(cd, dstdir));
disp(char(file.getCanonicalPath));
disp ('xxx\_log.txt \- messages from the extraction software');
disp ('xxx\_header.txt \- a text header describing how data is stored in the bin files');
disp ('xxx\_foreground.bmp \- a simulated long exposure image of the experiment');
disp ('xxx.bin \- the extracted track data');
disp ('xxx.mdat \- associated meta data including camera timing information');
disp ('when the track extraction software has finished running, this script will continue');

\[s,w] \= dos (\['"' progname '" "' bxxname '"']);

disp ('extraction completed!');
\-\-\-

\#\#\# File: MAGAT\_ANALYZER\_DEMO.m (ID: MAGATAnalyzer Example Scripts.3\)

% starting with raw image files, we
% (1\) run a c\+\+ program to extract maggot positions and postures from the
% video
% (2\) load the maggot positions and postures into matlab, perform
% associated calibrations, derive behavioral metrics, then save the
% result to disk, allowing for quick loading later
% (3\) segment each track into an alternating series of runs and turns
% (4\) calculate metrics of strategy, make example figures, save those
% figures to disk
% (5\) as examples, plots the path of a single track, 
% plays a movie of a track, 
% plays a movie of every left turn in a track 
%
% the whole process, start to finish should take \< \~1 hr on a desktop computer
% after this script has been run to completion, subsequent executions
% should take \<5 minutes
%
% before running this script, or any other MAGAT Analyzer function, you
% must call the function setupDirectories and add MAGATAnalyzer Example Scripts and subdirectories to the path
% (running MAGAT\_ANALYZER\_START\_HERE accomplishes this)
%
% at the conclusion of the script, the Example Data directory should have
% these subdirectories
% Image Data \- raw movies taken of larvae in LADY GAGA, saved in a
% special compressed format. 
% Extracted Tracks\\CS EtAc 2ppm per cm spatial gradient \- the results
% of the track extraction software are stored here
% Extracted Tracks\\CS EtAc 2ppm per cm spatial gradient subdirectories:
% matfiles \- extracted tracks processed by matlab for fast
% loading and computations in the future
% calculations \- spatial analysis results used to make figures
% figures \- pdfs with figures similar to those we use for
% screening (simpleMetrics) and navigational analysis
% (strategyMetrics)
datadirectory \= fullfile ('..', 'Example Data');
extracteddirectory \= fullfile(datadirectory, 'Extracted Tracks');
dataname \= 'CS EtAc 2ppm per cm spatial gradient';
basedir \= fullfile(extracteddirectory, dataname);

% step 1
d \= dir(fullfile(basedir, '\*.bin'));
if (isempty(d))
 disp ('extracting tracks from raw image files');
 ExtractTracksFromRawData;
end

esetname \= 'CS\-EtAc\-2ppm\-per\-cm';

% step 2
d \= dir(fullfile(basedir, 'matfiles', \[esetname '\_experiment\*.mat']));
if (isempty(d))
 disp ('loading tracks from bin files');
 \[eset,success] \= processBinFilesToMatfiles(basedir, esetname);
 if (\~success)
 disp('eset processing bins to matfiles failed');
 return
 end
else
 if (\~exist('eset', 'var'))
 disp ('loading tracks from mat files');
 eset \= ExperimentSet.fromMatFiles(fullfile(basedir, 'matfiles', esetname));
 end
end

% step 3
disp('segmenting tracks into runs and turns');
eset.executeTrackFunction('segmentTrack');

% step 4
disp ('calculating navigational metrics');
spatialNavigationOptions \= spatialMaggotAnalysis;
spatialNavigationOptions.validname \= 'eti';
spatialNavigationOptions.validoperation \= '@(x) x \> 120 \& x \< 1020'; %only consider time between 2 \& 17 minutes

spatialCalculations \= spatialMaggotCalculations(eset, spatialNavigationOptions);
analyzedData \= spatialMaggotAnalysis(spatialCalculations, spatialNavigationOptions);
if (\~exist(fullfile(basedir, 'calculations'), 'dir'))
 mkdir(fullfile(basedir, 'calculations'));
end
disp ('saving calculations to disk');
save(fullfile(basedir, 'calculations', 'spatial\_analysis.mat'), 'spatialCalculations', 'analyzedData');

simpleMetricFigure(analyzedData, 'CS Navigating 2ppm/cm EtAc', \[],\[],'fignum', 1\);
strategyMetricFigure(analyzedData,\[], 'figureTitle', 'CS Navigating 2ppm/cm EtAc', 'fignum', 2\);
simpleTemporalFigures(analyzedData, \[], 'figureTitle', 'CS Navigating 2ppm/cm EtAc', 'fignum', 3\);

% save the figures to disk as pdfs
if (\~exist(fullfile(basedir, 'figures'), 'dir'))
 mkdir(fullfile(basedir, 'figures'));
end
saveas(1, fullfile(basedir, 'figures', 'simpleMetrics.pdf'), 'pdf');
saveas(2, fullfile(basedir, 'figures', 'strategyMetrics.pdf'), 'pdf');
saveas(3, fullfile(basedir, 'figures', 'simpleTemporal.pdf'), 'pdf');

% step 5

%find a pretty \& long track
htv \= eset.gatherField('ihtValid', 'mean');
npts \= eset.gatherField('npts');
\[\~,I] \= sort(htv, 'descend');
tind \= I(find(npts(I) \> 4000,1, 'first')); 
track \= eset.indToTrack(tind);

% plot the track path
figure(10\); clf
track.plotPath('sloc', 'b\-', 'highlightinds', 1, 'highlightlinetype', 'g.','MarkerSize',20\); axis equal;
%track will be plotted as a blue line with a green dot at the starting
%position; axes are labeled in cm



%play a short excerpt of the track 
figure(11\); clf
track.playMovie('startTime', 485, 'stopTime', 605\);

%now play every turn(reorientation) with at least one headsweep where the larva
%turns to the left
track.reorientation(\[track.reorientation.numHS] \> 0 \& diff(unwrap(\[\[track.reorientation.prevDir];\[track.reorientation.nextDir]])) \> 0\).playMovie('nopause', true);
\-\-\-

\#\#\# Folder: MAGATAnalyzer Example Scripts/higher level analysis for spatial gradients (ID: MAGATAnalyzer Example Scripts.higher level analysis for spatial gradients)

\-\-\-

\#\#\# File: simpleTemporalFigures.m (ID: MAGATAnalyzer Example Scripts.higher level analysis for spatial gradients.1\)

function axeshandles \= simpleTemporalFigures (ad, plot\_options, varargin)
%function axeshandles \= simpleTemporalFigures (ad, plot\_options, varargin)
%
% spatial\_navigation\_options \-\- 1 set of options for all esets
% just plots speed vs time, reo rate vs time, and if provided in file,
% temperature vs. time
%

SaveDirectory \= \[];
forprinting \= false;
showlegend \= false;
whichGraphs \= {};
fignum \= 1;
backgroundColor \= \[];
legendLocation \= 'BestOutside';
showtitle \= true;
vectorgraphics \= \[];
bigfont \= false;
figureTitle \= 'Experiment';

varargin \= assignApplicable(varargin);

f \= figure(fignum);
clf(f);
ss \= get(0, 'ScreenSize');

screenwidth \= ss(3\); screenheight \= ss(4\);
figratio \= 8/10;
r \= 0\.8;
figheight \= screenheight\*r;
figwidth \= figheight\*figratio;
figpos \= round(\[max(0,(screenwidth \- figwidth\*1\.33\)), (screenheight\-figheight)/2, figwidth, figheight]);
 
set(f, 'Position', figpos);
get(f, 'Position'); %calling get f,position here prevents a weird bug where text is incorrectly spaced later
% 
% if (\~all(get(f,'Position') \=\= figpos))
% rerun \= false;
% else
% rerun \= false;
% end
%get(f, 'Position')
set(f, 'PaperType', 'usletter', 'PaperPosition', \[0\.25 0\.25 8 10], 'PaperOrientation', 'portrait', 'color', 'w', 'inverthardcopy', 'off');
%get(f, 'Position')

leftmargin \= 1/8;
rightmargin \= .5/8;
allaxeswidth \= 1 \- leftmargin \- rightmargin;
topmargin \= 1/11;
bottommargin \= 1/11;
h0 \= 1\-topmargin;
allaxesheight \= h0\-bottommargin;

wspace2 \= 0\.2 \* allaxeswidth;
wspace3 \= 0\.12 \* allaxeswidth;
wspace4 \= 0\.12 \* allaxeswidth;

hspace \= .75/11;

if (isfield(ad, 'temperature\_vs\_time'))
 nrows \= 3;
else
 nrows \= 2;
end

h \= (allaxesheight \- (nrows\-1\)\*hspace)/nrows;
dh \= h \+ hspace;
w1 \= allaxeswidth;

w2 \= min((allaxeswidth \- wspace2\)/2, h\*1\.61803399\);
w3 \= (allaxeswidth \- 2\*wspace3\)/3;
w4 \= (allaxeswidth \- 3\*wspace4\)/4;

centerx \= 0\.5\*(1\+leftmargin \-rightmargin);

lx2 \= centerx \- wspace2/2 \- w2;
rx2 \= centerx \+ (wspace2\)/2;

lx3 \= centerx \- wspace3 \- 3\*w3/2;
cx3 \= centerx \- w3/2;
rx3 \= centerx \+ w3/2 \+ wspace3;


lx4 \= centerx \- 3\*wspace4/2 \- 2\*w4;
clx4 \= centerx \- wspace4/2 \- w4;
crx4 \= centerx \+ (wspace4\)/2;
rx4 \= centerx \+ 3\*(wspace4\)/2\+w4;

default\_properties \= get(0,'default');


vectorgraphics \= true;

default\_properties \= get(0,'default');



ccc \= 'bgrcymk';
sss \= 'sodvh\>p^\<';
po.lineWidth \= 1;
po.color \= ccc(1\);

po.marker \= 'none';
po.plotOptions \= {};
po.shadedErrorRegion \= true;
po.useGauss \= false;
po.directions \= \[\-180,\-90, 0, 90];
po.colors \= {\[0\.1 0 1], \[0\.1 0\.8 0\.2], \[1 0 0], \[0\.6 0\.6 0\.0]};
po.labelRadii \= false;
po.textOnPolar \= true;
po.font \= 'Arial';
po.fontsize \= 7;

if (nargin \=\= 0\)
 axeshandles \= po;
 return;
end


spatial\_navigation\_options \= ad.sno;
if (isstruct(spatial\_navigation\_options))
 fn \= fieldnames(spatial\_navigation\_options);
 for j \= 1:length(fn)
 sno.(fn{j}) \= spatial\_navigation\_options.(fn{j});
 end
end

nexp \= length(ad);
if (nexp \> 1\)
 error ('call on only one experiment analyzed data set');
end

po.legendEntry \= cellfun(@(x) \['to ' num2str(x) '$^\\circ$'], num2cell(po.directions),'UniformOutput',false);
if (nargin \> 2 \&\& isstruct(plot\_options))
 fn \= fieldnames(plot\_options);
 for j \= 1:length(fn)
 po.(fn{j}) \= plot\_options.(fn{j});
 end
end
for j \= 1:length(po.colors)
 if (ischar(po.colors{j}))
 po.colors{j} \= char2rgb(po.colors{j});
 end
end


fontsize \= po.fontsize;
font \= po.font;
linewidth \= po.lineWidth;
set(0,'DefaultAxesFontSize', fontsize);
set(0,'DefaultAxesFontName', font);
set(0, 'DefaultTextInterpreter', 'Tex');
axesopts \= {'Box', 'off', 'LineWidth', linewidth, 'FontSize', fontsize, 'FontName', font};

figureTitle(figureTitle \=\= '\_') \= '\-';
annotation ('textbox', \[leftmargin, 1\-hspace, 1\-leftmargin, hspace], 'String', figureTitle, ...
 'FontName', font, 'FontSize', 18, 'Color','k', 'HorizontalAlignment', 'left', 'VerticalAlignment', 'top',...
 'LineStyle', 'none');
 
an \= 1;
ah(an).name \= 'speed\_vs\_time';
ah(an).pos \= \[leftmargin, h0\-h, w1,h];
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});
shadedErrorPlot(ad.time\_axis, ad.speed\_vs\_time\*60, 60\*ad.speed\_vs\_time\_eb, \[],\[0 0 0], 'lineOptions', {'linewidth', 2});
xlabel ('time (s)');
ylabel ('speed (cm/min)');


an \= an\+1;
ah(an).name \= 'reo\_vs\_time';
ah(an).pos \= ah(an\-1\).pos; ah(an).pos(2\) \= ah(an).pos(2\) \- dh;
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});
shadedErrorPlot(ad.time\_axis, ad.reo\_vs\_time, ad.reo\_vs\_time\_eb, \[], \[ 0 0 0], 'lineOptions', {'linewidth', 2});
xlabel ('time (s)');
ylabel ('reorientation rate (min^{\-1})', 'Interpreter', 'Tex');

if (isfield(ad, 'temperature\_vs\_time'))
 an \= an\+1;
 ah(an).name \= 'temperatureVsTime';
 ah(an).pos \= ah(an\-1\).pos; ah(an).pos(2\) \= ah(an).pos(2\) \- dh;
 ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});
 plot(ad.time\_axis, ad.temperature\_vs\_time, 'k', 'LineWidth', 2\);
 xlabel ('time (s)');
 ylabel ('remperature (^{\\circ} C)', 'Interpreter', 'Tex');
end

\-\-\-

\#\#\# File: strategyMetricFigure.m (ID: MAGATAnalyzer Example Scripts.higher level analysis for spatial gradients.2\)

function axeshandles \= strategyMetricFigure (ad, plot\_options, varargin)
%function axeshandles \= strategyMetricFigure (ad, plot\_options, varargin)
%
% spatial\_navigation\_options \-\- 1 set of options for all esets
% plot\_options \-\- each eset gets its own options
% plot\_options.
% lineWidth \-\- width of lines
% color \-\- color for line and marker
% legendEntry \-\- what to put in legend
% marker \-\- marker 
% plotOptions \-\- additional options to pass to plotting function
%
% varargin: 'SaveDirectory', directory to save images in (if empty,
% nothing saved
% forprinting \= false;
% showlegend \= false;
% whichGraphs \= {}; all if empty \- choose from {'DirectionHistogram',
% 'RunStartHistogram','ReorientationRateVsHeading',
% 'InstantaneousDeltaThetaVsTheta','SpeedVsDirection',
% 'ReoDirVsHeading','RunDirVsHeading','ReoMagVsHeading', 'HeadSwingAcceptanceHandedness',
% 'FirstHeadSwingHandedness', 'ReoDirDistribution','RunLengthHistogram',
% 'RunDirDistribution','ReoDirDistributionPolar',
% 'RunDirDistributionPolar', 'FirstHeadSwingHandednessPerp'

SaveDirectory \= \[];
forprinting \= false;
showlegend \= false;
whichGraphs \= {};
fignum \= 1;
backgroundColor \= \[];
legendLocation \= 'BestOutside';
showtitle \= true;
vectorgraphics \= \[];
bigfont \= false;
figureTitle \= 'Experiment';

varargin \= assignApplicable(varargin);

f \= figure(fignum);
clf(f);
ss \= get(0, 'ScreenSize');

screenwidth \= ss(3\); screenheight \= ss(4\);
figratio \= 8/10;
r \= 0\.8;
figheight \= screenheight\*r;
figwidth \= figheight\*figratio;
figpos \= round(\[max(0,(screenwidth \- figwidth\*1\.33\)), (screenheight\-figheight)/2, figwidth, figheight]);
 
set(f, 'Position', figpos);
get(f, 'Position'); %calling get f,position here prevents a weird bug where text is incorrectly spaced later
% 
% if (\~all(get(f,'Position') \=\= figpos))
% rerun \= false;
% else
% rerun \= false;
% end
%get(f, 'Position')
set(f, 'PaperType', 'usletter', 'PaperPosition', \[0\.25 0\.25 8 10], 'PaperOrientation', 'portrait', 'color', 'w', 'inverthardcopy', 'off');
%get(f, 'Position')

dxc \= 0\.1;
allaxeswidth \= 0\.95 \- dxc;
allaxesheight \= 0\.9;
dh \= (.975 \- allaxesheight);

wspace \= 0\.1 \* allaxeswidth;

w \= (allaxeswidth \- 2\*wspace)/3;
h \= 0\.18 \* allaxesheight;


w4 \= w\*3/4\*(allaxeswidth\-dxc)/allaxeswidth;
h4 \= w4\*8/10;

w4s \= (allaxeswidth\-dxc\-4\*w4\)/3;


%dw \= (1 \- (3\*w \+ 2\*wspace))/2;

lx \= dxc;
cx \= dxc \+ allaxeswidth/2\-w/2;
rx \= allaxeswidth\+dxc\-w;

lx4 \= 2\*dxc;
clx4 \= lx4 \+ w4\+w4s;
crx4 \= clx4 \+ w4\+w4s;
rx4 \= crx4 \+ w4\+w4s;
x4 \= \[lx4, clx4, crx4, rx4];

hspace \= (allaxesheight \- 3\*h \-2\*h4\)/4\.5;


vectorgraphics \= true;

default\_properties \= get(0,'default');



ccc \= 'bgrcymk';
sss \= 'sodvh\>p^\<';
po.lineWidth \= 1;
po.color \= ccc(1\);

po.marker \= 'none';
po.plotOptions \= {};
po.shadedErrorRegion \= true;
po.useGauss \= false;
po.directions \= \[\-180,\-90, 0, 90];
po.colors \= {\[0\.1 0 1], \[0\.1 0\.8 0\.2], \[1 0 0], \[0\.6 0\.6 0\.0]};
po.labelRadii \= false;
po.textOnPolar \= true;
po.font \= 'Arial';
po.fontsize \= 7;

if (nargin \=\= 0\)
 axeshandles \= po;
 return;
end


spatial\_navigation\_options \= ad.sno;
if (isstruct(spatial\_navigation\_options))
 fn \= fieldnames(spatial\_navigation\_options);
 for j \= 1:length(fn)
 sno.(fn{j}) \= spatial\_navigation\_options.(fn{j});
 end
end

nexp \= length(ad);
if (nexp \> 1\)
 error ('call on only one experiment analyzed data set');
end

po.legendEntry \= cellfun(@(x) \['to ' num2str(x) '$^\\circ$'], num2cell(po.directions),'UniformOutput',false);
if (nargin \> 2 \&\& isstruct(plot\_options))
 fn \= fieldnames(plot\_options);
 for j \= 1:length(fn)
 po.(fn{j}) \= plot\_options.(fn{j});
 end
end
for j \= 1:length(po.colors)
 if (ischar(po.colors{j}))
 po.colors{j} \= char2rgb(po.colors{j});
 end
end


fontsize \= po.fontsize;
font \= po.font;
linewidth \= po.lineWidth;
set(0,'DefaultAxesFontSize', fontsize);
set(0,'DefaultAxesFontName', font);
set(0, 'DefaultTextInterpreter', 'Tex');
axesopts \= {'Box', 'off', 'LineWidth', linewidth, 'FontSize', fontsize, 'FontName', font};

figureTitle(figureTitle \=\= '\_') \= '\-';
annotation ('textbox', \[dxc, 1\-dh, 1\-dxc, dh], 'String', figureTitle, ...
 'FontName', font, 'FontSize', 18, 'Color','k', 'HorizontalAlignment', 'left', 'VerticalAlignment', 'top',...
 'LineStyle', 'none');
 
an \= 1;
ah(an).name \= 'Rose';
ah(an).pos \= \[allaxeswidth\+dxc\-dh, 1\-dh\*9/10, dh, dh\*7/10];
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});
polarBackground(1, ah(an).axes, 0, 'labelRadii', false, 'notext', false, 'numlabels',4\);
th \= \-45:45;
for j \= 1:4
 x \= \[0 cosd(po.directions(j) \+ th) 0];
 y \= \[0 sind(po.directions(j) \+ th) 0];
 patch(x,y,1,'FaceColor', po.colors{j}\*0\.25 \+ .75, 'EdgeColor', 'k');
end

an \= an\+1;
ah(an).name \= 'DirectionHistogram';
ah(an).pos \= \[lx 1\-dh\-h w h];
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});
quadrantGraph(ad, 'txc', 'thetahist', po, 1/sum(ad.thetahist), true);
ylabel({'Relative probability', 'of orientation'}, 'Interpreter', 'Tex');
xlabel('run heading (^\\circ)', 'Interpreter', 'Tex');
set(ah(an).axes, 'XTick', \[\-180 \-90 0 90 180], axesopts{:});


an \= an\+1;
ah(an).name \= 'SpeedVsDirection';
ah(an).pos \= ah(an\-1\).pos; ah(an).pos(1\) \= cx;
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});

yfield \= 'speedVsDir';
ymult \= 60;
if (po.useGauss)
 xfield \= 'txf';
 yfield \= \[yfield '\_gauss'];
 iscirc \= false;
else
 xfield \= 'txc';
 iscirc \= true;
end
quadrantGraph(ad,xfield,yfield, po, ymult, iscirc);
ylabel ('Run speed (cm/min)', 'Interpreter', 'Tex');
xlabel('run heading (\\circ)', 'Interpreter', 'Tex');
set(ah(an).axes, 'XTick', \[\-180 \-90 0 90 180], axesopts{:});

an \= an\+1;
ah(an).name \= 'RunDirVsHeading';
ah(an).pos \= ah(an\-1\).pos; ah(an).pos(1\) \= rx;
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});
yfield \= 'meanrunchange';
ymult \= 180/pi;
if (po.useGauss)
 xfield \= 'txf';
 yfield \= \[yfield '\_gauss'];
 iscirc \= false;
else
 xfield \= 'reotxc';
 iscirc \= true;
end

quadrantGraph(ad,xfield,yfield, po, ymult, iscirc);
xlabel ('Run start heading (\\circ)', 'Interpreter', 'Tex');
ylabel ({'Mean heading change (\\circ)', 'in run'}, 'Interpreter', 'Tex');
set(ah(an).axes, 'XTick', \[\-180 \-90 0 90 180], axesopts{:});

an \= an\+1;
ah(an).name \= 'ReorientationRateVsHeading';
ah(an).pos \= ah(an\-1\).pos; ah(an).pos(1\) \= lx; ah(an).pos(2\) \= ah(an).pos(2\)\-h\-hspace;
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});

quadrantGraph(ad, 'txc', 'reohist', po, 1, true);
xlabel ('Run heading (\\circ)', 'Interpreter', 'Tex');
ylabel ('Turn rate (min^\-^1\)', 'Interpreter', 'Tex');
set(ah(an).axes, 'XTick', \[\-180 \-90 0 90 180], axesopts{:});


an \= an\+1;
ah(an).name \= 'ReoMagVsHeading';
ah(an).pos \= ah(an\-1\).pos; ah(an).pos(1\) \= cx;
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});
yfield \= 'reoMag';
ymult \= 180/pi;
if (po.useGauss)
 xfield \= 'txf';
 yfield \= \[yfield '\_gauss'];
 iscirc \= false;
else
 xfield \= 'reotxc';
 iscirc \= true;
end
ad.(\[yfield '\_sqrt']) \= sqrt(ad.(yfield));
ad.(\[yfield '\_sqrt\_eb']) \= 0\.5\*sqrt(ad.(\[yfield '\_eb']) ./ ad.(yfield));
quadrantGraph(ad,xfield,\[yfield '\_sqrt'], po, ymult, iscirc);
xlabel ('Prev run heading (\\circ)', 'Interpreter', 'Tex');
ylabel ({'Heading change size', '(rms angle, \\circ)'}, 'Interpreter', 'Tex');
set(ah(an).axes, 'XTick', \[\-180 \-90 0 90 180], axesopts{:});


an \= an\+1;
ah(an).name \= 'ReoDirVsHeading';
ah(an).pos \= ah(an\-1\).pos; ah(an).pos(1\) \= rx;
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});
yfield \= 'reoDir';
ymult \= 180/pi;
if (po.useGauss)
 xfield \= 'txf';
 yfield \= \[yfield '\_gauss'];
 iscirc \= false;
else
 xfield \= 'reotxc';
 iscirc \= true;
end

quadrantGraph(ad,xfield,yfield, po, ymult, iscirc);
xlabel ('Prev run heading (\\circ)', 'Interpreter', 'Tex');
ylabel ({'Mean heading change (\\circ)', 'during reorientation'}, 'Interpreter', 'Tex');
set(ah(an).axes, 'XTick', \[\-180 \-90 0 90 180], axesopts{:});

ind \= find(strcmpi('RunDirVsHeading', {ah.name}));
yl1 \= get(ah(ind).axes, 'YLim');
yl2 \= get(ah(an).axes, 'YLim');
ylm \= max(abs(\[yl1 yl2]));
set(\[ah(\[ind an]).axes], 'YLim', \[\-ylm ylm]);


\[\~,I] \= max(cosd(po.directions \- sno.preferredDirection));
tocolor \= po.colors{I}/4 \+ 0\.75;
\[\~,I] \= min(cosd(po.directions \- sno.preferredDirection));
fromcolor \= po.colors{I}/4 \+ 0\.75;

an \= an\+1;
ah(an).name \= 'ReoDirBias';
ah(an).pos \= ah(an\-1\).pos; ah(an).pos(1\) \= lx; ah(an).pos(2\) \= ah(an).pos(2\)\-h\-hspace;
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});

bardat \= \[ad.simpleMetrics.prob\_turn\_towards 1\-ad.simpleMetrics.prob\_turn\_towards];
ebdat \= ad.simpleMetrics.prob\_turn\_towards\_eb\*\[1 1];
gnames \= {\['to ' num2str(ad.sno.preferredDirection)], \['to ' num2str(mod(ad.sno.preferredDirection \+ 180, 360\))]};
hhh \= barweb\_marc(bardat', ebdat', 0\.8, gnames);
set(hhh.bars, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
set(hhh.bars(1\), 'FaceColor', tocolor);
set(hhh.bars(2\), 'FaceColor', fromcolor);
set(hhh.ax, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 1], 'Box', 'off', 'LineWidth', linewidth);
ylabel ({'Distribution of turns', 'from perp. direction'});



an \= an\+1;
ah(an).name \= 'FirstHSDirBias';
ah(an).pos \= ah(an\-1\).pos; ah(an).pos(1\) \= cx; 
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});

bardat \= \[ad.firstHSProbTowards 1\-ad.firstHSProbTowards];
ebdat \= ad.firstHSProbTowards\_eb\*\[1 1];
gnames \= {\['to ' num2str(ad.sno.preferredDirection)], \['to ' num2str(mod(ad.sno.preferredDirection \+ 180, 360\))]};
hhh \= barweb\_marc(bardat', ebdat', 0\.8, gnames);
set(hhh.bars, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
set(hhh.bars(1\), 'FaceColor', tocolor);
set(hhh.bars(2\), 'FaceColor', fromcolor);
set(hhh.ax, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 1], 'Box', 'off', 'LineWidth', linewidth);
ylabel ({'Distribution of first head sweeps', 'from perp. direction'});


an \= an\+1;
ah(an).name \= 'HSAcceptanceBias';
ah(an).pos \= ah(an\-1\).pos; ah(an).pos(1\) \= rx; 
ah(an).axes \= axes('Position', ah(an).pos, axesopts{:});

bardat \= \[ad.headSwingAcceptanceRateTowards ad.headSwingAcceptanceRateAway];
ebdat \= \[ad.headSwingAcceptanceRateTowards\_eb ad.headSwingAcceptanceRateAway\_eb];
gnames \= {\['to ' num2str(ad.sno.preferredDirection)], \['to ' num2str(mod(ad.sno.preferredDirection \+ 180, 360\))]};
hhh \= barweb\_marc(bardat', ebdat', 0\.8, gnames);
set(hhh.bars, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
set(hhh.bars(1\), 'FaceColor', tocolor);
set(hhh.bars(2\), 'FaceColor', fromcolor);
set(hhh.ax, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 1], 'Box', 'off', 'LineWidth', linewidth);
ylabel ({'Probability of starting run', 'during head sweep'});



an \= an\+1;
ah(an).name \= 'RunDirDistribution';

pos \= \[lx4 ah(an\-1\).pos(2\)\-h4\-hspace\*2 w4 h4];
for j \= 1:4
 denom \= sum(ad.run\_dtheta\_dist{j});
 maxr(j) \= max(ad.run\_dtheta\_dist{j}\+ad.run\_dtheta\_dist\_eb{j})/denom;
end
maxr \= max(maxr);
xp \= \[0 0 .5 .5];
yp \= \[0\.5 0 0\.5 0];

for j \= 1:4
 pos(1\) \= x4(j);
 ah(an).axes(j) \= axes('Position', pos, axesopts{:});
 \[\~,ind(j)] \= min(abs(mod(po.directions \- ad.reobasedirections(j) \+ 180, 360\)\- 180\));
 denom \= sum(ad.run\_dtheta\_dist{j});% \+ ad.reo\_dtheta\_dist\_nohs{j});
 bc \= \[1 1 1];
 fc2 \= 0\.4\*po.colors{ind(j)} \+ 0\.6\*bc;
 
 \[\~,ax2(j)] \= polarBackground(maxr, ah(an).axes(j), ad.reobasedirections(j), 'labelRadii', po.labelRadii, 'notext', \~po.textOnPolar, 'numlabels', 4\);
 
 
 \[hh,heb] \= polarBarPlotWError(ad.dtx, ad.run\_dtheta\_dist{j}/denom, ad.run\_dtheta\_dist\_eb{j}/denom,\[], fc2, 'locOfZero', ad.reobasedirections(j), 'FaceColor', fc2, 'EdgeColor', po.colors{ind(j)}, 'Parent', ax2(j), 'LineWidth', 1, 'curveEB', true); 
 set(heb, 'LineWidth', po.lineWidth);
 
 \[x,y] \= dsxy2figxy\_marc(ah(an).axes(j), maxr\*cosd(ad.reobasedirections(j))\*\[\-1 \-.5], maxr\*sind(ad.reobasedirections(j))\*\[\-1 \-.5]);
 annotation('arrow', x,y, 'Color', po.colors{ind(j)}, 'LineWidth', po.lineWidth\*1\.5\);
 
 pp \= get(ah(an).axes(j), 'OuterPosition');
 if (cosd(ad.reobasedirections) \=\= \-1\)
 str \= '\\pm180\\circ';
 else
 str \= \[num2str(ad.reobasedirections(j)) '\\circ'];
 end
 annotation ('textbox', \[pos(1\)\+w4/2, pos(2\)\+h4\+hspace/2, 0\.001, 0\.001], 'String', str, ...
 'FontName', font, 'FontSize', fontsize\+2, 'Color', po.colors{ind(j)}, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'bottom',...
 'LineStyle', 'none');
end

annotation ('textbox', \[0, pos(2\)\+h4\+hspace/2, x4(1\)\-dxc/2, 0\.001], 'String', 'Initial heading:', ...
 'FontName', font, 'FontSize', fontsize, 'Color','k', 'HorizontalAlignment', 'right', 'VerticalAlignment', 'bottom',...
 'LineStyle', 'none');

annotation ('textbox', \[0, pos(2\)\+h4/2, x4(1\)\-dxc/2, 0\.001], 'String', {'Heading changes','during runs'}, ...
 'FontName', font, 'FontSize', fontsize, 'Color','k', 'HorizontalAlignment', 'right', 'VerticalAlignment', 'middle',...
 'LineStyle', 'none');
 
 
ah(an).pos \= pos;




an \= an\+1;
ah(an).name \= 'ReoDirDistribution';

pos \= \[lx4 ah(an\-1\).pos(2\)\-h4\-hspace/2 w4 h4];
for j \= 1:4
 denom \= sum(ad.reo\_dtheta\_dist\_hs{j});
 maxr(j) \= max(ad.reo\_dtheta\_dist\_hs{j}\+ad.reo\_dtheta\_dist\_hs\_eb{j})/denom;
end
maxr \= max(maxr);
xp \= \[0 0 .5 .5];
yp \= \[0\.5 0 0\.5 0];

for j \= 1:4
 pos(1\) \= x4(j);
 ah(an).axes(j) \= axes('Position', pos, axesopts{:});
 \[\~,ind(j)] \= min(abs(mod(po.directions \- ad.reobasedirections(j) \+ 180, 360\)\- 180\));
 denom \= sum(ad.reo\_dtheta\_dist\_hs{j});% \+ ad.reo\_dtheta\_dist\_nohs{j});
 bc \= \[1 1 1];
 fc2 \= 0\.4\*po.colors{ind(j)} \+ 0\.6\*bc;
 
 \[\~,ax2(j)] \= polarBackground(maxr, ah(an).axes(j), ad.reobasedirections(j), 'labelRadii', po.labelRadii, 'notext', \~po.textOnPolar, 'numlabels', 4\);
 
 
 \[hh,heb] \= polarBarPlotWError(ad.dtx, ad.reo\_dtheta\_dist\_hs{j}/denom, ad.reo\_dtheta\_dist\_hs\_eb{j}/denom,\[], fc2, 'locOfZero', ad.reobasedirections(j), 'FaceColor', fc2, 'EdgeColor', po.colors{ind(j)}, 'Parent', ax2(j), 'LineWidth', 1, 'curveEB', true); 
 set(heb, 'LineWidth', po.lineWidth);
 
 \[x,y] \= dsxy2figxy\_marc(ah(an).axes(j), maxr\*cosd(ad.reobasedirections(j))\*\[\-1 \-.5], maxr\*sind(ad.reobasedirections(j))\*\[\-1 \-.5]);
 annotation('arrow', x,y, 'Color', po.colors{ind(j)}, 'LineWidth', po.lineWidth\*1\.5\);
 
end
annotation ('textbox', \[0, pos(2\)\+h4/2, x4(1\)\-dxc/2, 0\.001], 'String', {'Heading changes','during turns'}, ...
 'FontName', font, 'FontSize', fontsize, 'Color','k', 'HorizontalAlignment', 'right', 'VerticalAlignment', 'middle',...
 'LineStyle', 'none');


ah(an).pos \= pos;
if (nargout \> 0\)
 axeshandles \= ah;
end
set(0, default\_properties);






 
function quadrantGraph(ad, xfield, yfield,po, mult, iscirc)
%function quadrantGraph(ad, xfield, yfield,po, mult, iscirc)
\[directions,I] \= sort(po.directions);
colors \= po.colors(I);
existsAndDefault('mult', 1\);

tx \= ad.(xfield);


q \= zeros(size(tx));
for j \= 1:length(tx)
 \[\~,I] \= max(cosd(directions \- tx(j)));
 q(j) \= I;
end
yd \= mult\*ad.(yfield);
ebd \= mult\*ad.(\[yfield '\_eb']);

if (iscirc)
 yd \= yd(\[1:end 1]);
 ebd \= ebd(\[1:end 1]);
end

for j \= 1:length(directions)
 inds \= find(q \=\= j);
 \[xdata{j},I] \= sort(tx(inds));
 inds \= inds(I);
 ydata{j} \= yd(inds);
 ebdata{j} \= ebd(inds);
end
for j \= 1:length(xdata)
 if (any(diff(xdata{j}) \> min(diff(directions)))) 
 \[\~,I] \= max(diff(xdata{j}));
 ni \= length(xdata) \+ 1;
 colors{ni} \= colors{j};
 xdata{ni} \= xdata{j}((I\+1\):end);
 xdata{j} \= xdata{j}(1:I); 
 ydata{ni} \= ydata{j}((I\+1\):end);
 ydata{j} \= ydata{j}(1:I);
 ebdata{ni} \= ebdata{j}((I\+1\):end);
 ebdata{j} \= ebdata{j}(1:I);
 end
end



xf \= zeros(size(xdata)); xr \= xf; yf \= xf; yr \= xf; ebf \= xf; ebr \= xf;

for j \= 1:length(xdata)
 ahead \= mod(j, length(xdata)) \+ 1;
 behind \= mod(j\-2, length(xdata)) \+ 1;
 
 xf(j) \= 0\.5\* (xdata{j}(end) \+ mod(xdata{ahead}(1\) \- xdata{j}(end), 360\) \+ xdata{j}(end));
 xr(j) \= 0\.5\* (\-mod(xdata{j}(1\) \- xdata{behind}(end), 360\) \+ xdata{j}(1\) \+ xdata{j}(1\));
 yf(j) \= 0\.5\* (ydata{j}(end) \+ ydata{ahead}(1\));
 yr(j) \= 0\.5\* (ydata{behind}(end) \+ ydata{j}(1\));
 ebf(j) \= 0\.5\* (ebdata{j}(end) \+ ebdata{ahead}(1\));
 ebr(j) \= 0\.5\* (ebdata{behind}(end) \+ ebdata{j}(1\));
end

if (po.shadedErrorRegion)
 for j \= 1:length(xdata)
 xxdata{j} \= \[xr(j) xdata{j} xf(j)];
 yydata{j} \= \[yr(j) ydata{j} yf(j)];
 eebdata{j} \= \[ebr(j) ebdata{j} ebf(j)];
 end
 hh \= shadedErrorPlot(xxdata, yydata, eebdata, \[], colors, 'LineWidth', po.lineWidth);
 set(hh((length(xdata)\+1\):end), 'LineWidth', po.lineWidth, po.plotOptions{:});
 hold on;
 if (length(tx) \> 60\)
 marker \= 'none';
 else
 marker \= po.marker;
 end
 for j \= 1:length(xdata)
 plot (xdata{j}, ydata{j}, 'Color', colors{j},'Marker', marker, 'LineStyle', 'none', 'LineWidth', po.lineWidth, po.plotOptions{:}); 
 end
 hold off;
else
 for j \= 1:length(xdata)
 plot (\[xr(j) xdata{j} xf(j)], \[yr(j) ydata{j} yf(j)], 'k\-', 'Color', colors{j}, 'LineWidth', po.lineWidth, po.plotOptions{:}); hold on;
 errorbar (xdata{j}, ydata{j}, ebdata{j}, 'Color', colors{j}, 'Marker', po.marker, 'LineWidth', po.lineWidth, po.plotOptions{:});
 end
 hold off
end

% 
% function quadrantGraph(ad, fieldname,po, mult)
% %function quadrantGraph(ad, fieldname,po, mult)
% directions \= po.directions;
% colors \= po.colors;
% existsAndDefault('mult', 1\);
% q \= zeros(size(ad.txc));
% for j \= 1:length(ad.txc)
% \[\~,I] \= max(cosd(directions).\*cosd(ad.txc(j)) \+ sind(directions).\*sind(ad.txc(j)));
% q(j) \= I;
% end
% 
% yd \= mult\*ad.(fieldname)(\[1:end 1]);
% ebd \= mult\*ad.(\[fieldname '\_eb'])(\[1:end 1]);
% 
% 
% for j \= 1:(length(ad.txc) \- 1\)
% xdata \= interp1(ad.txc, \[j j\+0\.5]);
% ydata \= interp1(yd, \[j j\+0\.5]);
% plot (xdata, ydata, 'k\-', 'Color',colors{q(j)}, 'LineWidth', po.lineWidth, po.plotOptions{:}); hold on;
% xdata \= interp1(ad.txc, \[j\+0\.5 j\+1]);
% ydata \= interp1(yd, \[j\+0\.5 j\+1]);
% plot (xdata, ydata, 'k\-', 'Color',colors{q(j\+1\)}, 'LineWidth', po.lineWidth, po.plotOptions{:}); hold on;
% end
% 
% for j \= 1:length(directions)
% inds \= q \=\= j;
% 
% hhhh(j) \= errorbar (ad.txc(inds), yd(inds), ebd(inds), 'k.', 'Color',colors{j}); hold on;
% % get(hhhh)
% % bob \= get(get(hhhh,'Children'))
% % pause
% end
% set(hhhh, 'Marker', po.marker, 'LineWidth', po.lineWidth, po.plotOptions{:});
% 
% function quadrantGraphReo(ad, fieldname,po, mult)
% %function quadrantGraph(ad, fieldname,po, mult)
% directions \= po.directions;
% colors \= po.colors;
% existsAndDefault('mult', 1\);
% q \= zeros(size(ad.reotxc));
% for j \= 1:length(ad.reotxc)
% \[\~,I] \= max(cosd(directions).\*cosd(ad.reotxc(j)) \+ sind(directions).\*sind(ad.reotxc(j)));
% q(j) \= I;
% end
% 
% yd \= mult\*ad.(fieldname)(\[1:end 1]);
% ebd \= mult\*ad.(\[fieldname '\_eb'])(\[1:end 1]);
% 
% for j \= 1:length(directions)
% inds \= q \=\= j;
% errorbar (ad.reotxc(inds), yd(inds), ebd(inds), 'k.', 'Color',colors{j}, 'Marker', po.marker, 'LineWidth', po.lineWidth, po.plotOptions{:}); hold on;
% end
% 
% for j \= 1:(length(ad.reotxc) \- 1\)
% xdata \= interp1(ad.reotxc, \[j j\+0\.5]);
% ydata \= interp1(yd, \[j j\+0\.5]);
% plot (xdata, ydata, 'k\-', 'Color',colors{q(j)}, 'LineWidth', po.lineWidth, po.plotOptions{:}); hold on;
% xdata \= interp1(ad.reotxc, \[j\+0\.5 j\+1]);
% ydata \= interp1(yd, \[j\+0\.5 j\+1]);
% plot (xdata, ydata, 'k\-', 'Color',colors{q(j\+1\)}, 'LineWidth', po.lineWidth, po.plotOptions{:}); hold on;
% end
\-\-\-

\#\#\# File: calculateStatisticsOfEset.m (ID: MAGATAnalyzer Example Scripts.higher level analysis for spatial gradients.3\)

function eset\_statistics \= calculateStatisticsOfEset(eset, varargin )
%UNTITLED2 Summary of this function goes here
% Detailed explanation goes here

if (length(eset) \> 1\)
 for j \= 1:length(eset)
 es(j) \= calculateStatisticsOfEset(eset(j), varargin{:}); %\#ok
 end
 eset\_statistics \= es;
 return;
end

timerange \= \[];
validname \= \[];
validoperation \= func2str(@(x) logical(setNonFiniteToZero(x)));
directions \= \[0 180 \-90 90];
varargin \= assignApplicable(varargin); %\#ok

if (\~isempty(timerange))
 validname \= 'eti';
 validoperation \= \['@(x) x \>\= ' num2str(min(timerange)) ' \& x \<\= ' num2str(min(timerange)) ];
end
es.validname \= validname;
es.validoperation \= validoperation;
es.directions \= directions;

if (\~isempty(validname) \&\& ischar(validoperation))
 validoperation \= str2func(validoperation);
end

es.directions \= directions;


es.runStartTheta \= eset.gatherSubField ('run', 'startTheta');
es.runEndTheta \= eset.gatherSubField ('run', 'endTheta');
es.runMeanTheta \= eset.gatherSubField('run' ,'meanTheta');

es.reoPrevDir \= eset.gatherSubField ('reorientation', 'prevDir');
es.reoNextDir \= eset.gatherSubField ('reorientation', 'nextDir');
es.reoNumHS \= eset.gatherSubField ('reorientation', 'numHS');

es.headSwingAccepted \= eset.gatherSubField ('headSwing', 'accepted');
es.headSwingPrevDir \= eset.gatherSubField ('headSwing', 'prevDir');
es.firstHeadSwingPrevDir \= eset.gatherSubField ('firsths', 'prevDir');
es.firstHeadSwingAccepted \= eset.gatherSubField ('firsths', 'accepted');
es.lastHeadSwingAccepted \= eset.gatherSubField ('lasths', 'accepted');
es.headSwingValid \= eset.gatherSubField ('headSwing', 'valid');
es.firstHeadSwingValid \= eset.gatherSubField ('firsths', 'valid');
es.lastHeadSwingValid \= eset.gatherSubField ('lasths', 'valid');

if (\~isempty(validname))
 es.runvfield\_start \= eset.gatherFromSubField ('run', validname, 'position', 'start');
 es.runvfield\_end \= eset.gatherFromSubField ('run', validname, 'position', 'end');
 es.reovfield \= eset.gatherFromSubField ('reorientation', validname, 'position', 'start');
 es.hsvfield \= eset.gatherFromSubField ('headSwing', validname, 'position', 'start');
 es.firsthsvfield \= eset.gatherFromSubField ('firsths', validname, 'position', 'start');
 es.lasthsvfield \= eset.gatherFromSubField ('lasths', validname, 'position', 'start');
 
 
 es.runStartValid \= validoperation(es.runvfield\_start);
 es.runEndValid \= validoperation(es.runvfield\_end);
 es.reoValid \= validoperation(es.reovfield);
 es.headSwingValid \= es.headSwingValid \& validoperation(es.hsvfield);
 es.firstHeadSwingValid \= es.firstHeadSwingValid \& validoperation(es.firsthsvfield);
 es.lastHeadSwingValid \= es.lastHeadSwingValid \& validoperation(es.lasthsvfield);
else
 es.runvfield\_start \= \[];
 es.runvfield\_end \= \[];
 es.runStartValid \= true(size(es.runStartTheta));
 es.runEndValid \= true(size(es.runEndTheta));
 es.reoValid \= true(size(es.reoPrevDir));
 
end

eti \= eset.gatherField('eti');
if (isempty(timerange))
 timerange \= \[min(eti)\-1 max(eti)\+1];
end
es.timerange \= timerange;

it \= eset.gatherSubField('dr','interpTime');
dt \= median(it);
if (any(it \~\= dt))
 disp (\['warning: eset does not have homogenous interpolation times, instead range from ' num2str(min(it)) ' to ' num2str(max(it))]);
end

es.maxNumAnimals \= zeros(size(eset.expt));
es.maxNumAnimalsValid \= es.maxNumAnimals;
for j \= 1:length(eset.expt)
 et \= eset.expt(j).gatherField('eti');
 if (\~isempty(validname))
 valid \= validoperation(eset.expt(j).gatherField(validname));
 else
 valid \= true(size(et));
 end

 es.maxNumAnimals(j) \= max(histc(et, min(et):1:max(et)))\*dt;
 es.maxNumAnimalsValid(j) \= max(histc(et(valid), min(et):1:max(et)))\*dt;
end
es.numExpts \= length(eset.expt);
es.numAnimals \= sum(es.maxNumAnimalsValid);
eti \= eset.expt(j).gatherField('eti');
if (\~isempty(validname))
 valid \= validoperation(eset.gatherField(validname));
else
 valid \= true(size(eti));
end
es.animalTime \= nnz(valid)\*dt;

for j \= 1:length(directions)
 
 es.numRunsFromDirection(j) \= nnz(cos(es.runStartTheta \- deg2rad(directions(j))) \> 1/sqrt(2\) \& es.runStartValid);
 es.numRunsInDirection(j) \= nnz(cos(es.runMeanTheta \- deg2rad(directions(j))) \> 1/sqrt(2\) \& es.runStartValid);
 es.numReosFromDirection(j) \= nnz(cos(es.reoPrevDir \- deg2rad(directions(j))) \> 1/sqrt(2\) \& es.reoValid);
 es.numReosWithHSFromDirection(j) \= nnz(cos(es.reoPrevDir \- deg2rad(directions(j))) \> 1/sqrt(2\) \& es.reoValid \& es.reoNumHS \> 0\);
 es.numHSFromDirection(j) \= nnz(cos(es.headSwingPrevDir \- deg2rad(directions(j))) \> 1/sqrt(2\) \& es.headSwingValid);
end
if (\~isempty(es.validoperation) \&\& \~ischar(es.validoperation))
 es.validoperation \= func2str(es.validoperation);
end
eset\_statistics \= es;


\-\-\-

\#\#\# File: simpleMetricFigure.m (ID: MAGATAnalyzer Example Scripts.higher level analysis for spatial gradients.4\)

function simpleMetricFigure(ad, expname, baselinead, baselinename, varargin)
%function simpleMetricFigure(ad, expname, baselinead, baselinename, varargin)


fignum \= 1;

font \= 'Arial';
fontsize \= 9;
bigfontsize \= 16;
navindylim \= 0\.5;
runfracylim \= 0\.5;
runlenylim \= 1\.5;
runtimeylim \= 40;
speedylim \= 5;
lengthylim \= 4;
numhsylim \= 3;
linewidth \= 1;

varargin \= assignApplicable(varargin);


hasbaseline \= existsAndDefault('baselinead', \[]);
existsAndDefault('baselinename', 'baseline');
f \= figure(fignum);
clf(f);
ss \= get(0, 'ScreenSize');

screenwidth \= ss(3\); screenheight \= ss(4\);
figratio \= 8/10;
r \= 0\.8;
figheight \= screenheight\*r;
figwidth \= figheight\*figratio;
figpos \= round(\[max((screenwidth \- 2\*figwidth)/3,0\), (screenheight\-figheight)/2, figwidth, figheight]);
 
set(f, 'Position', figpos);
get(f, 'Position'); %calling get f,position here prevents a weird bug where text is incorrectly spaced later
% 
% if (\~all(get(f,'Position') \=\= figpos))
% rerun \= false;
% else
% rerun \= false;
% end
%get(f, 'Position')
set(f, 'PaperType', 'usletter', 'PaperPosition', \[0\.25 0\.25 8 10], 'PaperOrientation', 'portrait', 'color', 'w', 'inverthardcopy', 'off');
%get(f, 'Position')

allaxeswidth \= 0\.92;
allaxesheight \= 0\.99;
dw \= (1 \- allaxeswidth)/2;
dh \= (1 \- allaxesheight)/2;
spacing \= 0\.04\*allaxesheight;

w \= 1 \* allaxeswidth;
h \= 0\.1 \* allaxesheight;

textaxespos \= \[dw 1\-dh\-h w h];
textaxes \= axes('Position', textaxespos, 'Box', 'Off', 'XLim', \[0 1], 'YLim', \[\-1 0], 'XTick', \[], 'YTick', \[]);
axis(textaxes, 'off');

existsAndDefault('expname', 'Experiment Summary');
expname(expname \=\= '\_') \= '\-';
if (hasbaseline)
 expname \= \[expname ' {\\color{blue}(baseline \= ' baselinename ')}'];
end
t1 \= text(0,0, expname, 'FontName', font, 'FontSize', bigfontsize\+2, 'FontWeight', 'bold', 'HorizontalAlignment', 'left', 'VerticalAlignment', 'top', 'Parent', textaxes, 'Interpreter', 'Tex');
p \= get(t1, 'Extent');
t2 \= text(0,p(2\), ad.summary\_message, 'FontName', font, 'FontSize', bigfontsize\-2, 'HorizontalAlignment', 'left', 'VerticalAlignment', 'top', 'Parent', textaxes);

w \= 0\.45 \* allaxeswidth;
h \= 0\.2 \* allaxesheight;
bardat \= \[ad.navind ad.navind\_expt];
ebdat \= \[ad.navind\_eb ad.navind\_expt\_eb];

gnames \= \['all' cellfun(@(x) \['exp ' num2str(x)], num2cell(1:length(ad.navind\_expt)), 'UniformOutput', false)];
if (hasbaseline)
 bardat \= \[bardat baselinead.navind];
 ebdat \= \[ebdat baselinead.navind\_eb];
 gnames \= \[gnames 'baseline'];
end

parnavaxespos \= \[dw textaxespos(2\)\-h\-spacing w h];
parnavaxes \= axes('Position', parnavaxespos, 'Box', 'Off','FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
hhh \= barweb\_marc(bardat(1,:)', ebdat(1,:)', 0\.8, gnames);
%th \= rotateticklabel(hhh.ax, 20\);
%get(hhh.ax)
set(hhh.ax, 'FontSize', fontsize, 'FontName', font, 'YLim', \[\-navindylim navindylim], 'Box', 'off', 'LineWidth', linewidth);
if (length(bardat) \> 6\)
 if (hasebaseline)
 set(hhh.ax, 'XTick', \[1 length(bardat)/2 length(bardat)], 'XTickLabel', {'all', 'individual experiments', 'baseline'});
 else
 set(hhh.ax, 'XTick', \[1 length(bardat)/2], 'XTickLabel', {'all', 'individual experiments'});
 end
end

set(hhh.bars(1\), 'FaceColor', \[0\.4 0\.4 0\.4], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
set(hhh.bars(2:end), 'FaceColor', \[0\.7 0\.7 0\.7], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
if (hasbaseline)
 set(hhh.bars(end), 'FaceColor', \[0 0 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
end

xl \= get(parnavaxes, 'Xlim'); yl \= get(parnavaxes, 'YLim');
text (mean(xl), max(yl), \['Navigation Index towards ' num2str(ad.sno.preferredDirection) '$^{\\circ}$'], 'Interpreter', 'Latex', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle', 'FontWeight', 'bold');



perpnavaxespos \= \[1\-dw\-w textaxespos(2\)\-h\-spacing w h];
perpnavaxes \= axes('Position', perpnavaxespos, 'Box', 'Off','FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
hhh \= barweb\_marc(bardat(2,:)', ebdat(2,:)', 0\.8, gnames);
%th \= rotateticklabel(hhh.ax, 20\);
%get(hhh.ax)
set(hhh.ax, 'FontSize', fontsize, 'FontName', font, 'YLim', \[\-navindylim navindylim], 'Box', 'off', 'LineWidth', linewidth);
if (length(bardat) \> 6\)
 if (hasebaseline)
 set(hhh.ax, 'XTick', \[1 length(bardat)/2 length(bardat)], 'XTickLabel', {'all', 'individual experiments', 'baseline'});
 else
 set(hhh.ax, 'XTick', \[1 length(bardat)/2], 'XTickLabel', {'all', 'individual experiments'});
 end
end
set(hhh.bars(1\), 'FaceColor', \[0\.4 0\.4 0\.4], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
set(hhh.bars(2:end), 'FaceColor', \[0\.7 0\.7 0\.7], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
if (hasbaseline)
 set(hhh.bars(end), 'FaceColor', \[0 0 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
end

xl \= get(perpnavaxes, 'Xlim'); yl \= get(perpnavaxes, 'YLim');
text (mean(xl), max(yl), \['Navigation Index towards ' num2str(mod(ad.sno.preferredDirection \+ 90, 360\)) '$^{\\circ}$'], 'Interpreter', 'Latex', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle', 'FontWeight', 'bold');



w \= 0\.27\*allaxeswidth;
h \= 0\.18\*allaxeswidth;

sm \= ad.simpleMetrics;
gnames \= cellfun(@(x) num2str(x), num2cell(sm.quadrants), 'UniformOutput', false);


pos \= \[dw perpnavaxespos(2\)\-h\-spacing w h];
nrunsaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
bardat \= sm.numRuns/sum(sm.numRuns);
ebdat \= sqrt(bardat.\*(1\-bardat)./sm.numRuns);
hhh \= barweb\_marc(bardat', ebdat', 0\.8, gnames);
set(hhh.bars, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
set(hhh.ax, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 runfracylim], 'Box', 'off', 'LineWidth', linewidth);
xl \= get(nrunsaxes, 'Xlim'); yl \= get(nrunsaxes, 'YLim');
if (hasbaseline)
 hold(nrunsaxes, 'on')
 bardat \= baselinead.simpleMetrics.numRuns/sum(baselinead.simpleMetrics.numRuns);
 ebdat \= sqrt(bardat.\*(1\-bardat)./baselinead.simpleMetrics.numRuns);
 errorbar(nrunsaxes, 1:4, bardat, ebdat, 'b\*', 'LineWidth', linewidth);
 hold(nrunsaxes, 'off');
end
text (mean(xl), max(yl), 'fraction of runs / quadrant', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');


pos \= \[0\.5\-w/2 perpnavaxespos(2\)\-h\-spacing w h];
runlenaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
bardat \= sm.runLen;
ebdat \= sm.runLen\_eb;
hhh \= barweb\_marc(bardat', ebdat', 0\.8, gnames);
set(hhh.bars, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
set(hhh.ax, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 runlenylim], 'Box', 'off', 'LineWidth', linewidth);
xl \= get(runlenaxes, 'Xlim'); yl \= get(runlenaxes, 'YLim');
t1 \= text (mean(xl), max(yl), 'mean run length by quadrant', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
p \= get(t1, 'Extent');
text (mean(xl), p(2\), '(cm)', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'top');
if (hasbaseline)
 hold(runlenaxes, 'on')
 bardat \= baselinead.simpleMetrics.runLen;
 ebdat \= baselinead.simpleMetrics.runLen\_eb;
 errorbar(runlenaxes, 1:4, bardat, ebdat, 'b\*', 'LineWidth', linewidth);
 hold (runlenaxes, 'off');
end

pos \= \[1\-dw\-w perpnavaxespos(2\)\-h\-spacing w h];
rtpos \= pos;
runtimaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
bardat \= sm.runTime;
ebdat \= sm.runTime\_eb;
hhh \= barweb\_marc(bardat', ebdat', 0\.8, gnames);
set(hhh.bars, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
set(hhh.ax, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 runtimeylim], 'Box', 'off', 'LineWidth', linewidth);
xl \= get(runtimaxes, 'Xlim'); yl \= get(runtimaxes, 'YLim');
t1 \= text (mean(xl), max(yl), 'mean run time by quadrant', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
p \= get(t1, 'Extent');
text (mean(xl), p(2\), '(s)', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'top');
if (hasbaseline)
 hold(runtimaxes, 'on')
 bardat \= baselinead.simpleMetrics.runTime;
 ebdat \= baselinead.simpleMetrics.runTime\_eb;
 errorbar(runtimaxes, 1:4, bardat, ebdat, 'b\*', 'LineWidth', linewidth);
 hold (runtimaxes, 'off');
end


pos \= \[dw rtpos(2\)\-h\-spacing w h];
reobiasaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
bardat \= \[sm.prob\_turn\_towards 1\-sm.prob\_turn\_towards];
ebdat \= sm.prob\_turn\_towards\_eb\*\[1 1];
gnames \= {\['to ' num2str(ad.sno.preferredDirection)], \['to ' num2str(mod(ad.sno.preferredDirection \+ 180, 360\))]};
hhh \= barweb\_marc(bardat', ebdat', 0\.8, gnames);
set(hhh.bars, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
set(hhh.ax, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 .8], 'Box', 'off', 'LineWidth', linewidth);
if (hasbaseline)
 hold(reobiasaxes, 'on')
 bardat \= \[baselinead.simpleMetrics.prob\_turn\_towards 1\-baselinead.simpleMetrics.prob\_turn\_towards];
 ebdat \= baselinead.simpleMetrics.prob\_turn\_towards\_eb\*\[1 1];
 errorbar(reobiasaxes, bardat, ebdat, 'b\*', 'LineWidth', linewidth);
 hold (reobiasaxes, 'off');
end
xl \= get(reobiasaxes, 'Xlim'); yl \= get(reobiasaxes, 'YLim');
t1 \= text (mean(xl), max(yl), 'prob turn from perp', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
p \= get(t1, 'Extent');
text (mean(xl), p(2\), 'is to direction', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'top');

pos \= \[0\.5\-w/2 rtpos(2\)\-h\-spacing w h];
runspeedaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
bardat \= \[sm.meanspeed sm.meanrunspeed]\*60;
hhh \= bar(1:2, bardat, 0\.8, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
set(runspeedaxes, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 speedylim], 'Box', 'off','XTick', \[1 2], 'XTickLabel', {'all time', 'in runs'}, 'LineWidth', linewidth);
xl \= get(runspeedaxes, 'Xlim'); yl \= get(runspeedaxes, 'YLim');
t1 \= text (mean(xl), max(yl), 'mean speed', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
p \= get(t1, 'Extent');
text (mean(xl), p(2\), '(cm/min)', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'top');
if (hasbaseline)
 hold(runspeedaxes, 'on')
 bardat \= \[baselinead.simpleMetrics.meanspeed baselinead.simpleMetrics.meanrunspeed]\*60;
 plot(runspeedaxes, 1:2, bardat,'b\*', 'LineWidth', linewidth);
 hold (runspeedaxes, 'off');
end

if (hasbaseline)
 pos \= \[1\-dw\-w rtpos(2\)\-h\-spacing w h];
 rmpos \= pos;
 fracrunsaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
 bardat \= \[sm.pctTimeInRuns\*100 baselinead.simpleMetrics.pctTimeInRuns\*100];
 hhh \= bar(1, bardat(1\), 0\.8, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth); hold on
 hhh(2\) \= bar(2, bardat(2\), 0\.8, 'FaceColor', \[0 0 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth); hold off
 set(fracrunsaxes, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 100], 'Box', 'off','XTick',\[], 'LineWidth', linewidth);
 xl \= get(fracrunsaxes, 'Xlim'); yl \= get(fracrunsaxes, 'YLim');
 t1 \= text (mean(xl), max(yl), 'time in runs', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
 p \= get(t1, 'Extent');
 text (mean(xl), p(2\), '(%)', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'top');
else
 pos \= \[1\-dw\-7\*w/8 rtpos(2\)\-h\-spacing w\*.75 h];
 rmpos \= pos;
 fracrunsaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
 bardat \= sm.pctTimeInRuns\*100;
 hhh \= bar(1, bardat, 0\.8\*2/3, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
 set(fracrunsaxes, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 100], 'Box', 'off','XTick',\[], 'LineWidth', linewidth);
 xl \= get(fracrunsaxes, 'Xlim'); yl \= get(fracrunsaxes, 'YLim');
 t1 \= text (mean(xl), max(yl), 'time in runs', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
 p \= get(t1, 'Extent');
 text (mean(xl), p(2\), '(%)', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'top');
end

if (hasbaseline)
 pos \= \[dw rmpos(2\)\-h\-spacing w h];
 lengthaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
 errorbar(lengthaxes,1, 10\*sm.meanSpineLength, 10\*sm.stdSpineLength, 'ko', 'LineWidth', linewidth); hold (lengthaxes, 'on');
 errorbar(lengthaxes,2, 10\*baselinead.simpleMetrics.meanSpineLength, 10\*baselinead.simpleMetrics.stdSpineLength, 'b\*', 'LineWidth', linewidth); hold (lengthaxes, 'off')
 
 set(lengthaxes, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 lengthylim], 'Box', 'off','XTick',2, 'XTickLabel', 'base', 'LineWidth', linewidth);
 xl \= get(lengthaxes, 'Xlim'); yl \= get(lengthaxes, 'YLim');
 t1 \= text (mean(xl), max(yl), 'larval length', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
 p \= get(t1, 'Extent');
 text (mean(xl), p(2\), '(mm)', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'top');
else
 pos \= \[dw\+w/4 rmpos(2\)\-h\-spacing w/2 h];
 lengthaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
 errorbar(lengthaxes,1, 10\*sm.meanSpineLength, 10\*sm.stdSpineLength, 'ko', 'LineWidth', linewidth); hold (lengthaxes, 'on');

 set(lengthaxes, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 lengthylim], 'Box', 'off','XTick',2, 'XTickLabel', 'base', 'LineWidth', linewidth);
 xl \= get(lengthaxes, 'Xlim'); yl \= get(lengthaxes, 'YLim');
 t1 \= text (mean(xl), max(yl), 'larval length', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
 p \= get(t1, 'Extent');
 text (mean(xl), p(2\), '(mm)', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'top');
end

if (hasbaseline)
 pos \= \[0\.5\-w/2 rmpos(2\)\-h\-spacing w h];
 fracvalaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
 bardat \= \[sm.fractionOfHSMarkedValid\*100 baselinead.simpleMetrics.fractionOfHSMarkedValid\*100];
 hhh \= bar(1, bardat(1\), 0\.8, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth); hold on
 hhh(2\) \= bar(2, bardat(2\), 0\.8, 'FaceColor', \[0 0 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth); hold off
 set(fracvalaxes, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 100], 'Box', 'off','XTick',\[], 'LineWidth', linewidth);
 xl \= get(fracvalaxes, 'Xlim'); yl \= get(fracvalaxes, 'YLim');
 t1 \= text (mean(xl), max(yl), 'HS Validity (%)', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
 
else
 pos \= \[0\.5\-3\*w/8 rmpos(2\)\-h\-spacing w\*.75 h];
 fracvalaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
 bardat \= sm.fractionOfHSMarkedValid\*100;
 hhh \= bar(1, bardat(1\), 0\.8\*2/3, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth);
 
 set(fracvalaxes, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 100], 'Box', 'off','XTick',\[], 'LineWidth', linewidth);
 xl \= get(fracvalaxes, 'Xlim'); yl \= get(fracvalaxes, 'YLim');
 t1 \= text (mean(xl), max(yl), 'HS Validity (%)', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
 
end

if (hasbaseline)
 pos \= \[1\-dw\-w rmpos(2\)\-h\-spacing w h];
 nhsaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
 bardat \= \[sm.meanHSPerReo baselinead.simpleMetrics.meanHSPerReo];
 hhh \= bar(1, bardat(1\), 0\.8, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth); hold on
 hhh(2\) \= bar(2, bardat(2\), 0\.8, 'FaceColor', \[0 0 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth); hold off
 set(nhsaxes, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 numhsylim], 'Box', 'off','XTick',\[], 'LineWidth', linewidth);
 xl \= get(nhsaxes, 'Xlim'); yl \= get(nhsaxes, 'YLim');
 t1 \= text (mean(xl), max(yl), 'Mean HS/Turn', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
else
 pos \= \[1\-dw\-7\*w/8 rmpos(2\)\-h\-spacing 3\*w/4 h];
 nhsaxes \= axes('Position', pos, 'Box', 'Off', 'FontName', font, 'FontSize', fontsize, 'LineWidth', linewidth);
 bardat \= \[sm.meanHSPerReo];
 hhh \= bar(1, bardat(1\), 0\.8\*2/3, 'FaceColor', \[1 1 1], 'EdgeColor', \[0 0 0], 'LineWidth', linewidth); 
 set(nhsaxes, 'FontSize', fontsize, 'FontName', font, 'YLim', \[0 numhsylim], 'Box', 'off','XTick',\[], 'LineWidth', linewidth);
 xl \= get(nhsaxes, 'Xlim'); yl \= get(nhsaxes, 'YLim');
 t1 \= text (mean(xl), max(yl), 'Mean HS/Turn', 'FontName', font, 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
end

\-\-\-

\#\#\# File: spatialMaggotCalculations.m (ID: MAGATAnalyzer Example Scripts.higher level analysis for spatial gradients.5\)

function sc \= spatialMaggotCalculations (eset, spatial\_navigation\_options)
%function sc \= spatialMaggotCalculations (eset,
%spatial\_navigation\_options)
%
% spatial\_navigation\_options \-\- 1 set of options for all esets


sno.angleBinSize \= 30; % in degrees
sno.dtAngleBinSize \= 20; % in degrees
sno.hsdtAngleBinSize \= 20; % in degrees
sno.preferredDirection \= 0;
sno.reoBinSize \= 30;
sno.hsBinSize \= 90;
sno.hsBinSpacing \= 90;
sno.minHS \= 1;
sno.minHSTheta \= 20;
sno.validname \= \[];
sno.relativeDirField \= \[];
sno.dirOffsetField \= \[];
sno.validoperation \= func2str(@(x) logical(setNonFiniteToZero(x)));
sno.confidenceLevel \= 0\.95;
sno.autocorr\_timerange \= \[];
sno.runTimeBinSize \= 10;

if (nargin \=\= 0\)
 if (nargout \>\= 1\)
 sc \= sno;
 end
 %disp ('spatialNavigationMaggotAnalysis (esets, spatial\_navigation\_options)');
 return;
end
existsAndDefault('spatial\_navigation\_options', \[]);

if (length(eset) \> 1\)
 for j \= 1:length(eset)
 disp (\['start ' num2str(j)]); ts1 \= tic;
 sc(j) \= spatialMaggotCalculations\_Janelia(eset(j), spatial\_navigation\_options); %\#ok
 disp (\['end ' num2str(j) ' ' num2str(toc(ts1\)) ' s']);
 end
 return;
end

if (\~isempty(spatial\_navigation\_options) \&\& isstruct(spatial\_navigation\_options))
 fn \= fieldnames(spatial\_navigation\_options);
 for j \= 1:length(fn)
 sno.(fn{j}) \= spatial\_navigation\_options.(fn{j});
 end
end

if (xor(isempty(sno.relativeDirField), isempty(sno.dirOffsetField)))
 disp('relativeDirField \= theta \- dirOffsetField');
 error('you must define both relativeDirField and dirOffsetField or neither');
 return; %\#ok
end

%general statistics of experiment, may be duplicative
sc.eset\_stats \= calculateStatisticsOfEset(eset, 'validname', sno.validname, 'validoperation', sno.validoperation);
sc.autocorr\_tau \= eset.getAutocorrTau;
sc.interptime \= median(eset.gatherSubField('dr', 'interpTime'));
sc.sno \= sno;
if (ischar(sno.validoperation))
 sno.validoperation \= str2func(sno.validoperation);
end
% 
% ad.txf \= \-180:1:180;
% ad.tx \= (\-180:sno.angleBinSize:(180\-sno.angleBinSize)) \+ sno.preferredDirection;
% ad.txc \= (\-180:sno.angleBinSize:(180\)) \+ sno.preferredDirection;
% 
% txrad \= deg2rad(ad.txf);
% bsa \= deg2rad(sno.angleBinSize);
% 

%{

dtx \= (\-180:sno.dtAngleBinSize:(180\-sno.dtAngleBinSize));
dtxc \= (\-180:sno.dtAngleBinSize:180\);

hsdtx \= sort(\[(sno.minHSTheta \- sno.hsdtAngleBinSize/2\):(\-sno.hsdtAngleBinSize):0 (sno.minHSTheta \+ sno.hsdtAngleBinSize/2\):(sno.hsdtAngleBinSize):180]);
hsdtx \= sort(\[\-hsdtx hsdtx]);
%hsdtx \= hsdtxc(1:(end\-1\));
%}

%calculate statistics of runs including change within runs and run length
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-%
rs \= eset.gatherSubField('run', 'startTheta');
re \= eset.gatherSubField('run', 'endTheta');
rt \= eset.gatherSubField('run', 'runTime');
rmt \= eset.gatherSubField('run', 'meanTheta');

dt \= diff(unwrap(\[rs;re]));

sc.runStartTheta \= rs;
sc.runEndTheta \= re;
sc.runTime \= rt;
sc.runMeanTheta \= rmt;
sc.runDeltaTheta \= dt;
sc.runLength \= eset.gatherSubField('run', 'pathLength');
sc.runEuclidLength \= eset.gatherSubField('run', 'euclidLength');
if (\~isempty(sno.validname))
 sc.runvalidField \= (eset.gatherFromSubField('run', sno.validname, 'position', 'start'));
 sc.runvalid \= sno.validoperation(sc.runvalidField);
else
 sc.runvalidField \= \[];
 sc.runvalid \= true(size(sc.runTime));
end


sc.minruntime \= median(eset.gatherSubField('so', 'minRunTime'));


%calculate instantaneous change within runs vs. heading angle
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-%
if(\~isempty(sno.relativeDirField))
 fieldname \= sno.relativeDirField;
else
 fieldname \= 'theta';
end

sc.dir \= eset.gatherField(fieldname); %dir is either theta or gather field
sc.isrun \= eset.gatherField('isrun');
if (\~isempty(sno.validname))
 sc.validField \= (eset.gatherField(sno.validname));
 sc.valid \= sno.validoperation(sc.validField);
else
 sc.validField \= \[];
 sc.valid \= true(size(sc.isrun));
end

for j \= 1:length(eset.expt)
 sc.exp(j).fname \= eset.expt(j).fname;
 sc.exp(j).vel \= eset.expt(j).gatherField('vel'); %dir is either theta or gather field
 sc.exp(j).isrun \= eset.expt(j).gatherField('isrun');
 if (\~isempty(sno.validname))
 sc.exp(j).validField \= (eset.expt(j).gatherField(sno.validname));
 sc.exp(j).valid \= sno.validoperation(sc.exp(j).validField);
 else
 sc.exp(j).validField \= \[];
 sc.exp(j).valid \= true(size(sc.exp(j).isrun));
 end
end

sc.lrdtheta \= eset.gatherField('lrdtheta');
sc.speed \= eset.gatherField('speed');
sc.vel \= eset.gatherField('vel');
sc.numhs \= eset.gatherSubField('reorientation', 'numHS');

if (\~isempty(sno.validname))
 sc.reovalidField \= (eset.gatherFromSubField('reorientation', sno.validname, 'position', 'start'));
 sc.reo\_prevrunvalidField \= (eset.gatherFromSubField('reorientation', sno.validname, 'position', {'prevRun', 'start'}));
 sc.reovalid \= sno.validoperation(sc.reovalidField);
 sc.reo\_prevrunvalid \= sno.validoperation(sc.reo\_prevrunvalidField);
else
 sc.reovalidField \= \[];
 sc.reovalid \= true(size(sc.numhs));
 sc.reo\_prevrunvalidField \= \[];
 sc.reo\_prevrunvalid \= sc.reovalid;
end
if (\~isempty(sno.dirOffsetField))
 sc.reo\_dirOffset \= eset.gatherFromSubField('reorientation', sno.dirOffsetField, 'position', 'mean');
else
 sc.reo\_dirOffset \= zeros(size(sc.numhs));
end
sc.reo\_nextdir \= eset.gatherSubField('reorientation', 'nextDir');
sc.reo\_prevdir \= eset.gatherSubField('reorientation', 'prevDir');
sc.reo\_dtheta \= diff(unwrap(\[sc.reo\_prevdir;sc.reo\_nextdir]));



sc.hs\_taildir \= eset.gatherSubField('headSwing', 'tailDir');
if (\~isempty(sno.dirOffsetField))
 sc.hs\_dirOffset \= eset.gatherFromSubField('headSwing', sno.dirOffsetField, 'position', 'mean');
else
 sc.hs\_dirOffset \= zeros(size(sc.hs\_taildir));
end

sc.hs\_headdir \= eset.gatherSubField('headSwing', 'headDir');
sc.hs\_acc \= eset.gatherSubField('headSwing', 'accepted');
sc.hs\_sign \= eset.gatherSubField('headSwing', 'sign');
sc.hs\_htv \= logical(eset.gatherSubField('headSwing', 'valid'));
sc.hs\_maxtheta \= eset.gatherSubField('headSwing', 'maxTheta');
if (\~isempty(sno.validname))
 sc.hsvalidField \= (eset.gatherFromSubField('headSwing', sno.validname, 'position', 'start'));
 sc.hsvalid \= sno.validoperation(sc.hsvalidField);
else
 sc.hsvalidField \= \[];
 sc.hsvalid \= true(size(sc.hs\_htv));
end
sc.hsnum \= eset.gatherSubField('headSwing', 'num');

eti \= eset.gatherField('eti');
sc.eti \= eti;
sc.reo\_eti \= eset.gatherFromSubField('reorientation', 'eti', 'position', 'start');
sc.hs\_eti \= eset.gatherFromSubField('headSwing', 'eti', 'position', 'start');

% it \= eset.gatherSubField('dr','interpTime');
% sc.delta\_t \= median(it);
% if (any(it \~\= sc.delta\_t))
% disp (\['warning: eset does not have homogenous interpolation times, instead range from ' num2str(min(it)) ' to ' num2str(max(it))]);
% end
%find the time with the most valid animals
tx \= min(eti(sc.valid)):30:max(eti(sc.valid));
h \= hist(eti, tx);
\[\~,I] \= max(h);


sl \= eset.gatherField('spineLength', 'mean');
st \= eset.evaluateTrackExpression('min(track.getDerivedQuantity(''eti''))');
et \= eset.evaluateTrackExpression('max(track.getDerivedQuantity(''eti''))');
sc.spineLengths \= sl(st \<\= tx(I) \& et \> tx(I) \& et\-st \> 30\);

if (isfield(eset.expt(1\).track(1\).dq, 'temperature'))
 sc.temperature \= eset.gatherField('temperature');
 sc.reo\_temperature \= eset.gatherFromSubField('reorientation', 'temperature', 'position', 'start');
 sc.hs\_temperature \= eset.gatherFromSubField('headSwing', 'temperature', 'position', 'start');
end


% 

\-\-\-

\#\#\# File: spatialMaggotAnalysis.m (ID: MAGATAnalyzer Example Scripts.higher level analysis for spatial gradients.6\)

function ad \= spatialMaggotAnalysis (sc, spatial\_navigation\_options)
%function ad \= spatialMaggotAnalysis (sc, spatial\_navigation\_options)
%
% spatial\_navigation\_options \-\- 1 set of options for all esets
% plot\_options \-\- each eset gets its own options
% plot\_options.
% lineWidth \-\- width of lines
% color \-\- color for line and marker
% legendEntry \-\- what to put in legend
% marker \-\- marker 
% plotOptions \-\- additional options to pass to plotting function

sno.angleBinSize \= 30; % in degrees
sno.dtAngleBinSize \= 20; % in degrees
sno.hsdtAngleBinSize \= 20; % in degrees
sno.preferredDirection \= 0;
sno.reoBinSize \= 30;
sno.hsBinSize \= 90;
sno.hsBinSpacing \= 90;
sno.minHS \= 1;
sno.minHSTheta \= 20;
sno.validname \= \[];
sno.relativeDirField \= \[];
sno.dirOffsetField \= \[];
sno.validoperation \= func2str(@(x) logical(setNonFiniteToZero(x)));
sno.confidenceLevel \= 0\.95;
sno.autocorr\_timerange \= \[];
sno.runTimeBinSize \= 10;
sno.useInvalidHeadSweeps \= false;
sno.timeBinSizeForTemporalPlots \= 15; %seconds

if (nargin \=\= 0\)
 if (nargout \>\= 1\)
 ad \= sno;
 end
 %disp ('spatialNavigationMaggotAnalysis (spatialcalcs, spatial\_navigation\_options)');
 return;
end
existsAndDefault('spatial\_navigation\_options', sc(1\).sno);

if (length(sc) \> 1\)
 for j \= 1:length(sc)
 disp (\['start ' num2str(j)]); ts1 \= tic;
 ad(j) \= spatialMaggotAnalysis(sc(j), spatial\_navigation\_options); %\#ok
 disp (\['end ' num2str(j) ' ' num2str(toc(ts1\)) ' s']);
 end
 return;
end

if (\~isempty(spatial\_navigation\_options) \&\& isstruct(spatial\_navigation\_options))
 fn \= fieldnames(spatial\_navigation\_options);
 for j \= 1:length(fn)
 sno.(fn{j}) \= spatial\_navigation\_options.(fn{j});
 end
end

if (xor(isempty(sno.relativeDirField), isempty(sno.dirOffsetField)))
 disp('relativeDirField \= theta \- dirOffsetField');
 error('you must define both relativeDirField and dirOffsetField or neither');
 return; %\#ok
end


ad.sno \= sno;
ad.eset\_stats \= sc.eset\_stats;
ad.summary\_message \= {\[num2str(ad.eset\_stats.numExpts) ' Experiments, ' num2str(round(ad.eset\_stats.numAnimals)), ' animals. Total time \= ' num2str(ad.eset\_stats.animalTime/3600, '%.1f') ...
 ' hours (' num2str(ad.eset\_stats.animalTime/ad.eset\_stats.numAnimals/60, '%.1f') ' min/animal)'], ...
 \[num2str(sum(ad.eset\_stats.numRunsFromDirection)) ' runs, ' num2str(sum(ad.eset\_stats.numReosFromDirection)), ' reorientations (' num2str(sum(ad.eset\_stats.numReosWithHSFromDirection)) ' with at least 1 headsweep)']};


if (ischar(sno.validoperation))
 sno.validoperation \= str2func(sno.validoperation);
end

%simple metrics \-\- 
% average run length to each quadrant
% average run time to each quadrant
% number of runs to each quadrant
% probability of turning towards better direction from perpendicular directions
% average run speed;
% average speed; 
% percent of time in runs
% mean number of headsweeps/reorientation
% fraction of headsweeps marked as valid; 
% mean and std of spinelength

sm.quadrants \= sno.preferredDirection \+ (0:90:270\);
for j \= 1:4
 inds \= cos(sc.runMeanTheta \- deg2rad(sm.quadrants(j))) \> 1/sqrt(2\) \& sc.runvalid;
 sm.numRuns(j) \= nnz(inds);
 sm.runLen(j) \= mean(sc.runLength(inds));
 sm.runLen\_eb(j) \= std(sc.runLength(inds))/sqrt(sm.numRuns(j));
 sm.runTime(j) \= mean(sc.runTime(inds));
 sm.runTime\_eb(j) \= std(sc.runTime(inds))/sqrt(sm.numRuns(j));
end

inds \= sc.reovalid \& sc.numhs \>\= sno.minHS \& abs(cos(sc.reo\_prevdir \- deg2rad(sno.preferredDirection))) \< 1/sqrt(2\);
pd \= sc.reo\_prevdir(inds) \- deg2rad(sno.preferredDirection);
nd \= sc.reo\_nextdir(inds) \- deg2rad(sno.preferredDirection);
towards \= cos(pd) \< cos(nd);
sm.prob\_turn\_towards \= mean(towards);
x \= mean(towards);
n \= length(towards);
sm.prob\_turn\_towards\_eb \= sqrt(x\*(1\-x)/n);

sm.meanrunspeed \= mean(sc.speed(sc.isrun \& sc.valid));
sm.meanspeed \= mean(sc.speed(sc.valid));
sm.pctTimeInRuns \= mean(sc.isrun(sc.valid));
sm.meanHSPerReo \= mean(sc.numhs(sc.reovalid \& sc.numhs \>\= sno.minHS));
sm.fractionOfHSMarkedValid \= mean(sc.hs\_htv(sc.hsvalid));
sm.meanSpineLength \= mean(sc.spineLengths);
sm.stdSpineLength \= std(sc.spineLengths);

ad.simpleMetrics \= sm;

kappa \= sqrt((1 \+ exp(\-sc.interptime/sc.autocorr\_tau))/(1 \- exp(\-sc.interptime/sc.autocorr\_tau)));

ad.txf \= \-180:1:180;
ad.tx \= (\-180:sno.angleBinSize:(180\-sno.angleBinSize)) \+ sno.preferredDirection;
ad.txc \= (\-180:sno.angleBinSize:(180\)) \+ sno.preferredDirection;

txrad \= deg2rad(ad.txf);
bsa \= deg2rad(sno.angleBinSize);

rs \= sc.runStartTheta(sc.runvalid);
rt \= sc.runTime(sc.runvalid);
dt \= diff(unwrap(\[sc.runStartTheta;sc.runEndTheta]));
dt \= dt(sc.runvalid);

\[\~,my, se] \= meanyvsx\_slidingwindow(rs, dt, txrad, bsa, 'step', true);
ad.meanrunchange\_step \= my;
ad.meanrunchange\_step\_eb \= se;
\[\~,my, se] \= meanyvsx\_slidingwindow(rs, dt, txrad, bsa, 'gaussian', true);
ad.meanrunchange\_gauss \= my;
ad.meanrunchange\_gauss\_eb \= se;

\[\~,my, se] \= meanyvsx\_slidingwindow(rs, dt.^2, txrad, bsa, 'step', true);
ad.magrunchange\_step \= my;
ad.magrunchange\_step\_eb \= se;
\[\~,my, se] \= meanyvsx\_slidingwindow(rs, dt.^2, txrad, bsa, 'gaussian', true);
ad.magrunchange\_gauss \= my;
ad.magrunchange\_gauss\_eb \= se;


\[\~,my, se] \= meanyvsx\_slidingwindow(rs, dt.^2\./rt, txrad, bsa, 'step', true);
ad.diffconstrunchange\_step \= my;
ad.diffconstrunchange\_step\_eb \= se;
\[\~,my, se] \= meanyvsx\_slidingwindow(rs, dt.^2\./rt, txrad, bsa, 'gaussian', true);
ad.diffconstrunchange\_gauss \= my;
ad.diffconstrunchange\_gauss\_eb \= se;





rt \= sc.runTime(sc.runvalid);
rmt \= sc.runMeanTheta(sc.runvalid);
ad.runTimeAxis \= sc.minruntime \+ (sno.runTimeBinSize/2\)\+ (0:sno.runTimeBinSize:(sno.runTimeBinSize\*ceil(600/sno.runTimeBinSize)));
rth \= hist(rt(cos(rmt \- deg2rad(sno.preferredDirection)) \> 1/sqrt(2\)), ad.runTimeAxis);
ad.runTimeHistTowards \= (rth/sum(rth));
ad.runTimeHistTowards\_eb \= sqrt((rth/sum(rth)).\*(1\-(rth/sum(rth)))./sum(rth));
rth \= hist(rt(\-cos(rmt \- deg2rad(sno.preferredDirection)) \> 1/sqrt(2\)), ad.runTimeAxis);
ad.runTimeHistAway \= (rth/sum(rth));
ad.runTimeHistAway\_eb \= sqrt((rth/sum(rth)).\*(1\-(rth/sum(rth)))./sum(rth));


th \= sc.dir(sc.isrun \& sc.valid);
dth \= sc.lrdtheta(sc.isrun \& sc.valid);
\[\~,my,se] \= meanyvsx\_slidingwindow(th, dth, txrad, bsa, 'step', true);
ad.instantaneousdthetavstheta\_step \= my;
ad.instantaneousdthetavstheta\_step\_eb \= se\*kappa;

\[\~,my,se] \= meanyvsx\_slidingwindow(th, dth, txrad, bsa, 'gaussian', true);
ad.instantaneousdthetavstheta\_gauss \= my;
ad.instantaneousdthetavstheta\_gauss\_eb \= se\*kappa;

sp \= sc.speed(sc.isrun \& sc.valid);
\[\~,my,se] \= meanyvsx\_slidingwindow(th, sp, txrad, bsa, 'step', true);
ad.speedVsDir\_step \= my;
ad.speedVsDir\_step\_eb \= se\*kappa;

\[\~,my,se] \= meanyvsx\_slidingwindow(th, sp, txrad, bsa, 'gaussian', true);
ad.speedVsDir\_gauss \= my;
ad.speedVsDir\_gauss\_eb \= se\*kappa;

%speedVsDir \= my;
%speedVsDir\_eb \= se;



%calculate navigation index for eset as a whole and for individual
%experiments
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-%

v \= \[sc.exp.vel];
v \= v(:,\[sc.exp.valid]);
M \= \[cosd(sno.preferredDirection) sind(sno.preferredDirection); \-sind(sno.preferredDirection) cosd(sno.preferredDirection)];
v \= M\*v;
s \= sqrt(sum(v.^2\));
ad.navind \= mean(v,2\)/mean(s);
ad.navind\_eb \= kappa\*std(v,0,2\)/mean(s)/sqrt(length(s));

for k \= 1:length(sc.exp)
 v \= sc.exp(k).vel;
 v \= v(:,sc.exp(k).valid);
 M \= \[cosd(sno.preferredDirection) sind(sno.preferredDirection); \-sind(sno.preferredDirection) cosd(sno.preferredDirection)];
 v \= M\*v;
 s \= sqrt(sum(v.^2\));
 ad.navind\_expt(:,k) \= mean(v,2\)/mean(s);
 ad.navind\_expt\_eb(:,k) \= kappa\*std(v,0,2\)/mean(s)/sqrt(length(s));
end


v \= \[sc.exp.vel];
v \= v(:,\[sc.exp.valid] \& \[sc.exp.isrun]);
M \= \[cosd(sno.preferredDirection) sind(sno.preferredDirection); \-sind(sno.preferredDirection) cosd(sno.preferredDirection)];
v \= M\*v;
s \= sqrt(sum(v.^2\));
ad.navind\_run \= mean(v,2\)/mean(s);
ad.navind\_run\_eb \= kappa\*std(v,0,2\)/mean(s)/sqrt(length(s));

for k \= 1:length(sc.exp)
 v \= sc.exp(k).vel;
 v \= v(:,sc.exp(k).valid\&sc.exp(k).isrun);
 M \= \[cosd(sno.preferredDirection) sind(sno.preferredDirection); \-sind(sno.preferredDirection) cosd(sno.preferredDirection)];
 v \= M\*v;
 s \= sqrt(sum(v.^2\));
 ad.navind\_run\_expt(:,k) \= mean(v,2\)/mean(s);
 ad.navind\_run\_expt\_eb(:,k) \= kappa\*std(v,0,2\)/mean(s)/sqrt(length(s));
end

%calculate histogram of instantaneous direction
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-%

data \= adjustForPolarHistogram(sc.dir(sc.isrun \& sc.valid), deg2rad(ad.tx));
h \= hist(data(isfinite(data)), deg2rad(ad.tx));
n \= sum(h);
eb \= kappa\*sqrt((h/n).\*(1\-h/n))\*sqrt(n);
ad.thetahist\_eb \= eb/n;
ad.thetahist \= h/n;


%calculate reorientation rate vs. direction
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-%

h1 \= histc(adjustForPolarHistogram(sc.reo\_prevdir(sc.reovalid \& sc.numhs \>\= sno.minHS) \- sc.reo\_dirOffset(sc.reovalid \& sc.numhs \>\= sno.minHS), deg2rad(ad.tx)),binEdgesFromCenters(deg2rad(ad.tx)));
h2 \= histc(adjustForPolarHistogram(sc.dir(sc.isrun \& sc.valid), deg2rad(ad.tx)),binEdgesFromCenters(deg2rad(ad.tx)));
h1 \= h1(1:(end\-1\));
h2 \= h2(1:(end\-1\));

ad.reohist \= h1\./h2 \* 60/sc.interptime;
ad.reohist\_eb \= sqrt(h1\)./h2 \* 60/sc.interptime;


%calculate statistics of reorientations
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
ad.reobasedirections \= \[mod(sno.preferredDirection \+ 180, 360\) \- 180, mod(sno.preferredDirection, 360\) \- 180, mod(sno.preferredDirection \+ 270, 360\) \- 180, mod(sno.preferredDirection \+ 90, 360\) \- 180];

ad.reotx \= (\-180:sno.reoBinSize:(180\-sno.reoBinSize)) \+ sno.preferredDirection;
ad.reotxc \= (\-180:sno.reoBinSize:(180\)) \+ sno.preferredDirection;


reo\_prevdir \= sc.reo\_prevdir(sc.reovalid \& sc.numhs \>\= sno.minHS);
reo\_nextdir \= sc.reo\_nextdir(sc.reovalid \& sc.numhs \>\= sno.minHS);
reo\_dtheta \= sc.reo\_dtheta(sc.reovalid \& sc.numhs \>\= sno.minHS);
nhs \= sc.numhs(sc.reovalid \& sc.numhs \>\= sno.minHS);

nd \= adjustForPolarHistogram(reo\_nextdir, deg2rad(ad.tx)); 
runStartDirectionHist \= hist(nd, deg2rad(ad.tx));
h \= runStartDirectionHist;
n \= sum(h);

ad.runStartDirectionHist\_eb \= sqrt(h/n).\*sqrt(1\-h/n).\*sqrt(n) ./ sum(runStartDirectionHist);
ad.runStartDirectionHist \= runStartDirectionHist./sum(runStartDirectionHist);
 
%calculate distributions of reorientations for given previous headings
topref \= cos(reo\_prevdir \- deg2rad(sno.preferredDirection)) \> 1/sqrt(2\);
frompref \= cos(reo\_prevdir \- deg2rad(sno.preferredDirection)) \< \-1/sqrt(2\);
leftofpref \= sin(reo\_prevdir \- deg2rad(sno.preferredDirection)) \> 1/sqrt(2\);
rightofpref \= sin(reo\_prevdir \- deg2rad(sno.preferredDirection)) \< \-1/sqrt(2\);

indset \= {topref, frompref, leftofpref, rightofpref};


ad.dtx \= (\-180:sno.dtAngleBinSize:(180\-sno.dtAngleBinSize));
ad.dtxc \= (\-180:sno.dtAngleBinSize:180\);


dt \= adjustForPolarHistogram(reo\_dtheta, deg2rad(ad.dtx)); 
for j \= 1:length(indset)
 ad.reo\_dtheta\_dist\_hs{j} \= hist(dt(indset{j} \& nhs \> 0\), deg2rad(ad.dtx));
 ad.reo\_dtheta\_dist\_hs\_eb{j} \= sqrt(ad.reo\_dtheta\_dist\_hs{j}.\*(1\-ad.reo\_dtheta\_dist\_hs{j}/nnz(indset{j} \& nhs \> 0\)));
 ad.reo\_dtheta\_dist\_nohs{j} \= hist(dt(indset{j} \& nhs \=\= 0\), deg2rad(ad.dtx));
 ad.reo\_dtheta\_dist\_nohs\_eb{j} \= sqrt(ad.reo\_dtheta\_dist\_nohs{j}.\*(1\-ad.reo\_dtheta\_dist\_nohs{j}/nnz(indset{j} \& nhs \=\= 0\)));
end

%calculate mean reorientation magnitude, direction, and number of head sweeps vs. previous heading

\[\~,my,se] \= meanyvsx\_slidingwindow(reo\_prevdir, reo\_dtheta.^2, txrad, deg2rad(sno.reoBinSize), 'step', true);
ad.reoMag\_step \= my;
ad.reoMag\_step\_eb \= se; 
\[\~,my,se] \= meanyvsx\_slidingwindow(reo\_prevdir, reo\_dtheta.^2, txrad, deg2rad(sno.reoBinSize), 'gaussian', true);
ad.reoMag\_gauss \= my;
ad.reoMag\_gauss\_eb \= se; 


\[\~,my,se] \= meanyvsx\_slidingwindow(reo\_prevdir, reo\_dtheta, txrad, deg2rad(sno.reoBinSize), 'step', true);
ad.reoDir\_step \= my;
ad.reoDir\_step\_eb \= se; 
\[\~,my,se] \= meanyvsx\_slidingwindow(reo\_prevdir, reo\_dtheta, txrad, deg2rad(sno.reoBinSize), 'gaussian', true);
ad.reoDir\_gauss \= my;
ad.reoDir\_gauss\_eb \= se; 

\[\~,my,se] \= meanyvsx\_slidingwindow(reo\_prevdir, nhs, txrad, deg2rad(sno.reoBinSize), 'step', true);
ad.meanNumHS\_step \= my;
ad.meanNumHS\_step\_eb \= se; 
\[\~,my,se] \= meanyvsx\_slidingwindow(reo\_prevdir, nhs, txrad, deg2rad(sno.reoBinSize), 'gaussian', true);
ad.meanNumHS\_gauss \= my;
ad.meanNumHS\_gauss\_eb \= se; 

%create similar distributions to reorientations but within runs instead
runStartTheta \= sc.runStartTheta(sc.runvalid);
runEndTheta \= sc.runEndTheta(sc.runvalid);
topref \= cos(runStartTheta \- deg2rad(sno.preferredDirection)) \> 1/sqrt(2\);
frompref \= cos(runStartTheta \- deg2rad(sno.preferredDirection)) \< \-1/sqrt(2\);
leftofpref \= sin(runStartTheta \- deg2rad(sno.preferredDirection)) \> 1/sqrt(2\);
rightofpref \= sin(runStartTheta \- deg2rad(sno.preferredDirection)) \< \-1/sqrt(2\);

indset \= {topref, frompref, leftofpref, rightofpref};

dt \= diff(unwrap(\[runStartTheta;runEndTheta]));
dt \= adjustForPolarHistogram(dt, deg2rad(ad.dtx)); 
for j \= 1:length(indset)
 ad.run\_dtheta\_dist{j} \= hist(dt(indset{j}), deg2rad(ad.dtx));
 ad.run\_dtheta\_dist\_eb{j} \= sqrt(ad.run\_dtheta\_dist{j}.\*(1\-ad.run\_dtheta\_dist{j}/nnz(indset{j}))); 
end


%on to head sweeps

ad.hstx \= (\-180:sno.hsBinSpacing:(180\-sno.hsBinSpacing)) \+ sno.preferredDirection;
ad.hstxc \= (\-180:sno.hsBinSpacing:(180\)) \+ sno.preferredDirection;
hstx \= ad.hstx;
%hstxc \= ad.hstxc;
hstxe \= ad.hstxc \- sno.hsBinSpacing/2;
hbw \= sno.hsBinSize/2;

hsinds \= sc.hsvalid \& (sc.hs\_htv \| sno.useInvalidHeadSweeps) \& abs(sc.hs\_maxtheta) \> deg2rad(sno.minHSTheta);
hstail \= sc.hs\_taildir(hsinds);
hshead \= sc.hs\_headdir(hsinds);
hsoffset \= sc.hs\_dirOffset(hsinds);
hsacc \= sc.hs\_acc(hsinds);
hsmt \= sc.hs\_maxtheta(hsinds);
hssign \= sc.hs\_sign(hsinds);

hstail \= diff(unwrap(\[hsoffset;hstail]));
hshead \= diff(unwrap(\[hsoffset;hshead]));

toleft \= logical(hssign \> 0\);
toright \= logical(hssign \< 0\);
tdeg \= rad2deg(hstail);
tdeg \= mod(tdeg, 360\);
tdeg (tdeg \> max(hstxe)) \= tdeg(tdeg \> max(hstxe)) \- 360;
tdeg (tdeg \< min(hstxe)) \= tdeg(tdeg \< min(hstxe)) \+ 360;




%\[\~,bin] \= histc(tdeg, hstxe);
bin \= \-ones(size(tdeg));
for k \= 1:length(hstx)
 bin(tdeg \>\= hstx(k)\-hbw \& tdeg \<\= hstx(k)\+hbw) \= k;
end
towards \= cos(deg2rad(sno.preferredDirection) \- hshead) \> cos(deg2rad(sno.preferredDirection) \- hstail);
\[\~,my,se] \= meanyvsx(adjustForPolarHistogram(hstail,deg2rad(hstx)), double(toleft), deg2rad(hstxe));
 
ad.allHSDir \= my;
ad.allHSDir\_eb \= se;
for k \= 1:length(hstx)
 
 ad.headSwingAcceptanceRateRight(k) \= mean(hsacc(bin \=\= k \& toright));
 ad.headSwingAcceptanceRateRight\_eb(k) \= sqrt(ad.headSwingAcceptanceRateRight(k) \* (1\-ad.headSwingAcceptanceRateRight(k))) / sqrt(nnz(bin \=\=k \& toright));

 ad.headSwingAcceptanceRateLeft(k) \= mean(hsacc(bin \=\= k \& toleft));
 ad.headSwingAcceptanceRateLeft\_eb(k) \= sqrt(ad.headSwingAcceptanceRateLeft(k) \* (1\-ad.headSwingAcceptanceRateLeft(k))) / sqrt(nnz(bin \=\=k \& toleft));

 ad.headSwingRejectionBiasRight(k) \= nnz(\~hsacc(bin \=\= k \& toright))/nnz(\~hsacc(bin \=\= k)) / mean(toright(bin \=\= k));
 ad.headSwingRejectionBiasRight\_eb(k) \= sqrt(nnz(\~hsacc(bin \=\= k \& toright)))/nnz(\~hsacc(bin \=\= k)) / mean(toright(bin \=\= k)); %this is a kludge for now
 
 ad.headSwingRejectionBiasLeft(k) \= nnz(\~hsacc(bin \=\= k \& toleft))/nnz(\~hsacc(bin \=\= k)) / mean(toleft(bin \=\= k));
 ad.headSwingRejectionBiasLeft\_eb(k) \= sqrt(nnz(\~hsacc(bin \=\= k \& toleft)))/nnz(\~hsacc(bin \=\= k)) / mean(toleft(bin \=\= k)); %this is a kludge for now
 
 ad.meanRejectedHeadSwingDir(k) \= mean(hsmt(bin \=\= k \& \~hsacc));
 ad.meanRejectedHeadSwingDir\_eb(k) \= std(hsmt(bin \=\= k \& \~hsacc))/sqrt(nnz(bin \=\= k \& \~hsacc));

 ad.meanAcceptedHeadSwingDir(k) \= mean(hsmt(bin \=\= k \& hsacc));
 ad.meanAcceptedHeadSwingDir\_eb(k) \= std(hsmt(bin \=\= k \& hsacc))/sqrt(nnz(bin \=\= k \& hsacc));
end

perp \= abs(sind(sno.preferredDirection \- tdeg)) \> cosd(hbw);

ad.headSwingAcceptanceRateTowards \= mean(hsacc(perp \& towards));
ad.headSwingAcceptanceRateTowards\_eb \= sqrt(ad.headSwingAcceptanceRateTowards \* (1\-ad.headSwingAcceptanceRateTowards)) / sqrt(nnz(perp \& towards));

ad.headSwingAcceptanceRateAway \= mean(hsacc(perp \& \~towards));
ad.headSwingAcceptanceRateAway\_eb \= sqrt(ad.headSwingAcceptanceRateAway \* (1\-ad.headSwingAcceptanceRateAway)) / sqrt(nnz(perp \& \~towards));

ad.headSwingAcceptanceRateIndex \= (ad.headSwingAcceptanceRateTowards \- ad.headSwingAcceptanceRateAway)/(ad.headSwingAcceptanceRateTowards \+ ad.headSwingAcceptanceRateAway);
ad.headSwingAcceptanceRateIndex\_eb \= sqrt(var(hsacc(perp \& towards)) \* nnz(perp \& towards) \+ var(hsacc(perp \& \~towards)) \* nnz(perp \& \~towards))/nnz(perp)/(ad.headSwingAcceptanceRateTowards \+ ad.headSwingAcceptanceRateAway);




%repeat head sweep analysis, but only for first head sweeps

hsinds \= sc.hsvalid \& (sc.hs\_htv \| sno.useInvalidHeadSweeps) \& abs(sc.hs\_maxtheta) \> deg2rad(sno.minHSTheta) \& sc.hsnum \=\= 1;
hstail \= sc.hs\_taildir(hsinds);

hshead \= sc.hs\_headdir(hsinds);
hsoffset \= sc.hs\_dirOffset(hsinds);
hsacc \= sc.hs\_acc(hsinds);
hsmt \= sc.hs\_maxtheta(hsinds);
hssign \= sc.hs\_sign(hsinds);

hstail \= diff(unwrap(\[hsoffset;hstail]));
hshead \= diff(unwrap(\[hsoffset;hshead]));

toleft \= logical(hssign \> 0\);
%toright \= logical(hssign \< 0\);
tdeg \= rad2deg(hstail);
tdeg \= mod(tdeg, 360\);
tdeg (tdeg \> max(hstxe)) \= tdeg(tdeg \> max(hstxe)) \- 360;
tdeg (tdeg \< min(hstxe)) \= tdeg(tdeg \< min(hstxe)) \+ 360;



%\[\~,bin] \= histc(tdeg, hstxe);
bin \= \-ones(size(tdeg));
for k \= 1:length(hstx)
 bin(tdeg \>\= hstx(k)\-hbw \& tdeg \<\= hstx(k)\+hbw) \= k;
end
 
towards \= cos(deg2rad(sno.preferredDirection) \- hshead) \> cos(deg2rad(sno.preferredDirection) \- hstail);

td \= adjustForPolarHistogram(hstail, deg2rad(hstx));
\[\~,my,se] \= meanyvsx(td, towards, deg2rad(hstxe));
ad.firstHSBias \= my;
ad.firstHSBias\_eb \=se;
\[\~,my,se] \= meanyvsx(td, toleft, deg2rad(hstxe));
ad.firstHSDir \= my;
ad.firstHSDir\_eb \= se;

\[\~,my,se] \= meanyvsx(td, hsmt, deg2rad(hstxe));
ad.firstHSMeanDir \= my;
ad.firstHSMeanDir\_eb \= se;


perp \= abs(sind(sno.preferredDirection \- tdeg)) \> cosd(hbw);

ad.firstHSProbTowards \= mean(towards(perp));
x \= mean(towards(perp));
n \= nnz(perp);
ad.firstHSProbTowards\_eb \= sqrt(x\*(1\-x)/n);


fn \= {'meanrunchange','instantaneousdthetavstheta', 'instantaneousdthetavstheta', 'speedVsDir'};
tx \= ad.tx;
for j \= 1:length(fn)
 yd \= ad.(\[fn{j} '\_step']);
 eb \= ad.(\[fn{j} '\_step\_eb']);
 inds \= zeros(size(tx));
 for k \= 1:length(tx)
 \[\~,I] \= min(abs(ad.txf \- tx(k)));
 inds(k) \= I;
 end
 ad.(fn{j}) \= yd(inds);
 ad.(\[fn{j} '\_eb']) \= eb(inds);
end
fn \= {'reoMag','reoDir','meanNumHS'};
tx \= ad.reotx;
for j \= 1:length(fn)
 yd \= ad.(\[fn{j} '\_step']);
 eb \= ad.(\[fn{j} '\_step\_eb']);
 inds \= zeros(size(tx));
 for k \= 1:length(tx)
 \[\~,I] \= min(abs(ad.txf \- tx(k)));
 inds(k) \= I;
 end
 ad.(fn{j}) \= yd(inds);
 ad.(\[fn{j} '\_eb']) \= eb(inds);
end
if (isfield(sc, 'eti'))
 ad.time\_axis \= (min(sc.eti(sc.valid))\+sno.timeBinSizeForTemporalPlots/2\):sno.timeBinSizeForTemporalPlots:(max(sc.eti(sc.valid))\-sno.timeBinSizeForTemporalPlots/2\);
 txedg \= \[ad.time\_axis\-sno.timeBinSizeForTemporalPlots/2 ad.time\_axis(end)\+sno.timeBinSizeForTemporalPlots/2];
 \[\~,ad.speed\_vs\_time,se] \= meanyvsx(sc.eti(sc.valid), sc.speed(sc.valid), txedg);
 ad.speed\_vs\_time\_eb \= kappa\*se;
 
 \[\~,ad.speed\_inruns\_vs\_time,se] \= meanyvsx(sc.eti(sc.valid\&sc.isrun), sc.speed(sc.valid\&sc.isrun), txedg);
 ad.speed\_inruns\_vs\_time\_eb \= kappa\*se;
 
 h1 \= histc(sc.reo\_eti(sc.reovalid \& sc.numhs \>\= 1\), txedg);
 h2 \= histc(sc.eti(sc.valid), txedg);
 
 h2 \= h2(1:end\-1\) \* sc.interptime / 60;
 h1 \= h1(1:end\-1\);
 ad.reo\_vs\_time \= h1\./h2;
 ad.reo\_vs\_time\_eb \= sqrt(h1\)./h2;
 if (isfield(sc, 'temperature'))
 \[\~,ad.temperature\_vs\_time] \= meanyvsx(sc.eti(sc.valid), sc.temperature(sc.valid), txedg);
 end
end



\-\-\-

\#\#\# Folder: utility functions (ID: utility functions)

\-\-\-

\#\#\# File: getCommonPath.m (ID: utility functions.1\)

function \[commonpath, p1residual, p2residual] \= getCommonPath (p1, p2\)
%function commonpath \= getCommonPath (p1, p2\)
%
%p1 \= 'c:\\foo\\bar\\foobar\\yourmom\\bob.rob'
%p2 \= 'c:\\foo\\bar\\foobar\\mymom\\bob.rob'
%commonpath \= 'c:\\foo\\bar\\foobar'

if (\~any(p1 \=\= '.'))
 p1 \= fullfile(p1, '.');
end
if (\~any(p2 \=\= '.'))
 p2 \= fullfile(p2, '.');
end


f1 \= java.io.File(p1\);
f2 \= java.io.File(p2\);

p1 \= char(f1\.getCanonicalPath);
p2 \= char(f2\.getCanonicalPath);

c1 \= pathToCellOfStrings(p1\);
c2 \= pathToCellOfStrings(p2\);

minl \= min(length(c1\), length(c2\));
cc1 \= c1(1:minl);
cc2 \= c2(1:minl);

tf \= strcmpi(cc1, cc2\);
if (all(tf))
 ind \= length(tf);
else
 ind \= find(\~strcmpi(c1, c2\), 1, 'first') \- 1;
end

commonpath \= fullfile(c1{1:(ind)});
if (ind \=\= length(c1\))
 p1residual \= \[];
else
 p1residual \= fullfile(c1{(ind\+1\):end});
end
if (ind \=\= length(c2\))
 p2residual \= \[];
else
 p2residual \= fullfile(c2{(ind\+1\):end});
end

\-\-\-

\#\#\# File: addTemperatureToExperiment.m (ID: utility functions.2\)

function addTemperatureToExperiment(expt, varargin)
%function addTemperatureToExperiment(expt, varargin)
%
% expt \< Experiment
% optional arguments:
% 'tmpfname' \- the name of the .tmp file; default is to use the
% expt.fname with the extension changed to .tmp
% 'tmpchannel' \- the channel number of the temperature sensor (0 \-
% 15\) \- default is to show a graph and allow the user to enter

if length(expt) \> 1
 for j \= 1:length(expt)
 addTemperatureToExperiment(expt(j), varargin{:});
 end
 return;
end

\[pathstr,name] \= fileparts(expt.fname);
tmpfname \= fullfile(pathstr, \[name '.tmp']);

tmpchannel \= \[];

varargin \= assignApplicable(varargin);

try 
 data \= load(tmpfname);
 if (isempty(data))
 disp (\['failed to load temperature data from ' tmpfname]);
 return;
 end
catch me
 disp(me.getReport);
 disp (\['failed to load temperature data from ' tmpfname]);
 return;
end

chnum \= data(1:3:end, 1\);
temp \= data(3:3:end, :);
tim \= data(2:3:end, :);
tim \= tim \- min(min(tim));
chname \= cellfun(@num2str, num2cell(chnum), 'UniformOutput', false);
if \~isempty(tmpchannel)
 ch \= find(chnum \=\= tmpchannel);
else
 ch \= \[];
end

while isempty(ch)
 clf()
 plot (tim', temp');
 legend(chname);
 tmpchannel \= input ('input the channel number of the surface temperature probe');
 ch \= find(chnum \=\= tmpchannel);
end

\[tim,I] \= unique(tim(ch,:));
tim \= (tim \- tim(1\))/1000; %convert to seconds
temp \= temp(ch,I);

%rescale timing to match time in experiment (.tim file) \-\- this is because
%the clock on the temperature controller may not run at exactly the same
%speed as the clock on the camera
% report if the difference is greater than 1%

totaltimetc \= tim(end);
totaltimecam \= expt.elapsedTime(end);

if (abs(totaltimetc \- totaltimecam)/totaltimecam \> 0\.01\)
 disp (\['warning: camera time differs from temperature controller time by ' num2str(100\*abs(totaltimetc \- totaltimecam)/totaltimecam) '%']);
 disp(\['camera time \= ' num2str(totlatimecam) ' and tc time \= ' num2str(totaltimetc)]);
 disp (\['.tim file \= ' expt.timfname]);
 disp (\['.tmp file \= ' tmpfname]);
end

t \= tim \* totaltimecam/totaltimetc;
dt \= min(min(diff(tim)), expt.dr.interpTime);
ti \= 0:dt:max(t);
tempi \= interp1(tim,temp,ti);
temps \= lowpass1D(tempi, max(30/dt,3\));
dtemp \= deriv(temps, max(5/dt,3\));

gq \= GlobalQuantity();
gq.xData \= ti;
gq.xField \= 'eti';
gq.derivationMethod \= @GlobalQuantity.oneDinterpolation;

gq.fieldname \= 'temp';
gq.yData \= temps;

expt.addGlobalQuantity(gq);

gq.fieldname \= 'dtemp';
gq.yData \= dtemp;

expt.addGlobalQuantity(gq);

clf();
subplot(2,1,1\); plot (ti, temps); title ('temperature vs. time');
subplot(2,1,2\); plot (ti, dtemp); title ('temperature derivative vs. time');


\-\-\-

\#\#\# File: filledRibbon.m (ID: utility functions.3\)

function h \= filledRibbon (x,y,z,u,v,w,c, varargin)
%function filledRibbon (x,y,z,u,v,w,c, varargin)
%
%plots a ribbon spanning the area between the lines x,y,z and x\+u,y\+v,z\+w
%in the color c
%varargin is passed directly to patch
%returns a handle to the patch graphic created


if \~exist('w', 'var') \|\| isempty(w)
 w \= 0;
end
if \~exist('u', 'var') \|\| isempty(u)
 u \= 0;
end
if \~exist('v', 'var') \|\| isempty(v)
 v \= 0;
end
if \~exist('c', 'var') \|\| isempty(c)
 c \= 'b';
end


%make all vectors 1xN 
x \= reshape(x,1,\[]);
y \= reshape(y,1,\[]);
z \= reshape(z,1,\[]);

%if any offsets are scalar, expand to a vector
if all(size(u) \=\= 1\)
 u \= repmat(u, size(x));
end

if all(size(v) \=\= 1\)
 v \= repmat(v, size(x));
end
if all(size(w) \=\= 1\)
 w \= repmat(w, size(x));
end

%make up a set of regions that span the space between the lines

xr \= \[x(1:end\-1\); x(1:end\-1\) \+ u(1:end\-1\); x(2:end) \+ u(2:end); x(2:end)];
yr \= \[y(1:end\-1\); y(1:end\-1\) \+ v(1:end\-1\); y(2:end) \+ v(2:end); y(2:end)];
zr \= \[z(1:end\-1\); z(1:end\-1\) \+ w(1:end\-1\); z(2:end) \+ w(2:end); z(2:end)];

%plot the regions with no edges
h \= patch(xr,yr,zr,c, 'LineStyle','none', varargin{:});
\-\-\-

\#\#\# File: writeFrameOrPause.m (ID: utility functions.4\)

function writeFrameOrPause(vidObj, avirect, fps, nframes)
%function writeFrameOrPause(vidObj, avirect, fps, nframes)

existsAndDefault('fps', 25\);
existsAndDefault('nframes', 1\);
existsAndDefault('avirect', \[]);
for j \= 1:nframes
 if (\~isempty(vidObj))
 if (isempty(avirect))
 currFrame \= getframe(gcf);
 else
 currFrame \= getframe(gcf,avirect);
 end
 % disp('writing a frame');
 writeVideo(vidObj,currFrame);
 else
 pause(1/fps);
 end
end
\-\-\-

\#\#\# File: stdOfFunVal.m (ID: utility functions.5\)

function \[sigma trialValues] \= stdOfFunVal(modelParams, modelLogLikelihoodHessian, funOfModelParams, varargin)
%function \[minval maxval] \= confidenceRange(modelParams, modelLogLikelihoodHessian, funOfModelParams, varargin)
%parameter value pairs:
%numtrials, 1E6 : number of points to calculate for taking the minimum and
%maximum
%
%modelParams: the parameters that maximize the likelihood of the model: (k x 1\)
%modelLogLikelihoodHessian: the second derivative matrix at the maximum (k x k)
%funOfModelParams: should take a kxN vector of inputs and return a 1xN
%output

numtrials \= 1E6;

varargin \= assignApplicable(varargin);
if (size(modelParams, 1\) \=\= 1\)
 modelParams \= modelParams';
end
k \= length(modelParams);

x \= randn(k, numtrials);
if (any (\~isfinite(modelLogLikelihoodHessian)))
 disp ('model hessian has non finite values')
 sigma \= NaN;
 trialValues \= \[];
 return;
end

\[V,D] \= eig(modelLogLikelihoodHessian);
if (any(D \> 0\))
 disp ('model hessian has non\-negative eigenvalues')
 sigma \= NaN;
 trialValues \= \[];
 return;
end

trialPoints \= repmat(modelParams,1,size(x,2\));
s \= 1\./sqrt(\-D(logical(eye(size(D,1\)))));
for j \= 1:length(modelParams)
 trialPoints \= trialPoints\+s(j)\*V(:,j)\*x(j,:);
end
%whos trialPoints
trialValues \= funOfModelParams(trialPoints);
sigma \= std(trialValues);



end


\-\-\-

\#\#\# File: dftregistration.m (ID: utility functions.6\)



function \[output Greg] \= dftregistration(buf1ft,buf2ft,usfac)
% function \[output Greg] \= dftregistration(buf1ft,buf2ft,usfac);
% Efficient subpixel image registration by crosscorrelation. This code
% gives the same precision as the FFT upsampled cross correlation in a
% small fraction of the computation time and with reduced memory 
% requirements. It obtains an initial estimate of the crosscorrelation peak
% by an FFT and then refines the shift estimation by upsampling the DFT
% only in a small neighborhood of that estimate by means of a 
% matrix\-multiply DFT. With this procedure all the image points are used to
% compute the upsampled crosscorrelation.
% Manuel Guizar \- Dec 13, 2007

% Portions of this code were taken from code written by Ann M. Kowalczyk 
% and James R. Fienup. 
% J.R. Fienup and A.M. Kowalczyk, "Phase retrieval for a complex\-valued 
% object by using a low\-resolution image," J. Opt. Soc. Am. A 7, 450\-458 
% (1990\).

% Citation for this algorithm:
% Manuel Guizar\-Sicairos, Samuel T. Thurman, and James R. Fienup, 
% "Efficient subpixel image registration algorithms," Opt. Lett. 33, 
% 156\-158 (2008\).

% Inputs
% buf1ft Fourier transform of reference image, 
% DC in (1,1\) \[DO NOT FFTSHIFT]
% buf2ft Fourier transform of image to register, 
% DC in (1,1\) \[DO NOT FFTSHIFT]
% usfac Upsampling factor (integer). Images will be registered to 
% within 1/usfac of a pixel. For example usfac \= 20 means the
% images will be registered within 1/20 of a pixel. (default \= 1\)

% Outputs
% output \= \[error,diffphase,net\_row\_shift,net\_col\_shift]
% error Translation invariant normalized RMS error between f and g
% diffphase Global phase difference between the two images (should be
% zero if images are non\-negative).
% net\_row\_shift net\_col\_shift Pixel shifts between images
% Greg (Optional) Fourier transform of registered version of buf2ft,
% the global phase difference is compensated for.

% Default usfac to 1
if exist('usfac')\~\=1, usfac\=1; end

% Compute error for no pixel shift
if usfac \=\= 0,
 CCmax \= sum(sum(buf1ft.\*conj(buf2ft))); 
 rfzero \= sum(abs(buf1ft(:)).^2\);
 rgzero \= sum(abs(buf2ft(:)).^2\); 
 error \= 1\.0 \- CCmax.\*conj(CCmax)/(rgzero\*rfzero); 
 error \= sqrt(abs(error));
 diffphase\=atan2(imag(CCmax),real(CCmax)); 
 output\=\[error,diffphase];
 
% Whole\-pixel shift \- Compute crosscorrelation by an IFFT and locate the
% peak
elseif usfac \=\= 1,
 \[m,n]\=size(buf1ft);
 CC \= ifft2(buf1ft.\*conj(buf2ft));
 \[max1,loc1] \= max(CC);
 \[max2,loc2] \= max(max1\);
 rloc\=loc1(loc2\);
 cloc\=loc2;
 CCmax\=CC(rloc,cloc); 
 rfzero \= sum(abs(buf1ft(:)).^2\)/(m\*n);
 rgzero \= sum(abs(buf2ft(:)).^2\)/(m\*n); 
 error \= 1\.0 \- CCmax.\*conj(CCmax)/(rgzero(1,1\)\*rfzero(1,1\));
 error \= sqrt(abs(error));
 diffphase\=atan2(imag(CCmax),real(CCmax)); 
 md2 \= fix(m/2\); 
 nd2 \= fix(n/2\);
 if rloc \> md2
 row\_shift \= rloc \- m \- 1;
 else
 row\_shift \= rloc \- 1;
 end

 if cloc \> nd2
 col\_shift \= cloc \- n \- 1;
 else
 col\_shift \= cloc \- 1;
 end
 output\=\[error,diffphase,row\_shift,col\_shift];
 
% Partial\-pixel shift
else
 
 % First upsample by a factor of 2 to obtain initial estimate
 % Embed Fourier data in a 2x larger array
 \[m,n]\=size(buf1ft);
 mlarge\=m\*2;
 nlarge\=n\*2;
 CC\=zeros(mlarge,nlarge);
 CC(m\+1\-fix(m/2\):m\+1\+fix((m\-1\)/2\),n\+1\-fix(n/2\):n\+1\+fix((n\-1\)/2\)) \= ...
 fftshift(buf1ft).\*conj(fftshift(buf2ft));
 
 % Compute crosscorrelation and locate the peak 
 CC \= ifft2(ifftshift(CC)); % Calculate cross\-correlation
 \[max1,loc1] \= max(CC);
 \[max2,loc2] \= max(max1\);
 rloc\=loc1(loc2\);cloc\=loc2;
 CCmax\=CC(rloc,cloc);
 
 % Obtain shift in original pixel grid from the position of the
 % crosscorrelation peak 
 \[m,n] \= size(CC); md2 \= fix(m/2\); nd2 \= fix(n/2\);
 if rloc \> md2 
 row\_shift \= rloc \- m \- 1;
 else
 row\_shift \= rloc \- 1;
 end
 if cloc \> nd2
 col\_shift \= cloc \- n \- 1;
 else
 col\_shift \= cloc \- 1;
 end
 row\_shift\=row\_shift/2;
 col\_shift\=col\_shift/2;

 % If upsampling \> 2, then refine estimate with matrix multiply DFT
 if usfac \> 2,
 %%% DFT computation %%%
 % Initial shift estimate in upsampled grid
 row\_shift \= round(row\_shift\*usfac)/usfac; 
 col\_shift \= round(col\_shift\*usfac)/usfac; 
 dftshift \= fix(ceil(usfac\*1\.5\)/2\); %% Center of output array at dftshift\+1
 % Matrix multiply DFT around the current shift estimate
 CC \= conj(dftups(buf2ft.\*conj(buf1ft),ceil(usfac\*1\.5\),ceil(usfac\*1\.5\),usfac,...
 dftshift\-row\_shift\*usfac,dftshift\-col\_shift\*usfac))/(md2\*nd2\*usfac^2\);
 % Locate maximum and map back to original pixel grid 
 \[max1,loc1] \= max(CC); 
 \[max2,loc2] \= max(max1\); 
 rloc \= loc1(loc2\); cloc \= loc2;
 CCmax \= CC(rloc,cloc);
 rg00 \= dftups(buf1ft.\*conj(buf1ft),1,1,usfac)/(md2\*nd2\*usfac^2\);
 rf00 \= dftups(buf2ft.\*conj(buf2ft),1,1,usfac)/(md2\*nd2\*usfac^2\); 
 rloc \= rloc \- dftshift \- 1;
 cloc \= cloc \- dftshift \- 1;
 row\_shift \= row\_shift \+ rloc/usfac;
 col\_shift \= col\_shift \+ cloc/usfac; 

 % If upsampling \= 2, no additional pixel shift refinement
 else 
 rg00 \= sum(sum( buf1ft.\*conj(buf1ft) ))/m/n;
 rf00 \= sum(sum( buf2ft.\*conj(buf2ft) ))/m/n;
 end
 error \= 1\.0 \- CCmax.\*conj(CCmax)/(rg00\*rf00\);
 error \= sqrt(abs(error));
 diffphase\=atan2(imag(CCmax),real(CCmax));
 % If its only one row or column the shift along that dimension has no
 % effect. We set to zero.
 if md2 \=\= 1,
 row\_shift \= 0;
 end
 if nd2 \=\= 1,
 col\_shift \= 0;
 end
 output\=\[error,diffphase,row\_shift,col\_shift];
end 

% Compute registered version of buf2ft
if (nargout \> 1\)\&\&(usfac \> 0\),
 \[nr,nc]\=size(buf2ft);
 Nr \= ifftshift(\[\-fix(nr/2\):ceil(nr/2\)\-1]);
 Nc \= ifftshift(\[\-fix(nc/2\):ceil(nc/2\)\-1]);
 \[Nc,Nr] \= meshgrid(Nc,Nr);
 Greg \= buf2ft.\*exp(i\*2\*pi\*(\-row\_shift\*Nr/nr\-col\_shift\*Nc/nc));
 Greg \= Greg\*exp(i\*diffphase);
elseif (nargout \> 1\)\&\&(usfac \=\= 0\)
 Greg \= buf2ft\*exp(i\*diffphase);
end
return

function out\=dftups(in,nor,noc,usfac,roff,coff)
% function out\=dftups(in,nor,noc,usfac,roff,coff);
% Upsampled DFT by matrix multiplies, can compute an upsampled DFT in just
% a small region.
% usfac Upsampling factor (default usfac \= 1\)
% \[nor,noc] Number of pixels in the output upsampled DFT, in
% units of upsampled pixels (default \= size(in))
% roff, coff Row and column offsets, allow to shift the output array to
% a region of interest on the DFT (default \= 0\)
% Recieves DC in upper left corner, image center must be in (1,1\) 
% Manuel Guizar \- Dec 13, 2007
% Modified from dftus, by J.R. Fienup 7/31/06

% This code is intended to provide the same result as if the following
% operations were performed
% \- Embed the array "in" in an array that is usfac times larger in each
% dimension. ifftshift to bring the center of the image to (1,1\).
% \- Take the FFT of the larger array
% \- Extract an \[nor, noc] region of the result. Starting with the 
% \[roff\+1 coff\+1] element.

% It achieves this result by computing the DFT in the output array without
% the need to zeropad. Much faster and memory efficient than the
% zero\-padded FFT approach if \[nor noc] are much smaller than \[nr\*usfac nc\*usfac]

\[nr,nc]\=size(in);
% Set defaults
if exist('roff')\~\=1, roff\=0; end
if exist('coff')\~\=1, coff\=0; end
if exist('usfac')\~\=1, usfac\=1; end
if exist('noc')\~\=1, noc\=nc; end
if exist('nor')\~\=1, nor\=nr; end
% Compute kernels and obtain DFT by matrix products
kernc\=exp((\-i\*2\*pi/(nc\*usfac))\*( ifftshift(\[0:nc\-1]).' \- floor(nc/2\) )\*( \[0:noc\-1] \- coff ));
kernr\=exp((\-i\*2\*pi/(nr\*usfac))\*( \[0:nor\-1].' \- roff )\*( ifftshift(\[0:nr\-1]) \- floor(nr/2\) ));
out\=kernr\*in\*kernc;
return

\-\-\-

\#\#\# File: listOfPointsToBWCC.m (ID: utility functions.7\)

function \[cc,d] \= listOfPointsToBWCC (points, connectivity)
%function cc \= listOfPointsToBWCC (points, connectivity)

existsAndDefault('connectivity', 8\);
dx \= diff(points(1,:));
dy \= diff(points(2,:));
dx \= min(abs(dx(dx \~\= 0\)));
dy \= min(abs(dy(dy \~\= 0\)));
d \= max(dx,dy);
d \= max(d,0\.01\);
x \= points(1,\[1:end 1])/d;
y \= points(2,\[1:end 1])/d;


x \= round(x \- min(x)) \+ 1;
y \= round(y \- min(y)) \+ 1;
%xx \= \[];
%yy \= \[];
%{
for j \= 1:(length(x) \- 1\)
 np \= max(abs((x(j\+1\) \- x(j))), abs((y(j\+1\)\-y(j)))) \+ 1;
 xx \= \[xx, round(linspace(x(j),x(j\+1\), np))];
 yy \= \[yy, round(linspace(y(j),y(j\+1\), np))];
end

plot (x,y,'r.', xx, yy)
%} 
sz \= \[max(y), max(x)];
\[xx,yy] \= meshgrid(1:sz(2\), 1:sz(1\));
\[\~,on] \= inpolygon(xx,yy,x,y);
ind \= sub2ind(sz, yy(on), xx(on));
cc.Connectivity \= connectivity;
cc.ImageSize \= sz;
cc.NumObjects \= 1;
cc.PixelIdxList \= {ind};

\-\-\-

\#\#\# File: gaussWithOffset.m (ID: utility functions.8\)

function kernel \= gaussWithOffset(amp, sigma, offset)
%function kernel \= gaussWithOffset(amp, sigma, offset)

SIGMA \= 20;
k \= gaussKernel(SIGMA);
kernel \= zeros(\[1, ceil(6\*sigma \+ 1 \+ abs(2\*offset))]);
kinds \= linspace(\-(length(k)\-1\)/2, (length(k)\-1\)/2, length(k))\*sigma/SIGMA;
kerninds \= linspace(\-(length(kernel)\-1\)/2, (length(kernel)\-1\)/2, length(kernel)) \- offset;
%{
min(kinds)
max(kinds)
min(kerninds)
max(kerninds)
%}
kernel \= interp1(kinds, k, kerninds, 'linear', 0\);
kernel \= amp\*kernel/sum(kernel);
\-\-\-

\#\#\# File: ndhist.m (ID: utility functions.9\)

function binned\_data\=ndhist(data,M)
% this function computes the histogram
% of an n\-dimensional data set;
% 'data' is nrows by n columns
% M is the number of bins used in each dimension
% so that 'binned\_data' is a hypercube with
% size length equal to M;
% data is assumed to range from 0 to 1 \& all values outside this range are
% discarded
% modified form of internal function from kde2d.m
% Reference:
% Kernel density estimation via diffusion
% Z. I. Botev, J. F. Grotowski, and D. P. Kroese (2010\)
% Annals of Statistics, Volume 38, Number 5, pages 2916\-2957\.
% see original license at end of file

\[nrows,ncols]\=size(data);
bins\=zeros(nrows,ncols);
for i\=1:ncols
 bins(:,i) \= discretize(data(:,i), 0:1/M:1\);
 % \[\~,bins(:,i)] \= histc(data(:,i),0:1/M:1,1\);
 % bins(:,i) \= min(bins(:,i),M);
end
% Combine the vectors of 1D bin counts into a grid of nD bin
% counts.
binned\_data \= accumarray(bins(all(bins\>0,2\),:),1,M(ones(1,ncols)))'; 
%note transpose added \-\- in kde2d, transpose happens in dct/idct pair
%note normalization factor of 1/nrows removed
end

%{
Copyright (c) 2015, Dr. Zdravko Botev
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

 \* Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 \* Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in
 the documentation and/or other materials provided with the distribution
 \* Neither the name of the The University of New South Wales nor the names
 of its contributors may be used to endorse or promote products derived
 from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
%}

\-\-\-

\#\#\# File: comp\_struct.m (ID: utility functions.10\)

function \[fs1, fs2, er] \= comp\_struct(s1,s2,n1,n2,p,tol)
% check two structures for differances \- i.e. see if strucutre s1 \=\= structure s2
% function \[fs1, fs2, er] \= comp\_struct(s1,s2,n1,n2,p,tol)
%
% inputs 6 \- 5 optional
% s1 structure one class structure
% s2 structure two class structure \- optional
% n1 first structure name (variable name) class char \- optional
% n2 second structure name (variable name) class char \- optional
% p pause flag (0 / 1\) class integer \- optional
% tol tol default tolerance (real numbers) class integer \- optional
%
% outputs 3 \- 3 optional
% fs1 non\-matching feilds for structure one class cell \- optional
% fs2 non\-matching feilds for structure two class cell \- optional
% er error flag (value) class 
%
% example: \[r1 r2] \= comp\_struct(data1,data2,'data1','data2',1\)
% michael arant \- april 5 2003
%
% hint:
% passing just one structure causes the program to copy the structure
% and compare the two. This is an easy way to list the structure

if nargin \< 1; help comp\_struct; error('I / O error'); end
if nargin \< 2; s2 \= s1; end
if nargin \< 3; n1 \= 's1'; end
if nargin \< 4; n2 \= 's2'; end
if nargin \< 5; p \= 0; elseif p \~\= 1 \&\& p \~\= 0; p \= 0; end
if nargin \< 6; tol \= 1e\-6; end

% define fs
fs1 \= {}; fs2 \= {}; er \= {};

% are the variables structures
if isstruct(s1\) \&\& isstruct(s2\)
% both structures \- get the field names
 fn1 \= fieldnames(s1\);
 fn2 \= fieldnames(s2\);
% loop through structure 1 and match to structure 2
 pnt1 \= zeros(1,length(fn1\));
 for ii \= 1:length(fn1\)
 for jj \= 1:length(fn2\)
 if strcmp(fn1(ii),fn2(jj)); pnt1(ii) \= jj; end
 end
 end
 pnt2 \= zeros(1,length(fn2\));
 for ii \= 1:length(fn2\)
 for jj \= 1:length(fn1\)
 if strcmp(fn2(ii),fn1(jj)); pnt2(ii) \= jj; end
 end
 end
% get un\-matched fields
 for ii \= find(\~pnt1\)
 fs1 \= \[fs1; {\[char(n1\) '.' char(fn1(ii))]}];
 fs2 \= \[fs2; {''}]; er \= \[er; {'Un\-matched'}];
 end
 for ii \= find(\~pnt2\)
 fs2 \= \[fs2; {\[char(n2\) '.' char(fn2(ii))]}];
 fs1 \= \[fs1; {''}]; er \= \[er; {'Un\-matched'}];
 end
% % look for non\-matched fields fs1 to fs2
% fs1a \= fn1(\~pnt1\);
% fs2a \= setxor(pnt1,1:length(fn2\));
% if \~isempty(fs2a); fs2a \= fs2a(fs2a \~\= 0\);
% if \~isempty(fs2a)
% for kk \= 1:length(fs2a)
% fs2 \= \[fs2; {\[char(n2\) '.' char(fn2(fs2a(kk)))]}];
% er \= {'Un\-matched'}; fs1 \= \[fs1; {''}];
% end
% end
% end
% if isempty(fs2\); fs2 \= cell(0,1\); end
% now evaluate the matching fields remove "bad" matched
% loop through structure fields
 pnt1i \= find(pnt1\); pnt2i \= find(pnt2\);
 for ii\=1:numel(pnt1i)
% added loop for indexed structured variables
 for jj \= 1:size(s1,2\)
% clean display \- add index if needed
 if size(s1,2\) \=\= 1
 n1p \= \[n1 '.' char(fn1(pnt1i(ii)))];
 n2p \= \[n2 '.' char(fn2(pnt2i(ii)))];
 else
 n1p \= \[n1 '(' num2str(jj) ').' char(fn1(ii))]; ...
 n2p \= \[n2 '(' num2str(jj) ').' char(fn2(pnt2(ii)))];
 end
 \[fss1 fss2 err] \= comp\_struct(getfield(s1(jj),char(fn1(pnt1i(ii)))), ...
 getfield(s2(jj),char(fn2(pnt2i(ii)))),n1p,n2p,p);
 if \~iscell(err); err \= cellstr(err); end
 fs1 \= \[fs1; fss1]; fs2 \= \[fs2; fss2]; er \= \[er; err];
 end
 end
elseif isstruct(s1\) \~\= isstruct(s2\)
% one structure, one not
 disp(sprintf('%s %s Type mismatch \- NOT equal',n1,n2\));
 fs1 \= cell(0,1\); fs2 \= fs1;
 if p; disp('Paused .....'); pause; end
elseif isa(s1,'sym') \&\& isa(s2,'sym')
% compare two symbolic expresions
% direct compare
 \[ss1 r] \= simple(s1\); \[ss2 r] \= simple(s2\);
 t \= isequal(simplify(ss1\),simplify(ss2\));
 if \~t
% could still be equal, but not able to reduce the symbolic expresions
% get factors
 f1 \= findsym(ss1\); f2 \= findsym(ss2\);
 w \= warning; 
 if isequal(f1,f2\)
% same symbolic variables. same eqn?
 temp \= \[1 findstr(f1,' ') \+ 1]; tres \= NaN \* zeros(1,30\);
 for jj \= 1:1e3
 ss1e \= ss1; ss2e \= ss2;
 for ii \= 1:length(temp);
 tv \= (real(rand^rand)) / (real(rand^rand));
 ss1e \= subs(ss1e,f1(temp(ii)),tv);
 ss2e \= subs(ss2e,f2(temp(ii)),tv);
 end
 % check for match
 if isnan(ss1e) \|\| isnan(ss2e)
 tres(jj) \= 1;
 elseif (double(ss1e) \- double(ss2e)) \< tol
 tres(jj) \= 1;
 end
 end
% now check symbolic equation results
 if sum(tres) \=\= length(tres)
% symbolics assumed to be the same equation
 t \= 1;
 end
 else
% different symbolic variables
 end
 warning(w)
 end
 if t
 disp(sprintf('%s %s match',n1,n2\))
 else
 disp(sprintf('%s %s do NOT match',n1,n2\))
 fs1 \= n1; fs2 \= n2; er \= 'Symbolic disagreement';
 end
else
% neither structure \- compare
 if isequal(s1,s2\);
 disp(sprintf('%s %s match',n1,n2\))
 else
% check for "false" failures
% check structure size
 if strcmp(num2str(size(s1\)),num2str(size(s2\)));
% structures are same size \- check for precision error if numbers
 if ischar(s1\) \|\| iscell(s1\) \|\| ...
 (max(max(max(abs(s1 \- s2\)))) \> tol \* (max(max(max(\[s1 s2]))) ...
 \- min(min(min(\[s1 s2])))))
% same size, diferent values or not numbers
 disp(sprintf('%s %s do NOT match',n1,n2\))
 fs1 \= \[fs1; {n1}]; fs2 \= \[fs2; {n2}]; er \= \[er; {'?'}];
 if ischar(s1\)
 er1 \= sprintf('%s is char \- %s',n1,char(s1\)); disp(er1\);
 end
 if ischar(s2\)
 er2 \= sprintf('%s is char \- %s',n2,char(s2\)); disp(er2\);
 end
 if exist('er1','var') \&\& exist('er2','var')
 er \= \[er; {\[er1 ' \-\-\-\> ' er2]}];
 end
 if \~ischar(s1\) \&\& \~iscell(s1\);
 er \= sprintf('Max error (%%) \= %g%%', ...
 max(max(max(abs(s1 \- s2\)))) / ...
 (max(max(max(\[s1 s2]))) \- min(min(min(\[s1 s2])))));
 disp(er);
 end
 if p; disp('Paused .....'); pause; end
 else
% tolerance agreement
 disp(sprintf('%s %s tolerance match',n1,n2\))
 end
 else
% size difference
 disp(sprintf('%s %s do NOT match \- DIFFERENT SIZES',n1,n2\))
 fs1 \= \[fs1; {n1}]; fs2 \= \[fs2; {n2}]; er \= \[er; {'String size error'}];
 if p; disp('Paused .....'); pause; end
 end
 end
% fs1 \= cell(0,1\); fs2 \= fs1;
end

% display non matching fields
if 1
 if \~isempty(fs1\)
 for ii \= 1:length(fs1\)
 if strcmp(n1,fs1(ii))
 disp(sprintf('First Structure non\-matched fields: %s',\[n1]))
 else
% if isempty(findstr(n1,char(fs1(ii))))
% disp(sprintf('First Structure non\-matched fields: %s', ...
% \[n1 '.' char(fs1(ii))]))
% else
% disp(sprintf('First Structure non\-matched fields: %s', ...
% \[n1 strrep(char(fs1(ii)),n1,'')]))
% end
 end
 if p; disp('Paused .....'); pause; end
 end
 end
 if \~isempty(fs2\)
 for ii \= 1:length(fs2\)
 if strcmp(n2,fs2(ii))
 disp(sprintf('Second Structure non\-matched fields: %s',\[n2]))
 else
% if isempty(findstr(n2,char(fs2(ii))))
% disp(sprintf('Second Structure non\-matched fields: %s', ...
% \[n2 '.' char(fs2(ii))]))
% else
% disp(sprintf('Second Structure non\-matched fields: %s', ...
% \[n2 strrep(char(fs2(ii)),n2,'')]))
% end
 end
 if p; disp('Paused .....'); pause; end
 end
 end
end

\-\-\-

\#\#\# File: getNestedSubfieldsFromStruct.m (ID: utility functions.11\)

function val \= getNestedSubfieldsFromStruct (st, dotnamedfield)
%function val \= getNestedSubfieldsFromStruct (st, dotnamedfield)
%what st.(dotnamedfield) would give you if that were legal
%ex: dotnamefield \= 'superstruct.substruct'
 subfields \= regexp(dotnamedfield, '\\.', 'split');
 ds \= \[st.(subfields{1})];
 for j \= 2:length(subfields)
 ds \= \[ds.(subfields{j})];
 end
 val \= ds;
end
\-\-\-

\#\#\# File: toHashMap.m (ID: utility functions.12\)

function data \= toHashMap(obj, varargin)
%convert a generic object or structure into a java hashmap
%function data \= toHashMap(obj, varargin)
%
%converts an object or structure into a java hashmap, where
%each field name is a key, and each field value is a value
%if the field value is itself an object, then that object is converted to
%a hashmap, and that hashmap is stored as the value
%
%to prevent infinite recursion, if the a field is a handle object, it is
%only converted to a hashmap if handleRecurseLevel \> 0 (default 0\)
%in this case, handleRecurseLevel is decremented before being passed to 
%toHashMap(subfield)
%
%if obj is an array of objects, a java array of hashmaps is returned
handleRecurseLevel \= 0;
varargin \= assignApplicable(varargin);
data \= java.util.HashMap();
if (length(obj) \> 1\)
 arr \= javaArray('java.util.HashMap', length(obj));
 for j \= 1:length(obj)
 arr(j) \= toHashMap(obj(j), 'handleRecurseLevel', handleRecurseLevel, varargin{:});
 end
 data \= arr;
 return;
end

if (isa(obj, 'handle'))
 if (handleRecurseLevel \<\= 0\)
 warning ('oth:mrl', 'maximum handle recursion reached');
 data.put('handle type', class(obj));
 return;
 else
 handleRecurseLevel \= handleRecurseLevel \- 1;
 end
end
f \= fieldnames(obj);
for j \= 1:length(f)
 if (isobject(obj.(f{j})) \|\| isstruct(obj.(f{j})))
 data.put(f{j}, toHashMap(obj.(f{j}), 'handleRecurseLevel', handleRecurseLevel, varargin{:}));
 else
 data.put(f{j}, matlabArrToJavaArr(obj.(f{j})));
 end
 
end

function javatype \= getJavaType (matlabarr)
matlabtypes \= {'logical', 'single', 'double', 'char', 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64', 'uint64'};
javatypes \= {'Boolean', 'Float', 'Double', 'String', 'Byte', 'Byte', 'Short', 'Short', 'Integer', 'Integer', 'Long', 'Long'};
for j \= 1:length(matlabtypes)
 if (isa (matlabarr, matlabtypes{j}))
 javatype \= \['java.lang.' javatypes{j}];
 return;
 end
end
if (isnumeric(matlabarr))
 javatype \= 'java.lang.Double';
 return;
end
javatype \= 'java.lang.Object';

function arr \= matlabArrToJavaArr (matlabarr)
if ischar(matlabarr)
 matlabarr \= {matlabarr};
end
if (iscell(matlabarr))
 if (iscellstr(matlabarr))
 javatype \= 'java.lang.String';
 arr \= javaArray('java.lang.String', max(1,length(matlabarr)));
 else
 try 
 matlabarr \= cell2mat(matlabarr);
 javatype \= getJavaType(matlabarr);
 catch
% warning ('could not convert cell to array');
 javatype \= 'java.lang.Object';
 end
 end
else
 javatype \= getJavaType(matlabarr);
end
arr \= javaArray(javatype, max(1,length(matlabarr)));

if (iscellstr(matlabarr))
 for j \= 1:length(matlabarr)
 arr(j) \= javaObject(javatype, matlabarr{j});
 end
 return;
end
if (iscell(matlabarr))
 for j \= 1:length(matlabarr)
 if isa(matlabarr{j}, 'function\_handle')
 msg \= func2str(matlabarr{j});
 arr(j) \= java.lang.String(msg);
 else
 arr(j) \= matlabArrToJavaArr(matlabarr{j});
 end
 end
 return;
end
matlabarr \= matlabarr(:);
for j \= 1:length(matlabarr)
 if (strcmpi(javatype, 'java.lang.Object'))
 if isa(matlabarr(j), 'function\_handle')
 msg \= func2str(matlabarr(j));
 else
 msg \= 'unknown type';
 end
 arr(j) \= java.lang.String(msg);
 else
 arr(j) \= javaObject(javatype,matlabarr(j));
 end
end
\-\-\-

\#\#\# File: objFromHashmap.m (ID: utility functions.13\)

function obj \= objFromHashmap(hm)
%convert a java hashmap into a structure
%function obj \= objFromHashmap(hm)
%
%converts a java hashmap into a class or stucture given by obj, where
%each field name is a key, and each field value is a value
%if the field value is itself an object, then that object is converted to
%a hashmap, and that hashmap is stored as the value
%
%in general, one should not expect that objFromHashmap(objToHashmap(obj))
%is the same as obj
%
%if hm is an array of hashmaps (hm is a java.util.ArrayList), obj will be
%an array of objects

if isa(hm, 'java.util.ArrayList')
 it \= hm.iterator;
 for j \= 1:hm.size()
 try
 no \= it.next; %matlab autoconverts basic types
 if (isjava(no)) 
 obj(j) \= objFromHashmap(no);
 else
 obj{j} \= no;
 end
 catch me
 disp('error');
 me.getReport
 break;
 end
 end
 if (iscell(obj) )
 if (length(obj) \=\= 1\)
 obj \= obj{1};
 else
 if (\~iscellstr(obj))
 try 
 obj \= cell2mat(obj);
 catch
 %nothing
 end
 end
 end
 end 
 return;
end
if \~isa(hm, 'java.util.HashMap')
 warning ('expecting a hash map or java arraylist of hashmaps');
 obj \= \[];
 return;
end

keys \= hm.keySet;
it \= keys.iterator;
for j \= 1:keys.size();
 try
 fn \= it.next();
 val \= hm.get(fn);
 if (isjava(val))
 obj.(fn) \= objFromHashmap(val);
 else
 obj.(fn) \= val;
 end
 catch me
 'parse error'
 me.getReport;
 end
end

\-\-\-

\#\#\# File: pathToCellOfStrings.m (ID: utility functions.14\)

function c \= pathToCellOfStrings(p)
%function c \= pathToCellOfStrings(p)
%
%p \= 'c:\\foo\\bar\\fubar.foo'
%c \= 'c:\\' 'foo' 'bar' 'fubar.foo'
j \= 1;
while (j \< 100\)
 \[p, nm, ext] \= fileparts(p);
 if (\~isempty(nm))
 c{j} \= \[nm ext];
 else
 c{j} \= p;
 break;
 end
 j \= j\+1;
end

c \= c(end:\-1:1\);


\-\-\-

\#\#\# File: createTimingInfoForFileSets.m (ID: utility functions.15\)

function createTimingInfoForFileSets (batfilename, varargin)
%function createTimingInfoForFileSets (batfilename, varargin)
%
%looks through a bat file, detects input \& output files, then adds timing
%info files (.tim files) if these do not already exist
%
%optional param, value pairs
%'verbose', true/false \-\- whether or not to display additional info as
%processing proceeds
%'extension', '.ext' \-\- extension if not jpg, see createTimFile

verbose \= false;
varargin \= assignApplicable(varargin);

if (verbose)
 ts \= tic;
 disp (\['reading in ' batfilename]);
end

str \= fileread(batfilename);
\[directories, fstubs, outnames] \= getFileInfoFromBatFile(str);
if (length(directories) \~\= length(fstubs) \|\| length(fstubs) \~\= length(outnames))
 disp ('Error! Did not parse correctly')
 directories
 fstubs
 outnames
end

if (verbose)
 toc (ts);
 disp (\['detected ' num2str(length(directories)) ' file sets']);
end

for j \= 1:length(outnames)
 ind \= find(outnames{j} \=\= '.',1,'last');
 outnames{j} \= \[outnames{j}(1:ind) 'tim'];
end

for j \= 1:length(outnames)
 if (exist(outnames{j}, 'file'))
 if (verbose)
 disp (\[outnames{j} ' already exists; taking no action']);
 end
 continue;
 else
 createTimFile(directories{j}, fstubs{j}, outnames{j}, 'verbose', verbose, varargin{:});
 end
end

\-\-\-

\#\#\# File: luminos.m (ID: utility functions.16\)

%LUMINOS Photopic luminosity function
%
% P \= LUMINOS(lam)
%
% Return photopic luminosity (0\..1\) for wavelength specified. 
% Lam maybe a vector.
%
% lambda is in nm
%
% Copyright (c) Peter Corke, 1999 Machine Vision Toolbox for Matlab
% modified by marc gershow 3/2/2012
 function lu \= luminos(lam)
 tab \= \[
 3\.8000000e\-007 0\.0000000e\+000
 3\.8500000e\-007 1\.0000000e\-004
 3\.9000000e\-007 1\.0000000e\-004
 3\.9500000e\-007 2\.0000000e\-004
 4\.0000000e\-007 4\.0000000e\-004
 4\.0500000e\-007 6\.0000000e\-004
 4\.1000000e\-007 1\.2000000e\-003
 4\.1500000e\-007 2\.2000000e\-003
 4\.2000000e\-007 4\.0000000e\-003
 4\.2500000e\-007 7\.3000000e\-003
 4\.3000000e\-007 1\.1600000e\-002
 4\.3500000e\-007 1\.6800000e\-002
 4\.4000000e\-007 2\.3000000e\-002
 4\.4500000e\-007 2\.9800000e\-002
 4\.5000000e\-007 3\.8000000e\-002
 4\.5500000e\-007 4\.8000000e\-002
 4\.6000000e\-007 6\.0000000e\-002
 4\.6500000e\-007 7\.3900000e\-002
 4\.7000000e\-007 9\.1000000e\-002
 4\.7500000e\-007 1\.1260000e\-001
 4\.8000000e\-007 1\.3900000e\-001
 4\.8500000e\-007 1\.6930000e\-001
 4\.9000000e\-007 2\.0800000e\-001
 4\.9500000e\-007 2\.5860000e\-001
 5\.0000000e\-007 3\.2300000e\-001
 5\.0500000e\-007 4\.0730000e\-001
 5\.1000000e\-007 5\.0300000e\-001
 5\.1500000e\-007 6\.0820000e\-001
 5\.2000000e\-007 7\.1000000e\-001
 5\.2500000e\-007 7\.9320000e\-001
 5\.3000000e\-007 8\.6200000e\-001
 5\.3500000e\-007 9\.1490000e\-001
 5\.4000000e\-007 9\.5400000e\-001
 5\.4500000e\-007 9\.8030000e\-001
 5\.5000000e\-007 9\.9500000e\-001
 5\.5500000e\-007 1\.0002000e\+000
 5\.6000000e\-007 9\.9500000e\-001
 5\.6500000e\-007 9\.7860000e\-001
 5\.7000000e\-007 9\.5200000e\-001
 5\.7500000e\-007 9\.1540000e\-001
 5\.8000000e\-007 8\.7000000e\-001
 5\.8500000e\-007 8\.1630000e\-001
 5\.9000000e\-007 7\.5700000e\-001
 5\.9500000e\-007 6\.9490000e\-001
 6\.0000000e\-007 6\.3100000e\-001
 6\.0500000e\-007 5\.6680000e\-001
 6\.1000000e\-007 5\.0300000e\-001
 6\.1500000e\-007 4\.4120000e\-001
 6\.2000000e\-007 3\.8100000e\-001
 6\.2500000e\-007 3\.2100000e\-001
 6\.3000000e\-007 2\.6500000e\-001
 6\.3500000e\-007 2\.1700000e\-001
 6\.4000000e\-007 1\.7500000e\-001
 6\.4500000e\-007 1\.3820000e\-001
 6\.5000000e\-007 1\.0700000e\-001
 6\.5500000e\-007 8\.1600000e\-002
 6\.6000000e\-007 6\.1000000e\-002
 6\.6500000e\-007 4\.4600000e\-002
 6\.7000000e\-007 3\.2000000e\-002
 6\.7500000e\-007 2\.3200000e\-002
 6\.8000000e\-007 1\.7000000e\-002
 6\.8500000e\-007 1\.1900000e\-002
 6\.9000000e\-007 8\.2000000e\-003
 6\.9500000e\-007 5\.7000000e\-003
 7\.0000000e\-007 4\.1000000e\-003
 7\.0500000e\-007 2\.9000000e\-003
 7\.1000000e\-007 2\.1000000e\-003
 7\.1500000e\-007 1\.5000000e\-003
 7\.2000000e\-007 1\.0000000e\-003
 7\.2500000e\-007 7\.0000000e\-004
 7\.3000000e\-007 5\.0000000e\-004
 7\.3500000e\-007 4\.0000000e\-004
 7\.4000000e\-007 3\.0000000e\-004
 7\.4500000e\-007 2\.0000000e\-004
 7\.5000000e\-007 1\.0000000e\-004
 7\.5500000e\-007 1\.0000000e\-004
 7\.6000000e\-007 1\.0000000e\-004
 7\.6500000e\-007 0\.0000000e\+000
 7\.7000000e\-007 0\.0000000e\+000];
 
 lu \= interp1(tab(:,1\), tab(:,2\), lam/1E9\);
\-\-\-

\#\#\# File: isSameFile.m (ID: utility functions.17\)

function tf \= isSameFile (path1, path2\)
%function tf \= isSameFile (path1, path2\)

if (\~ischar(path1\) \|\| \~ischar(path2\))
 warning ('can only compare string paths');
 tf \= false;
 return;
end

if (\~any(path1 \=\= '.'))
 path1 \= fullfile(path1, '.');
end
if (\~any(path2 \=\= '.'))
 path2 \= fullfile(path2, '.');
end

f1 \= java.io.File(path1\);
f2 \= java.io.File(path2\);

p1 \= f1\.getCanonicalFile;
p2 \= f2\.getCanonicalFile;

tf \= \~logical(p1\.compareTo(p2\));

\-\-\-

\#\#\# File: xc2\.m (ID: utility functions.18\)

function \[c2, lags ] \= xc2(A,B,C, maxLag)
%function \[c2, lags ] \= xc2(A,B,C, maxLag)
% c2(m,n) \= sum\_j (C(j)\*A(lags(m)\+j)\*B(lags(n)\+j)

nel \= 2\*maxLag \+ 1;
c2 \= zeros(nel, nel);
lags \= (\-2\*maxLag):maxLag;
for j \= 1:nel
 m \= \-maxLag \+ j;
 if (m \< 0\)
 d \= A(1:(end\+m)).\*C((\-m \+ 1\):end);
 else
 d \= A((m\+1\):end).\*C(1:(end\-m));
 end
 c2(:,j) \= xcorr(B,d, maxLag, 'none');
end


end


\-\-\-

\#\#\# File: unpackKerrChainCode.m (ID: utility functions.19\)

function \[x,y] \= unpackKerrChainCode(ccstr, npts)

dx \= zeros(\[1, npts]);
dy \= dx;
ccstr \= uint8(ccstr) \- '0'; %0 \= 48 not 33, as described in the manual
bc \= \[ccstr ccstr ccstr];
bc(1:3:end) \= bitand(bitshift(ccstr, \-4\), 3\);
bc(2:3:end) \= bitand(bitshift(ccstr, \-2\), 3\);
bc(3:3:end) \= bitand(ccstr, 3\);

bc \= bc(1:(npts));
dx(bc \=\= 0\) \= \-1;
dx(bc \=\= 1\) \= 1;
dy(bc \=\= 2\) \= \-1;
dy(bc \=\= 3\) \= 1;

x \= \[0 cumsum(dx)];
y \= \[0 cumsum(dy)];
% 
% 
% for j \= 2:npts
% c \= ccstr(floor((j\+1\)/3\)); 
% bs \= 4 \- 2\*mod((j\+1\),3\);
% %cc(j) \= c;
% x(j) \= x(j\-1\);
% y(j) \= y(j\-1\);
% switch (bitand(bitshift(c, \-bs), 3\))
% case 0
% x(j) \= x(j) \- 1;
% case 1
% x(j) \= x(j) \+ 1;
% case 2
% y(j) \= y(j) \- 1;
% case 3
% y(j) \= y(j) \+ 1;
% otherwise
% disp ('you dumb!');
% end
% %plot (x(1:j), y(1:j), 'b.\-'); pause
% end
% ccstr
% char(cc \+ 48\)
\-\-\-

\#\#\# File: DKL\_gauss\_est.m (ID: utility functions.20\)

function dkl \= DKL\_gauss\_est(x0, x1 )
%function dkl \= DKL\_gauss\_est(x1, x2 )
%
%estimates the kl divergence between set x1 and set x2 using the mean and
%covariances only (e.g. approximates the distributions as gaussian)
% dkl \= dkl(x1\|\|x2\)
%
%size(x1\) and size(x2\) should be MxD and NxD where M,N are the number of
%samples and D is the dimension

if (size(x0,2\) \~\= size(x1,2\))
 error ('second dimension must be the same for x1,x2');
end
v0 \= cov(x0,1\);
u0 \= mean(x0\);
v1 \= cov(x1,1\);
u1 \= mean(x1\);


dkl \= 0\.5\*(trace(v1\\v0\) \+ (u1\-u0\)\*(v1\\(u1\-u0\)') \- size(x0,2\) \+ log(det(v1\))\-log(det(v0\)));

end


\-\-\-

\#\#\# File: deg2rad.m (ID: utility functions.21\)

function y \= deg2rad(x)
%converts degrees to radians
%function y \= deg2rad(x)

y \= x.\*pi/180;

\-\-\-

\#\#\# File: convert8Connectedto4Connected.m (ID: utility functions.22\)

function \[dx4,dy4] \= convert8Connectedto4Connected(dx8, dy8\)
% function \[dx4,dy4] \= convert8Connectedto4Connected(dx8, dy8\)
% converts and 8\-connected chain to a 4 connected chain

dxmat \= {\[\-1 0], \[0], \[1 0]; \[\-1], \[], \[1]; \[\-1 0], \[0], \[1 0]};
dymat \= {\[0 \-1], \[\-1], \[0 \-1]; \[0], \[], \[0]; \[0 1], \[1], \[0 1]};

dx4 \= \[dxmat{sub2ind(size(dxmat), dy8\+2,dx8\+2\)}];
dy4 \= \[dymat{sub2ind(size(dymat), dy8\+2,dx8\+2\)}];

\-\-\-

\#\#\# File: confidenceRange.m (ID: utility functions.23\)

function \[minval maxval trialValues] \= confidenceRange(modelParams, modelLogLikelihoodHessian, funOfModelParams, confidenceLevel, varargin)
%function \[minval maxval] \= confidenceRange(modelParams, modelLogLikelihoodHessian, funOfModelParams, confidenceLevel, varargin)
%parameter value pairs:
%numtrials, 1E6 : number of points to calculate for taking the minimum and
%maximum
%
%modelParams: the parameters that maximize the likelihood of the model: (k x 1\)
%modelLogLikelihoodHessian: the second derivative matrix at the maximum (k x k)
%funOfModelParams: should take a kxN vector of inputs and return a 1xN
%output
if (length(confidenceLevel) \> 1\)
 for j \= 1:length(confidenceLevel)
 \[minvt maxvt tvt] \= confidenceRange(modelParams, modelLogLikelihoodHessian, funOfModelParams, confidenceLevel(j), varargin{:});
 minval(j) \= minvt;
 maxval(j) \= maxvt;
 if (nargout \> 2\)
 trialValues(j,:) \= tvt;
 end
 end
 return;
end

numtrials \= 1E6;

varargin \= assignApplicable(varargin);
if (size(modelParams, 1\) \=\= 1\)
 modelParams \= modelParams';
end
k \= length(modelParams);
%{
prefactor \= 1;
while true
 prefactor \= prefactor\*1\.1;
 x \= randn(k, ceil(prefactor\*numtrials/confidenceLevel));
 maxrsq \= chi2inv(confidenceLevel, k);
 x \= x(:,sum(x.^2,1\) \< maxrsq);
 if (size(x,2\) \>\= numtrials)
 break;
 end
end
x \= x(:,1:numtrials);
%}
x \= randomFromKBall(k, numtrials);
if (any (\~isfinite(modelLogLikelihoodHessian)))
 disp ('model hessian has non finite values')
 minval \= NaN;
 maxval \= NaN;
 trialValues \= \[];
 return;
end

\[V,D] \= eig(modelLogLikelihoodHessian);
if (any(D \> 0\))
 disp ('model hessian has non\-negative eigenvalues')
 minval \= NaN;
 maxval \= NaN;
 trialValues \= \[];
 return;
end

trialPoints \= repmat(modelParams,1,size(x,2\));
s \= 1\./sqrt(\-D(logical(eye(size(D,1\)))));
for j \= 1:length(modelParams)
 trialPoints \= trialPoints\+s(j)\*V(:,j)\*x(j,:);
end
%whos trialPoints
trialValues \= funOfModelParams(trialPoints);
%size(trialValues)
dim \= find(size(trialValues) \=\= length(trialPoints));
if (isempty(dim))
 dim \= 1;
end
minval \= min(trialValues,\[],dim);
maxval \= max(trialValues,\[],dim);



end


\-\-\-

\#\#\# File: recursiveDirectorySearch.m (ID: utility functions.24\)

function \[fileNames, relativePath] \= recursiveDirectorySearch(startingDirectory, fileSpecifier)
%function \[fileNames, relativePath] \= recursiveDirectorySearch(startingDirectory, fileSpecifier)
%
%returns complete paths to all files in startingDirectory or subdirectories
%that satisfy fileSpecifier
%
%example
%startingDirectory \= '\\\\labnas1\\share\\David\\Extracted\\Spatial'
%batfiles \= recursiveDirectorySearch(startingDirectory, '\*.bat')
if (nargin \< 2\)
 fileSpecifier \= '\*';
end
if (\~isempty(fileparts(fileSpecifier)))
 % fileSpecifier includes a directory
 \[fs, fs2, ext] \= fileparts(fileSpecifier);
 if (\~isempty(ext))
 fs2 \= \[fs2 ext];
 end
 fl \= recursiveDirectorySearch(startingDirectory, fs);
 fileNames \= {};
 
 for j \= 1:length(fl)
 d \= dir(fullfile(fl{j}, fs2\));
 for k \= 1:length(d)
 fileNames \= \[fileNames fullfile(fl{j}, d(k).name)]; %\#ok
 end
 end
else

 if (ispc)
 cmd \= \['dir /s /b "' fullfile(startingDirectory, fileSpecifier) '"'];

 else
 if (fileSpecifier(1\) \=\= '\*')
 fileSpecifier \= \['\\' fileSpecifier];
 end
 cmd \= \['find "' startingDirectory '" \-name ' fileSpecifier];
 % \[s,w] \= system(); % this has not been tested yet MHG 7/6/2011
 end
 \[s,w] \= system(cmd);
 if (s \~\= 0\)
 % warning (\['system command ' cmd ' returned an error code']);
 fileNames \= \[];
 relativePath \= \[];
 return;
 end
 fileNames \= regexp(w, '\[\\r\\n]\+', 'split');

 fileNames \= fileNames(cellfun(@(s) \~isempty(s),fileNames));
end

if (nargout \> 1\)
 for j \= 1:length(fileNames)
 relativePath{j} \= char(java.io.File(startingDirectory).toURI().relativize(java.io.File(fileNames{j}).toURI()).getPath());
 end
end

%{
p \= genpath(startingDirectory);
inds \= \[0 strfind(p,';')];
for j \= 1:(length(inds) \- 1\)
 directories{j} \= p((inds(j)\+1\):(inds(j\+1\) \- 1\));
end

fnnum \= 0;
for j \= 1:length(directories)
 d \= dir(\[directories{j} '\\' fileSpecifier]);
 for k \= 1:length(d)
 fnnum \= fnnum\+1;
 fileNames{fnnum} \= \[directories{j} '\\' d(k).name];
 end
end
%}
% 
% function shortPath \= getshortpath(longPath)
% fs \= actxserver('Scripting.FileSystemObject');
% shortPath \= fs.GetFolder(longPath).ShortPath;
% fs.delete;
% 
% function longPath \= getlongpath(shortPath)
% fs \= actxserver('Scripting.FileSystemObject');
% if (iscell(shortPath))
% for j \= 1:length(shortPath)
% longPath{j} \= fs.GetFolder(shortPath{j}).Path;
% end
% else
% longPath \= fs.GetFolder(shortPath).Path;
% end
\-\-\-

\#\#\# File: binarySearch.m (ID: utility functions.25\)

function ind \= binarySearch(x, xval, le, ind1, ind2\)
%DOES NOT WORK AS YOU MIGHT EXPECT \- AMBIGUITIES IN HOW EDGES ARE HANDLEDE
%function ind \= binarySearch(x, xval, le, ind1, ind2\)
%finds xval in ascending sorted list x between ind1 and ind2
%designed to be used to find nonoverlapping range
%le \= left edge
%if le is true x(ind) \<\= xval \< x(ind\+1\)
%if le is false xval \< x(ind\+1\);
if (ind2 \- ind1 \< 2\)
 if (le)
 if (xval \<\= x(ind1\))
 ind \= ind1;
 return;
 else
 if (xval \<\= x(ind2\))
 ind \= ind2;
 else
 ind \= \[];
 end
 return;
 end
 else
 if (x(ind2\) \< xval)
 ind \= ind2;
 return;
 else
 if (x(ind1\) \< xval)
 ind \= ind1;
 else
 ind \= \[];
 end
 return;
 end
% if (xval \< x(ind1\))
% ind \= ind1;
% return;
% else
% if (xval \< x(ind2\))
% ind \= ind2;
% else
% ind \= \[];
% end
% return;
% end
 end
end
 
ii \= ceil((ind1 \+ ind2\)/2\);
if (le)
 if (x(ii) \<\= xval)
 ind \= binarySearch(x, xval, le, ii, ind2\);
 return;
 else
 ind \= binarySearch(x, xval, le, ind1, ii);
 return;
 end
else
 if (x(ii) \< xval)
 ind \= binarySearch(x, xval, le, ii, ind2\);
 return;
 else
 ind \= binarySearch(x, xval, le, ind1, ii);
 return;
 end
end

\-\-\-

\#\#\# File: commonPath.m (ID: utility functions.26\)

function p \= commonPath (p1, p2\)
f1 \= java.io.File(p1\);
f2 \= java.io.File(p2\);

p1 \= char(f1\.getCanonicalPath);
p2 \= char(f2\.getCanonicalPath);

ll \= min(length(p1\),length(p2\));
ind \= find(p1(1:ll) \~\= p2(1:ll), 1, 'first');
if (isempty(ind))
 ind \= ll;
end
p \= p1(1:(ind\-1\));
if (isempty(strfind('\\/:', p(end))))
 p \= fileparts(p);
else
 p \= fileparts(fullfile(p, ''));
end

\-\-\-

\#\#\# File: findRangeInSortedData.m (ID: utility functions.27\)

function inds \= findRangeInSortedData(x, xmin, xmax)
%find all values of x in range \[xmin, xmax)

a \= 1;
b \= length(x);
if (x(end) \< xmin)
 inds \= \[];
 return;
end
if (x(1\) \>\= xmax)
 inds \= \[];
 return;
end

while (b \- a \> 1\)
 ii \= floor ((a\+b)/2\);
 if (x(ii) \< xmin)
 a \= ii;
 else
 b \= ii;
 end
end
if (x(a) \>\= xmin) %handle edge case
 ind1 \= a;
else
 ind1 \= b;
end
if (x(ind1\) \>\= xmax)
 inds \= \[];
 return;
end
a \= ind1;
b \= length(x);
while (b \- a \> 1\)
 ii \= ceil ((a\+b)/2\);
 if (x(ii) \>\= xmax)
 b \= ii;
 else
 a \= ii;
 end
end
if (x(b) \< xmax) %handle edge case
 ind2 \= b;
else
 ind2 \= a;
end
inds \= ind1:ind2;


\-\-\-

\#\#\# File: adjustForPolarHistogram.m (ID: utility functions.28\)

function values \= adjustForPolarHistogram(values, binCenters)
%function values \= adjustForPolarHistogram(values, binCenters)

lowedge \= 1\.5\*binCenters(1\) \- 0\.5\*binCenters(2\);
values \= mod(values \- lowedge, 2\*pi) \+ lowedge;

\-\-\-

\#\#\# File: toKerrChainCode.m (ID: utility functions.29\)

function ccstr \= toKerrChainCode(dx, dy)
dx \= round(dx);
dy \= round(dy);
if (any (dx \=\= dy \| abs(dx)\+abs(dy) \> 1\))
 error ('need 4 connected contour with single spacing;');
end
mat \= \[NaN 2 NaN; 0 NaN 1; NaN 3 NaN];

bc \= uint8(mat(sub2ind(size(mat),dy\+2,dx\+2\)));
switch (mod(length(dx), 3\))
 case 2
 bc \= \[bc 0];
 case 1
 bc \= \[bc 0 1];
end
ccstr \= char(((bitshift(bc(1:3:end),4\) \+ bitshift(bc(2:3:end),2\) \+ bc(3:3:end))) \+ '0');

\-\-\-

\#\#\# File: skewNormalMeanSq.m (ID: utility functions.30\)

function ms \= skewNormalMeanSq(u, s, a)
%
%mean and standard deviation of skew\-normal distribution with location u, scale s, and skew\-parameter a
%http://en.wikipedia.org/wiki/Skew\_normal\_distribution
\[mu, sigma] \= skewNormalMean(u, s, a);
ms \= mu.^2 \+ sigma.^2;
end


\-\-\-

\#\#\# File: getFileInfoFromBatFile.m (ID: utility functions.31\)

function \[directories, fstubs, outnames] \= getFileInfoFromBatFile(str)
%function \[directories, fstubs, extensions, outnames] \= getFileInfoFromBatFile(str)
%
%str contains the entire text of the bat file

fsinds \= strfind(str, 'file stub:');
ofinds \= strfind(str, 'output file:');

for j \= 1:length(fsinds)
 stub \= strtrim(sscanf(str(fsinds(j):end), 'file stub:%\[^\\n]s'));
 i \= strfind(stub, '\\');
 i \= i(end);
 directories{j} \= stub(1:i);
 fstubs{j} \= stub((i\+1\):end);
 
 outnames{j} \= strtrim(sscanf(str(ofinds(j):end), 'output file:%\[^\\n]s'));
end
\-\-\-

\#\#\# File: objToYaml.m (ID: utility functions.32\)

function str \= objToYaml(key, obj, handleRecurseLevel)
%parses an object to yaml using snakeyaml
%function str \= objToYaml(obj)
%
existsAndDefault('handleRecurseLevel', 0\);

import('org.yaml.snakeyaml.Yaml');
data \= java.util.HashMap();
arr \= javaArray('java.util.HashMap', length(obj));
for j \= 1:length(obj)
 arr(j) \= objToHashmap(obj(j), handleRecurseLevel);
end
data.put(key, arr);
yaml \= Yaml();
str \= yaml.dump(data);

%{

function data \= objToHashmap(obj, handleRecurseLevel)
data \= java.util.HashMap();
if (length(obj) \> 1\)
 arr \= javaArray('java.util.HashMap', length(obj));
 for j \= 1:length(obj)
 arr(j) \= objToHashmap(obj(j), handleRecurseLevel);
 end
 data \= arr;
 return;
end

existsAndDefault('handleRecurseLevel', 0\);
if (isa(obj, 'handle'))
 if (handleRecurseLevel \<\= 0\)
 warning ('oth:mrl', 'maximum handle recursion reached');
 data.put('handle type', class(obj));
 return;
 else
 handleRecurseLevel \= handleRecurseLevel \- 1;
 end
end
f \= fieldnames(obj);
for j \= 1:length(f)
 if (isobject(obj.(f{j})) \|\| isstruct(obj.(f{j})))
 data.put(f{j}, objToHashmap(obj.(f{j}), handleRecurseLevel));
 else
 data.put(f{j}, matlabArrToJavaArr(obj.(f{j})));
 end
 
end

function javatype \= getJavaType (matlabarr)
matlabtypes \= {'logical', 'single', 'double', 'char', 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64', 'uint64'};
javatypes \= {'Boolean', 'Float', 'Double', 'String', 'Byte', 'Byte', 'Short', 'Short', 'Int', 'Int', 'Long', 'Long'};
for j \= 1:length(matlabtypes)
 if (isa (matlabarr, matlabtypes{j}))
 javatype \= \['java.lang.' javatypes{j}];
 return;
 end
end
if (isnumeric(matlabarr))
 javatype \= 'java.lang.Double';
 return;
end
javatype \= 'java.lang.Object';

function arr \= matlabArrToJavaArr (matlabarr)
if ischar(matlabarr)
 matlabarr \= {matlabarr};
end
if (iscell(matlabarr))
 if (iscellstr(matlabarr))
 javatype \= 'java.lang.String';
 arr \= javaArray('java.lang.String', max(1,length(matlabarr)));
 else
 try 
 matlabarr \= cell2mat(matlabarr);
 javatype \= getJavaType(matlabarr);
 catch
 warning ('could not convert cell to array');
 javatype \= 'java.lang.Object';
 end
 end
else
 javatype \= getJavaType(matlabarr);
end
arr \= javaArray(javatype, max(1,length(matlabarr)));

if (iscellstr(matlabarr))
 for j \= 1:length(matlabarr)
 arr(j) \= javaObject(javatype, matlabarr{j});
 end
 return;
end
if (iscell(matlabarr))
 for j \= 1:length(matlabarr)
 if isa(matlabarr{j}, 'function\_handle')
 msg \= func2str(matlabarr{j});
 arr(j) \= java.lang.String(msg);
 else
 arr(j) \= matlabArrToJavaArr(matlabarr{j});
 end
 end
 return;
end

for j \= 1:length(matlabarr)
 if (strcmpi(javatype, 'java.lang.Object'))
 if isa(matlabarr(j), 'function\_handle')
 msg \= func2str(matlabarr(j));
 else
 msg \= 'unknown type';
 end
 arr(j) \= java.lang.String(msg);
 else
 arr(j) \= javaObject(javatype,matlabarr(j));
 end
end
%}
\-\-\-

\#\#\# File: createTimFile.m (ID: utility functions.33\)

function timinfo \= createTimFile (directory, file\_stub, outputfile, varargin)
%function timinfo \= createTimFile (directory, file\_stub, outputfile, varargin)
%
%creates a fake timing file based on file save times
%
%directory \- the directory containing all the image files, including the
%last '\\'
%file\_stub \- the part of the file preceding the numeric portion
%outputfile \- the file to which timing info should be saved (to create a
%fake .tim file) \-\- optional
%timinfo \- if you ask for a return, it will give you the three columns
%(including a column of 0s) that will be saved in the .tim file
%
%optional parameter/value pairs
%'extension', '.ext' \-\- if the extension is not jpg, pass it (including the
%dot) 
%'verbose', true/false \-\- if you want extra details
%
%example:
%dirfn \= '\\\\labnas1\\share\\David\\Image Data\\david\\20090306\\18\-23\_C25\_1\\';
%fstub \= 'N2g15\_';
%createTimFile
verbose \= false;
extension \= '.jpg';
varargin \= assignApplicable(varargin);

if (verbose)
 ts \= tic;
 disp ('getting directory information');
end

d \= dir(\[directory file\_stub '\*' extension]);

if (verbose)
 toc(ts);
 disp (\[num2str(length(d)) ' files found']);
end

\[inds,I] \= sort(sscanf(\[d.name], \[file\_stub '%d' extension]));
inds \= inds';
pictim \= \[d(I).datenum]; %datenum is in days
pictim \= reshape(pictim, size(inds));
pictim \= (pictim\-min(pictim))\* 24 \* 3600;
%stepinds \= find(diff(pictim) \> 0\);
%sigma \= 3 \* max(diff(stepinds));
sigma \= 10;
if (verbose)
 disp (\['low passing with sigma \= ' num2str(sigma)]);
end
mselapsed \= 1000 \* lowpass1D(pictim, sigma,'padType','mirror');

triggernum \= zeros(size(inds));
tinfo \= uint32(round(\[mselapsed;triggernum;pictim]));

existsAndDefault('outputfile', \[]);
if (\~isempty(outputfile))
 if (verbose)
 disp (\['saving tim info to ', outputfile]);
 end
 fid \= fopen(outputfile, 'w');
 fprintf(fid, '%d\\t%d\\t%d\\n', tinfo);
 fclose(fid);
end
if (nargout \> 0\)
 timinfo \= tinfo;
end
\-\-\-

\#\#\# File: plotboxpos.m (ID: utility functions.34\)

function pos \= plotboxpos(h)
%PLOTBOXPOS Returns the position of the plotted axis region
%
% pos \= plotboxpos(h)
%
% This function returns the position of the plotted region of an axis,
% which may differ from the actual axis position, depending on the axis
% limits, data aspect ratio, and plot box aspect ratio. The position is
% returned in the same units as the those used to define the axis itself.
% This function can only be used for a 2D plot. 
%
% Input variables:
%
% h: axis handle of a 2D axis
%
% Output variables:
%
% pos: four\-element position vector, in same units as h

% Copyright 2010 Kelly Kearney

% Check input

if \~ishandle(h) \|\| \~strcmp(get(h,'type'), 'axes')
 error('Input must be an axis handle');
end

% Get position of axis in pixels

currunit \= get(h, 'units');
set(h, 'units', 'pixels');
axisPos \= get(h, 'Position');
set(h, 'Units', currunit);

% Calculate box position based axis limits and aspect ratios

darismanual \= strcmpi(get(h, 'DataAspectRatioMode'), 'manual');
pbarismanual \= strcmpi(get(h, 'PlotBoxAspectRatioMode'), 'manual');

if \~darismanual \&\& \~pbarismanual
 
 pos \= axisPos;
 
else

 dx \= diff(get(h, 'XLim'));
 dy \= diff(get(h, 'YLim'));
 dar \= get(h, 'DataAspectRatio');
 pbar \= get(h, 'PlotBoxAspectRatio');

 limDarRatio \= (dx/dar(1\))/(dy/dar(2\));
 pbarRatio \= pbar(1\)/pbar(2\);
 axisRatio \= axisPos(3\)/axisPos(4\);

 if darismanual
 if limDarRatio \> axisRatio
 pos(1\) \= axisPos(1\);
 pos(3\) \= axisPos(3\);
 pos(4\) \= axisPos(3\)/limDarRatio;
 pos(2\) \= (axisPos(4\) \- pos(4\))/2 \+ axisPos(2\);
 else
 pos(2\) \= axisPos(2\);
 pos(4\) \= axisPos(4\);
 pos(3\) \= axisPos(4\) \* limDarRatio;
 pos(1\) \= (axisPos(3\) \- pos(3\))/2 \+ axisPos(1\);
 end
 elseif pbarismanual
 if pbarRatio \> axisRatio
 pos(1\) \= axisPos(1\);
 pos(3\) \= axisPos(3\);
 pos(4\) \= axisPos(3\)/pbarRatio;
 pos(2\) \= (axisPos(4\) \- pos(4\))/2 \+ axisPos(2\);
 else
 pos(2\) \= axisPos(2\);
 pos(4\) \= axisPos(4\);
 pos(3\) \= axisPos(4\) \* pbarRatio;
 pos(1\) \= (axisPos(3\) \- pos(3\))/2 \+ axisPos(1\);
 end
 end
end

% Convert plot box position to the units used by the axis

temp \= axes('Units', 'Pixels', 'Position', pos, 'Visible', 'off');
set(temp, 'Units', currunit);
pos \= get(temp, 'position');
delete(temp);
\-\-\-

\#\#\# File: fieldNamesAndSizes.m (ID: utility functions.35\)

function nas \= fieldNamesAndSizes (structin)

fn \= fieldnames(structin);

for j \= 1:length(fn)
 bob \= structin.(fn{j}); 
 rob \= whos('bob');
 nas(j).name \= fn{j};
 nas(j).bytes \= rob.bytes;
end
\[\~,I] \= sort(\[nas.bytes], 'descend');
nas \= nas(I);

\-\-\-

\#\#\# File: heavisideStep.m (ID: utility functions.36\)

function \[ Y ] \= heavisideStep( X )
%HEAVISIDEFUNCTION Summary of this function goes here
% We are using this so we can compile the code since MATLAB does not
% allow compilation of functions of the Symbolic Math Toolbox

Y \= zeros(size(X));
Y(X \> 0\) \= 1;
Y(X \=\= 0\) \= .5;

end


\-\-\-

\#\#\# File: getSomeArgsOut.m (ID: utility functions.37\)

function varargout \= getSomeArgsOut (args, fun, varargin) %\#ok
%function varargout \= getSomeArgsOut (args, fun, varargin)
%
%calls fun(varargin{:}) and returns the arguments selected by args
%
%example usage:
%\>\>getSomeArgsOut(1, @max, (1:7\).^2\)
%ans \=
% 49
%\>\>getSomeArgsOut(2, @max, (1:7\).^2\)
%ans \=
% 7

arglist \= '\[';
for j \= 1:max(args)
 if (j \~\= 1\)
 arglist \= \[arglist ',']; %\#ok\<\*AGROW\>
 end
 if (any(args \=\= j))
 arglist \= \[arglist 'arg' num2str(j)];
 else
 arglist \= \[arglist '\~'];
 end
end
arglist \= \[arglist ']'];

eval(\[arglist ' \= fun(varargin{:});']);

for j \= 1:length(args)
 eval( \['varargout{j} \= arg' num2str(args(j)) ';']);
end

 
 
 
\-\-\-

\#\#\# File: stripFunctionHandles.m (ID: utility functions.38\)

function mystruct \= stripFunctionHandles( mystruct )
% function mystruct \= stripFunctionHandles( mystruct )
% converts any function handles in struct or nested structures
% to strings
% the purpose is to remove stack data saved with the function that leads
% to large file sizes

if (isstruct(mystruct))
 fn \= fieldnames(mystruct);
 for k \= 1:length(mystruct)
 for j \= 1:length(fn)
 mystruct(k).(fn{j}) \= stripFunctionHandles(mystruct(k).(fn{j}));
 end
 end
 return;
end
if (iscell(mystruct))
 for k \= 1:length(mystruct)
 mystruct{k} \= stripFunctionHandles(mystruct{k});
 
 end
 return;
end

if isa(mystruct, 'function\_handle')
 mystruct \= func2str(mystruct);
end

end


\-\-\-

\#\#\# File: detectTimingGaps.m (ID: utility functions.39\)

function tr \= detectTimingGaps (basedir, varargin)
% looks through all .tim files and detects large gaps in acquistition time
% function timingreport \= detectTimingGaps (basedir, varargin)
% optional arguments:
% mingap \= 1000; minimum gap time in milliseconds

mingap \= 1000;
varargin \= assignApplicable(varargin);

timfiles \= recursiveDirectorySearch(basedir, '\*.tim');
if (isempty(timfiles))
 tr \= \[];
 return;
end

for j \= 1:length(timfiles)
 data \= load(timfiles{j});
 t \= data(:,1\);
 ind \= find(diff(t) \< 0, 1, 'first');
 while (\~isempty(ind))
 t((ind\+1\):end) \= t((ind\+1\):end) \+ 65536;
 ind \= find(diff(t) \< 0, 1, 'first');
 end
 tr(j).fname \= timfiles{j};
 tr(j).maxdt \= max(diff(t));
 tr(j).nbad \= sum(diff(t) \> mingap);
 tr(j).haserrors \= tr(j).nbad \> 0;
 tr(j).et \= t;
end

disp (\[num2str(length(timfiles)) ' files examined. ' num2str(sum(\[tr.haserrors])) ' have large timing gaps.']);
if (any(\[tr.haserrors]))
 disp ('the following files have errors: ');
 for j \= 1:length(tr)
 if (tr(j).haserrors)
 disp(\[tr(j).fname ' \- max gap ' num2str(tr(j).maxdt)]);
 end
 end
end
\-\-\-

\#\#\# File: parseDotField.m (ID: utility functions.40\)

function value \= parseDotField(obj, dotfieldstring)
%function value \= parseDotField(obj, dotfieldstring)

fields \= textscan(dotfieldstring,'%s','Delimiter','.');
value \= getfield(obj,fields{1}{:});
\-\-\-

\#\#\# File: findGaussianKernel.m (ID: utility functions.41\)

function \[kernel, amp, sigma, offset] \= findGaussianKernel(xdata, convdata, x)
%function \[kernel, amp, sigma, offset] \= findGaussianKernel(xdata, convdata)
%
%finds the gaussian kernel that minimizes the square error between
%conv(xdata, kernel) and convdata
%amp \= area of gaussian
%sigma \= standard deviation of gaussian
%offset \= location of maximum point relative to center of kernel

existsAndDefault('x',\[mean(convdata)/mean(xdata), 1, 0]);
x \= lsqcurvefit(@convWithKernel,x,xdata,convdata);
kernel \= gaussWithOffset(x(1\), x(2\), x(3\));
amp \= x(1\);
sigma \= x(2\);
offset \= x(3\);

function yout \= convWithKernel(x, xdata)
k \= gaussWithOffset(x(1\), x(2\), x(3\));
yout \= conv(xdata, k, 'same');

\-\-\-

\#\#\# File: polygeom.m (ID: utility functions.42\)

function \[ geom, iner, cpmo ] \= polygeom( x, y ) 
%POLYGEOM Geometry of a planar polygon
%
% POLYGEOM( X, Y ) returns area, X centroid,
% Y centroid and perimeter for the planar polygon
% specified by vertices in vectors X and Y.
%
% \[ GEOM, INER, CPMO ] \= POLYGEOM( X, Y ) returns
% area, centroid, perimeter and area moments of 
% inertia for the polygon.
% GEOM \= \[ area X\_cen Y\_cen perimeter ]
% INER \= \[ Ixx Iyy Ixy Iuu Ivv Iuv ]
% u,v are centroidal axes parallel to x,y axes.
% CPMO \= \[ I1 ang1 I2 ang2 J ]
% I1,I2 are centroidal principal moments about axes
% at angles ang1,ang2\.
% ang1 and ang2 are in radians.
% J is centroidal polar moment. J \= I1 \+ I2 \= Iuu \+ Ivv

% H.J. Sommer III \- 02\.05\.14 \- tested under MATLAB v5\.2
%
% sample data
% x \= \[ 2\.000 0\.500 4\.830 6\.330 ]';
% y \= \[ 4\.000 6\.598 9\.098 6\.500 ]';
% 3x5 test rectangle with long axis at 30 degrees
% area\=15, x\_cen\=3\.415, y\_cen\=6\.549, perimeter\=16
% Ixx\=659\.561, Iyy\=201\.173, Ixy\=344\.117
% Iuu\=16\.249, Ivv\=26\.247, Iuv\=8\.660
% I1\=11\.249, ang1\=30deg, I2\=31\.247, ang2\=120deg, J\=42\.496
%
% H.J. Sommer III, Ph.D., Professor of Mechanical Engineering, 337 Leonhard Bldg
% The Pennsylvania State University, University Park, PA 16802
% (814\)863\-8997 FAX (814\)865\-9693 hjs1@psu.edu www.me.psu.edu/sommer/

% begin function POLYGEOM

% check if inputs are same size
if \~isequal( size(x), size(y) ),
 error( 'X and Y must be the same size');
end

% number of vertices
\[ x, ns ] \= shiftdim( x );
\[ y, ns ] \= shiftdim( y );
\[ n, c ] \= size( x );

% temporarily shift data to mean of vertices for improved accuracy
xm \= mean(x);
ym \= mean(y);
x \= x \- xm\*ones(n,1\);
y \= y \- ym\*ones(n,1\);

% delta x and delta y
dx \= x( \[ 2:n 1 ] ) \- x;
dy \= y( \[ 2:n 1 ] ) \- y;

% summations for CW boundary integrals
A \= sum( y.\*dx \- x.\*dy )/2;
Axc \= sum( 6\*x.\*y.\*dx \-3\*x.\*x.\*dy \+3\*y.\*dx.\*dx \+dx.\*dx.\*dy )/12;
Ayc \= sum( 3\*y.\*y.\*dx \-6\*x.\*y.\*dy \-3\*x.\*dy.\*dy \-dx.\*dy.\*dy )/12;
Ixx \= sum( 2\*y.\*y.\*y.\*dx \-6\*x.\*y.\*y.\*dy \-6\*x.\*y.\*dy.\*dy ...
 \-2\*x.\*dy.\*dy.\*dy \-2\*y.\*dx.\*dy.\*dy \-dx.\*dy.\*dy.\*dy )/12;
Iyy \= sum( 6\*x.\*x.\*y.\*dx \-2\*x.\*x.\*x.\*dy \+6\*x.\*y.\*dx.\*dx ...
 \+2\*y.\*dx.\*dx.\*dx \+2\*x.\*dx.\*dx.\*dy \+dx.\*dx.\*dx.\*dy )/12;
Ixy \= sum( 6\*x.\*y.\*y.\*dx \-6\*x.\*x.\*y.\*dy \+3\*y.\*y.\*dx.\*dx ...
 \-3\*x.\*x.\*dy.\*dy \+2\*y.\*dx.\*dx.\*dy \-2\*x.\*dx.\*dy.\*dy )/24;
P \= sum( sqrt( dx.\*dx \+dy.\*dy ) );

% check for CCW versus CW boundary
if A \< 0,
 A \= \-A;
 Axc \= \-Axc;
 Ayc \= \-Ayc;
 Ixx \= \-Ixx;
 Iyy \= \-Iyy;
 Ixy \= \-Ixy;
end

% centroidal moments
xc \= Axc / A;
yc \= Ayc / A;
Iuu \= Ixx \- A\*yc\*yc;
Ivv \= Iyy \- A\*xc\*xc;
Iuv \= Ixy \- A\*xc\*yc;
J \= Iuu \+ Ivv;

% replace mean of vertices
x\_cen \= xc \+ xm;
y\_cen \= yc \+ ym;
Ixx \= Iuu \+ A\*y\_cen\*y\_cen;
Iyy \= Ivv \+ A\*x\_cen\*x\_cen;
Ixy \= Iuv \+ A\*x\_cen\*y\_cen;

% principal moments and orientation
I \= \[ Iuu \-Iuv ;
 \-Iuv Ivv ];
\[ eig\_vec, eig\_val ] \= eig(I);
I1 \= eig\_val(1,1\);
I2 \= eig\_val(2,2\);
ang1 \= atan2( eig\_vec(2,1\), eig\_vec(1,1\) );
ang2 \= atan2( eig\_vec(2,2\), eig\_vec(1,2\) );

% return values
geom \= \[ A x\_cen y\_cen P ];
iner \= \[ Ixx Iyy Ixy Iuu Ivv Iuv ];
cpmo \= \[ I1 ang1 I2 ang2 J ];

% end of function POLYGEOM


\-\-\-

\#\#\# File: parseXML.m (ID: utility functions.43\)

function theStruct \= parseXML(filename)
% PARSEXML Convert XML file to a MATLAB structure.
try
 tree \= xmlread(filename);
catch
 error('Failed to read XML file %s.',filename);
end

% Recurse over child nodes. This could run into problems 
% with very deeply nested trees.
try
 theStruct \= parseChildNodes(tree);
catch
 error('Unable to parse XML file %s.',filename);
end


% \-\-\-\-\- Subfunction PARSECHILDNODES \-\-\-\-\-
function children \= parseChildNodes(theNode)
% Recurse over node children.
children \= \[];
if theNode.hasChildNodes
 childNodes \= theNode.getChildNodes;
 numChildNodes \= childNodes.getLength;
 allocCell \= cell(1, numChildNodes);

 children \= struct( ...
 'Name', allocCell, 'Attributes', allocCell, ...
 'Data', allocCell, 'Children', allocCell);

 for count \= 1:numChildNodes
 theChild \= childNodes.item(count\-1\);
 children(count) \= makeStructFromNode(theChild);
 end
end

% \-\-\-\-\- Subfunction MAKESTRUCTFROMNODE \-\-\-\-\-
function nodeStruct \= makeStructFromNode(theNode)
% Create structure of node info.

nodeStruct \= struct( ...
 'Name', char(theNode.getNodeName), ...
 'Attributes', parseAttributes(theNode), ...
 'Data', '', ...
 'Children', parseChildNodes(theNode));

if any(strcmp(methods(theNode), 'getData'))
 nodeStruct.Data \= char(theNode.getData); 
else
 nodeStruct.Data \= '';
end

% \-\-\-\-\- Subfunction PARSEATTRIBUTES \-\-\-\-\-
function attributes \= parseAttributes(theNode)
% Create attributes structure.

attributes \= \[];
if theNode.hasAttributes
 theAttributes \= theNode.getAttributes;
 numAttributes \= theAttributes.getLength;
 allocCell \= cell(1, numAttributes);
 attributes \= struct('Name', allocCell, 'Value', ...
 allocCell);

 for count \= 1:numAttributes
 attrib \= theAttributes.item(count\-1\);
 attributes(count).Name \= char(attrib.getName);
 attributes(count).Value \= char(attrib.getValue);
 end
end
\-\-\-

\#\#\# File: relativepath.m (ID: utility functions.44\)

function rel\_path \= relativepath( tgt\_path, act\_path )
%RELATIVEPATH returns the relative path from an actual path to the target path.
% Both arguments must be strings with absolute paths.
% The actual path is optional, if omitted the current dir is used instead.
% In case the volume drive letters don't match, an absolute path will be returned.
% If a relative path is returned, it always starts with '.\\' or '..\\'
%
% Syntax:
% rel\_path \= RELATIVEPATH( target\_path, actual\_path )
% 
% Parameters:
% target\_path \- Path which is targetted
% actual\_path \- Start for relative path (optional, default \= current dir)
%
% Examples:
% relativepath( 'C:\\local\\data\\matlab' , 'C:\\local' ) \= '.\\data\\matlab\\'
% relativepath( 'A:\\MyProject\\' , 'C:\\local' ) \= 'a:\\myproject\\'
%
% relativepath( 'C:\\local\\data\\matlab' , cd ) is the same as
% relativepath( 'C:\\local\\data\\matlab' )
%
% See also: ABSOLUTEPATH PATH

% Jochen Lenz


% 2nd parameter is optional:
if nargin \< 2
 act\_path \= cd;
end

% Predefine return string:
rel\_path \= '';

% Make sure strings end by a filesep character:
if length(act\_path) \=\= 0 \| \~isequal(act\_path(end),filesep)
 act\_path \= \[act\_path filesep];
end
if length(tgt\_path) \=\= 0 \| \~isequal(tgt\_path(end),filesep)
 tgt\_path \= \[tgt\_path filesep];
end

% Convert to all lowercase:
\[act\_path] \= fileparts( lower(act\_path) );
\[tgt\_path] \= fileparts( lower(tgt\_path) );

% Create a cell\-array containing the directory levels:
act\_path\_cell \= pathparts(act\_path);
tgt\_path\_cell \= pathparts(tgt\_path);

% If volumes are different, return absolute path:
if length(act\_path\_cell) \=\= 0 \| length(tgt\_path\_cell) \=\= 0
 return % rel\_path \= ''
else
 if \~isequal( act\_path\_cell{1} , tgt\_path\_cell{1} )
 rel\_path \= tgt\_path;
 return
 end
end

% Remove level by level, as long as both are equal:
while length(act\_path\_cell) \> 0 \& length(tgt\_path\_cell) \> 0
 if isequal( act\_path\_cell{1}, tgt\_path\_cell{1} )
 act\_path\_cell(1\) \= \[];
 tgt\_path\_cell(1\) \= \[];
 else
 break
 end
end

% As much levels down ('..\\') as levels are remaining in "act\_path":
for i \= 1 : length(act\_path\_cell)
 rel\_path \= \['..' filesep rel\_path];
end

% Relative directory levels to target directory:
for i \= 1 : length(tgt\_path\_cell)
 rel\_path \= \[rel\_path tgt\_path\_cell{i} filesep];
end

% Start with '.' or '..' :
if isempty(rel\_path)
 rel\_path \= \['.' filesep];
elseif \~isequal(rel\_path(1\),'.')
 rel\_path \= \['.' filesep rel\_path];
end

return

% \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

function path\_cell \= pathparts(path\_str)

path\_str \= \[filesep path\_str filesep];
path\_cell \= {};

sep\_pos \= findstr( path\_str, filesep );
for i \= 1 : length(sep\_pos)\-1
 path\_cell{i} \= path\_str( sep\_pos(i)\+1 : sep\_pos(i\+1\)\-1 );
end

return
\-\-\-

\#\#\# File: skewNormalPDF.m (ID: utility functions.45\)

function pdf \= skewNormalPDF(x, u, s, a)
%function pdf \= skewNormalPDF(x, u, s, a)
%skew\-normal distribution with location parameter u, scale parameter s, and skew\-parameter a
%http://en.wikipedia.org/wiki/Skew\_normal\_distribution
%pdf \= 1/sqrt(2\*pi)\*exp(\-(x\-u).^2/(2\*s^2\)).\*(1\+erf(a \* (x \- u)/(sqrt(2\)\*s)));

%1/(pi\*s)\*exp(\-(x\-u)^2/(2\*s^2\)) \* Sqrt\[\\\[Pi]/2] Erfc\[(a (u \- x))/(Sqrt\[2] s)]
%pdf \= 1/(sqrt(2\*pi).\*s).\*exp(\-(x\-u).^2\./(2\*s.^2\)).\*(1\+erf(a .\* (x \- u)./((sqrt(2\).\*s))));


%pdf \= 1\./ sqrt(2\* pi) ./ s .\* exp(\-(x\-u).^2\./(2\*s.^2\)) .\* erfc(a .\* (u \- x)./sqrt(2\)./s);

%Erfc\[\-((a\*(\-u \+ x))/(Sqrt\[2]\*s))]/(E^((\-u \+ x)^2/(2\*s^2\))\*Sqrt\[2\*Pi]\*s)
pdf \= erfc(\-((a.\*(\-u \+ x))./(sqrt(2\).\*s))).\*exp(\-(\-u \+ x).^2/(2\.\*s^2\))./(sqrt(2\*pi).\*s);

end


\-\-\-

\#\#\# File: subdir.m (ID: utility functions.46\)

function varargout \= subdir(varargin)
%SUBDIR Performs a recursive file search
%
% subdir
% subdir(name)
% files \= subdir(...)
%
% This function performs a recursive file search. The input and output
% format is identical to the dir function.
%
% Input variables:
%
% name: pathname or filename for search, can be absolute or relative
% and wildcards (\*) are allowed. If ommitted, the files in the
% current working directory and its child folders are returned 
%
% Output variables:
%
% files: m x 1 structure with the following fields:
% name: full filename
% date: modification date timestamp
% bytes: number of bytes allocated to the file
% isdir: 1 if name is a directory; 0 if no
%
% Example:
%
% \>\> a \= subdir(fullfile(matlabroot, 'toolbox', 'matlab', '\*.mat'))
%
% a \= 
%
% 67x1 struct array with fields:
% name
% date
% bytes
% isdir
%
% \>\> a(2\)
%
% ans \= 
%
% name: '/Applications/MATLAB73/toolbox/matlab/audiovideo/chirp.mat'
% date: '14\-Mar\-2004 07:31:48'
% bytes: 25276
% isdir: 0
%
% See also:
%
% dir

% Copyright 2006 Kelly Kearney


%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% Get folder and filter
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

error(nargchk(0,1,nargin));
error(nargoutchk(0,1,nargout));

if nargin \=\= 0
 folder \= pwd;
 filter \= '\*';
else
 \[folder, name, ext] \= fileparts(varargin{1});
 if isempty(folder)
 folder \= pwd;
 end
 if isempty(ext)
 if isdir(fullfile(folder, name))
 folder \= fullfile(folder, name);
 filter \= '\*';
 end
 else
 filter \= \[name ext];
 end
end

%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% Search all folders
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

pathstr \= genpath(folder);
seplocs \= findstr(pathstr, pathsep);
loc1 \= \[1 seplocs(1:end\-1\)\+1];
loc2 \= seplocs(1:end)\-1;
pathfolders \= arrayfun(@(a,b) pathstr(a:b), loc1, loc2, 'UniformOutput', false);

Files \= \[];
for ifolder \= 1:length(pathfolders)
 NewFiles \= dir(fullfile(pathfolders{ifolder}, filter));
 if \~isempty(NewFiles)
 fullnames \= cellfun(@(a) fullfile(pathfolders{ifolder}, a), {NewFiles.name}, 'UniformOutput', false); 
 \[NewFiles.name] \= deal(fullnames{:});
 Files \= \[Files; NewFiles];
 end
end

%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
% Output
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 
if nargout \=\= 0
 if \~isempty(Files)
 fprintf('\\n');
 fprintf('%s\\n', Files.name);
 fprintf('\\n');
 end
elseif nargout \=\= 1
 varargout{1} \= Files;
end

\-\-\-

\#\#\# File: randomFromKBall.m (ID: utility functions.47\)

function x \= randomFromKBall (k, npts)
%function x \= randomFromKBall (k, npts)
%
%picks random points uniformly from the ball in k dimensions

x \= randn(k, npts);
r \= sqrt(sum(x.^2, 1\));
pf \= rand(1, npts).^(1/k)./r;
for j \= 1:k
 x(j,:) \= x(j,:).\*pf;
end

\-\-\-

\#\#\# File: skewNormalMean.m (ID: utility functions.48\)

function \[mu, sigma] \= skewNormalMean(u, s, a)
%function \[mu, sigma] \= skewNormalMean(u, s, a)
%mean and standard deviation of skew\-normal distribution with location u, scale s, and skew\-parameter a
%http://en.wikipedia.org/wiki/Skew\_normal\_distribution
delta \= a./sqrt(1\+a.^2\);
mu \= u \+ delta.\*s.\*sqrt(2/pi);
sigma \= s.\*sqrt(1\-2\.\*delta.^2/pi);
end


\-\-\-

\#\#\# Folder: utility functions/signal generation (ID: utility functions.signal generation)

\-\-\-

\#\#\# File: randomround.m (ID: utility functions.signal generation.1\)

function xr \= randomround(x)

fx \= floor(x);
dx \= x \- fx;
xr \= fx \+ double(dx \> rand(size(dx)));
\-\-\-

\#\#\# File: matchRoundedVar.m (ID: utility functions.signal generation.2\)

function normSigma \= matchRoundedVar(targetSigma)
%function normSigma \= matchRoundedVar(targetSigma)
%gives a new value of sigma s.t. round(randn(\[1 N]) \* normSigma) has the
%standard deviation targetSigma
%
%note that despite function name, you give target std dev, not variance

if (length(targetSigma) \> 1\)
 normSigma \= targetSigma;
 for j \= 1:length(targetSigma)
 normSigma(j) \= matchRoundedVar(targetSigma(j));
 end
 return;
end

if (2\*normcdf(\-1\.5, 0, targetSigma) \< 1e\-4\) %probability of a number other than 0,\+/\-1 \< 1e\-4, so variance is \= pval of 0\.5 \| sigma
 normSigma \= \-0\.5\./norminv(.5 \* targetSigma.^2, 0, 1\);
 return;
end

%maxreps \= 100;
nsamples \= 1e7;
%normSigma \= targetSigma;
rd \= randn(\[1 nsamples]);
%convergence \= 1e\-3;

normSigma \= fminbnd(@(s) (std(round(rd\*s))\-targetSigma).^2, targetSigma/10, targetSigma \* 2\);

% for j \= 1:maxreps
% s \= std(round(rd\*normSigma));
% if (s \=\= 0\)
% normSigma \= normSigma \* 2;
% else
% normSigma \= normSigma \* targetSigma/s;
% end
% if (abs(s/targetSigma \- 1\) \< convergence)
% break;
% end
% end
\-\-\-

\#\#\# File: randomWalkLinear.m (ID: utility functions.signal generation.3\)

function x \= randomWalkLinear(n, sigma, minval, maxval)
%function x \= randomWalkLinear(n, sigma, minval, maxval)
%
%n is number of samples, minval is minimum value: default 0 , maxval is
%maximum value (default: 255\)
%sigma is step size (in log units) default 1

existsAndDefault('sigma', 1\);
existsAndDefault('minval', 0\);
existsAndDefault('maxval', 255\);
%x0 \= log(exp(maxval) \+ exp(minval));
x0 \= 0\.5 \* (maxval \+ minval);


x \= zeros(\[1 n]);
dx \= sigma\*randn(\[1 n]);
x(1\) \= x0;
for j \= 2:length(dx)
 x(j) \= x(j\-1\) \+ dx(j);
 if (x(j) \< minval)
 x(j) \= 2\*minval\-x(j);
 end
 if (x(j) \> maxval)
 x(j) \= 2\*maxval \- x(j);
 end
end

x \= randomRound(x);

function z \= randomRound(y)
z \= floor(y);
z \= z\+(rand(size(z)) \< z\-y);


% 
% 
% x \= x0 \+ cumsum(sigma\*randn(\[1 n]));
% ind \= find (x \> maxval \| x \< minval, 1, 'first');
% while (\~isempty(ind))
% if (x(ind) \< minval)
% x(ind:end) \= 2\*minval \- x(ind:end);
% else
% x(ind:end) \= 2\*maxval \- x(ind:end);
% end
% ind \= find (x \> maxval \| x \< minval, 1, 'first');
% end
% 
% x \= round(exp(x));

\-\-\-

\#\#\# File: randomWalkInLogarithms.m (ID: utility functions.signal generation.4\)

function x \= randomWalkInLogarithms(n, sigma, minval, maxval)
%function randomWalkInLogarithms(n, sigma, minval, maxval)
%
%n is number of samples, minval is minimum value in log units(default: log(1\) \= 0\), maxval is
%maximum value (default: log(255\) \= 5\.5413\)
%sigma is step size (in log units) (default log(255\)/255 \= 0\.0217\)

existsAndDefault('sigma', 0\.0217\);
existsAndDefault('minval', 0\);
existsAndDefault('maxval', log(255\));
%x0 \= log(exp(maxval) \+ exp(minval));
x0 \= 0\.5 \* (maxval \+ minval);


x \= zeros(\[1 n]);
dx \= sigma\*randn(\[1 n]);
x(1\) \= x0;
for j \= 2:length(dx)
 x(j) \= x(j\-1\) \+ dx(j);
 if (x(j) \< minval)
 x(j) \= 2\*minval\-x(j);
 end
 if (x(j) \> maxval)
 x(j) \= 2\*maxval \- x(j);
 end
end

x \= randomRound(exp(x));

function z \= randomRound(y)
z \= floor(y);
z \= z\+(rand(size(z)) \< z\-y);


% 
% 
% x \= x0 \+ cumsum(sigma\*randn(\[1 n]));
% ind \= find (x \> maxval \| x \< minval, 1, 'first');
% while (\~isempty(ind))
% if (x(ind) \< minval)
% x(ind:end) \= 2\*minval \- x(ind:end);
% else
% x(ind:end) \= 2\*maxval \- x(ind:end);
% end
% ind \= find (x \> maxval \| x \< minval, 1, 'first');
% end
% 
% x \= round(exp(x));

\-\-\-

\#\#\# Folder: utility functions/DERIVESTsuite (ID: utility functions.DERIVESTsuite)

\-\-\-

\#\#\# File: derivest.m (ID: utility functions.DERIVESTsuite.1\)

function \[der,errest,finaldelta] \= derivest(fun,x0,varargin)
% DERIVEST: estimate the n'th derivative of fun at x0, provide an error estimate
% usage: \[der,errest] \= DERIVEST(fun,x0\) % first derivative
% usage: \[der,errest] \= DERIVEST(fun,x0,prop1,val1,prop2,val2,...)
%
% Derivest will perform numerical differentiation of an
% analytical function provided in fun. It will not
% differentiate a function provided as data. Use gradient
% for that purpose, or differentiate a spline model.
%
% The methods used by DERIVEST are finite difference
% approximations of various orders, coupled with a generalized
% (multiple term) Romberg extrapolation. This also yields
% the error estimate provided. DERIVEST uses a semi\-adaptive
% scheme to provide the best estimate that it can by its
% automatic choice of a differencing interval.
%
% Finally, While I have not written this function for the
% absolute maximum speed, speed was a major consideration
% in the algorithmic design. Maximum accuracy was my main goal.
%
%
% Arguments (input)
% fun \- function to differentiate. May be an inline function,
% anonymous, or an m\-file. fun will be sampled at a set
% of distinct points for each element of x0\. If there are
% additional parameters to be passed into fun, then use of
% an anonymous function is recommended.
%
% fun should be vectorized to allow evaluation at multiple
% locations at once. This will provide the best possible
% speed. IF fun is not so vectorized, then you MUST set
% 'vectorized' property to 'no', so that derivest will
% then call your function sequentially instead.
%
% Fun is assumed to return a result of the same
% shape as its input x0\.
%
% x0 \- scalar, vector, or array of points at which to
% differentiate fun.
%
% Additional inputs must be in the form of property/value pairs.
% Properties are character strings. They may be shortened
% to the extent that they are unambiguous. Properties are
% not case sensitive. Valid property names are:
%
% 'DerivativeOrder', 'MethodOrder', 'Style', 'RombergTerms'
% 'FixedStep', 'MaxStep'
%
% All properties have default values, chosen as intelligently
% as I could manage. Values that are character strings may
% also be unambiguously shortened. The legal values for each
% property are:
%
% 'DerivativeOrder' \- specifies the derivative order estimated.
% Must be a positive integer from the set \[1,2,3,4].
%
% DEFAULT: 1 (first derivative of fun)
%
% 'MethodOrder' \- specifies the order of the basic method
% used for the estimation.
%
% For 'central' methods, must be a positive integer
% from the set \[2,4].
%
% For 'forward' or 'backward' difference methods,
% must be a positive integer from the set \[1,2,3,4].
%
% DEFAULT: 4 (a second order method)
%
% Note: higher order methods will generally be more
% accurate, but may also suffere more from numerical
% problems.
%
% Note: First order methods would usually not be
% recommended.
%
% 'Style' \- specifies the style of the basic method
% used for the estimation. 'central', 'forward',
% or 'backwards' difference methods are used.
%
% Must be one of 'Central', 'forward', 'backward'.
%
% DEFAULT: 'Central'
%
% Note: Central difference methods are usually the
% most accurate, but sometiems one must not allow
% evaluation in one direction or the other.
%
% 'RombergTerms' \- Allows the user to specify the generalized
% Romberg extrapolation method used, or turn it off
% completely.
%
% Must be a positive integer from the set \[0,1,2,3].
%
% DEFAULT: 2 (Two Romberg terms)
%
% Note: 0 disables the Romberg step completely.
%
% 'FixedStep' \- Allows the specification of a fixed step
% size, preventing the adaptive logic from working.
% This will be considerably faster, but not necessarily
% as accurate as allowing the adaptive logic to run.
%
% DEFAULT: \[]
%
% Note: If specified, 'FixedStep' will define the
% maximum excursion from x0 that will be used.
%
% 'Vectorized' \- Derivest will normally assume that your
% function can be safely evaluated at multiple locations
% in a single call. This would minimize the overhead of
% a loop and additional function call overhead. Some
% functions are not easily vectorizable, but you may
% (if your matlab release is new enough) be able to use
% arrayfun to accomplish the vectorization.
%
% When all else fails, set the 'vectorized' property
% to 'no'. This will cause derivest to loop over the
% successive function calls.
%
% DEFAULT: 'yes'
%
%
% 'MaxStep' \- Specifies the maximum excursion from x0 that
% will be allowed, as a multiple of x0\.
%
% DEFAULT: 100
%
% 'StepRatio' \- Derivest uses a proportionally cascaded
% series of function evaluations, moving away from your
% point of evaluation. The StepRatio is the ratio used
% between sequential steps.
%
% DEFAULT: 2
%
%
% See the document DERIVEST.pdf for more explanation of the
% algorithms behind the parameters of DERIVEST. In most cases,
% I have chosen good values for these parameters, so the user
% should never need to specify anything other than possibly
% the DerivativeOrder. I've also tried to make my code robust
% enough that it will not need much. But complete flexibility
% is in there for your use.
%
%
% Arguments: (output)
% der \- derivative estimate for each element of x0
% der will have the same shape as x0\.
%
% errest \- 95% uncertainty estimate of the derivative, such that
%
% abs(der(j) \- f'(x0(j))) \< erest(j)
%
% finaldelta \- The final overall stepsize chosen by DERIVEST
%
%
% Example usage:
% First derivative of exp(x), at x \=\= 1
% \[d,e]\=derivest(@(x) exp(x),1\)
% d \=
% 2\.71828182845904
%
% e \=
% 1\.02015503167879e\-14
%
% True derivative
% exp(1\)
% ans \=
% 2\.71828182845905
%
% Example usage:
% Third derivative of x.^3\+x.^4, at x \= \[0,1]
% derivest(@(x) x.^3 \+ x.^4,\[0 1],'deriv',3\)
% ans \=
% 6 30
%
% True derivatives: \[6,30]
%
%
% See also: gradient
%
%
% Author: John D'Errico
% e\-mail: woodchips@rochester.rr.com
% Release: 1\.0
% Release date: 12/27/2006

par.DerivativeOrder \= 1;
par.MethodOrder \= 4;
par.Style \= 'central';
par.RombergTerms \= 2;
par.FixedStep \= \[];
par.MaxStep \= 100;
par.StepRatio \= 2;
par.NominalStep \= \[];
par.Vectorized \= 'yes';

na \= length(varargin);
if (rem(na,2\)\=\=1\)
 error 'Property/value pairs must come as PAIRS of arguments.'
elseif na\>0
 par \= parse\_pv\_pairs(par,varargin);
end
par \= check\_params(par);

% Was fun a string, or an inline/anonymous function?
if (nargin\<1\)
 help derivest
 return
elseif isempty(fun)
 error 'fun was not supplied.'
elseif ischar(fun)
 % a character function name
 fun \= str2func(fun);
end

% no default for x0
if (nargin\<2\) \|\| isempty(x0\)
 error 'x0 was not supplied'
end
par.NominalStep \= max(x0,0\.02\);

% was a single point supplied?
nx0 \= size(x0\);
n \= prod(nx0\);

% Set the steps to use.
if isempty(par.FixedStep)
 % Basic sequence of steps, relative to a stepsize of 1\.
 delta \= par.MaxStep\*par.StepRatio .^(0:\-1:\-25\)';
 ndel \= length(delta);
else
 % Fixed, user supplied absolute sequence of steps.
 ndel \= 3 \+ ceil(par.DerivativeOrder/2\) \+ ...
 par.MethodOrder \+ par.RombergTerms;
 if par.Style(1\) \=\= 'c'
 ndel \= ndel \- 2;
 end
 delta \= par.FixedStep\*par.StepRatio .^(\-(0:(ndel\-1\)))';
end

% generate finite differencing rule in advance.
% The rule is for a nominal unit step size, and will
% be scaled later to reflect the local step size.
fdarule \= 1;
switch par.Style
 case 'central'
 % for central rules, we will reduce the load by an
 % even or odd transformation as appropriate.
 if par.MethodOrder\=\=2
 switch par.DerivativeOrder
 case 1
 % the odd transformation did all the work
 fdarule \= 1;
 case 2
 % the even transformation did all the work
 fdarule \= 2;
 case 3
 % the odd transformation did most of the work, but
 % we need to kill off the linear term
 fdarule \= \[0 1]/fdamat(par.StepRatio,1,2\);
 case 4
 % the even transformation did most of the work, but
 % we need to kill off the quadratic term
 fdarule \= \[0 1]/fdamat(par.StepRatio,2,2\);
 end
 else
 % a 4th order method. We've already ruled out the 1st
 % order methods since these are central rules.
 switch par.DerivativeOrder
 case 1
 % the odd transformation did most of the work, but
 % we need to kill off the cubic term
 fdarule \= \[1 0]/fdamat(par.StepRatio,1,2\);
 case 2
 % the even transformation did most of the work, but
 % we need to kill off the quartic term
 fdarule \= \[1 0]/fdamat(par.StepRatio,2,2\);
 case 3
 % the odd transformation did much of the work, but
 % we need to kill off the linear \& quintic terms
 fdarule \= \[0 1 0]/fdamat(par.StepRatio,1,3\);
 case 4
 % the even transformation did much of the work, but
 % we need to kill off the quadratic and 6th order terms
 fdarule \= \[0 1 0]/fdamat(par.StepRatio,2,3\);
 end
 end
 case {'forward' 'backward'}
 % These two cases are identical, except at the very end,
 % where a sign will be introduced.

 % No odd/even trans, but we already dropped
 % off the constant term
 if par.MethodOrder\=\=1
 if par.DerivativeOrder\=\=1
 % an easy one
 fdarule \= 1;
 else
 % 2:4
 v \= zeros(1,par.DerivativeOrder);
 v(par.DerivativeOrder) \= 1;
 fdarule \= v/fdamat(par.StepRatio,0,par.DerivativeOrder);
 end
 else
 % par.MethodOrder methods drop off the lower order terms,
 % plus terms directly above DerivativeOrder
 v \= zeros(1,par.DerivativeOrder \+ par.MethodOrder \- 1\);
 v(par.DerivativeOrder) \= 1;
 fdarule \= v/fdamat(par.StepRatio,0,par.DerivativeOrder\+par.MethodOrder\-1\);
 end
 
 % correct sign for the 'backward' rule
 if par.Style(1\) \=\= 'b'
 fdarule \= \-fdarule;
 end
 
end % switch on par.style (generating fdarule)
nfda \= length(fdarule);

% will we need fun(x0\)?
if (rem(par.DerivativeOrder,2\) \=\= 0\) \|\| \~strncmpi(par.Style,'central',7\)
 if strcmpi(par.Vectorized,'yes')
 f\_x0 \= fun(x0\);
 else
 % not vectorized, so loop
 f\_x0 \= zeros(size(x0\));
 for j \= 1:numel(x0\)
 f\_x0(j) \= fun(x0(j));
 end
 end
else
 f\_x0 \= \[];
end

% Loop over the elements of x0, reducing it to
% a scalar problem. Sorry, vectorization is not
% complete here, but this IS only a single loop.
der \= zeros(nx0\);
errest \= der;
finaldelta \= der;
for i \= 1:n
 x0i \= x0(i);
 h \= par.NominalStep(i);

 % a central, forward or backwards differencing rule?
 % f\_del is the set of all the function evaluations we
 % will generate. For a central rule, it will have the
 % even or odd transformation built in.
 if par.Style(1\) \=\= 'c'
 % A central rule, so we will need to evaluate
 % symmetrically around x0i.
 if strcmpi(par.Vectorized,'yes')
 f\_plusdel \= fun(x0i\+h\*delta);
 f\_minusdel \= fun(x0i\-h\*delta);
 else
 % not vectorized, so loop
 f\_minusdel \= zeros(size(delta));
 f\_plusdel \= zeros(size(delta));
 for j \= 1:numel(delta)
 f\_plusdel(j) \= fun(x0i\+h\*delta(j));
 f\_minusdel(j) \= fun(x0i\-h\*delta(j));
 end
 end
 
 if ismember(par.DerivativeOrder,\[1 3])
 % odd transformation
 f\_del \= (f\_plusdel \- f\_minusdel)/2;
 else
 f\_del \= (f\_plusdel \+ f\_minusdel)/2 \- f\_x0(i);
 end
 elseif par.Style(1\) \=\= 'f'
 % forward rule
 % drop off the constant only
 if strcmpi(par.Vectorized,'yes')
 f\_del \= fun(x0i\+h\*delta) \- f\_x0(i);
 else
 % not vectorized, so loop
 f\_del \= zeros(size(delta));
 for j \= 1:numel(delta)
 f\_del(j) \= fun(x0i\+h\*delta(j)) \- f\_x0(i);
 end
 end
 else
 % backward rule
 % drop off the constant only
 if strcmpi(par.Vectorized,'yes')
 f\_del \= fun(x0i\-h\*delta) \- f\_x0(i);
 else
 % not vectorized, so loop
 f\_del \= zeros(size(delta));
 for j \= 1:numel(delta)
 f\_del(j) \= fun(x0i\-h\*delta(j)) \- f\_x0(i);
 end
 end
 end
 
 % check the size of f\_del to ensure it was properly vectorized.
 f\_del \= f\_del(:);
 if length(f\_del)\~\=ndel
 error 'fun did not return the correct size result (fun must be vectorized)'
 end

 % Apply the finite difference rule at each delta, scaling
 % as appropriate for delta and the requested DerivativeOrder.
 % First, decide how many of these estimates we will end up with.
 ne \= ndel \+ 1 \- nfda \- par.RombergTerms;

 % Form the initial derivative estimates from the chosen
 % finite difference method.
 der\_init \= vec2mat(f\_del,ne,nfda)\*fdarule.';

 % scale to reflect the local delta
 der\_init \= der\_init(:)./(h\*delta(1:ne)).^par.DerivativeOrder;
 
 % Each approximation that results is an approximation
 % of order par.DerivativeOrder to the desired derivative.
 % Additional (higher order, even or odd) terms in the
 % Taylor series also remain. Use a generalized (multi\-term)
 % Romberg extrapolation to improve these estimates.
 switch par.Style
 case 'central'
 rombexpon \= 2\*(1:par.RombergTerms) \+ par.MethodOrder \- 2;
 otherwise
 rombexpon \= (1:par.RombergTerms) \+ par.MethodOrder \- 1;
 end
 \[der\_romb,errors] \= rombextrap(par.StepRatio,der\_init,rombexpon);
 
 % Choose which result to return
 
 % first, trim off the 
 if isempty(par.FixedStep)
 % trim off the estimates at each end of the scale
 nest \= length(der\_romb);
 switch par.DerivativeOrder
 case {1 2}
 trim \= \[1 2 nest\-1 nest];
 case 3
 trim \= \[1:4 nest\+(\-3:0\)];
 case 4
 trim \= \[1:6 nest\+(\-5:0\)];
 end
 
 \[der\_romb,tags] \= sort(der\_romb);
 
 der\_romb(trim) \= \[];
 tags(trim) \= \[];
 errors \= errors(tags);
 trimdelta \= delta(tags);
 
 \[errest(i),ind] \= min(errors);
 
 finaldelta(i) \= h\*trimdelta(ind);
 der(i) \= der\_romb(ind);
 else
 \[errest(i),ind] \= min(errors);
 finaldelta(i) \= h\*delta(ind);
 der(i) \= der\_romb(ind);
 end
end

end % mainline end

% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% subfunction \- romberg extrapolation
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function \[der\_romb,errest] \= rombextrap(StepRatio,der\_init,rombexpon)
% do romberg extrapolation for each estimate
%
% StepRatio \- Ratio decrease in step
% der\_init \- initial derivative estimates
% rombexpon \- higher order terms to cancel using the romberg step
%
% der\_romb \- derivative estimates returned
% errest \- error estimates
% amp \- noise amplification factor due to the romberg step

srinv \= 1/StepRatio;

% do nothing if no romberg terms
nexpon \= length(rombexpon);
rmat \= ones(nexpon\+2,nexpon\+1\);
switch nexpon
 case 0
 % rmat is simple: ones(2,1\)
 case 1
 % only one romberg term
 rmat(2,2\) \= srinv^rombexpon;
 rmat(3,2\) \= srinv^(2\*rombexpon);
 case 2
 % two romberg terms
 rmat(2,2:3\) \= srinv.^rombexpon;
 rmat(3,2:3\) \= srinv.^(2\*rombexpon);
 rmat(4,2:3\) \= srinv.^(3\*rombexpon);
 case 3
 % three romberg terms
 rmat(2,2:4\) \= srinv.^rombexpon;
 rmat(3,2:4\) \= srinv.^(2\*rombexpon);
 rmat(4,2:4\) \= srinv.^(3\*rombexpon);
 rmat(5,2:4\) \= srinv.^(4\*rombexpon);
end

% qr factorization used for the extrapolation as well
% as the uncertainty estimates
\[qromb,rromb] \= qr(rmat,0\);

% the noise amplification is further amplified by the Romberg step.
% amp \= cond(rromb);

% this does the extrapolation to a zero step size.
ne \= length(der\_init);
rhs \= vec2mat(der\_init,nexpon\+2,max(1,ne \- (nexpon\+2\)));
rombcoefs \= rromb\\(qromb.'\*rhs); 
der\_romb \= rombcoefs(1,:).';

% uncertainty estimate of derivative prediction
s \= sqrt(sum((rhs \- rmat\*rombcoefs).^2,1\));
rinv \= rromb\\eye(nexpon\+1\);
cov1 \= sum(rinv.^2,2\); % 1 spare dof
errest \= s.'\*12\.7062047361747\*sqrt(cov1(1\));

end % rombextrap


% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% subfunction \- vec2mat
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function mat \= vec2mat(vec,n,m)
% forms the matrix M, such that M(i,j) \= vec(i\+j\-1\)
\[i,j] \= ndgrid(1:n,0:m\-1\);
ind \= i\+j;
mat \= vec(ind);
if n\=\=1
 mat \= mat.';
end

end % vec2mat


% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% subfunction \- fdamat
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function mat \= fdamat(sr,parity,nterms)
% Compute matrix for fda derivation.
% parity can be
% 0 (one sided, all terms included but zeroth order)
% 1 (only odd terms included)
% 2 (only even terms included)
% nterms \- number of terms

% sr is the ratio between successive steps
srinv \= 1\./sr;

switch parity
 case 0
 % single sided rule
 \[i,j] \= ndgrid(1:nterms);
 c \= 1\./factorial(1:nterms);
 mat \= c(j).\*srinv.^((i\-1\).\*j);
 case 1
 % odd order derivative
 \[i,j] \= ndgrid(1:nterms);
 c \= 1\./factorial(1:2:(2\*nterms));
 mat \= c(j).\*srinv.^((i\-1\).\*(2\*j\-1\));
 case 2
 % even order derivative
 \[i,j] \= ndgrid(1:nterms);
 c \= 1\./factorial(2:2:(2\*nterms));
 mat \= c(j).\*srinv.^((i\-1\).\*(2\*j));
end

end % fdamat



% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% subfunction \- check\_params
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function par \= check\_params(par)
% check the parameters for acceptability
%
% Defaults
% par.DerivativeOrder \= 1;
% par.MethodOrder \= 2;
% par.Style \= 'central';
% par.RombergTerms \= 2;
% par.FixedStep \= \[];

% DerivativeOrder \=\= 1 by default
if isempty(par.DerivativeOrder)
 par.DerivativeOrder \= 1;
else
 if (length(par.DerivativeOrder)\>1\) \|\| \~ismember(par.DerivativeOrder,1:4\)
 error 'DerivativeOrder must be scalar, one of \[1 2 3 4].'
 end
end

% MethodOrder \=\= 2 by default
if isempty(par.MethodOrder)
 par.MethodOrder \= 2;
else
 if (length(par.MethodOrder)\>1\) \|\| \~ismember(par.MethodOrder,\[1 2 3 4])
 error 'MethodOrder must be scalar, one of \[1 2 3 4].'
 elseif ismember(par.MethodOrder,\[1 3]) \&\& (par.Style(1\)\=\='c')
 error 'MethodOrder\=\=1 or 3 is not possible with central difference methods'
 end
end

% style is char
valid \= {'central', 'forward', 'backward'};
if isempty(par.Style)
 par.Style \= 'central';
elseif \~ischar(par.Style)
 error 'Invalid Style: Must be character'
end
ind \= find(strncmpi(par.Style,valid,length(par.Style)));
if (length(ind)\=\=1\)
 par.Style \= valid{ind};
else
 error(\['Invalid Style: ',par.Style])
end

% vectorized is char
valid \= {'yes', 'no'};
if isempty(par.Vectorized)
 par.Vectorized \= 'yes';
elseif \~ischar(par.Vectorized)
 error 'Invalid Vectorized: Must be character'
end
ind \= find(strncmpi(par.Vectorized,valid,length(par.Vectorized)));
if (length(ind)\=\=1\)
 par.Vectorized \= valid{ind};
else
 error(\['Invalid Vectorized: ',par.Vectorized])
end

% RombergTerms \=\= 2 by default
if isempty(par.RombergTerms)
 par.RombergTerms \= 2;
else
 if (length(par.RombergTerms)\>1\) \|\| \~ismember(par.RombergTerms,0:3\)
 error 'RombergTerms must be scalar, one of \[0 1 2 3].'
 end
end

% FixedStep \=\= \[] by default
if (length(par.FixedStep)\>1\) \|\| (\~isempty(par.FixedStep) \&\& (par.FixedStep\<\=0\))
 error 'FixedStep must be empty or a scalar, \>0\.'
end

% MaxStep \=\= 10 by default
if isempty(par.MaxStep)
 par.MaxStep \= 10;
elseif (length(par.MaxStep)\>1\) \|\| (par.MaxStep\<\=0\)
 error 'MaxStep must be empty or a scalar, \>0\.'
end

end % check\_params


% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% Included subfunction \- parse\_pv\_pairs
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function params\=parse\_pv\_pairs(params,pv\_pairs)
% parse\_pv\_pairs: parses sets of property value pairs, allows defaults
% usage: params\=parse\_pv\_pairs(default\_params,pv\_pairs)
%
% arguments: (input)
% default\_params \- structure, with one field for every potential
% property/value pair. Each field will contain the default
% value for that property. If no default is supplied for a
% given property, then that field must be empty.
%
% pv\_array \- cell array of property/value pairs.
% Case is ignored when comparing properties to the list
% of field names. Also, any unambiguous shortening of a
% field/property name is allowed.
%
% arguments: (output)
% params \- parameter struct that reflects any updated property/value
% pairs in the pv\_array.
%
% Example usage:
% First, set default values for the parameters. Assume we
% have four parameters that we wish to use optionally in
% the function examplefun.
%
% \- 'viscosity', which will have a default value of 1
% \- 'volume', which will default to 1
% \- 'pie' \- which will have default value 3\.141592653589793
% \- 'description' \- a text field, left empty by default
%
% The first argument to examplefun is one which will always be
% supplied.
%
% function examplefun(dummyarg1,varargin)
% params.Viscosity \= 1;
% params.Volume \= 1;
% params.Pie \= 3\.141592653589793
%
% params.Description \= '';
% params\=parse\_pv\_pairs(params,varargin);
% params
%
% Use examplefun, overriding the defaults for 'pie', 'viscosity'
% and 'description'. The 'volume' parameter is left at its default.
%
% examplefun(rand(10\),'vis',10,'pie',3,'Description','Hello world')
%
% params \= 
% Viscosity: 10
% Volume: 1
% Pie: 3
% Description: 'Hello world'
%
% Note that capitalization was ignored, and the property 'viscosity'
% was truncated as supplied. Also note that the order the pairs were
% supplied was arbitrary.

npv \= length(pv\_pairs);
n \= npv/2;

if n\~\=floor(n)
 error 'Property/value pairs must come in PAIRS.'
end
if n\<\=0
 % just return the defaults
 return
end

if \~isstruct(params)
 error 'No structure for defaults was supplied'
end

% there was at least one pv pair. process any supplied
propnames \= fieldnames(params);
lpropnames \= lower(propnames);
for i\=1:n
 p\_i \= lower(pv\_pairs{2\*i\-1});
 v\_i \= pv\_pairs{2\*i};
 
 ind \= strmatch(p\_i,lpropnames,'exact');
 if isempty(ind)
 ind \= find(strncmp(p\_i,lpropnames,length(p\_i)));
 if isempty(ind)
 error(\['No matching property found for: ',pv\_pairs{2\*i\-1}])
 elseif length(ind)\>1
 error(\['Ambiguous property name: ',pv\_pairs{2\*i\-1}])
 end
 end
 p\_i \= propnames{ind};
 
 % override the corresponding default in params
 params \= setfield(params,p\_i,v\_i); %\#ok
 
end

end % parse\_pv\_pairs







\-\-\-

\#\#\# File: jacobianest.m (ID: utility functions.DERIVESTsuite.2\)

function \[jac,err] \= jacobianest(fun,x0\)
% gradest: estimate of the Jacobian matrix of a vector valued function of n variables
% usage: \[jac,err] \= jacobianest(fun,x0\)
%
% 
% arguments: (input)
% fun \- (vector valued) analytical function to differentiate.
% fun must be a function of the vector or array x0\.
% 
% x0 \- vector location at which to differentiate fun
% If x0 is an nxm array, then fun is assumed to be
% a function of n\*m variables.
%
%
% arguments: (output)
% jac \- array of first partial derivatives of fun.
% Assuming that x0 is a vector of length p
% and fun returns a vector of length n, then
% jac will be an array of size (n,p)
%
% err \- vector of error estimates corresponding to
% each partial derivative in jac.
%
%
% Example: (nonlinear least squares)
% xdata \= (0:.1:1\)';
% ydata \= 1\+2\*exp(0\.75\*xdata);
% fun \= @(c) ((c(1\)\+c(2\)\*exp(c(3\)\*xdata)) \- ydata).^2;
%
% \[jac,err] \= jacobianest(fun,\[1 1 1])
%
% jac \=
% \-2 \-2 0
% \-2\.1012 \-2\.3222 \-0\.23222
% \-2\.2045 \-2\.6926 \-0\.53852
% \-2\.3096 \-3\.1176 \-0\.93528
% \-2\.4158 \-3\.6039 \-1\.4416
% \-2\.5225 \-4\.1589 \-2\.0795
% \-2\.629 \-4\.7904 \-2\.8742
% \-2\.7343 \-5\.5063 \-3\.8544
% \-2\.8374 \-6\.3147 \-5\.0518
% \-2\.9369 \-7\.2237 \-6\.5013
% \-3\.0314 \-8\.2403 \-8\.2403
%
% err \=
% 5\.0134e\-15 5\.0134e\-15 0
% 5\.0134e\-15 0 2\.8211e\-14
% 5\.0134e\-15 8\.6834e\-15 1\.5804e\-14
% 0 7\.09e\-15 3\.8227e\-13
% 5\.0134e\-15 5\.0134e\-15 7\.5201e\-15
% 5\.0134e\-15 1\.0027e\-14 2\.9233e\-14
% 5\.0134e\-15 0 6\.0585e\-13
% 5\.0134e\-15 1\.0027e\-14 7\.2673e\-13
% 5\.0134e\-15 1\.0027e\-14 3\.0495e\-13
% 5\.0134e\-15 1\.0027e\-14 3\.1707e\-14
% 5\.0134e\-15 2\.0053e\-14 1\.4013e\-12
%
% (At \[1 2 0\.75], jac should be numerically zero)
%
%
% See also: derivest, gradient, gradest
%
%
% Author: John D'Errico
% e\-mail: woodchips@rochester.rr.com
% Release: 1\.0
% Release date: 3/6/2007

% get the length of x0 for the size of jac
nx \= numel(x0\);

MaxStep \= 100;
StepRatio \= 2;

% was a string supplied?
if ischar(fun)
 fun \= str2func(fun);
end

% get fun at the center point
f0 \= fun(x0\);
f0 \= f0(:);
n \= length(f0\);
if n\=\=0
 % empty begets empty
 jac \= zeros(0,nx);
 err \= jac;
 return
end

relativedelta \= MaxStep\*StepRatio .^(0:\-1:\-25\);
nsteps \= length(relativedelta);

% total number of derivatives we will need to take
jac \= zeros(n,nx);
err \= jac;
for i \= 1:nx
 x0\_i \= x0(i);
 if x0\_i \~\= 0
 delta \= x0\_i\*relativedelta;
 else
 delta \= relativedelta;
 end
 
 % evaluate at each step, centered around x0\_i
 % difference to give a second order estimate
 fdel \= zeros(n,nsteps);
 for j \= 1:nsteps
 fdif \= fun(swapelement(x0,i,x0\_i \+ delta(j))) \- ...
 fun(swapelement(x0,i,x0\_i \- delta(j)));
 
 fdel(:,j) \= fdif(:);
 end
 
 % these are pure second order estimates of the
 % first derivative, for each trial delta.
 derest \= fdel.\*repmat(0\.5 ./ delta,n,1\);
 
 % The error term on these estimates has a second order
 % component, but also some 4th and 6th order terms in it.
 % Use Romberg exrapolation to improve the estimates to
 % 6th order, as well as to provide the error estimate.
 
 % loop here, as rombextrap coupled with the trimming
 % will get complicated otherwise.
 for j \= 1:n
 \[der\_romb,errest] \= rombextrap(StepRatio,derest(j,:),\[2 4]);
 
 % trim off 3 estimates at each end of the scale
 nest \= length(der\_romb);
 trim \= \[1:3, nest\+(\-2:0\)];
 \[der\_romb,tags] \= sort(der\_romb);
 der\_romb(trim) \= \[];
 tags(trim) \= \[];
 
 errest \= errest(tags);
 
 % now pick the estimate with the lowest predicted error
 \[err(j,i),ind] \= min(errest);
 jac(j,i) \= der\_romb(ind);
 end
end

end % mainline function end

% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% sub\-functions
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function vec \= swapelement(vec,ind,val)
% swaps val as element ind, into the vector vec
vec(ind) \= val;

end % sub\-function end

% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% subfunction \- romberg extrapolation
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function \[der\_romb,errest] \= rombextrap(StepRatio,der\_init,rombexpon)
% do romberg extrapolation for each estimate
%
% StepRatio \- Ratio decrease in step
% der\_init \- initial derivative estimates
% rombexpon \- higher order terms to cancel using the romberg step
%
% der\_romb \- derivative estimates returned
% errest \- error estimates
% amp \- noise amplification factor due to the romberg step

srinv \= 1/StepRatio;

% do nothing if no romberg terms
nexpon \= length(rombexpon);
rmat \= ones(nexpon\+2,nexpon\+1\);
% two romberg terms
rmat(2,2:3\) \= srinv.^rombexpon;
rmat(3,2:3\) \= srinv.^(2\*rombexpon);
rmat(4,2:3\) \= srinv.^(3\*rombexpon);

% qr factorization used for the extrapolation as well
% as the uncertainty estimates
\[qromb,rromb] \= qr(rmat,0\);

% the noise amplification is further amplified by the Romberg step.
% amp \= cond(rromb);

% this does the extrapolation to a zero step size.
ne \= length(der\_init);
rhs \= vec2mat(der\_init,nexpon\+2,ne \- (nexpon\+2\));
rombcoefs \= rromb\\(qromb'\*rhs);
der\_romb \= rombcoefs(1,:)';

% uncertainty estimate of derivative prediction
s \= sqrt(sum((rhs \- rmat\*rombcoefs).^2,1\));
rinv \= rromb\\eye(nexpon\+1\);
cov1 \= sum(rinv.^2,2\); % 1 spare dof
errest \= s'\*12\.7062047361747\*sqrt(cov1(1\));

end % rombextrap


% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% subfunction \- vec2mat
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function mat \= vec2mat(vec,n,m)
% forms the matrix M, such that M(i,j) \= vec(i\+j\-1\)
\[i,j] \= ndgrid(1:n,0:m\-1\);
ind \= i\+j;
mat \= vec(ind);
if n\=\=1
 mat \= mat';
end

end % vec2mat




\-\-\-

\#\#\# File: hessdiag.m (ID: utility functions.DERIVESTsuite.3\)

function \[HD,err,finaldelta] \= hessdiag(fun,x0\)
% HESSDIAG: diagonal elements of the Hessian matrix (vector of second partials)
% usage: \[HD,err,finaldelta] \= hessdiag(fun,x0\)
%
% When all that you want are the diagonal elements of the hessian
% matrix, it will be more efficient to call HESSDIAG than HESSIAN.
% HESSDIAG uses DERIVEST to provide both second derivative estimates
% and error estimates. fun needs not be vectorized.
% 
% arguments: (input)
% fun \- SCALAR analytical function to differentiate.
% fun must be a function of the vector or array x0\.
% 
% x0 \- vector location at which to differentiate fun
% If x0 is an nxm array, then fun is assumed to be
% a function of n\*m variables. 
%
% arguments: (output)
% HD \- vector of second partial derivatives of fun.
% These are the diagonal elements of the Hessian
% matrix, evaluated at x0\.
% HD will be a row vector of length numel(x0\).
%
% err \- vector of error estimates corresponding to
% each second partial derivative in HD.
%
% finaldelta \- vector of final step sizes chosen for
% each second partial derivative.
%
%
% Example usage:
% \[HD,err] \= hessdiag(@(x) x(1\) \+ x(2\)^2 \+ x(3\)^3,\[1 2 3])
% HD \=
% 0 2 18
%
% err \=
% 0 0 0
%
%
% See also: derivest, gradient, gradest
%
%
% Author: John D'Errico
% e\-mail: woodchips@rochester.rr.com
% Release: 1\.0
% Release date: 2/9/2007

% get the size of x0 so we can reshape
% later.
sx \= size(x0\);

% total number of derivatives we will need to take
nx \= numel(x0\);

HD \= zeros(1,nx);
err \= HD;
finaldelta \= HD;
for ind \= 1:nx
 \[HD(ind),err(ind),finaldelta(ind)] \= derivest( ...
 @(xi) fun(swapelement(x0,ind,xi)), ...
 x0(ind),'deriv',2,'vectorized','no');
end

end % mainline function end

% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% sub\-functions
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function vec \= swapelement(vec,ind,val)
% swaps val as element ind, into the vector vec
vec(ind) \= val;

end % sub\-function end




\-\-\-

\#\#\# File: gradest.m (ID: utility functions.DERIVESTsuite.4\)

function \[grad,err,finaldelta] \= gradest(fun,x0\)
% gradest: estimate of the gradient vector of an analytical function of n variables
% usage: \[grad,err,finaldelta] \= gradest(fun,x0\)
%
% Uses derivest to provide both derivative estimates
% and error estimates. fun needs not be vectorized.
% 
% arguments: (input)
% fun \- analytical function to differentiate. fun must
% be a function of the vector or array x0\.
% 
% x0 \- vector location at which to differentiate fun
% If x0 is an nxm array, then fun is assumed to be
% a function of n\*m variables. 
%
% arguments: (output)
% grad \- vector of first partial derivatives of fun.
% grad will be a row vector of length numel(x0\).
%
% err \- vector of error estimates corresponding to
% each partial derivative in grad.
%
% finaldelta \- vector of final step sizes chosen for
% each partial derivative.
%
%
% Example:
% \[grad,err] \= gradest(@(x) sum(x.^2\),\[1 2 3])
% grad \=
% 2 4 6
% err \=
% 5\.8899e\-15 1\.178e\-14 0
%
%
% Example:
% At \[x,y] \= \[1,1], compute the numerical gradient
% of the function sin(x\-y) \+ y\*exp(x)
%
% z \= @(xy) sin(diff(xy)) \+ xy(2\)\*exp(xy(1\))
%
% \[grad,err ] \= gradest(z,\[1 1])
% grad \=
% 1\.7183 3\.7183
% err \=
% 7\.537e\-14 1\.1846e\-13
%
%
% Example:
% At the global minimizer (1,1\) of the Rosenbrock function,
% compute the gradient. It should be essentially zero.
%
% rosen \= @(x) (1\-x(1\)).^2 \+ 105\*(x(2\)\-x(1\).^2\).^2;
% \[g,err] \= gradest(rosen,\[1 1])
% g \=
% 1\.0843e\-20 0
% err \=
% 1\.9075e\-18 0
%
%
% See also: derivest, gradient
%
%
% Author: John D'Errico
% e\-mail: woodchips@rochester.rr.com
% Release: 1\.0
% Release date: 2/9/2007

% get the size of x0 so we can reshape
% later.
sx \= size(x0\);

% total number of derivatives we will need to take
nx \= numel(x0\);

grad \= zeros(1,nx);
err \= grad;
finaldelta \= grad;
for ind \= 1:nx
 \[grad(ind),err(ind),finaldelta(ind)] \= derivest( ...
 @(xi) fun(swapelement(x0,ind,xi)), ...
 x0(ind),'deriv',1,'vectorized','no', ...
 'methodorder',2\);
end

end % mainline function end

% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% sub\-functions
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function vec \= swapelement(vec,ind,val)
% swaps val as element ind, into the vector vec
vec(ind) \= val;

end % sub\-function end



\-\-\-

\#\#\# File: ReadMe.rtf (ID: utility functions.DERIVESTsuite.5\)

{\\rtf1\\mac\\ansicpg10000\\cocoartf102
{\\fonttbl\\f0\\fswiss\\fcharset77 Helvetica;}
{\\colortbl;\\red255\\green255\\blue255;\\red0\\green0\\blue0;}
\\margl1440\\margr1440\\vieww9000\\viewh9000\\viewkind0
\\pard\\tx720\\tx1440\\tx2160\\tx2880\\tx3600\\tx4320\\tx5040\\tx5760\\tx6480\\tx7200\\tx7920\\tx8640\\ql\\qnatural

\\f0\\fs24 \\cf2 Numerical differentiation \\
\\
\\pard\\pardeftab720\\ql\\qnatural
\\cf2 Author: John D'Errico\\
e\-mail: woodchips@rochester.rr.com\\
Release: 1\.0\\
Release date: 3/7/2007\\
\\
This is a suite of tools to solve automatic numerical differentiation problems in one or more variables. All of these methods also produce error estimates on the result.\\
A pdf file is also provided to explain the theory behind these tools.\\
\\
\\
DERIVEST.m\\
A flexible tool for the computation of derivatives of order 1 through 4 on any scalar function. Finite differences are used in an adaptive manner, coupled with a Romberg extrapolation methodology to provide a maximally accurate result. The user can configure many of the options, changing the order of the method or the extrapolation, even allowing the user to specify whether central, forward or backward differences are used.\\
\\
GRADEST.m\\
Computes the gradient vector of a scalar function of one or more variables at any location.\\
\\
JACOBIANEST.m\\
Computes the Jacobian matrix of a vector (or array) valued function of one or more variables.\\
\\
DIRECTIONALDIFF.m\\
Computes the directional derivative (along some line) of a scalar function of one or more variables.\\
\\
HESSIAN.m\\
Computes the Hessian matrix of all 2nd partial derivatives of a scalar function of one or more variables.\\
\\
HESSDIAG.m\\
The diagonal elements of the Hessian matrix are the pure second order partial derivatives. This function is called by HESSIAN.m, but since some users may need only the diagonal elements, I've provided HESSDIAG.\\
\\
\\
}
\-\-\-

\#\#\# File: hessian.m (ID: utility functions.DERIVESTsuite.6\)

function \[hess,err] \= hessian(fun,x0\)
% hessian: estimate elements of the Hessian matrix (array of 2nd partials)
% usage: \[hess,err] \= hessian(fun,x0\)
%
% Hessian is NOT a tool for frequent use on an expensive
% to evaluate objective function, especially in a large
% number of dimensions. Its computation will use roughly
% O(6\*n^2\) function evaluations for n parameters.
% 
% arguments: (input)
% fun \- SCALAR analytical function to differentiate.
% fun must be a function of the vector or array x0\.
% fun does not need to be vectorized.
% 
% x0 \- vector location at which to compute the Hessian.
%
% arguments: (output)
% hess \- nxn symmetric array of second partial derivatives
% of fun, evaluated at x0\.
%
% err \- nxn array of error estimates corresponding to
% each second partial derivative in hess.
%
%
% Example usage:
% Rosenbrock function, minimized at \[1,1]
% rosen \= @(x) (1\-x(1\)).^2 \+ 105\*(x(2\)\-x(1\).^2\).^2;
% 
% \[h,err] \= hessian(rosen,\[1 1])
% h \=
% 842 \-420
% \-420 210
% err \=
% 1\.0662e\-12 4\.0061e\-10
% 4\.0061e\-10 2\.6654e\-13
%
%
% Example usage:
% cos(x\-y), at (0,0\)
% Note: this hessian matrix will be positive semi\-definite
%
% hessian(@(xy) cos(xy(1\)\-xy(2\)),\[0 0])
% ans \=
% \-1 1
% 1 \-1
%
%
% See also: derivest, gradient, gradest, hessdiag
%
%
% Author: John D'Errico
% e\-mail: woodchips@rochester.rr.com
% Release: 1\.0
% Release date: 2/10/2007

% parameters that we might allow to change
params.StepRatio \= 2;
params.RombergTerms \= 3;

% get the size of x0 so we can reshape
% later.
sx \= size(x0\);

% was a string supplied?
if ischar(fun)
 fun \= str2func(fun);
end

% total number of derivatives we will need to take
nx \= length(x0\);

% get the diagonal elements of the hessian (2nd partial
% derivatives wrt each variable.)
\[hess,err] \= hessdiag(fun,x0\);

% form the eventual hessian matrix, stuffing only
% the diagonals for now.
hess \= diag(hess);
err \= diag(err);
if nx\<2
 % the hessian matrix is 1x1\. all done
 return
end

% get the gradient vector. This is done only to decide
% on intelligent step sizes for the mixed partials
\[grad,graderr,stepsize] \= gradest(fun,x0\);

% Get params.RombergTerms\+1 estimates of the upper
% triangle of the hessian matrix
dfac \= params.StepRatio.^(\-(0:params.RombergTerms)');
for i \= 2:nx
 for j \= 1:(i\-1\)
 dij \= zeros(params.RombergTerms\+1,1\);
 for k \= 1:(params.RombergTerms\+1\)
 dij(k) \= fun(x0 \+ swap2(zeros(sx),i, ...
 dfac(k)\*stepsize(i),j,dfac(k)\*stepsize(j))) \+ ...
 fun(x0 \+ swap2(zeros(sx),i, ...
 \-dfac(k)\*stepsize(i),j,\-dfac(k)\*stepsize(j))) \- ...
 fun(x0 \+ swap2(zeros(sx),i, ...
 dfac(k)\*stepsize(i),j,\-dfac(k)\*stepsize(j))) \- ...
 fun(x0 \+ swap2(zeros(sx),i, ...
 \-dfac(k)\*stepsize(i),j,dfac(k)\*stepsize(j)));
 
 end
 dij \= dij/4/prod(stepsize(\[i,j]));
 dij \= dij./(dfac.^2\);
 
 % Romberg extrapolation step
 \[hess(i,j),err(i,j)] \= rombextrap(params.StepRatio,dij,\[2 4]);
 hess(j,i) \= hess(i,j);
 err(j,i) \= err(i,j);
 end
end


end % mainline function end

% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% sub\-functions
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function vec \= swap2(vec,ind1,val1,ind2,val2\)
% swaps val as element ind, into the vector vec
vec(ind1\) \= val1;
vec(ind2\) \= val2;

end % sub\-function end


% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
% subfunction \- romberg extrapolation
% \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
function \[der\_romb,errest] \= rombextrap(StepRatio,der\_init,rombexpon)
% do romberg extrapolation for each estimate
%
% StepRatio \- Ratio decrease in step
% der\_init \- initial derivative estimates
% rombexpon \- higher order terms to cancel using the romberg step
%
% der\_romb \- derivative estimates returned
% errest \- error estimates
% amp \- noise amplification factor due to the romberg step

srinv \= 1/StepRatio;

% do nothing if no romberg terms
nexpon \= length(rombexpon);
rmat \= ones(nexpon\+2,nexpon\+1\);
switch nexpon
 case 0
 % rmat is simple: ones(2,1\)
 case 1
 % only one romberg term
 rmat(2,2\) \= srinv^rombexpon;
 rmat(3,2\) \= srinv^(2\*rombexpon);
 case 2
 % two romberg terms
 rmat(2,2:3\) \= srinv.^rombexpon;
 rmat(3,2:3\) \= srinv.^(2\*rombexpon);
 rmat(4,2:3\) \= srinv.^(3\*rombexpon);
 case 3
 % three romberg terms
 rmat(2,2:4\) \= srinv.^rombexpon;
 rmat(3,2:4\) \= srinv.^(2\*rombexpon);
 rmat(4,2:4\) \= srinv.^(3\*rombexpon);
 rmat(5,2:4\) \= srinv.^(4\*rombexpon);
end

% qr factorization used for the extrapolation as well
% as the uncertainty estimates
\[qromb,rromb] \= qr(rmat,0\);

% the noise amplification is further amplified by the Romberg step.
% amp \= cond(rromb);

% this does the extrapolation to a zero step size.
ne \= length(der\_init);
rombcoefs \= rromb\\(qromb'\*der\_init);
der\_romb \= rombcoefs(1,:)';

% uncertainty estimate of derivative prediction
s \= sqrt(sum((der\_init \- rmat\*rombcoefs).^2,1\));
rinv \= rromb\\eye(nexpon\+1\);
cov1 \= sum(rinv.^2,2\); % 1 spare dof
errest \= s'\*12\.7062047361747\*sqrt(cov1(1\));

end % rombextrap



\-\-\-

\#\#\# File: directionaldiff.m (ID: utility functions.DERIVESTsuite.7\)

function \[dd,err,finaldelta] \= directionaldiff(fun,x0,vec)
% directionaldiff: estimate of the directional derivative of a function of n variables
% usage: \[grad,err,finaldelta] \= directionaldiff(fun,x0,vec)
%
% Uses derivest to provide both a directional derivative
% estimates plus an error estimates. fun needs not be vectorized.
% 
% arguments: (input)
% fun \- analytical function to differentiate. fun must
% be a function of the vector or array x0\. Fun needs
% not be vectorized.
% 
% x0 \- vector location at which to differentiate fun
% If x0 is an nxm array, then fun is assumed to be
% a function of n\*m variables. 
%
% vec \- vector defining the line along which to take the
% derivative. Vec should be the same size as x0\. It
% need not be a vector of unit length.
%
% arguments: (output)
% dd \- scalar estimate of the first derivative of fun
% in the SPECIFIED direction.
%
% err \- error estimate of the directional derivative
%
% finaldelta \- vector of final step sizes chosen for
% each partial derivative.
%
%
% Example:
% At the global minimizer (1,1\) of the Rosenbrock function,
% compute the directional derivative in the direction \[1 2]
% It should be 0\.
%
% rosen \= @(x) (1\-x(1\)).^2 \+ 105\*(x(2\)\-x(1\).^2\).^2;
% \[dd,err] \= directionaldiff(rosen,\[1 1])
%
% dd \=
% 0
% err \=
% 0
%
%
% See also: derivest, gradest, gradient
%
%
% Author: John D'Errico
% e\-mail: woodchips@rochester.rr.com
% Release: 1\.0
% Release date: 3/5/2007

% get the size of x0 so we can make sure vec is
% the same shape.
sx \= size(x0\);
if numel(x0\)\~\=numel(vec)
 error 'vec and x0 must be the same sizes'
end
vec \= vec(:);
vec \= vec/norm(vec);
vec \= reshape(vec,sx);

\[dd,err,finaldelta] \= derivest(@(t) fun(x0\+t\*vec), ...
 0,'deriv',1,'vectorized','no');

end % mainline function end



\-\-\-

\#\#\# Folder: utility functions/DERIVESTsuite/demo (ID: utility functions.DERIVESTsuite.demo)

\-\-\-

\#\#\# File: multivariable\_calc\_demo.m (ID: utility functions.DERIVESTsuite.demo.1\)

% Multivariate calculus demo script

% This script file is designed to be used in cell mode
% from the matlab editor, or best of all, use the publish
% to HTML feature from the matlab editor. Older versions
% of matlab can copy and paste entire blocks of code into
% the Matlab command window.

% Typical usage of the gradient and Hessian might be in
% optimization problems, where one might compare an analytically
% derived gradient for correctness, or use the Hessian matrix
% to compute confidence interval estimates on parameters in a
% maximum likelihood estimation.

%% Gradient of the Rosenbrock function at \[1,1], the global minimizer
rosen \= @(x) (1\-x(1\)).^2 \+ 105\*(x(2\)\-x(1\).^2\).^2;
% The gradient should be zero (within floating point noise)
\[grad,err] \= gradest(rosen,\[1 1])

%% The Hessian matrix at the minimizer should be positive definite
H \= hessian(rosen,\[1 1])
% The eigenvalues of h should be positive
eig(H)

%% Gradient estimation using gradest \- a function of 5 variables
\[grad,err] \= gradest(@(x) sum(x.^2\),\[1 2 3 4 5])

%% Simple Hessian matrix of a problem with 3 independent variables
\[H,err] \= hessian(@(x) x(1\) \+ x(2\)^2 \+ x(3\)^3,\[1 2 3])

%% A semi\-definite Hessian matrix
H \= hessian(@(xy) cos(xy(1\) \- xy(2\)),\[0 0])
% one of these eigenvalues will be zero (approximately)
eig(H)

%% Directional derivative of the Rosenbrock function at the solution
% This should be zero. Ok, its a trivial test case.
\[dd,err] \= directionaldiff(rosen,\[1 1],\[1 2])

%% Directional derivative at other locations
\[dd,err] \= directionaldiff(rosen,\[2 3],\[1 \-1])

% We can test this example
v \= \[1 \-1];
v \= v/norm(v);
g \= gradest(rosen,\[2 3]);

% The directional derivative will be the dot product of the gradient with
% the (unit normalized) vector. So this difference will be (approx) zero.
dot(g,v) \- dd

%% Jacobian matrix of a scalar function is just the gradient
\[jac,err] \= jacobianest(rosen,\[2 3])

grad \= gradest(rosen,\[2 3])

%% Jacobian matrix of a linear system will reduce to the design matrix
A \= rand(5,3\);
b \= rand(5,1\);
fun \= @(x) (A\*x\-b);

x \= rand(3,1\);
\[jac,err] \= jacobianest(fun,x)

disp 'This should be essentially zero at any location x'
jac \- A

%% The jacobian matrix of a nonlinear transformation of variables
% evaluated at some arbitrary location \[\-2, \-3]
fun \= @(xy) \[xy(1\).^2, cos(xy(1\) \- xy(2\))];
\[jac,err] \= jacobianest(fun,\[\-2 \-3])



\-\-\-

\#\#\# File: derivest\_demo.m (ID: utility functions.DERIVESTsuite.demo.2\)

% DERIVEST demo script

% This script file is designed to be used in cell mode
% from the matlab editor, or best of all, use the publish
% to HTML feature from the matlab editor. Older versions
% of matlab can copy and paste entire blocks of code into
% the Matlab command window.

% DERIVEST is property/value is driven for its arguments.
% Properties can be shortened to the

%% derivative of exp(x), at x \=\= 0
\[deriv,err] \= derivest(@(x) exp(x),0\)

%% DERIVEST can also use an inline function
\[deriv,err] \= derivest(inline('exp(x)'),0\)

%% Higher order derivatives (second derivative)
% Truth: 0
\[deriv,err] \= derivest(@(x) sin(x),pi,'deriv',2\)

%% Higher order derivatives (third derivative)
% Truth: 1
\[deriv,err] \= derivest(@(x) cos(x),pi/2,'der',3\)

%% Higher order derivatives (up to the fourth derivative)
% Truth: sqrt(2\)/2 \= 0\.707106781186548
\[deriv,err] \= derivest(@(x) sin(x),pi/4,'d',4\)

%% Evaluate the indicated (default \= first) derivative at multiple points
\[deriv,err] \= derivest(@(x) sin(x),linspace(0,2\*pi,13\))

%% Specify the step size (default stepsize \= 0\.1\)
deriv \= derivest(@(x) polyval(1:5,x),1,'deriv',4,'FixedStep',1\)

%% Provide other parameters via an anonymous function
% At a minimizer of a function, its derivative should be
% essentially zero. So, first, find a local minima of a
% first kind bessel function of order nu.
nu \= 0;
fun \= @(t) besselj(nu,t);
fplot(fun,\[0,10])
x0 \= fminbnd(fun,0,10,optimset('TolX',1\.e\-15\))
hold on
plot(x0,fun(x0\),'ro')
hold off

deriv \= derivest(fun,x0,'d',1\)

%% The second derivative should be positive at a minimizer.
deriv \= derivest(fun,x0,'d',2\)

%% Compute the numerical gradient vector of a 2\-d function
% Note: the gradient at this point should be \[4 6]
fun \= @(x,y) x.^2 \+ y.^2;
xy \= \[2 3];
gradvec \= \[derivest(@(x) fun(x,xy(2\)),xy(1\),'d',1\), ...
 derivest(@(y) fun(xy(1\),y),xy(2\),'d',1\)]

%% Compute the numerical Laplacian function of a 2\-d function
% Note: The Laplacian of this function should be everywhere \=\= 4
fun \= @(x,y) x.^2 \+ y.^2;
xy \= \[2 3];
lapval \= derivest(@(x) fun(x,xy(2\)),xy(1\),'d',2\) \+ ...
 derivest(@(y) fun(xy(1\),y),xy(2\),'d',2\)

%% Compute the derivative of a function using a central difference scheme
% Sometimes you may not want your function to be evaluated
% above or below a given point. A 'central' difference scheme will
% look in both directions equally.
\[deriv,err] \= derivest(@(x) sinh(x),0,'Style','central')

%% Compute the derivative of a function using a forward difference scheme
% But a forward scheme will only look above x0\.
\[deriv,err] \= derivest(@(x) sinh(x),0,'Style','forward')

%% Compute the derivative of a function using a backward difference scheme
% And a backward scheme will only look below x0\.
\[deriv,err] \= derivest(@(x) sinh(x),0,'Style','backward')

%% Although a central rule may put some samples in the wrong places, it may still succeed
\[d,e,del]\=derivest(@(x) log(x),.001,'style','central')

%% But forcing the use of a one\-sided rule may be smart anyway
\[d,e,del]\=derivest(@(x) log(x),.001,'style','forward')

%% Control the behavior of DERIVEST \- forward 2nd order method, with only 1 Romberg term
% Compute the first derivative, also return the final stepsize chosen
\[deriv,err,fdelta] \= derivest(@(x) tan(x),pi,'deriv',1,'Style','for','MethodOrder',2,'RombergTerms',1\)

%% Functions should be vectorized for speed, but its not always easy to do.
\[deriv,err] \= derivest(@(x) x.^2,0:5,'deriv',1\)
\[deriv,err] \= derivest(@(x) x^2,0:5,'deriv',1,'vectorized','no')



\-\-\-

\#\#\# Folder: utility functions/DERIVESTsuite/demo/html (ID: utility functions.DERIVESTsuite.demo.html)

\-\-\-

\#\#\# File: derivest\_demo.png (ID: utility functions.DERIVESTsuite.demo.html.1\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: derivest\_demo\_01\.png (ID: utility functions.DERIVESTsuite.demo.html.2\)

Could not read file: 'utf\-8' codec can't decode byte 0x89 in position 0: invalid start byte

\-\-\-

\#\#\# File: derivest\_demo.html (ID: utility functions.DERIVESTsuite.demo.html.3\)







derivest\_demo





## Contents



* [derivative of exp(x), at x \=\= 0](#2)
* [DERIVEST can also use an inline function](#3)
* [Higher order derivatives (second derivative)](#4)
* [Higher order derivatives (third derivative)](#5)
* [Higher order derivatives (up to the fourth derivative)](#6)
* [Evaluate the indicated (default \= first) derivative at multiple points](#7)
* [Specify the step size (default stepsize \= 0\.1\)](#8)
* [Provide other parameters via an anonymous function](#9)
* [The second derivative should be positive at a minimizer.](#10)
* [Compute the numerical gradient vector of a 2\-d function](#11)
* [Compute the numerical Laplacian function of a 2\-d function](#12)
* [Compute the derivative of a function using a central difference scheme](#13)
* [Compute the derivative of a function using a forward difference scheme](#14)
* [Compute the derivative of a function using a backward difference scheme](#15)
* [Although a central rule may put some samples in the wrong places, it may still succeed](#16)
* [But forcing the use of a one\-sided rule may be smart anyway](#17)
* [Control the behavior of DERIVEST \- forward 2nd order method, with only 1 Romberg term](#18)
* [Functions should be vectorized for speed, but its not always easy to do.](#19)



```
% DERIVEST demo script

% This script file is designed to be used in cell mode
% from the matlab editor, or best of all, use the publish
% to HTML feature from the matlab editor. Older versions
% of matlab can copy and paste entire blocks of code into
% the Matlab command window.

% DERIVEST is property/value is driven for its arguments.
% Properties can be shortened to the

```
## derivative of exp(x), at x \=\= 0


```
[deriv,err] = derivest(@(x) exp(x),0)

```

```
deriv =
            1
err =
   1.4046e-14

```
## DERIVEST can also use an inline function


```
[deriv,err] = derivest(inline('exp(x)'),0)

```

```
deriv =
            1
err =
   1.4046e-14

```
## Higher order derivatives (second derivative)


Truth: 0


```
[deriv,err] = derivest(@(x) sin(x),pi,'deriv',2)

```

```
deriv =
  -5.5372e-19
err =
    1.865e-18

```
## Higher order derivatives (third derivative)


Truth: 1


```
[deriv,err] = derivest(@(x) cos(x),pi/2,'der',3)

```

```
deriv =
            1
err =
   4.3657e-12

```
## Higher order derivatives (up to the fourth derivative)


Truth: sqrt(2\)/2 \= 0\.707106781186548


```
[deriv,err] = derivest(@(x) sin(x),pi/4,'d',4)

```

```
deriv =
      0.70711
err =
   1.9122e-05

```
## Evaluate the indicated (default \= first) derivative at multiple points


```
[deriv,err] = derivest(@(x) sin(x),linspace(0,2*pi,13))

```

```
deriv =
  Columns 1 through 7
            1      0.86603          0.5            0         -0.5     -0.86603           -1
  Columns 8 through 13
     -0.86603         -0.5            0          0.5      0.86603            1
err =
  Columns 1 through 7
   1.0412e-15   1.4725e-15   2.5102e-14            0   1.3754e-14   2.7429e-14   1.8034e-15
  Columns 8 through 13
   3.0284e-14   4.9044e-14            0   3.2092e-15   1.2987e-13   2.5504e-15

```
## Specify the step size (default stepsize \= 0\.1\)


```
deriv = derivest(@(x) polyval(1:5,x),1,'deriv',4,'FixedStep',1)

```

```
deriv =
           24

```
## Provide other parameters via an anonymous function


At a minimizer of a function, its derivative should be essentially zero. So, first, find a local minima of a first kind bessel
 function of order nu.
 


```
nu = 0;
fun = @(t) besselj(nu,t);
fplot(fun,[0,10])
x0 = fminbnd(fun,0,10,optimset('TolX',1.e-15))
hold on
plot(x0,fun(x0),'ro')
hold off

deriv = derivest(fun,x0,'d',1)

```

```
x0 =
       3.8317
deriv =
  -2.3285e-09

```
![](derivest_demo_01.png) ## The second derivative should be positive at a minimizer.


```
deriv = derivest(fun,x0,'d',2)

```

```
deriv =
      0.40276

```
## Compute the numerical gradient vector of a 2\-d function


Note: the gradient at this point should be \[4 6]


```
fun = @(x,y) x.^2 + y.^2;
xy = [2 3];
gradvec = [derivest(@(x) fun(x,xy(2)),xy(1),'d',1), ...
           derivest(@(y) fun(xy(1),y),xy(2),'d',1)]

```

```
gradvec =
            4            6

```
## Compute the numerical Laplacian function of a 2\-d function


Note: The Laplacian of this function should be everywhere \=\= 4


```
fun = @(x,y) x.^2 + y.^2;
xy = [2 3];
lapval = derivest(@(x) fun(x,xy(2)),xy(1),'d',2) + ...
           derivest(@(y) fun(xy(1),y),xy(2),'d',2)

```

```
lapval =
     4

```
## Compute the derivative of a function using a central difference scheme


Sometimes you may not want your function to be evaluated above or below a given point. A 'central' difference scheme will
 look in both directions equally.
 


```
[deriv,err] = derivest(@(x) sinh(x),0,'Style','central')

```

```
deriv =
     1
err =
   1.0412e-15

```
## Compute the derivative of a function using a forward difference scheme


But a forward scheme will only look above x0\.


```
[deriv,err] = derivest(@(x) sinh(x),0,'Style','forward')

```

```
deriv =
     1
err =
   3.1516e-15

```
## Compute the derivative of a function using a backward difference scheme


And a backward scheme will only look below x0\.


```
[deriv,err] = derivest(@(x) sinh(x),0,'Style','backward')

```

```
deriv =
     1
err =
   3.1516e-15

```
## Although a central rule may put some samples in the wrong places, it may still succeed


```
[d,e,del]=derivest(@(x) log(x),.001,'style','central')

```

```
d =
         1000
e =
   1.7072e-10
del =
   3.0518e-05

```
## But forcing the use of a one\-sided rule may be smart anyway


```
[d,e,del]=derivest(@(x) log(x),.001,'style','forward')

```

```
d =
         1000
e =
   6.5547e-08
del =
   0.00012207

```
## Control the behavior of DERIVEST \- forward 2nd order method, with only 1 Romberg term


Compute the first derivative, also return the final stepsize chosen


```
[deriv,err,fdelta] = derivest(@(x) tan(x),pi,'deriv',1,'Style','for','MethodOrder',2,'RombergTerms',1)

```

```
deriv =
            1
err =
   2.8399e-13
fdelta =
    0.0011984

```
## Functions should be vectorized for speed, but its not always easy to do.


```
[deriv,err] = derivest(@(x) x.^2,0:5,'deriv',1)
[deriv,err] = derivest(@(x) x^2,0:5,'deriv',1,'vectorized','no')

```

```
deriv =
            0            2            4            6            8           10
err =
            0   4.6563e-15   9.3127e-15    1.178e-14   1.8625e-14   2.3559e-14
deriv =
            0            2            4            6            8           10
err =
            0   4.6563e-15   9.3127e-15    1.178e-14   1.8625e-14   2.3559e-14

```
  

 Published with MATLABÂ® 7\.4  







\-\-\-

\#\#\# File: multivariable\_calc\_demo.html (ID: utility functions.DERIVESTsuite.demo.html.4\)







multivariable\_calc\_demo





## Contents



* [Gradient of the Rosenbrock function at \[1,1], the global minimizer](#2)
* [The Hessian matrix at the minimizer should be positive definite](#3)
* [Gradient estimation using gradest \- a function of 5 variables](#4)
* [Simple Hessian matrix of a problem with 3 independent variables](#5)
* [A semi\-definite Hessian matrix](#6)
* [Directional derivative of the Rosenbrock function at the solution](#7)
* [Directional derivative at other locations](#8)
* [Jacobian matrix of a scalar function is just the gradient](#9)
* [Jacobian matrix of a linear system will reduce to the design matrix](#10)
* [The jacobian matrix of a nonlinear transformation of variables](#11)



```
% Multivariate calculus demo script

% This script file is designed to be used in cell mode
% from the matlab editor, or best of all, use the publish
% to HTML feature from the matlab editor. Older versions
% of matlab can copy and paste entire blocks of code into
% the Matlab command window.

% Typical usage of the gradient and Hessian might be in
% optimization problems, where one might compare an analytically
% derived gradient for correctness, or use the Hessian matrix
% to compute confidence interval estimates on parameters in a
% maximum likelihood estimation.

```
## Gradient of the Rosenbrock function at \[1,1], the global minimizer


```
rosen = @(x) (1-x(1)).^2 + 105*(x(2)-x(1).^2).^2;
% The gradient should be zero (within floating point noise)
[grad,err] = gradest(rosen,[1 1])

```

```
grad =
   3.6989e-20            0
err =
   1.4545e-18            0

```
## The Hessian matrix at the minimizer should be positive definite


```
H = hessian(rosen,[1 1])
% The eigenvalues of h should be positive
eig(H)

```

```
H =
          842         -420
         -420          210
ans =
      0.39939
       1051.6

```
## Gradient estimation using gradest \- a function of 5 variables


```
[grad,err] = gradest(@(x) sum(x.^2),[1 2 3 4 5])

```

```
grad =
            2            4            6            8           10
err =
   1.2533e-14   2.5067e-14   3.4734e-14   5.0134e-14    2.836e-14

```
## Simple Hessian matrix of a problem with 3 independent variables


```
[H,err] = hessian(@(x) x(1) + x(2)^2 + x(3)^3,[1 2 3])

```

```
H =
     0     0     0
     0     2     0
     0     0    18
err =
            0            0            0
            0   4.6563e-15            0
            0            0   3.3318e-14

```
## A semi\-definite Hessian matrix


```
H = hessian(@(xy) cos(xy(1) - xy(2)),[0 0])
% one of these eigenvalues will be zero (approximately)
eig(H)

```

```
H =
           -1            1
            1           -1
ans =
           -2
  -3.8795e-07

```
## Directional derivative of the Rosenbrock function at the solution


This should be zero. Ok, its a trivial test case.


```
[dd,err] = directionaldiff(rosen,[1 1],[1 2])

```

```
dd =
     0
err =
     0

```
## Directional derivative at other locations


```
[dd,err] = directionaldiff(rosen,[2 3],[1 -1])

% We can test this example
v = [1 -1];
v = v/norm(v);
g = gradest(rosen,[2 3]);

% The directional derivative will be the dot product of the gradient with
% the (unit normalized) vector. So this difference will be (approx) zero.
dot(g,v) - dd

```

```
dd =
       743.88
err =
   1.5078e-12
ans =
   1.5916e-12

```
## Jacobian matrix of a scalar function is just the gradient


```
[jac,err] = jacobianest(rosen,[2 3])

grad = gradest(rosen,[2 3])

```

```
jac =
          842         -210
err =
   2.8698e-12   1.0642e-12
grad =
          842         -210

```
## Jacobian matrix of a linear system will reduce to the design matrix


```
A = rand(5,3);
b = rand(5,1);
fun = @(x) (A*x-b);

x = rand(3,1);
[jac,err] = jacobianest(fun,x)

disp 'This should be essentially zero at any location x'
jac - A

```

```
jac =
      0.81472      0.09754      0.15761
      0.90579       0.2785      0.97059
      0.12699      0.54688      0.95717
      0.91338      0.95751      0.48538
      0.63236      0.96489      0.80028
err =
   3.9634e-15   3.8376e-16   5.4271e-16
   3.9634e-15   8.8625e-16   5.0134e-15
   7.0064e-16   3.0701e-15   5.3175e-15
     3.76e-15   4.8542e-15   2.4271e-15
   3.0701e-15   4.3417e-15   3.9634e-15
This should be essentially zero at any location x
ans =
            0  -3.1919e-16            0
   1.1102e-16  -1.6653e-16            0
   2.7756e-17            0  -1.1102e-16
  -1.1102e-16  -3.3307e-16   1.6653e-16
            0   2.2204e-16   1.1102e-16

```
## The jacobian matrix of a nonlinear transformation of variables


evaluated at some arbitrary location \[\-2, \-3]


```
fun = @(xy) [xy(1).^2, cos(xy(1) - xy(2))];
[jac,err] = jacobianest(fun,[-2 -3])

```

```
jac =
           -4            0
     -0.84147      0.84147
err =
   2.5067e-14            0
   6.1478e-14   1.9658e-14

```
  

 Published with MATLABÂ® 7\.4  







\-\-\-

\#\#\# Folder: utility functions/DERIVESTsuite/doc (ID: utility functions.DERIVESTsuite.doc)

\-\-\-

\#\#\# File: DERIVEST.pdf (ID: utility functions.DERIVESTsuite.doc.1\)

Could not read file: 'utf\-8' codec can't decode byte 0xd0 in position 10: invalid continuation byte

\-\-\-

\#\#\# File: DERIVEST.tex (ID: utility functions.DERIVESTsuite.doc.2\)

 \\documentclass\[a4paper,11pt]{article}

\\usepackage{fancyhdr}
\\usepackage\[dvips]{graphicx} % for eps and MatLab Diagrams
\\usepackage{amsmath}
\\usepackage{psfrag,color}
\\usepackage\[framed]{/Applications/TeX/mcode}

\\pagestyle{fancy}

\\begin{document} % Begin Document

% Title
\\title{\\textsc{DERIVEST}}

% Authors and Contact Information
\\author{\\textbf{John R. D'Errico}\\\\
Email: woodchips@rochester.rr.com}

\\maketitle

\\section{Introduction \- Derivative Estimation}

The general problem of differentiation of a function typically pops up in
three ways in Matlab.

\\begin{itemize}
 \\item The symbolic derivative of a function.
 \\item Compute numerical derivatives of a function defined only by a sequence of data points.
 \\item Compute numerical derivatives of a analytically supplied function.
\\end{itemize}

Clearly the first member of this list is the domain of the symbolic toolbox, or some
set of symbolic tools. Numerical differentiation of a function defined by data points
can be achieved with the function gradient, or perhaps by differentiation of a curve fit
to the data, perhaps to an interpolating spline or a least squares spline fit.

The third class of differentiation problems is where \\mcode{DERIVEST} is valuable. This
document will describe the methods used in \\mcode{DERIVEST}.

\\bigskip

\\section{Numerical differentiation of a general function of one variable}

Surely you recall the traditional definition of a derivative, in terms of a limit.

\\begin{equation} \\tag{1}
 f'(x) \= \\lim\_{\\delta \\to 0}{\\frac{f(x\+\\delta) \- f(x)}{\\delta}}
\\end{equation}

For small $\\delta$, the limit approaches $f'(x)$. This is a one\-sided approximation for
the derivative. For a fixed value of $\\delta$, this is also known as a finite difference
approximation (a forward difference.) Other approximations for the derivative are also
available. We will see the origin of these approximations in the Taylor series expansion
of a function $f(x)$ around some point $x\_0$.

\\begin{multline} \\tag{2}
 f(x) \= f(x\_0\) \+ (x \- x\_0\)f'(x\_0\) \+ \\frac{(x \- x\_0\)^2}{2} f''(x\_0\) \+ \\\\
 \\frac{(x \- x\_0\)^3}{6} f^{(3\)}(x\_0\) \+ \\frac{(x \- x\_0\)^4}{24} f^{(4\)}(x\_0\) \+ \\\\
 \\frac{(x \- x\_0\)^5}{120} f^{(5\)}(x\_0\) \+ \\frac{(x \- x\_0\)^6}{720} f^{(6\)}(x\_0\) \+...
\\end{multline}

Truncate the series in (2\) to the first three terms, then form the forward difference
approximation (1\), where $x \= x\_0 \+ \\delta$.

\\begin{equation} \\tag{3}
 f'(x\_0\) \= \\frac{f(x\_0\+\\delta) \- f(x\_0\)}{\\delta} \- \\frac{\\delta}{2} f''(x\_0\) \- \\frac{\\delta^2}{6} f'''(x\_0\) \+ ...
\\end{equation}

When $\\delta$ is small, $\\delta^2$ and any higher powers are vanishingly small. So we tend
to ignore those higher powers, and describe the approximation in (3\) as a "first" order
approximation since the error in this approximation approaches zero at the same rate as the first power of $\\delta$. \\footnote{We would normally write these additional terms using O() notation, where all that matters is that the error term is $O(\\delta)$ or perhaps $O(\\delta^2\)$, but explicit understanding of these error terms will be useful in the Romberg extrapolation step later on.} The values of $f''(x\_0\)$ and $f'''(x\_0\)$, while unknown to us, are fixed constants as $\\delta$ varies.

Higher order approximations arise in the same fashion. The central difference (4\) is a second
order approximation.

\\begin{equation} \\tag{4}
 f'(x\_0\) \= \\frac{f(x\_0\+\\delta) \- f(x\_0\-\\delta)}{2\\delta} \- \\frac{\\delta^2}{3} f'''(x\_0\) \+ ...
\\end{equation}


\\bigskip

\\section{Unequally spaced finite difference rules}

While most finite difference rules used to differentiate a function will use equally spaced points,
this fails to be appropriate when one does not know the final spacing. Adaptive quadrature
rules can succeed by subdividing each sub\-interval as necessary. But an adaptive
differentiation scheme must work differently, since differentiation is a point estimate.
\\mcode{DERIVEST} generates a sequence of sample points that follow a log spacing away
from the point in question, then it uses a single rule (generated on the fly) to estimate the
desired derivative. Because the points are log spaced, the same rule applies at any scale,
with only a scale factor applied.


\\bigskip

\\section{Odd and even transformations of a function}

Returning to the Taylor series expansion of $f(x)$ around some point $x\_0$, an even function \\footnote{An even function is one which expresses an even symmetry around a given point. An even symmetry has the property that $f(x) \= f(\-x)$. Likewise, an odd function expresses an odd symmetry, wherein $f(x) \= \-f(\-x)$.} around $x\_0$ must have all the odd order derivatives vanish at $x\_0$. An odd function has all its even derivatives vanish from its expansion. Consider the derived functions $f\_{odd}(x)$ and $f\_{even}(x)$.

\\begin{equation} \\tag{5}
f\_{odd}(x) \= \\frac{f(x \- x\_0\) \- f(\-x \- x\_0\)}{2} 
\\end{equation}

The Taylor series expansion of $f\_{odd}(x)$ has the useful property that we have killed off any even order terms, but the odd order terms are identical to $f(x)$, as expanded around $x\_0$.

\\begin{multline} \\tag{6}
f\_{odd}(x) \= (x \- x\_0\)f'(x\_0\) \+ \\frac{(x \- x\_0\)^3}{6} f^{(3\)}(x\_0\) \+ \\\\
\\frac{(x \- x\_0\)^5}{120} f^{(5\)}(x\_0\) \+ \\frac{(x \- x\_0\)^7}{5040} f^{(7\)}(x\_0\) \+...
\\end{multline}

Likewise, $f\_{even}(x)$ has no odd order terms or a constant term, but other even order terms that are
identical to $f(x)$.

\\begin{equation} \\tag{7}
f\_{even}(x) \= \\frac{f(\-x\-x\_0\) \- 2f(x\_0\) \+ f(x\-x\_0\)}{2}
\\end{equation}

\\begin{multline} \\tag{8}
f\_{even}(x) \= \\frac{(x \- x\_0\)^2}{2} f^{(2\)}(x\_0\) \+ \\frac{(x \- x\_0\)^4}{24} f^{(4\)}(x\_0\) \+ \\\\
 \\frac{(x \- x\_0\)^6}{720} f^{(6\)}(x\_0\) \+ \\frac{(x \- x\_0\)^8}{40320} f^{(8\)}(x\_0\) \+ ...
\\end{multline}

The point of these transformations is we can rather simply generate a higher order approximation
for any odd order derivatives of $f(x)$ by working with $f\_{odd}(x)$. Even order derivatives of $f(x)$ are similarly generated from $f\_{even}(x)$. For example, a second order approximation for $f'(x\_0\)$ is trivially written in (9\) as a function of $\\delta$.

\\begin{equation} \\tag{9}
 f'(x\_0; \\delta) \= \\frac{f\_{odd}(x\_0 \+ \\delta)}{\\delta} \- \\frac{\\delta^2}{6} f^{(3\)}(x\_0\)
\\end{equation}

We can do better rather simply, so why not? (10\) shows a fourth order approximation for $f'(x\_0\)$.

\\begin{equation} \\tag{10}
 f'(x\_0; \\delta) \= \\frac{8 f\_{odd}(x\_0\+\\delta)\-f\_{odd}(x\_0\+2\\delta)}{6\\delta} \+ \\frac{\\delta^4}{30} f^{(5\)}(x\_0\)
\\end{equation}

Again, the next non\-zero term (11\) in that expansion has a higher power of $\\delta$ on it, so we
would normally ignore it since the lowest order neglected term should dominate the behavior
for small $\\delta$.

\\begin{equation} \\tag{11}
 \\frac{\\delta^6}{252} f^{(7\)}(x\_0\)
\\end{equation}

\\mcode{DERIVEST} uses similar approximations for all derivatives of $f$ up to the fourth order.
Of course, its not always possible for evaluation of a function on both sides of a point, as central difference rules will require. In these cases, you can specify forward or backward difference rules
as appropriate.


\\bigskip

\\section{Romberg extrapolation methodology applied to derivative estimation}

Some individuals might suggest that the above set of approximations are entirely adequate for
any sane person. Can we do better?

Suppose we were to generate several different estimates of the approximation in (3\) for
different values of $\\delta$ at a fixed $x\_0$. Thus, choose a single $\\delta$, estimate a
corresponding resulting approximation to $f'(x\_0\)$, then do the same for $\\delta/2$.
If we assume that the error drops off linearly as $\\delta \\to 0$, then it is a simple matter
to extrapolate this process to a zero step size. Our lack of knowledge of $f''(x\_0\)$ is
irrelevant. All that matters is $\\delta$ is small enough that the linear term dominates so we
can ignore the quadratic term, therefore the error is purely linear.

\\begin{equation} \\tag{12}
 f'(x\_0\) \= \\frac{f(x\_0\+\\delta) \- f(x\_0\)}{\\delta} \- \\frac{\\delta}{2} f''(x\_0\)
\\end{equation}

The linear extrapolant for this interval halving scheme as $\\delta \\to 0$ is given by (13\).

\\begin{equation} \\tag{13}
 f'\_0 \= 2f'\_\\delta \- f'\_{\\delta/2}
\\end{equation}

Since I've always been a big fan of convincing myself that something will work before I
proceed too far, lets try this out in Matlab. Consider the function $e^x$. Generate a pair of 
approximations to $f'(0\)$, once at $\\delta$ of 0\.1, and the second approximation at $1/2$
that value. Recall that $\\frac{d(e^x)}{dx} \= e^x$, so at x \= 0, the derivative should be
exactly 1\. How well will we do?

\\begin{lstlisting}
\>\> format long g

\>\> f \= @(x) exp(x);
\>\> del \= 0\.1;

\>\> df1 \= (f(del) \- f(0\))/del
df1 \=
 1\.05170918075648

\>\> df2 \= (f(del/2\) \- f(0\))/(del/2\)
df2 \=
 1\.02542192752048

\>\> 2\*df2 \- df1
ans \=
 0\.999134674284488
\\end{lstlisting}

In fact, this worked very nicely, reducing the error to roughly 1 percent of our initial estimates.
Should we be surprised at this reduction? Not if we recall that last term in (3\). We saw there that
the next term in the expansion was $O(\\delta^2\)$. Since $\\delta$ was 0\.1 in our experiment, that
1 percent number makes perfect sense.

The Romberg extrapolant in (13\) assumed a linear process, with a specific reduction in $\\delta$
by a factor of 2\. Assume the two term (linear \+ quadratic) residual term in (3\), evaluating our approximation there with a third value of $\\delta$. Again, assume the step size is cut in half again.
The three term Romberg extrapolant is given by (14\).

\\begin{equation} \\tag{14}
 f'\_0 \= \\frac{1}{3}f'\_\\delta \- 2f'\_{\\delta/2} \+ \\frac{8}{3}f'\_{\\delta/4}
\\end{equation}

A quick test in matlab yields much better results yet.

\\begin{lstlisting}
\>\> format long g
\>\> f \= @(x) exp(x);
\>\> del \= 0\.1;

\>\> df1 \= (f(del) \- f(0\))/del
df1 \=
 1\.05170918075648

\>\> df2 \= (f(del/2\) \- f(0\))/(del/2\)
df2 \=
 1\.02542192752048

\>\> df3 \= (f(del/4\) \- f(0\))/(del/4\)
df3 \=
 1\.01260482097715

\>\> 1/3\*df1 \- 2\*df2 \+ 8/3\*df3
ans \=
 1\.00000539448361
\\end{lstlisting} 

Again, \\mcode{DERIVEST} uses the appropriate multiple term Romberg extrapolants for all derivatives
of $f$ up to the fourth order. This, combined with the use of high order approximations for the derivatives, allows the use of quite large step sizes.

\\bigskip

\\section{Uncertainty estimates for DERIVEST}

We can view the Romberg extrapolation step as a polynomial curve fit in the step size parameter
$\\delta$. Our desired extrapolated value is seen as simply the constant term coefficient in that polynomial model. Remember though, this polynomial model (see (10\) and (11\)) has only a few
terms in it with known non\-zero coefficients. That is, we will expect a constant term $a\_0$, a term
of the form $a\_1 \\delta^4$, and a third term $a\_2 \\delta^6$. 

A neat trick to compute the "statistical" uncertainty in the estimate of our desired derivative is to
use statistical methodology for that error estimate. While I do appreciate that there is nothing
truly statistical or stochastic in this estimate, the approach still works nicely, providing a very reasonable estimate in practice. A three term Romberg\-like extrapolant, then evaluated at four distinct values for $\\delta$, will yield an estimate of the standard error of the constant term, with one spare degree of freedom. The uncertainty is then derived by multiplying that standard error by the appropriate percentile from the Students\-t distribution.

\\begin{lstlisting}
\>\> tcdf(12\.7062047361747,1\)
ans \=
 0\.975
\\end{lstlisting}

This critical level will yield a two\-sided confidence interval of 95 percent.

These error estimates are also of value in a difference sense. Since they are efficiently generated
at all the different scales, the particular spacing which yields the minimum predicted error is chosen
as the best derivative estimate. This has been shown to work consistently well. A spacing too large
tends to have large errors of approximation due to the finite difference schemes used. But a too
small spacing is bad also, in that we see a significant amplification of least significant fit errors
in the approximation. A middle value generally seems to yield quite good results. For example,
\\mcode{DERIVEST} will estimate the derivative of $e^x$ automatically. As we see, the final overall
spacing used was 0\.1953125\.

\\begin{lstlisting}
\>\> \[d,e,del]\=derivest(@(x) exp(x),1\)
d \=
 2\.71828182845904
e \=
 1\.02015503167879e\-14
del \=
 0\.1953125
\\end{lstlisting}

However, if we force the step size to be artificially large, then approximation error takes over.

\\begin{lstlisting}
\>\> \[d,e,del]\=derivest(@(x) exp(x),1,'FixedStep',10\)
d \=
 2\.3854987890005
e \=
 3\.90016042034995
del \=
 10
\\end{lstlisting}

And if the step size is forced to be too small, then we see noise dominate the problem.

\\begin{lstlisting}
\>\> \[d,e,del]\=derivest(@(x) exp(x),1,'FixedStep',.0000000001\)
d \=
 2\.71826406220403
e \=
 0\.000327191484277048
del \=
 1e\-10
\\end{lstlisting}

\\mcode{DERIVEST}, like Goldilocks in the fairy tale bearing her name, stays comfortably in
the middle ground.


\\bigskip

\\section{DERIVEST in action}

How does \\mcode{DERIVEST} work in action? A simple nonlinear function with a well
known derivative is $e^x$. At $x \= 0$, the derivative should be 1\.

\\begin{lstlisting}
\>\> \[d,err] \= derivest(@(x) exp(x),0\)
d \=
 0\.999999999999997

err \=
 2\.22066469352214e\-14
\\end{lstlisting}

A second simple example comes from trig functions. The first four derivatives of the sine
function, evaluated at $x \= 0$, should be respectively $\[cos(0\), \-sin(0\), \-cos(0\), sin(0\)]$,
or $\[1,0,\-1,0]$.

\\begin{lstlisting}
\>\> d \= derivest(@(x) sin(x),0,1\)
d \=
 0\.999999999999999

\>\> d \= derivest(@(x) sin(x),0,2\)
d \=
 0

\>\> d \= derivest(@(x) sin(x),0,3\)
d \=
 \-1\.00000000000046

\>\> d \= derivest(@(x) sin(x),0,4\)
d \=
 0
\\end{lstlisting}


\\bigskip

\\section{Gradient (\\mcode{GRADEST}) and Hessian (\\mcode{HESSIAN}) estimation}

Estimation of the gradient vector (\\mcode{GRADEST}) of a function of multiple variables is a
simple task, requiring merely repeated calls to \\mcode{DERIVEST}. Likewise, the diagonal
elements of the hessian matrix are merely pure second partial derivatives of a function.
\\mcode{HESSDIAG} accomplishes this task, again calling \\mcode{DERIVEST} multiple
times. Efficient computation of the off\-diagonal (mixed partial derivative) elements of the
Hessian matrix uses a scheme much like that of \\mcode{DERIVEST}, wherein
\\mcode{DERIVEST} is called to determine an initial step size, then Romberg extrapolation
is used to improve a set of second order finite difference estimates of those mixed partials.

\\bigskip

\\section{Conclusion}

\\mcode{DERIVEST} is an a adaptive scheme that can compute the derivative of arbitrary
(well behaved) functions. It is reasonably fast as an adaptive method. Many options have
been provided for the user who wishes the ultimate amount of control over the estimation.


\\bigskip

\\section{Acknowledgments}

My thanks are due to Shaun Simmons for convincing me to learn enough
LaTeX to write this document.

\\bigskip


\\begin{thebibliography}{3}

\\bibitem{LM66} Lyness, J. M., Moler, C. B. (1966\).
\\newblock Vandermonde Systems and Numerical Differentiation.
\\newblock \\emph{Numerische Mathematik}.

\\bibitem{LM69} Lyness, J. M., Moler, C. B. (1969\).
\\newblock Generalized Romberg Methods for Integrals of Derivatives.
\\newblock \\emph{Numerische Mathematik}.

\\bibitem{LM66} \\emph{NAG Library}.
\\newblock NAG Fortran Library Document: D04AAF

\\end{thebibliography}


\\end{document}

\-\-\-

\#\#\# Folder: utility functions/function minimization (ID: utility functions.function minimization)

\-\-\-

\#\#\# File: conjugateGradientResampleContour.m (ID: utility functions.function minimization.1\)

function x \= conjugateGradient(fn, gradfn, x0, varargin) 
%function x \= conjugateGradient(fn, gradfn, x0\) 
%
%implements conjugate gradient descent, inspired by nr

maxiter \= 200;
ftol \= 1E\-10;
resampleInterval \= 10;
plotInterval \= 0;
varargin \= assignApplicable(varargin);

x \= x0;
fp \= fn(x);
xi \= \-gradfn(x);
g \= xi;
h \= g;
fv \= zeros(\[1 maxiter]);
for its \= 1:maxiter
 \[x,fret] \= linmin(fn, x, xi);
 fv(its) \= fret;
 if (2\*abs(fret \- fp) \< ftol\*(abs(fret) \+ abs(fp) \+ eps))
 its
 figure(20\); plot(1:its, fv(1:its));
 return;
 end
 fp \= fret;
 oldx \= x;
 if (mod(its, resampleInterval) \=\= 0\)
 x \= resampleContour(x); %new, test
 end
 xi \= gradfn(x); %new, test
 %{
 gg \= sum(g.^2\);
 dgg \= sum((xi\+g).\*xi);
 if (gg \=\= 0\)
 disp('gg \= 0');
 its
 return;
 end
 gam \= dgg/gg;
 g \= \-xi;
 xi \= g\+gam\*h;
 oldx \= x;
 \[x, g, xi] \= resampleContour(x, g, xi);
 h \= xi;
 %}
 %{
 dl \= \[0 sqrt(sum(diff(x(:,\[1:end 1]),\[],2\)).^2\)];
 npts \= length(x);
 l \= cumsum(dl);
 il \= linspace(0, max(l)\*(npts\-1\)/npts, npts);
 oldx \= x;
 x \= interp1(l, x(:,\[1:end 1])', il)';
 g \= interp1(l, g(:,\[1:end 1])', il)';
 xi \= interp1(l, xi(:,\[1:end 1])', il)';
 h \= xi;
 %}
 if (plotInterval \> 0 \&\& mod(its, plotInterval) \=\= 0\)
 figure(11\);plot (oldx(1,:), oldx(2,:),'b.\-', x(1,:), x(2,:), 'r.\-'); hold on; quiver(x(1,:), x(2,:), xi(1,:), xi(2,:)); hold off; pause
 end
end
disp ('too many iters');


function \[x,fval] \= linmin(fn, x, dx)
myfn \= @(a) fn(x \+ a\*dx);
\[a,b] \= minbrak(myfn, 0, 0\.01\);
if (a \> b)
 temp \= a;
 a \= b;
 b \= temp;
end
%{
testvals \= linspace(a,b,20\);
for j \= 1:length(testvals)
 fnvals(j) \= myfn(testvals(j));
end
plot (testvals, fnvals, 'b.\-'); pause
%}
\[a,fval] \= fminbnd(myfn, a, b);
x \= x \+ a\*dx;

\-\-\-

\#\#\# File: conjugateGradient.m (ID: utility functions.function minimization.2\)

function x \= conjugateGradient(fn, gradfn, x0, varargin) 
%function x \= conjugateGradient(fn, gradfn, x0\) 
%
%implements conjugate gradient descent, inspired by nr
debug \= false;
maxiter \= 200;
ftol \= 1E\-6;
conjugate \= true;
varargin \= assignApplicable(varargin);

x \= x0;
fp \= fn(x);
xi \= \-gradfn(x);
g \= xi;
h \= g;
fv \= zeros(\[1 maxiter]);
for its \= 1:maxiter
 
 \[x,fret] \= linmin(fn, x, xi, false);
 fv(its) \= fret;
 if (2\*abs(fret \- fp) \< ftol\*(abs(fret) \+ abs(fp) \+ eps))
 %its
 if (debug)
 figure(20\); plot(1:its, fv(1:its)); 
 end
 return;
 end
 fp \= fret;
 xi \= gradfn(x);
 if (false)
 figure(10\); clf(10\); plot (x(1,:), x(2,:), 'b.\-'); hold on; quiver (x(1,:), x(2,:), \-xi(1,:), \-xi(2,:), 'g');
 end
 if (conjugate) 
 gg \= sum(g.^2\);
 dgg \= sum((xi\+g).\*xi);
 if (gg \=\= 0\)
 disp('gg \= 0');
 %its
 return;
 end
 gam \= dgg/gg;
 g \= \-xi;
 xi \= g\+gam\*h;
 h \= xi;
 
 else
 xi \= \-xi;
 end
 if (false)
 quiver (x(1,:), x(2,:), xi(1,:), xi(2,:), 'r'); hold off;
 axis equal
 pause
 end
end
disp ('too many iters');
if (debug)
 figure(20\); plot(1:its, fv(1:its)); 
end

function \[x,fval] \= linmin(fn, x, dx, debug)
myfn \= @(a) fn(x \+ a\*dx);
\[a,b] \= minbrak(myfn, 0, 1E\-4\);
if (a \> b)
 temp \= a;
 a \= b;
 b \= temp;
end
if (debug)
 figure(11\); clf(11\);
 aa \= linspace(a, b, 20\);
 for j \= 1:length(aa)
 fv(j) \= fn(x \+ aa(j)\*dx);
 end
 plot (aa, fv);
end
%{
testvals \= linspace(a,b,20\);
for j \= 1:length(testvals)
 fnvals(j) \= myfn(testvals(j));
end
plot (testvals, fnvals, 'b.\-'); pause
%}
\[a,fval] \= fminbnd(myfn, a, b);
if (debug)
 figure(10\); clf(10\); plot (x(1,:), x(2,:), 'b.\-', x(1,:) \- a\*dx(1,:), x(2,:) \- a\*dx(2,:), 'r.\-');
 pause;
end
x \= x \+ a\*dx;

\-\-\-

\#\#\# File: minbrak.m (ID: utility functions.function minimization.3\)

function \[a, b] \= minbrak(fn, a, b)
%function \[a, b] \= minbrak(fn, a, b)
%
%brackets the minimum of fn; adapted from numerical recipes in c
GOLD \= 1\.62;
fa \= fn(a);
fb \= fn(b);

if (fa \< fb)
 c \= a;
 a \= b;
 b \= c;
 fc \= fa;
 fa \= fb;
 fb \= fc;
end

c \= (1\+GOLD)\*b \- GOLD\*a;
fc \= fn(c);
while (fc \< fb) 
 r \= (b\-a)\*(fb\-fc);
 q \= (b\-c)\*(fb\-fa);
 u \= b \- ((b\-c)\*q \- (b\-a)\*r)/2\*(q\-r \+ eps\*sign(q\-r));
 ulim \= b \+ 10\*c\-b;
 if ((b\-u)\*(u\-c) \> 0\)
 fu \= fn(u);
 if (fu \< fc)
 a \= b;
 b \= c;
 return;
 end;
 if (fu \> fb)
 b \= u;
 return;
 end
 u \= c \+ GOLD\*(c\-b);
 fu \= fn(u);
 else
 if ((c \- u) \*(u \- ulim) \> 0\)
 fu \= fn(u);
 if (fu \< fc)
 b \= c;
 c \= u;
 u \= GOLD\*(c\-b);
 fb \= fc;
 fc \= fu;
 fu \= fn(u);
 end
 else
 if ((u \- ulim)\*(ulim \- c) \> 0\)
 u \= ulim;
 fu \= fn(u);
 else
 u \= c \+ GOLD\*(c\-b);
 fu \= fn(u);
 end
 end
 end
 a \= b;
 b \= c;
 c \= u;
 fa \= fb;
 fb \= fc;
 fc \= fu;
end
b \= c;

\-\-\-

\#\#\# Folder: utility functions/MWT interface (ID: utility functions.MWT interface)

\-\-\-

\#\#\# File: thisShouldAlsoWork.m (ID: utility functions.MWT interface.1\)

javaaddpath('Chore.jar')
cl \= '\-p 0\.02652 \-M 2 \-t 15 \-\-shadowless \-S \-\-plugin Reoutline::exp \-\-plugin Respine \-\-plugin SpinesForward \-\-plugin Flux::gate::\+E,892px,1185px,16mm,16mm \-\-map \-o speed,bias';
inputfname \= '/Users/gershow/mwt worm data/20120319\_192311\.zip';
outputdir \= '/Users/gershow/mwt worm data/test';
jsa \= commandLineToJavaStringArray(cl);
jsa(length(jsa)\+1\) \= java.lang.String(inputfname);
jsa(length(jsa)\+1\) \= java.lang.String('\-\-target');
jsa(length(jsa)\+1\) \= java.lang.String(outputdir);

if (\~exist(outputdir, 'dir'))
 mkdir(outputdir);
end

%{

jsa \= javaArray('java.lang.String',22'); jsa(1\) \= java.lang.String('\-p');
jsa(2\) \= java.lang.String('0\.02652'); jsa(3\) \= java.lang.String('\-M'); jsa(4\) \= java.lang.String('2'); 
jsa(5\) \= java.lang.String('\-t'); jsa(6\) \= java.lang.String('15'); 
jsa(7\) \= java.lang.String('\-\-shadowless'); 
jsa(8\) \= java.lang.String('\-S'); 
jsa(9\) \= java.lang.String('\-\-plugin'); jsa(10\) \= java.lang.String('Reoutline::exp');
jsa(11\) \= java.lang.String('\-\-plugin'); jsa(12\) \= java.lang.String('Respine'); 
jsa(13\) \= java.lang.String('\-\-plugin'); jsa(14\) \= java.lang.String('SpinesForward'); 
jsa(15\) \= java.lang.String('\-\-plugin'); jsa(16\) \= java.lang.String('Flux::gate::\+E,892px,1185px,16mm,16mm');
jsa(17\) \= java.lang.String('\-\-map'); jsa(18\) \= java.lang.String('\-o'); jsa(19\) \= java.lang.String('speed,bias'); jsa(20\) \= java.lang.String('/data/kerrr/multi\_paper/taxtap\_main/20120319\_192311\.zip'); jsa(21\) \= java.lang.String('\-\-target'); jsa(22\) \= java.lang.String('/data/kerrr/multi\_paper/test');
%}
jsp \= javaArray('CustomComputation',4\); jsp(1\) \= Reoutline(); jsp(2\) \= Respine(); jsp(3\) \= SpinesForward(); jsp(4\) \= Flux();
chore \= javaMethod('doEverything','Choreography',jsa,jsp,true);
dances \= chore.extractReasonableDancers();
length(dances)
xy \= dances(1\).extractNthSpinePoints(0\);
plot(xy)
xy2 \= dances(1\).extractNthSpinePoints(10\);
I \= 1:(length(xy)/2\);
plot(I,xy(I),I,xy2(I))



% Try also: extractCentroidPoints, extractOutlineAtFrame(n) \-\- counts up from zero
% Output arrays are x0 x1 x2 x3 .. xN y0 y1 y2 ... yN

\-\-\-

\#\#\# File: strCell2JavaStrArray.m (ID: utility functions.MWT interface.2\)

function sa \= strCell2JavaStrArray (sc)
%function sa \= strCell2JavaStrArray (sc)
%
%converts a cell of strings into a java array of strings

tf \= cellfun(@(s) ischar(s), sc);
sc \= sc(tf);
sa \= javaArray('java.lang.String', length(sc));
for j \= 1:length(sc)
 sa(j) \= java.lang.String(sc{j});
end
\-\-\-

\#\#\# File: thisShouldWork.m (ID: utility functions.MWT interface.3\)

javaaddpath('/jvm/Chore.jar')
jsa \= javaArray('java.lang.String',22'); jsa(1\) \= java.lang.String('\-p'); jsa(2\) \= java.lang.String('0\.02652'); jsa(3\) \= java.lang.String('\-M'); jsa(4\) \= java.lang.String('2'); jsa(5\) \= java.lang.String('\-t'); jsa(6\) \= java.lang.String('15'); jsa(7\) \= java.lang.String('\-\-shadowless'); jsa(8\) \= java.lang.String('\-S'); jsa(9\) \= java.lang.String('\-\-plugin'); jsa(10\) \= java.lang.String('Reoutline::exp'); jsa(11\) \= java.lang.String('\-\-plugin'); jsa(12\) \= java.lang.String('Respine'); jsa(13\) \= java.lang.String('\-\-plugin'); jsa(14\) \= java.lang.String('SpinesForward'); jsa(15\) \= java.lang.String('\-\-plugin'); jsa(16\) \= java.lang.String('Flux::gate::\+E,892px,1185px,16mm,16mm'); jsa(17\) \= java.lang.String('\-\-map'); jsa(18\) \= java.lang.String('\-o'); jsa(19\) \= java.lang.String('speed,bias'); jsa(20\) \= java.lang.String('/data/kerrr/multi\_paper/taxtap\_main/20120319\_192311\.zip'); jsa(21\) \= java.lang.String('\-\-target'); jsa(22\) \= java.lang.String('/data/kerrr/multi\_paper/test');
jsp \= javaArray('CustomComputation',4\); jsp(1\) \= Reoutline(); jsp(2\) \= Respine(); jsp(3\) \= SpinesForward(); jsp(4\) \= Flux();
chore \= javaMethod('doEverything','Choreography',jsa,jsp,true);
dances \= chore.extractReasonableDancers();
length(dances)
xy \= dances(1\).extractNthSpinePoints(0\);
plot(xy)
xy2 \= dances(1\).extractNthSpinePoints(10\);
I \= 1:(length(xy)/2\);
plot(I,xy(I),I,xy2(I))



% Try also: extractCentroidPoints, extractOutlineAtFrame(n) \-\- counts up from zero
% Output arrays are x0 x1 x2 x3 .. xN y0 y1 y2 ... yN

\-\-\-

\#\#\# File: thisShouldReallyWork.m (ID: utility functions.MWT interface.4\)

javaaddpath('Chore.jar')
inputfname \= '/Users/gershow/mwt worm data/20120319\_192311\.zip';
outputdir \= '/Users/gershow/mwt worm data/test';

jsa \= javaArray('java.lang.String',22'); jsa(1\) \= java.lang.String('\-p'); jsa(2\) \= java.lang.String('0\.02652'); jsa(3\) \= java.lang.String('\-M'); jsa(4\) \= java.lang.String('2'); jsa(5\) \= java.lang.String('\-t'); jsa(6\) \= java.lang.String('15'); jsa(7\) \= java.lang.String('\-\-shadowless'); jsa(8\) \= java.lang.String('\-S'); jsa(9\) \= java.lang.String('\-\-plugin'); jsa(10\) \= java.lang.String('Reoutline::exp'); jsa(11\) \= java.lang.String('\-\-plugin'); jsa(12\) \= java.lang.String('Respine'); jsa(13\) \= java.lang.String('\-\-plugin'); jsa(14\) \= java.lang.String('SpinesForward'); jsa(15\) \= java.lang.String('\-\-plugin'); jsa(16\) \= java.lang.String('Flux::gate::\+E,892px,1185px,16mm,16mm'); jsa(17\) \= java.lang.String('\-\-map'); jsa(18\) \= java.lang.String('\-o'); jsa(19\) \= java.lang.String('speed,bias'); 
jsa(20\) \= java.lang.String(inputfname); jsa(21\) \= java.lang.String('\-\-target'); 
jsa(22\) \= java.lang.String(outputdir);

if (\~exist(outputdir, 'dir'))
 mkdir(outputdir);
end

jsp \= javaArray('CustomComputation',4\); jsp(1\) \= Reoutline(); jsp(2\) \= Respine(); jsp(3\) \= SpinesForward(); jsp(4\) \= Flux();
chore \= javaMethod('doEverything','Choreography',jsa,jsp,true);
dances \= chore.extractReasonableDancers();
length(dances)
xy \= dances(1\).extractNthSpinePoints(0\);
plot(xy)
xy2 \= dances(1\).extractNthSpinePoints(10\);
I \= 1:(length(xy)/2\);
plot(I,xy(I),I,xy2(I))



% Try also: extractCentroidPoints, extractOutlineAtFrame(n) \-\- counts up from zero
% Output arrays are x0 x1 x2 x3 .. xN y0 y1 y2 ... yN

\-\-\-

\#\#\# File: commandLineToJavaStringArray.m (ID: utility functions.MWT interface.5\)

function sa \= commandLineToJavaStringArray(cl)
%function sa \= commandLineToJavaStringArray(cl)
%
%converts a command line into a java string array

sa \= strCell2JavaStrArray(regexp(cl, '\\s\+', 'split'));

\-\-\-

\#\#\# File: thisShouldWorkMarta.m (ID: utility functions.MWT interface.6\)

javaaddpath('Chore.jar')
%cl \= '\-t 30 \-s 0\.1 \-M 1 \-p $PV \-\-shadowless \-\-plugin Reoutline::exp \-\-plugin Respine::0\.23::tapered\=0\.28,1,2 \-\-plugin SpinesForward::rebias \-\-minimum\-biased 3mm \-S \-\-nanless';
cl \= '\-t 30 \-s 0\.1 \-M 1 \-\-shadowless \-\-plugin Reoutline::exp \-\-plugin Respine::0\.23::tapered\=0\.28,1,2 \-\-plugin SpinesForward::rebias \-\-minimum\-biased 3mm \-S \-\-nanless';

inputfname \= '/Users/gershow/mwt worm data/for Marc/20130111\_115604';
outputdir \= '/Users/gershow/mwt worm data/for Marc/20130111\_115604/test';
jsa \= commandLineToJavaStringArray(cl);
jsa(length(jsa)\+1\) \= java.lang.String(inputfname);
%jsa(length(jsa)\+1\) \= java.lang.String('\-\-target');
%jsa(length(jsa)\+1\) \= java.lang.String(outputdir);

if (\~exist(outputdir, 'dir'))
 mkdir(outputdir);
end

jsp \= javaArray('CustomComputation',3\); jsp(1\) \= Reoutline(); jsp(2\) \= Respine(); jsp(3\) \= SpinesForward(); 
%jsp(4\) \= Flux();
chore \= javaMethod('doEverything','Choreography',jsa,jsp,true);
dances \= chore.extractReasonableDancers();
length(dances)
xy \= dances(1\).extractNthSpinePoints(0\);
plot(xy)
xy2 \= dances(1\).extractNthSpinePoints(10\);
I \= 1:(length(xy)/2\);
plot(I,xy(I),I,xy2(I))



% Try also: extractCentroidPoints, extractOutlineAtFrame(n) \-\- counts up from zero
% Output arrays are x0 x1 x2 x3 .. xN y0 y1 y2 ... yN

\-\-\-

\#\#\# Folder: utility functions/file manipulation (ID: utility functions.file manipulation)

\-\-\-

\#\#\# File: importdata2\.m (ID: utility functions.file manipulation.1\)

function datastruct \= importdata2( fname )
%function datastruct \= importdata2( fname )
% imports data using impordata then adds fields using colheaders

datastruct \= importdata(fname);
if (\~isfield(datastruct, 'colheaders'))
 return;
end

%check for rows with only valid number \= frameNum and eliminate them
%these rows have no metadata

whichcol \= find(strcmpi (datastruct.colheaders, 'frameNum'), 1, 'first');
inds \= setdiff(1:length(datastruct.colheaders), whichcol);
valid \= any(datastruct.data(:,inds), 2\);
datastruct.data \= datastruct.data(valid,:);

for j \= 1:length(datastruct.colheaders)
 ch \= datastruct.colheaders{j};
 ch(isspace(ch)) \= '\_';
 datastruct.(ch) \= datastruct.data(:,j);
end

end


\-\-\-

\#\#\# File: loadObjectTypeFromMatFile.m (ID: utility functions.file manipulation.2\)

function objs \= loadObjectTypeFromMatFile (fname, objType)
%function loadObjectTypeFromMatFile (fname, objType)
%
%only loads objects of a specified type from file
%if multiple objects are present in the file, attempts to concatenate them
%as an array
%if that fails, returns a cell array
if (nargin \< 2\)
 error ('need object type');
end
try
 s \= load(fixFileNameWin(fname));
catch me
 disp ('failed to read from file');
 disp (me.getReport());
 objs \= \[];
 return;
end

fn \= fieldnames(s);
for j \= 1:length(fn)
 if \~isa(s.(fn{j}), objType)
 s \= rmField(s, fn{j});
 end
end

fn \= fieldnames(s);
for j \= 1:length(fn)
 objs{j} \= s.(fn{j}); %\#ok
end

try
 objs \= \[objs{:}];
catch
 %intentionally blank
end
\-\-\-

\#\#\# File: splitmat.m (ID: utility functions.file manipulation.3\)

function splitmat(filename)
f\=fopen(filename, 'rb');
header\=fread(f,128\);
i\=1;
\[p,fn,ext] \= fileparts(filename);
while true
 h2\=fread(f,2,'int32');
 if length(h2\) \< 2
 disp 'finished reading file';
 break;
 end
 if h2(2\) \=\= 0
 disp(sprintf('Found bad 0\-byte size at variable \#%d.', i));
 break;
 end
 fout\=fopen(sprintf('%s\_%d%s', fullfile(p,fn), i, ext), 'wb');
 fwrite(fout, header);
 fwrite(fout, h2, 'int32');
 data \= fread(f, h2(2\));
 fwrite(fout, data);
 fclose(fout);
 i \= i\+1;
end
fclose(f)
\-\-\-

\#\#\# File: getshortpath.m (ID: utility functions.file manipulation.4\)

function shortPath \= getshortpath(longPath)
%function shortPath \= getshortpath(longPath)
%on a windows PC only, returns the 8 character directory structure leading
%up to the file.
%

%adapted from code posted in MATLAB help
%http://www.mathworks.com/matlabcentral/answers/93932\-how\-can\-i\-get\-the\-short\-path\-for\-a\-windows\-long\-path\-using\-matlab\-7\-8\-r2009a

if (\~ispc)
 shortPath \= longPath;
 return;
end

ff \= {};
while(\~isdir(longPath))
 \[longPath, f, ext] \= fileparts(longPath);
 ff \= \[ff \[f ext]];
 if (isempty(longPath))
 shortPath \= longPath;
 return;
 end
end

fs \= actxserver('Scripting.FileSystemObject');

shortPath \= fullfile(fs.GetFolder(longPath).ShortPath, ff{end:\-1:1});

fs.delete;

\-\-\-

\#\#\# File: recursiveDirectorySearch\_never\_used\_or\_tested.m (ID: utility functions.file manipulation.5\)

function fileList \= recursiveDirectorySearch(dirName, pattern, maxDepth)
%function fileList \= recursiveDirectorySearch(dirName, pattern, maxDepth)
%
%modified from code posted by gnovice and Peter D on stackoverflow
%http://stackoverflow.com/questions/2652630/how\-to\-get\-all\-files\-under\-a\-specific\-directory\-in\-matlab

 if (nargin \< 3\)
 maxDepth \= 5; %by default, do not search farther than 5 directories deep
 end
 if (nargin \< 2\)
 pattern \= '';
 end
 if (maxDepth \< 0\)
 fileList \= {};
 return;
 end
 
 dirData \= dir(dirName); %\# Get the data for the current directory
 dirIndex \= \[dirData.isdir]; %\# Find the index for directories
 fileList \= {dirData(\~dirIndex).name}'; %'\# Get a list of the files
 
 if (\~isempty(pattern) \&\& \~isempty(fileList)) 
 matchstart \= regexp(fileList, pattern); 
 fileList \= fileList(\~cellfun(@isempty, matchstart));
 end
 
 
 if \~isempty(fileList)
 fileList \= cellfun(@(x) fullfile(dirName,x),... %\# Prepend path to files
 fileList,'UniformOutput',false);
 end
 subDirs \= {dirData(dirIndex).name}; %\# Get a list of the subdirectories
 validIndex \= \~ismember(subDirs,{'.','..'}); %\# Find index of subdirectories
 %\# that are not '.' or '..'
 for iDir \= find(validIndex) %\# Loop over valid subdirectories
 nextDir \= fullfile(dirName,subDirs{iDir}); %\# Get the subdirectory path
 fileList \= \[fileList; recursiveDirectorySearch(nextDir, pattern, maxDepth \- 1\)]; %\# Recursively call getAllFiles
 end

end
\-\-\-

\#\#\# File: fixFileNameWin.m (ID: utility functions.file manipulation.6\)

function f \= fixFileNameWin(f)
%function f \= fixFileNameWin(f)
%
%if is windows and is longer than 260 characters, generates short path (8
%char) directory names using windows API

MAX\_PATH \= 260;
if (\~ispc \|\| length(f) \< MAX\_PATH)
 return;
end

f \= getshortpath(f);

\-\-\-

\#\#\# File: shortenFileStub.m (ID: utility functions.file manipulation.7\)

function fs \= shortenFileStub (f)
%function fs \= shortenFileStub (f)
%
%shortens a file stub from an experiment file name by removing all 
%text between the first and last underscores ( \_ )
%if there are not two underscores or if the resulting stub is too long
%takes at most the first 12 and last 12 characters from the file name
%

\[\~,f,\~] \= fileparts(f);

t \= regexp(f, '\_', 'split');
t1 \= t{1};
t2 \= t{end};
t1 \= t1(1:min(length(t1\),12\));
t2 \= t2(max(1, length(t2\)\-11\):end);
fs \= \[t1 '\_' t2];

\-\-\-

\#\#\# Folder: utility functions/temperatureHumidityLogger (ID: utility functions.temperatureHumidityLogger)

\-\-\-

\#\#\# File: importTHLReadings.m (ID: utility functions.temperatureHumidityLogger.1\)

function readings \= importTHLReadings( input\_dir )
%UNTITLED Summary of this function goes here
% Detailed explanation goes here

dd \= dir(fullfile(input\_dir, '\*.csv'));
if (isempty(dd))
 warning ('thl:emptydir', \['no csv files found in ' input\_dir]);
 readings \= \[];
 return;
end
fn \= {};
for j \= 1:length(dd)
 data{j} \= importTHLData(fullfile(input\_dir, dd(j).name)); %\#ok\<\*AGROW\>
 fn \= union(fn, fieldnames(data{j}));
end

fn \= setdiff(fn, {'data', 'textdata'});
for j \= 1:length(data)
 for k \= 1:length(fn)
 if (\~any(cellfun(@(s) \~isempty(strfind(s, fn{k})), fieldnames(data{j}))))
 warning ('thl:notfound', \['field ' fn{k} ' not present in file: ' dd(j).name]);
 end
 end
end

for j \= 1:length(data)
 fn \= intersect(fn, fieldnames(data{j}));
end
for j \= 1:length(data)
 data{j} \= rmfield(data{j}, setdiff(fieldnames(data{j}),fn));
end
data \= cell2mat(data);



for j \= 1:length(fn)
 readings.(fn{j}) \= \[data.(fn{j})];
end
if (\~isfield(readings, 'time'))
 warning ('thl:notime', 'lost time information');
 return;
end

\[\~,I] \= sort(readings.time, 'ascend');
for j \= 1:length(fn)
 readings.(fn{j}) \= readings.(fn{j})(I);
end


\-\-\-

\#\#\# File: importTHLData.m (ID: utility functions.temperatureHumidityLogger.2\)


function data \= importTHLData (fn)
 
 data \= importdata(fn);
 colheaders \= data.textdata(1,:);
 colheaders \= regexp(colheaders, '(\\w)\+', 'match', 'once');
 colheaders \= lower(colheaders);
 ind \= find(strcmpi(colheaders, 'time'));
 data.(colheaders{ind}) \= reshape(datenum(data.textdata(2:end,ind)),1,\[]);
 colheaders \= colheaders(\~(strcmpi(colheaders, 'time')));
 for j \= 1:length(colheaders)
 data.(colheaders{j}) \= reshape(data.data(:,j),1,\[]);
 end
 
\-\-\-

\#\#\# Folder: utility functions/plotting (ID: utility functions.plotting)

\-\-\-

\#\#\# File: polarBarPlotWError.m (ID: utility functions.plotting.1\)

function \[h,heb] \= polarBarPlotWError (thetaInDeg, r, ru, rl, c, varargin)
%function \[h,heb] \= polarBarPlot (thetaInDeg, r, ru, rl, c, varargin)
%
%c \= color
%
% ru \= upper error, if all \< 0, not used 
% rl \= lower error; if empty, same as upper error, if all \< 0, not used
%varargin: 'locOfZero', angle in degrees where 0 should be located
% 'curveEB', \[false]/true, whether to curve the error bars to
% follow the data

%anything you want passed to patch

existsAndDefault('c', 'b');
locOfZero \= 0;
curveEB \= false;
varargin \= assignApplicable(varargin);

\[tid, I] \= sort(thetaInDeg \+ locOfZero);
r \= r(I);
if (size(tid, 1\) \> 1\)
 tid \= tid';
end

existsAndDefault('rl', ru);

for j \= 1:length(tid)
 dt \= median(diff(tid))/6;
 ti \= tid(j) \+ (\-dt:dt);
 if (curveEB)
 ri \= interp1(\[(tid \- 360\) tid (tid\+360\)], \[r r r], ti);
 else
 ri \= r(j);
 end
 if (isempty(rl))
 continue;
 end
 if (length(rl) \>\= j \&\& rl(j) \>\= 0\)
 r1 \= r(j) \- rl(j);
 lowerbarx{j} \= (ri \- rl(j)) .\* cosd(ti); %\#ok\<\*AGROW\>
 lowerbary{j} \= (ri \- rl(j)) .\* sind(ti);
 lowerstemx{j} \= \[r1 r(j)] \* cosd(tid(j));
 lowerstemy{j} \= \[r1 r(j)] \* sind(tid(j));
 else
 r1 \= r(j);
 lowerbarx{j} \= \[];
 lowerbary{j} \= \[];
 lowerstemx{j} \= \[];
 lowerstemy{j} \= \[];
 end
 if (length(ru) \>\= j \&\& ru(j) \>\= 0\)
 r2 \= r(j) \+ ru(j);
 upperbarx{j} \= (ri \+ ru(j)) .\* cosd(ti);
 upperbary{j} \= (ri \+ ru(j)) .\* sind(ti);
 upperstemx{j} \= \[r(j) r2] \* cosd(tid(j));
 upperstemy{j} \= \[r(j) r2] \* sind(tid(j));
 else
 r2 \= r(j);
 upperbarx{j} \= \[];
 upperbary{j} \= \[];
 upperstemx{j} \= \[];
 upperstemy{j} \= \[];
 end
 
 
 
end

ti \= min(tid):max(tid);
ri \= interp1(tid, r, ti);
tid \= tid \- median(diff(tid))/2; %was diff (thetaInDegrees)
for j \= 1:length(tid)
 
 if (j \< length(tid))
 inds \= (ti \>\= tid(j) \& ti \<\= tid(j\+1\));
 else
 inds \= \[find(ti \>\= tid(j)) find(ti \+ 360 \<\= tid(j) \+ median(diff(tid))/2\)];
 end
 xx{j} \= \[0 ri(inds).\*cosd(ti(inds)) 0];
 yy{j} \= \[0 ri(inds).\*sind(ti(inds)) 0];
end



% 
% 
% 
% x1 \= r.\*cosd(tid);
% y1 \= r.\*sind(tid);
% x2 \= r.\*cosd(tid(\[2:end 1]));
% y2 \= r.\*sind(tid(\[2:end 1]));
% 
% x0 \= zeros(size(x1\));
% y0 \= x0;

% xx \= reshape(\[x0(:) x1(:) x2(:) x0(:)]',\[],1\);
% yy \= reshape(\[y0(:) y1(:) y2(:) y0(:)]',\[],1\);
% size(xx)
xx \= \[xx{:}];
yy \= \[yy{:}];

h \= patch(xx, yy, c, varargin{:});
hold on;
if (isempty(rl) \|\| (all(rl) \< 0 \&\& all(ru) \< 0\))
 heb \= \[];
 return;
end
for j \= 1:length(upperstemx)
 heb(j,:) \= \[plot(upperstemx{j}, upperstemy{j}, upperbarx{j}, upperbary{j}, 'Color', c, 'LineWidth', 1\);plot(lowerstemx{j}, lowerstemy{j}, lowerbarx{j}, lowerbary{j}, 'Color', 'w', 'LineWidth', 1\)];
end


end


\-\-\-

\#\#\# File: projectionViewsWithIsoSurfaceCalculations.m (ID: utility functions.plotting.2\)

function pvstruct \= projectionViewsWithIsoSurfaceCalculations(im3d, xscale, yscale, zscale, isoval)
%function projectionViews(im3d, xaxis, yaxis, zaxis, clim)
%function projectionViews(im3d, xscale, yscale, zscale, clim)

clf(gcf);
existsAndDefault('xscale', 1\);
existsAndDefault('yscale', 1\);
existsAndDefault('zscale', 1\);

if (length(xscale) \=\= 1\)
 xaxis \= (1:size(im3d,2\))\*xscale;
else
 xaxis \= xscale;
end
if (length(yscale) \=\= 1\)
 yaxis \= (1:size(im3d,1\))\*yscale;
else
 yaxis \= yscale;
end
if (length(zscale) \=\= 1\)
 zaxis \= (1:size(im3d,3\))\*zscale;
else
 zaxis \= zscale;
end

pvstruct.xaxis \= xaxis;
pvstruct.yaxis \= yaxis;
pvstruct.zaxis \= zaxis;
pvstruct.imzp \= squeeze(max(im3d,\[],3\));
pvstruct.imxp \= squeeze(max(im3d,\[],2\));
pvstruct.imyp \= squeeze(max(im3d,\[],1\))';
pvstruct.fv \= isosurface(xaxis, yaxis,zaxis,im3d, isoval);
pvstruct.ison \= isonormals(xaxis, yaxis,zaxis,im3d,pvstruct.fv.vertices);
pvstruct.im3d \= im3d;
pvstruct.isoval \= isoval;

xinds \= \[find(any(pvstruct.imzp \>\= isoval, 1\), 1, 'first') find(any(pvstruct.imzp \>\= isoval, 1\), 1, 'last')];
yinds \= \[find(any(pvstruct.imzp \>\= isoval, 2\), 1, 'first') find(any(pvstruct.imzp \>\= isoval, 2\), 1, 'last')];
zinds \= \[find(any(pvstruct.imxp \>\= isoval, 1\), 1, 'first') find(any(pvstruct.imxp \>\= isoval, 1\), 1, 'last')];

pvstruct.axislims \= \[xaxis(xinds) yaxis(yinds) zaxis(zinds)];
\-\-\-

\#\#\# File: projectionViewsWithIsoSurface.m (ID: utility functions.plotting.3\)

function handles \= projectionViewsWithIsoSurface(pvstruct, clim)
%function \[ax1, ax2,ax3, ax4] \= projectionViews(pvstruct, clim)

clf(gcf);
existsAndDefault('xscale', 1\);
existsAndDefault('yscale', 1\);
existsAndDefault('zscale', 1\);

xaxis \= pvstruct.xaxis;
yaxis \= pvstruct.yaxis;
zaxis \= pvstruct.zaxis;

%figure out how big to make axes
xf \= 1;
yf \= diff(yaxis(\[1 end]))/diff(xaxis(\[1 end]));
zf \= diff(zaxis(\[1 end]))/diff(xaxis(\[1 end]));

p \= get(gcf, 'position');
w \= p(3\); h \= p(4\);

pixr \= min(w/(xf \+ zf \+ 0\.2\), h/(yf \+ zf \+ 0\.2\));

xs \= pixr\*xf;
ys \= pixr\*yf;
zs \= pixr\*zf;

sp1 \= (w \- (xs \+ zs))/(2\.5\*w);
sp2 \= (h \- (ys \+ zs))/(2\.5\*h);

ax(1\) \= axes('position', \[sp1 1\-sp2 \- ys/h xs/w ys/h]);
ax(2\) \= axes('position', \[1\-sp1\-zs/w 1\-sp2 \- ys/h zs/w ys/h]);
ax(3\) \= axes('position', \[sp1 sp2 xs/w zs/h]);
ax(4\) \= axes('position', \[1\-sp1\-zs/w sp2 zs/w zs/h]);

if (\~exist('clim', 'var') \|\| isempty(clim))
 clim \= \[0 max(pvstruct.imzp(:))];
end

imagesc(xaxis,yaxis,pvstruct.imzp, 'Parent', ax(1\));
imagesc(zaxis,yaxis,pvstruct.imxp, 'Parent', ax(2\));
imagesc(xaxis,zaxis,pvstruct.imyp, 'Parent', ax(3\));

hold(ax(1\), 'on');
\[\~,handles.cont\_h(1\)] \= contour(ax(1\), xaxis, yaxis, pvstruct.imzp, \[pvstruct.isoval pvstruct.isoval], 'w\-\-', 'LineWidth', 2\);
hold(ax(1\), 'off');

hold(ax(2\), 'on');
\[\~,handles.cont\_h(2\)] \= contour(ax(2\), zaxis, yaxis, pvstruct.imxp, \[pvstruct.isoval pvstruct.isoval], 'w\-\-', 'LineWidth', 2\);
hold(ax(2\), 'off');

hold(ax(3\), 'on');
\[\~,handles.cont\_h(3\)] \= contour(ax(3\), xaxis, zaxis, pvstruct.imyp, \[pvstruct.isoval pvstruct.isoval], 'w\-\-', 'LineWidth', 2\);
hold(ax(3\), 'off');


set(ax(1\), 'YAxisLocation', 'left', 'XAxisLocation', 'top', 'box', 'on', 'Clim', clim);
set(ax(2\), 'YAxisLocation', 'right', 'XAxisLocation', 'top', 'box', 'on', 'Clim', clim,'XDir','reverse');
set(ax(3\), 'YAxisLocation', 'left', 'XAxisLocation', 'bottom', 'box', 'on', 'Clim', clim);

axis(ax(1:3\), 'equal');
axis(ax(1:3\), 'xy');
p \= patch(pvstruct.fv, 'parent', ax(4\));
set(p,'FaceColor','red','EdgeColor','none','VertexNormals', pvstruct.ison);
daspect(ax(4\), \[1,1,1])
view(ax(4\), 3\);
axes(ax(4\));

axis(ax(4\), pvstruct.axislims);
hlight \= camlight;
lighting phong;

handles.ax \= ax;
handles.p \= p;
handles.light \= hlight;

set(gcf, 'color', 'k'); set(ax, 'color', 'k', 'XColor', 'w', 'YColor', 'w', 'ZColor', 'w');
set(ax(4\), 'XTick', \[], 'YTick', \[], 'ZTick', \[], 'XColor', 'k', 'YColor', 'k', 'ZColor', 'k'); 
set(ax(2\), 'XDir','reverse');
colormap hot;
% 
% axis(ax1, 'equal');
% axis(ax2, 'equal');
% axis(ax3, 'equal');
% axis(ax1, 'xy'); 


\-\-\-

\#\#\# File: blank8x10Figure.m (ID: utility functions.plotting.4\)

function \[axesdims, po] \= blank8x10Figure (fignum, varargin)
%function \[axesdims, po] \= blank8x10Figure (fignum, varargin)


hspace \= .6/11;
nrows \= 4;
leftmargin \= .5/8;
rightmargin \= .5/8;
topmargin \= 1/11;
bottommargin \= 1/11;
varargin \= assignApplicable(varargin);


allaxeswidth \= 1 \- leftmargin \- rightmargin;
if (existsAndDefault('fignum', \[]))
 f \= figure(fignum);
else
 f \= figure();
end
clf(f);
axesdims.fignum \= f;
ss \= get(0, 'ScreenSize');

screenwidth \= ss(3\); screenheight \= ss(4\);
figratio \= 8/10;
r \= 0\.8;
figheight \= screenheight\*r;
figwidth \= figheight\*figratio;
figpos \= round(\[(screenwidth \- figwidth)/2, (screenheight\-figheight)/2, figwidth, figheight]);
 
set(f, 'Position', figpos);
get(f, 'Position'); %calling get f,position here prevents a weird bug where text is incorrectly spaced later

set(f, 'PaperType', 'usletter', 'PaperPosition', \[0\.25 0\.25 8 10], 'PaperOrientation', 'portrait', 'color', 'w', 'inverthardcopy', 'off');


axesdims.h0 \= 1\-topmargin;
allaxesheight \= axesdims.h0\-bottommargin;

wspace2 \= 0\.08 \* allaxeswidth;
wspace3 \= 0\.08 \* allaxeswidth;
wspace4 \= 0\.08 \* allaxeswidth;
wspace5 \= 0\.05 \* allaxeswidth;

axesdims.h \= (allaxesheight \- (nrows\-1\)\*hspace)/nrows;
axesdims.dh \= axesdims.h \+ hspace;

axesdims.w2 \= min((allaxeswidth \- wspace2\)/2\);%, h\*1\.61803399\);
axesdims.w3 \= (allaxeswidth \- 2\*wspace3\)/3;
axesdims.w4 \= (allaxeswidth \- 3\*wspace4\)/4;
axesdims.w5 \= (allaxeswidth \- 4\*wspace5\)/5;

centerx \= 0\.5\*(1\+leftmargin \-rightmargin);

axesdims.lx2 \= centerx \- wspace2/2 \- axesdims.w2;
axesdims.rx2 \= centerx \+ (wspace2\)/2;

axesdims.lx3 \= centerx \- wspace3 \- 3\*axesdims.w3/2;
axesdims.cx3 \= centerx \- axesdims.w3/2;
axesdims.rx3 \= centerx \+ axesdims.w3/2 \+ wspace3;


axesdims.lx4 \= centerx \- 3\*wspace4/2 \- 2\*axesdims.w4;
axesdims.clx4 \= centerx \- wspace4/2 \- axesdims.w4;
axesdims.crx4 \= centerx \+ (wspace4\)/2;
axesdims.rx4 \= centerx \+ 3\*(wspace4\)/2\+axesdims.w4;

axesdims.lx5 \= centerx \- 2\*wspace5 \- 2\.5\*axesdims.w5;
axesdims.clx5 \= centerx \- wspace5 \- 1\.5\*axesdims.w5;
axesdims.cx5 \= centerx \- axesdims.w5/2;
axesdims.crx5 \= centerx \+ axesdims.w5/2 \+ (wspace5\);
axesdims.rx5 \= centerx \+ 1\.5\*axesdims.w5 \+ 2\*(wspace5\);

if nargout \> 1
 po.lineWidth \= 1;
 po.font \= 'Arial';
 po.fontsize \= 7;
 po.bigfontsize \= 14;
 po.color \= 'k';
 po.axesopts \= {'FontName', po.font, 'FontSize', po.fontsize, 'LineWidth', po.lineWidth/2, 'box', 'off'};
 po.plotOptions \= {'LineWidth', po.lineWidth};
 po.labelOptions \= {'Interpreter', 'Tex', 'FontSize', po.fontsize};

end
\-\-\-

\#\#\# File: colorWheelHSV.m (ID: utility functions.plotting.5\)

function colorWheelHSV()
%function colorWheelHSV()
%
%make a color wheel

dh \= 0\.01;
h \= 0:dh:1;
x \= cos(h\*2\*pi);
x1 \= cos((h\+dh)\*2\*pi);
y \= sin(h\*2\*pi);
y1 \= sin((h\+dh)\*2\*pi);

for j \= 1:length(h) 
 patch(\[0 x(j) x1(j) 0], \[0 y(j) y1(j) 0], hsv2rgb(h(j), 1,1\), 'EdgeColor', 'none'); hold on;
end

axis equal;

\-\-\-

\#\#\# File: polarBarPlot.m (ID: utility functions.plotting.6\)

function h \= polarBarPlot (thetaInDeg, r, c, varargin)
%function h \= polarBarPlot (thetaInDeg, r, c, varargin)
%
%c \= color
%varargin: 'locOfZero', angle in degrees where 0 should be located
%
%anything you want passed to patch

existsAndDefault('c', 'b');
locOfZero \= 0;
varargin \= assignApplicable(varargin);

\[tid, I] \= sort(thetaInDeg \+ locOfZero);
r \= r(I);
ti \= min(tid):max(tid);
ri \= interp1(tid, r, ti);

tid \= tid \- median(diff(tid))/2; %was diff (thetaInDegrees)
for j \= 1:length(tid)
 
 if (j \< length(tid))
 inds \= (ti \>\= tid(j) \& ti \<\= tid(j\+1\));
 else
 inds \= \[find(ti \>\= tid(j)) find(ti \+ 360 \<\= tid(j) \+ median(diff(tid))/2\)];
 end
 xx{j} \= \[0 ri(inds).\*cosd(ti(inds)) 0];
 yy{j} \= \[0 ri(inds).\*sind(ti(inds)) 0];
end

 
% 
% 
% 
 x1 \= r.\*cosd(tid);
 y1 \= r.\*sind(tid);
 x2 \= r.\*cosd(tid(\[2:end 1]));
 y2 \= r.\*sind(tid(\[2:end 1]));
 
 x0 \= zeros(size(x1\));
 y0 \= x0;

% xx \= reshape(\[x0(:) x1(:) x2(:) x0(:)]',\[],1\);
% yy \= reshape(\[y0(:) y1(:) y2(:) y0(:)]',\[],1\);
% size(xx)
xx \= \[xx{:}];
yy \= \[yy{:}];

h \= patch(xx, yy, c, varargin{:});


end


\-\-\-

\#\#\# File: dsxy2figxy\_marc.m (ID: utility functions.plotting.7\)

function varargout \= dsxy2figxy\_marc(varargin)
% dsxy2figxy \-\- Transform point or position from data space 
% coordinates into normalized figure coordinates 
% Transforms \[x y] or \[x y width height] vectors from data space
% coordinates to normalized figure coordinates in order to locate
% annotation objects within a figure. These objects are: arrow, 
% doublearrow, textarrow, ellipse line, rectangle, textbox 
%
% Syntax:
% \[figx figy] \= dsxy2figxy(\[x1 y1],\[x2 y2]) % GCA is used
% figpos \= dsxy2figxy(\[x1 y1 width height])
% \[figx figy] \= dsxy2figxy(axes\_handle, \[x1 y1],\[x2 y2])
% figpos \= dsxy2figxy(axes\_handle, \[x1 y1 width height])
%
% Usage: Obtain a position on a plot in data space and 
% apply this function to locate an annotation there, e.g., 
% \[axx axy] \= ginput(2\); (input is in data space)
% \[figx figy] \= dsxy2figxy(gca, axx, axy); (now in figure space)
% har \= annotation('textarrow',figx,figy); 
% set(har,'String',\['(' num2str(axx(2\)) ',' num2str(axy(2\)) ')']) 
%
% Copyright 2006\-2009 The MathWorks, Inc. 

% Obtain arguments (limited argument checking is done)
% Determine if axes handle is specified
if length(varargin{1}) \=\= 1 \&\& ishandle(varargin{1}) ...
 \&\& strcmp(get(varargin{1},'type'),'axes') 
 hAx \= varargin{1};
 varargin \= varargin(2:end); % Remove arg 1 (axes handle)
else
 hAx \= gca;
end;

% Remaining args are either two point locations or a position vector
if length(varargin) \=\= 1 % Assume a 4\-element position vector
 pos \= varargin{1};
else
 \[x,y] \= deal(varargin{:}); % Assume two pairs (start, end points)
end

% Get limits
axun \= get(hAx,'Units');
set(hAx,'Units','normalized'); % Make axes units normalized 
%axpos \= get(hAx,'Position'); % Get axes position
axpos \= plotboxpos(hAx); %changed by mhg to use plotboxpos
axlim \= axis(hAx); % Get the axis limits \[xlim ylim (zlim)]
axwidth \= diff(axlim(1:2\));
axheight \= diff(axlim(3:4\));

% Transform from data space coordinates to normalized figure coordinates 
if exist('x','var') % Transform a and return pair of points
 varargout{1} \= (x \- axlim(1\)) \* axpos(3\) / axwidth \+ axpos(1\);
 varargout{2} \= (y \- axlim(3\)) \* axpos(4\) / axheight \+ axpos(2\);
else % Transform and return a position rectangle
 pos(1\) \= (pos(1\) \- axlim(1\)) / axwidth \* axpos(3\) \+ axpos(1\);
 pos(2\) \= (pos(2\) \- axlim(3\)) / axheight \* axpos(4\) \+ axpos(2\);
 pos(3\) \= pos(3\) \* axpos(3\) / axwidth;
 pos(4\) \= pos(4\) \* axpos(4 )/ axheight;
 varargout{1} \= pos;
end

% Restore axes units
set(hAx,'Units',axun)
\-\-\-

\#\#\# File: projectionViewsWithIsoSurfaceWhite.m (ID: utility functions.plotting.8\)

function handles \= projectionViewsWithIsoSurfaceWhite(pvstruct, clim)
%function \[ax1, ax2,ax3, ax4] \= projectionViews(pvstruct, clim)

clf(gcf);
existsAndDefault('xscale', 1\);
existsAndDefault('yscale', 1\);
existsAndDefault('zscale', 1\);

xaxis \= pvstruct.xaxis;
yaxis \= pvstruct.yaxis;
zaxis \= pvstruct.zaxis;

%figure out how big to make axes
xf \= 1;
yf \= diff(yaxis(\[1 end]))/diff(xaxis(\[1 end]));
zf \= diff(zaxis(\[1 end]))/diff(xaxis(\[1 end]));

p \= get(gcf, 'position');
w \= p(3\); h \= p(4\);

pixr \= min(w/(xf \+ zf \+ 0\.2\), h/(yf \+ zf \+ 0\.2\));

xs \= pixr\*xf;
ys \= pixr\*yf;
zs \= pixr\*zf;

sp1 \= (w \- (xs \+ zs))/(2\.5\*w);
sp2 \= (h \- (ys \+ zs))/(2\.5\*h);

ax(1\) \= axes('position', \[sp1 1\-sp2 \- ys/h xs/w ys/h]);
ax(2\) \= axes('position', \[1\-sp1\-zs/w 1\-sp2 \- ys/h zs/w ys/h]);
ax(3\) \= axes('position', \[sp1 sp2 xs/w zs/h]);
ax(4\) \= axes('position', \[1\-sp1\-zs/w sp2 zs/w zs/h]);

if (\~exist('clim', 'var') \|\| isempty(clim))
 clim \= \[0 max(pvstruct.imzp(:))];
end

imagesc(xaxis,yaxis,pvstruct.imzp, 'Parent', ax(1\));
imagesc(zaxis,yaxis,pvstruct.imxp, 'Parent', ax(2\));
imagesc(xaxis,zaxis,pvstruct.imyp, 'Parent', ax(3\));

hold(ax(1\), 'on');
\[\~,handles.cont\_h(1\)] \= contour(ax(1\), xaxis, yaxis, pvstruct.imzp, \[pvstruct.isoval pvstruct.isoval], 'k\-\-', 'LineWidth', 2\);
hold(ax(1\), 'off');

hold(ax(2\), 'on');
\[\~,handles.cont\_h(2\)] \= contour(ax(2\), zaxis, yaxis, pvstruct.imxp, \[pvstruct.isoval pvstruct.isoval], 'k\-\-', 'LineWidth', 2\);
hold(ax(2\), 'off');

hold(ax(3\), 'on');
\[\~,handles.cont\_h(3\)] \= contour(ax(3\), xaxis, zaxis, pvstruct.imyp, \[pvstruct.isoval pvstruct.isoval], 'k\-\-', 'LineWidth', 2\);
hold(ax(3\), 'off');


set(ax(1\), 'YAxisLocation', 'left', 'XAxisLocation', 'top', 'box', 'on', 'Clim', clim);
set(ax(2\), 'YAxisLocation', 'right', 'XAxisLocation', 'top', 'box', 'on', 'Clim', clim,'XDir','reverse');
set(ax(3\), 'YAxisLocation', 'left', 'XAxisLocation', 'bottom', 'box', 'on', 'Clim', clim);

axis(ax(1:3\), 'equal');
axis(ax(1:3\), 'xy');
p \= patch(pvstruct.fv, 'parent', ax(4\));
set(p,'FaceColor','red','EdgeColor','none','VertexNormals', pvstruct.ison);
daspect(ax(4\), \[1,1,1])
view(ax(4\), 3\);
axes(ax(4\));

axis(ax(4\), pvstruct.axislims);
hlight \= camlight;
lighting phong;

handles.ax \= ax;
handles.p \= p;
handles.light \= hlight;

set(gcf, 'color', 'w'); set(ax, 'color', 'w', 'XColor', 'k', 'YColor', 'k', 'ZColor', 'k');
set(ax(4\), 'XTick', \[], 'YTick', \[], 'ZTick', \[], 'XColor', 'w', 'YColor', 'w', 'ZColor', 'w'); 
set(ax(2\), 'XDir','reverse');
colormap hot;
% 
% axis(ax1, 'equal');
% axis(ax2, 'equal');
% axis(ax3, 'equal');
% axis(ax1, 'xy'); 


\-\-\-

\#\#\# File: plotContourC.m (ID: utility functions.plotting.9\)

function plotContourC(cc, varargin)
%function plotContourC(cc, varargin)
%
rect \= \[\-Inf Inf \-Inf Inf];
varargin \= assignApplicable(varargin);

ind \= 1;
ih \= true;
while (ind \< size(cc,2\))
 nextind \= cc(2,ind) \+ ind;
 x \= cc(1,(ind\+1\):nextind);
 y \= cc(2,(ind\+1\):nextind);
 if (any(x \>\= rect(1\) \& x \<\= rect(2\) \& y \>\= rect(3\) \& y \<\= rect(4\)))
 h \= plot (x, y, varargin{:});
 ax \= get(h, 'Parent');
 ih \= ih \&\& ishold(ax);
 hold(ax, 'on');
 end
 ind \= nextind\+1;
end

if (\~ih)
 hold(ax, 'off');
end
\-\-\-

\#\#\# File: errorbarxy.m (ID: utility functions.plotting.10\)

Could not read file: 'utf\-8' codec can't decode byte 0xf6 in position 179: invalid start byte

\-\-\-

\#\#\# File: rateFunVAdaptGraphs.m (ID: utility functions.plotting.11\)

function hh \= rateFunVAdaptGraphs (rf, c, marker, fitType, varargin)
ax \= gca;
varargin \= assignApplicable(varargin);
ih \= ishold(ax);

if (length(rf) \> 1\) 
 existsAndDefault('c', {\[0 0 0]});
 existsAndDefault('fitType', 'linear');
 existsAndDefault('marker', 'o');
 for j \= 1:length(rf)
 if (iscell(c) \&\& length(c) \>\= j)
 cc \= c{j};
 else
 cc \= c;
 end
 if (iscell(fitType) \&\& length(fitType) \>\= j)
 ff \= fitType{j};
 else
 ff \= fitType;
 end
 if (iscell(marker) \&\& length(marker) \>\= j)
 mm \= marker{j};
 else
 mm \= marker;
 end
 if (j \=\= 1\)
 h \= rateFunVAdaptGraphs (rf(j), cc, mm, ff, 'ax', ax, varargin{:});
 hold (ax, 'on');
 else
 h \= \[h;rateFunVAdaptGraphs(rf(j), cc, mm, ff, 'ax',ax, varargin{:})];
 end
 
 end
 if (nargout \> 0\)
 hh \= h;
 end
 if (\~ih)
 hold(ax, 'off');
 end
 return;
end
existsAndDefault('c', {\[0 0 0]});
existsAndDefault('fitType', 'linear');
existsAndDefault('marker', 'o');
if (iscell(c))
 c \= c{1};
end
if (iscell(fitType))
 fitType \= fitType{1};
end
if (iscell(marker))
 marker \= marker{1};
end


nclip \= 0;
ax \= gca;
rscale \= 60;
varargin \= assignApplicable(varargin);

h \= errorbar(ax, rf.lx((1\+nclip):(end\-nclip)), rscale\*rf.rate((1\+nclip):(end\-nclip)), rscale\*rf.rate\_eb((1\+nclip):(end\-nclip)), marker, 'Color', c); %\#ok\<\*AGROW\>
hold on;

switch (fitType)
 case 'both'
 hp \= plot(rf.lx, rscale\*exp(polyval(rf.rateFitLin, rf.lx)), 'k\-\-', rf.lx, rscale\*exp(polyval(rf.rateFitQuad, rf.lx)), 'k\-');
 case 'quad'
 hp \= plot(rf.lx, rscale\*exp(polyval(rf.rateFitQuad, rf.lx)), 'k\-');
 case 'none'
 hp \= repmat(h(1\),0\);
 otherwise
 hp \= plot(rf.lx, rscale\*exp(polyval(rf.rateFitLin, rf.lx)), 'k\-\-');
end
set(hp, 'Color', c);
h \= \[h;hp];
if (\~ih)
 hold(ax, 'off');
end
if (nargout \> 0\)
 hh \= h;
end
\-\-\-

\#\#\# File: blankPPTFigure.m (ID: utility functions.plotting.12\)

function \[axesdims, po] \= blankPPTFigure (fignum, varargin)

figwidthin \= 6;
hspace \= .6;
nrows \= 2;
leftmargin \= .5;
rightmargin \= .5;
topmargin \= .5;
bottommargin \= .5;
figratio \= 4/3;
varargin \= assignApplicable(varargin);

figheightin \= figwidthin/figratio;
hspace \= hspace/figheightin;
leftmargin \= leftmargin/figwidthin;
rightmargin \= rightmargin/figwidthin;
topmargin \= topmargin/figheightin;
bottommargin \= bottommargin/figheightin;


allaxeswidth \= 1 \- leftmargin \- rightmargin;
if (exist ('fignum', 'var'))
 f \= figure(fignum);
else
 f \= figure();
end
clf(f);
axesdims.fignum \= f;
ss \= get(0, 'ScreenSize');

screenwidth \= ss(3\); screenheight \= ss(4\);

r \= 0\.6;
figheight \= screenheight\*r;
figwidth \= figheight\*figratio;
figpos \= round(\[(screenwidth \- figwidth)/2, (screenheight\-figheight)/2, figwidth, figheight]);
 
set(f, 'Position', figpos);
get(f, 'Position'); %calling get f,position here prevents a weird bug where text is incorrectly spaced later

%set(f, 'PaperSize', \[6\.5 6\*figratio\+0\.5], 'PaperPosition', \[0\.25 0\.25 6 6\*figratio], 'PaperOrientation', 'portrait', 'color', 'w', 'inverthardcopy', 'off');
set(f, 'PaperType', 'USLetter', 'PaperPositionMode', 'auto', 'PaperOrientation', 'landscape', 'color', 'w', 'inverthardcopy', 'off');


axesdims.h0 \= 1\-topmargin;
allaxesheight \= axesdims.h0\-bottommargin;

wspace2 \= 0\.12 \* allaxeswidth;
wspace3 \= 0\.06 \* allaxeswidth;
wspace4 \= 0\.06 \* allaxeswidth;
wspace5 \= 0\.05 \* allaxeswidth;

axesdims.h \= (allaxesheight \- (nrows\-1\)\*hspace)/nrows;
axesdims.dh \= axesdims.h \+ hspace;

axesdims.w2 \= min((allaxeswidth \- wspace2\)/2\);%, h\*1\.61803399\);
axesdims.w3 \= (allaxeswidth \- 2\*wspace3\)/3;
axesdims.w4 \= (allaxeswidth \- 3\*wspace4\)/4;
axesdims.w5 \= (allaxeswidth \- 4\*wspace5\)/5;

centerx \= 0\.5\*(1\+leftmargin \-rightmargin);

axesdims.lx2 \= centerx \- wspace2/2 \- axesdims.w2;
axesdims.rx2 \= centerx \+ (wspace2\)/2;

axesdims.lx3 \= centerx \- wspace3 \- 3\*axesdims.w3/2;
axesdims.cx3 \= centerx \- axesdims.w3/2;
axesdims.rx3 \= centerx \+ axesdims.w3/2 \+ wspace3;


axesdims.lx4 \= centerx \- 3\*wspace4/2 \- 2\*axesdims.w4;
axesdims.clx4 \= centerx \- wspace4/2 \- axesdims.w4;
axesdims.crx4 \= centerx \+ (wspace4\)/2;
axesdims.rx4 \= centerx \+ 3\*(wspace4\)/2\+axesdims.w4;

axesdims.lx5 \= centerx \- 2\*wspace5 \- 2\.5\*axesdims.w5;
axesdims.clx5 \= centerx \- wspace5 \- 1\.5\*axesdims.w5;
axesdims.cx5 \= centerx \- axesdims.w5/2;
axesdims.crx5 \= centerx \+ axesdims.w5/2 \+ (wspace5\);
axesdims.rx5 \= centerx \+ 1\.5\*axesdims.w5 \+ 2\*(wspace5\);

if nargout \> 1
 po.lineWidth \= 1\.5;
 po.font \= 'Arial';
 po.fontsize \= 12;
 po.bigfontsize \= 16;
 po.color \= 'k';
 po.axesopts \= {'FontName', po.font, 'FontSize', po.fontsize, 'LineWidth', po.lineWidth/2, 'box', 'off', 'Color', 'white'};
 po.plotOptions \= {'LineWidth', po.lineWidth};
 po.labelOptions \= {'Interpreter', 'Tex', 'FontSize', po.fontsize};

end
\-\-\-

\#\#\# File: polarBackground.m (ID: utility functions.plotting.13\)

function \[cax, cax2] \= polarBackground(radii, cax, locOfZero, varargin)
%function \[cax, cax2] \= polarBackground(radii, cax, locOfZero, varargin)
%function \[cax, cax2] \= polarBackground(maxRadius, cax, locOfZero, varargin)
%radii \= vector of radii that will be plotted, or the maximum Radius
%if second argument is requested, a new axes is created on top of cax and
%set to be clear with no box
%if locOfZero is passed then zero is rotated to occupy the angle (in
%degrees) specified
%
%varargin:
%'labelRadii' true/\[false]: if true the dotted circles are labeled with
% their radii
%'notext' \[false]/true : if true, no labels for angles or radii
%'numlabels' : number of theta positions to label;
labelRadii \= false;
notext \= false;
numlabels \= 12;
varargin \= assignApplicable(varargin);

existsAndDefault('cax', gca);
existsAndDefault('locOfZero', 0\);
cax \= newplot(cax);

next \= lower(get(cax,'NextPlot'));
hold\_state \= ishold(cax);

% get x\-axis text color so grid is in same color
tc \= get(cax,'xcolor');
ls \= get(cax,'gridlinestyle');

% Hold on to current Text defaults, reset them to the
% Axes' font attributes so tick marks use them.
fAngle \= get(cax, 'DefaultTextFontAngle');
fName \= get(cax, 'DefaultTextFontName');
fSize \= get(cax, 'DefaultTextFontSize');
fWeight \= get(cax, 'DefaultTextFontWeight');
fUnits \= get(cax, 'DefaultTextUnits');
set(cax, 'DefaultTextFontAngle', get(cax, 'FontAngle'), ...
 'DefaultTextFontName', get(cax, 'FontName'), ...
 'DefaultTextFontSize', get(cax, 'FontSize'), ...
 'DefaultTextFontWeight', get(cax, 'FontWeight'), ...
 'DefaultTextUnits','data')
rho \= radii;
% only do grids if hold is off
if \~hold\_state

% make a radial grid
 hold(cax,'on');
% ensure that Inf values don't enter into the limit calculation.
 arho \= abs(rho(:));
 maxrho \= max(arho(arho \~\= Inf));
 mult \= 0;
 while (maxrho \< 1\)
 maxrho \= maxrho\*10;
 mult \= mult\+1;
 end
 maxrho \= ceil(maxrho\*5\)/5 / 10^mult;
 hhh\=line(\[\-maxrho \-maxrho maxrho maxrho],\[\-maxrho maxrho maxrho \-maxrho],'parent',cax);
 axis(cax, 'tight');
 set(cax,'dataaspectratio',\[1 1 1],'plotboxaspectratiomode','auto')
 v \= \[get(cax,'xlim') get(cax,'ylim')];
 ticks \= sum(get(cax,'ytick')\>\=0\);
 delete(hhh);
% check radial limits and ticks
 rmin \= 0; rmax \= v(4\); rticks \= max(ticks\-1,2\);
 if rticks \> 5 % see if we can reduce the number
 if rem(rticks,2\) \=\= 0
 rticks \= rticks/2;
 elseif rem(rticks,3\) \=\= 0
 rticks \= rticks/3;
 end
 end

% define a circle
 th \= 0:pi/50:2\*pi;
 xunit \= cos(th);
 yunit \= sin(th);
% now really force points on x/y axes to lie on them exactly
 inds \= 1:(length(th)\-1\)/4:length(th);
 xunit(inds(2:2:4\)) \= zeros(2,1\);
 yunit(inds(1:2:5\)) \= zeros(3,1\);
% plot background if necessary
 if \~ischar(get(cax,'color')),
 patch('xdata',xunit\*rmax,'ydata',yunit\*rmax, ...
 'edgecolor',tc,'facecolor',get(cax,'color'),...
 'handlevisibility','off','parent',cax);
 end

% draw radial circles
 c82 \= cos(82\*pi/180\);
 s82 \= sin(82\*pi/180\);
 rinc \= (rmax\-rmin)/rticks;
 for i\=(rmin\+rinc):rinc:rmax
 hhh \= line(xunit\*i,yunit\*i,'linestyle',ls,'color',tc,'linewidth',1,...
 'handlevisibility','off','parent',cax);
 
 if (labelRadii \&\& \~notext)
 text((i\+rinc/20\)\*c82,(i\+rinc/20\)\*s82, ...
 \[' ' num2str(i,2\)],'verticalalignment','bottom',...
 'handlevisibility','off','parent',cax)
 end
 end
 set(hhh,'linestyle','\-') % Make outer circle solid

% plot spokes
 th \= ((1:6\)\*2\*pi/12\) \+ deg2rad(locOfZero);
 cst \= cos(th); snt \= sin(th);
 cs \= \[\-cst; cst];
 sn \= \[\-snt; snt];
 line(rmax\*cs,rmax\*sn,'linestyle',ls,'color',tc,'linewidth',1,...
 'handlevisibility','off','parent',cax)

% annotate spokes in degrees
 rt \= 1\.05\*rmax;
 ddtt \= 360/numlabels;
 tthh \= (0:(numlabels\-1\))\*ddtt;
 for i \= 1:length(tthh)
 if (\~notext)
 if (tthh(i) \=\= 180\)
 loc \= '\\pm 180';
 else
 loc \= int2str(mod(tthh(i) \+ 180,360\)\-180\);
 end
 if (cosd(tthh(i)\+locOfZero) \> 1/sqrt(2\))
 ha \= 'left';
 else
 if (cosd(tthh(i)\+locOfZero) \< \-1/sqrt(2\))
 ha \= 'right';
 else
 ha \= 'center';
 end
 end
 if (sind(tthh(i)\+locOfZero) \> 1/sqrt(2\))
 va \= 'bottom';
 else
 if (sind(tthh(i)\+locOfZero) \< \-1/sqrt(2\))
 va \= 'top';
 else
 va \= 'middle';
 end
 end
 text(rt\*cosd(tthh(i)\+locOfZero),rt\*sind(tthh(i)\+locOfZero),loc,'horizontalalignment',ha,'verticalalignment',va,...
 'handlevisibility','off','parent',cax)
 end
 end

% set view to 2\-D
 view(cax,2\);
% set axis limits
 axis(cax,rmax\*\[\-1 1 \-1\.15 1\.15]);
end

% Reset defaults.
set(cax, 'DefaultTextFontAngle', fAngle , ...
 'DefaultTextFontName', fName , ...
 'DefaultTextFontSize', fSize, ...
 'DefaultTextFontWeight', fWeight, ...
 'DefaultTextUnits',fUnits );

if \~hold\_state
 set(cax,'dataaspectratio',\[1 1 1]), axis(cax,'off'); set(cax,'NextPlot',next);
end

if (nargout \> 1\)
 cax2 \= cloneaxes(cax);
 set(cax2, 'Color', 'none', 'XTick', \[], 'YTick', \[],'dataaspectratio',\[1 1 1],'plotboxaspectratiomode','auto'); 
 axis(cax2, 'off');
end

\-\-\-

\#\#\# File: labeledBar.m (ID: utility functions.plotting.14\)

function \[lineHandle, textHandle ] \= labeledBar(ax, x, y, str, offset, c, lineOptions, textOptions )
%function \[lineHandle, textHandle ] \= labeledBar(ax, x, y, str, offset, c, lineOptions, textOptions )
% creates a labeled line using coordinates from selected axis, using annotation

existsAndDefault('lineOptions', {});
existsAndDefault('textOptions', {});


\[lx,ly] \= dsxy2figxy\_marc(ax, x, y);
lineHandle \= annotation('line', lx, ly, 'Color', c, lineOptions{:});
switch (lower(offset))
 case 'right'
 tx \= x(2\); ty \= mean(y);
 va \= 'middle'; ha \= 'left';
 case 'left'
 tx \= x(1\); ty \= mean(y);
 va \= 'middle'; ha \= 'right';
 case 'above'
 tx \= mean(x); ty \= y(2\);
 va \= 'bottom'; ha \= 'center';
 case 'below'
 tx \= mean(x); ty \= y(1\);
 va \= 'top'; ha \= 'center';
 otherwise
 tx \= mean(x); ty \= mean(y); 
 va \= 'middle'; ha \= 'center';
end
textHandle \= annotation('textbox', dsxy2figxy\_marc(ax, \[tx ty 0 0]), 'String', str, 'Color', 'w', 'LineStyle', 'none', 'EdgeColor', 'none', 'BackgroundColor', 'none', 'FitBoxToText', 'on', 'VerticalAlignment', va, 'HorizontalAlignment', ha, 'Margin', 2, textOptions{:});
end

% tp \= textHandle.Position;
% lp \= lineHandle.Position;
% switch (lower(offset))
% case 'right'
% lpm \= lp(2\) \+ 0\.5 \* lp(4\);
% tp(1\) \= lp(1\) \+ lp(3\);
% tp(2\) \= lpm \- tp(4\)/2;
% textHandle.Position \= tp;
% case 'left'
% lpm \= lp(2\) \+ 0\.5 \* lp(4\);
% tp(1\) \= lp(1\) \- tp(3\);
% tp(2\) \= lpm \- tp(4\)/2;
% textHandle.Position \= tp;
% case 'above'
% lpm \= lp(1\) \+ 0\.5 \* lp(2\);
% tp(2\) \= lp(2\) \+ lp(4\);
% tp(1\) \= lpm \- tp(3\)/2;
% textHandle.Position \= tp;
% case 'below'
% lpm \= lp(1\) \+ 0\.5 \* lp(2\);
% tp(2\) \= lp(2\) \- tp(4\);
% tp(1\) \= lpm \- tp(3\)/2;
% textHandle.Position \= tp;
% otherwise
% disp('unknown offset');
% end
% 
% 
% 
% end


\-\-\-

\#\#\# File: projectionViews.m (ID: utility functions.plotting.15\)

function \[ax1, ax2,ax3] \= projectionViews(im3d, xscale, yscale, zscale, clim)
%function projectionViews(im3d, xaxis, yaxis, zaxis, clim)
%function projectionViews(im3d, xscale, yscale, zscale, clim)

clf(gcf);
existsAndDefault('xscale', 1\);
existsAndDefault('yscale', 1\);
existsAndDefault('zscale', 1\);

if (length(xscale) \=\= 1\)
 xaxis \= (1:size(im3d,2\))\*xscale;
else
 xaxis \= xscale;
end
if (length(yscale) \=\= 1\)
 yaxis \= (1:size(im3d,1\))\*yscale;
else
 yaxis \= yscale;
end
if (length(zscale) \=\= 1\)
 zaxis \= (1:size(im3d,3\))\*zscale;
else
 zaxis \= zscale;
end

%figure out how big to make axes
xf \= 1;
yf \= diff(yaxis(\[1 end]))/diff(xaxis(\[1 end]));
zf \= diff(zaxis(\[1 end]))/diff(xaxis(\[1 end]));

p \= get(gcf, 'position');
w \= p(3\); h \= p(4\);

pixr \= min(w/(xf \+ zf \+ 0\.2\), h/(yf \+ zf \+ 0\.2\));

xs \= pixr\*xf;
ys \= pixr\*yf;
zs \= pixr\*zf;

sp1 \= (w \- (xs \+ zs))/(2\.5\*w);
sp2 \= (h \- (ys \+ zs))/(2\.5\*h);

ax1 \= axes('position', \[sp1 1\-sp2 \- ys/h xs/w ys/h]);
ax2 \= axes('position', \[1\-sp1\-zs/w 1\-sp2 \- ys/h zs/w ys/h]);
ax3 \= axes('position', \[sp1 sp2 xs/w zs/h]);

if (\~exist('clim', 'var') \|\| isempty(clim))
 clim \= \[0 max(im3d(:))];
end

imagesc(xaxis,yaxis,squeeze(max(im3d,\[],3\)), 'Parent', ax1\);
imagesc(zaxis,yaxis,squeeze(max(im3d,\[],2\)), 'Parent', ax2\);
imagesc(xaxis,zaxis,squeeze(max(im3d,\[],1\))', 'Parent', ax3\);

set(ax1, 'YAxisLocation', 'left', 'XAxisLocation', 'top', 'box', 'on', 'Clim', clim);
set(ax2, 'YAxisLocation', 'right', 'XAxisLocation', 'top', 'box', 'on', 'Clim', clim);
set(ax3, 'YAxisLocation', 'left', 'XAxisLocation', 'bottom', 'box', 'on', 'Clim', clim);


axis(ax1, 'equal');
axis(ax2, 'equal');
axis(ax3, 'equal');


\-\-\-

\#\#\# File: polarBackgroundHalfMoon.m (ID: utility functions.plotting.16\)

function \[cax, cax2] \= polarBackgroundHalfMoon(radii, cax, locOfZero, centerOfFace1, colorOfFace1, colorOfFace2, varargin)
%function \[cax, cax2] \= polarBackground(radii, cax, locOfZero)
%function \[cax, cax2] \= polarBackground(maxRadius, cax, locOfZero)
%radii \= vector of radii that will be plotted, or the maximum Radius
%if second argument is requested, a new axes is created on top of cax and
%set to be clear with no box
%if locOfZero is passed then zero is rotated to occupy the angle (in
%degrees) specified
labelRadii \= false;
notext \= false;
numlabels \= 12;
linewidth \= 1;
varargin \= assignApplicable(varargin);

existsAndDefault('cax', gca);
existsAndDefault('locOfZero', 0\);
existsAndDefault('centerOfFace1', 0\);
existsAndDefault('colorOfFace1', \[1 1 1]);
if (ischar(colorOfFace1\))
 colorOfFace1 \= char2rgb(colorOfFace1\);
end
existsAndDefault('colorOfFace2', 1 \- colorOfFace1\);
if (ischar(colorOfFace2\))
 colorOfFace2 \= char2rgb(colorOfFace2\);
end
cax \= newplot(cax);

next \= lower(get(cax,'NextPlot'));
hold\_state \= ishold(cax);

% get x\-axis text color so grid is in same color
tc \= get(cax,'xcolor');
%ls \= get(cax,'gridlinestyle');
ls \= ':';

% Hold on to current Text defaults, reset them to the
% Axes' font attributes so tick marks use them.
fAngle \= get(cax, 'DefaultTextFontAngle');
fName \= get(cax, 'DefaultTextFontName');
fSize \= get(cax, 'DefaultTextFontSize');
fWeight \= get(cax, 'DefaultTextFontWeight');
fUnits \= get(cax, 'DefaultTextUnits');
set(cax, 'DefaultTextFontAngle', get(cax, 'FontAngle'), ...
 'DefaultTextFontName', get(cax, 'FontName'), ...
 'DefaultTextFontSize', get(cax, 'FontSize'), ...
 'DefaultTextFontWeight', get(cax, 'FontWeight'), ...
 'DefaultTextUnits','data')
rho \= radii;
% only do grids if hold is off
if \~hold\_state
 
 % make a radial grid
 hold(cax,'on');
 % ensure that Inf values don't enter into the limit calculation.
 arho \= abs(rho(:));
 maxrho \= max(arho(arho \~\= Inf));
 mult \= 0;
 while (maxrho \< 1\)
 maxrho \= maxrho\*10;
 mult \= mult\+1;
 end
 maxrho \= ceil(maxrho\*5\)/5 / 10^mult;
 hhh\=line(\[\-maxrho \-maxrho maxrho maxrho],\[\-maxrho maxrho maxrho \-maxrho],'parent',cax);
 axis(cax, 'tight');
 set(cax,'dataaspectratio',\[1 1 1],'plotboxaspectratiomode','auto')
 v \= \[get(cax,'xlim') get(cax,'ylim')];
 ticks \= sum(get(cax,'ytick')\>\=0\);
 delete(hhh);
 % check radial limits and ticks
 rmin \= 0; rmax \= v(4\); rticks \= max(ticks\-1,2\);
 if rticks \> 5 % see if we can reduce the number
 if rem(rticks,2\) \=\= 0
 rticks \= rticks/2;
 elseif rem(rticks,3\) \=\= 0
 rticks \= rticks/3;
 end
 end
 
 % define a circle
 fc \= colorOfFace1;
 tc \= 1 \- colorOfFace1;
 th \= linspace(\-pi/2, pi/2, 50\) \+ deg2rad(centerOfFace1\);
 xunit \= cos(th);
 yunit \= sin(th);
 
 patch('xdata',xunit(\[1:end 1])\*rmax,'ydata',yunit(\[1:end 1])\*rmax, ...
 'edgecolor','none','facecolor',fc,...
 'handlevisibility','off','parent',cax);
 
 % draw radial circles
 rang \= 82 \- mod(locOfZero, 30\);
 c82 \= cos(rang\*pi/180\);
 s82 \= sin(rang\*pi/180\);
 rinc \= (rmax\-rmin)/rticks;
 for i\=(rmin\+rinc):rinc:rmax
 hhh \= line(xunit\*i,yunit\*i,'linestyle',ls,'color',tc,'linewidth',linewidth,...
 'handlevisibility','off','parent',cax);
 if (labelRadii \&\& \~notext)
 if (cosd(centerOfFace1 \- rang) \> 0\)
 text((i\+rinc/20\)\*c82,(i\+rinc/20\)\*s82, ...'
 \[' ' num2str(i)],'verticalalignment','bottom',...
 'handlevisibility','off','parent',cax, 'color', tc)
 end
 end
 end
 % Make outer circle solid
 set(hhh,'linestyle','\-', 'color', \[0 0 0]);
 
 
 fc \= colorOfFace2;
 tc \= 1 \- colorOfFace2;
 th \= pi \+ linspace(\-pi/2, pi/2, 50\) \+ deg2rad(centerOfFace1\);
 xunit \= cos(th);
 yunit \= sin(th);
 
 patch('xdata',xunit(\[1:end 1])\*rmax,'ydata',yunit(\[1:end 1])\*rmax, ...
 'edgecolor','none','facecolor',fc,...
 'handlevisibility','off','parent',cax);
 
 % draw radial circles
 for i\=(rmin\+rinc):rinc:rmax
 hhh \= line(xunit\*i,yunit\*i,'linestyle',ls,'color',tc,'linewidth',linewidth,...
 'handlevisibility','off','parent',cax);
 if (labelRadii \&\& \~notext)
 
 if (cosd(centerOfFace1 \- rang) \< 0\)
 text((i\+rinc/20\)\*c82,(i\+rinc/20\)\*s82, ...'
 \[' ' num2str(i)],'verticalalignment','bottom',...
 'handlevisibility','off','parent',cax, 'color', tc)
 end
 end
 end
 % Make outer circle solid
 set(hhh,'linestyle','\-', 'color', \[0 0 0]);
 
 
 % plot spokes
 
 for th \= ((1:12\)\*2\*pi/12\) \+ deg2rad(locOfZero);
 cst \= cos(th); snt \= sin(th);
 cs \= \[0; cst];
 sn \= \[0; snt];
 if (cos(th \- deg2rad(centerOfFace1\)) \> 0\)
 tc \= 1 \- colorOfFace1;
 else
 tc \= 1 \- colorOfFace2;
 end
 line(rmax\*cs,rmax\*sn,'linestyle',ls,'color',tc,'linewidth',linewidth,...
 'handlevisibility','off','parent',cax)
 end
% %annotate spokes in degrees
% rt \= 1\.1\*rmax;
% th \= ((1:6\)\*2\*pi/12\) \+ deg2rad(locOfZero);
% cst \= cos(th); snt \= sin(th);
% for i \= 1:length(th)
% if (\~notext)
% 
% text(rt\*cst(i),rt\*snt(i),int2str(mod(i\*30 \+ 180, 360\)\-180\),...
% 'horizontalalignment','center',...
% 'handlevisibility','off','parent',cax);
% 
% loc \= int2str(mod(i\*30, 360\) \- 180\);
% text(\-rt\*cst(i),\-rt\*snt(i),loc,'horizontalalignment','center',...
% 'handlevisibility','off','parent',cax)
% end
% end
% annotate spokes in degrees
 rt \= 1\.05\*rmax;
 ddtt \= 360/numlabels;
 tthh \= (0:(numlabels\-1\))\*ddtt;
 for i \= 1:length(tthh)
 if (\~notext)
 if (tthh(i) \=\= 180\)
 loc \= '\\pm 180';
 else
 loc \= int2str(mod(tthh(i) \+ 180,360\)\-180\);
 end
 if (cosd(tthh(i)\+locOfZero) \> 1/sqrt(2\))
 ha \= 'left';
 else
 if (cosd(tthh(i)\+locOfZero) \< \-1/sqrt(2\))
 ha \= 'right';
 else
 ha \= 'center';
 end
 end
 if (sind(tthh(i)\+locOfZero) \> 1/sqrt(2\))
 va \= 'bottom';
 else
 if (sind(tthh(i)\+locOfZero) \< \-1/sqrt(2\))
 va \= 'top';
 else
 va \= 'middle';
 end
 end
 text(rt\*cosd(tthh(i)\+locOfZero),rt\*sind(tthh(i)\+locOfZero),loc,'horizontalalignment',ha,'verticalalignment',va,...
 'handlevisibility','off','parent',cax)
 end
 end
 % set view to 2\-D
 view(cax,2\);
 % set axis limits
 axis(cax,rmax\*\[\-1 1 \-1\.15 1\.15]);
end

% Reset defaults.
set(cax, 'DefaultTextFontAngle', fAngle , ...
 'DefaultTextFontName', fName , ...
 'DefaultTextFontSize', fSize, ...
 'DefaultTextFontWeight', fWeight, ...
 'DefaultTextUnits',fUnits );

if \~hold\_state
 set(cax,'dataaspectratio',\[1 1 1]), axis(cax,'off'); set(cax,'NextPlot',next);
end

if (nargout \> 1\)
 cax2 \= cloneaxes(cax);
 set(cax2, 'Color', 'none', 'XTick', \[], 'YTick', \[],'dataaspectratio',\[1 1 1],'plotboxaspectratiomode','auto');
 axis(cax2, 'off');
end

\-\-\-

\#\#\# Folder: utility functions/geometry (ID: utility functions.geometry)

\-\-\-

\#\#\# File: resampleContour.m (ID: utility functions.geometry.1\)

function \[newctr, varargout] \= resampleContour(ctr, varargin)
%resamples contour and any other associated quantities (varargins) to 
%be evenly spaced (associated quantities are resampled along the same
%indices as contour
%
closed \= true;
varargin \= assignApplicable(varargin);
if (closed)
 npts \= length(ctr);
 dl \= sqrt(sum(diff(ctr(:,\[1 1:end 1]),\[],2\).^2\));
 l \= cumsum(dl);
 il \= linspace(0, l(end)\*(npts\-1\)/npts, npts);
 inds \= interp1(cumsum(dl), 1:(npts \+ 1\), il);

 %newctr \= interp1(cumsum(dl), ctr(:, \[1:end 1])', il,'linear')';
 newctr \= interp1(ctr(:, \[1:end 1])', inds, 'spline')';

 for j \= 1:length(varargin)
 x \= varargin{j};
 varargout{j} \= interp1(x(:, \[1:end 1])', inds, 'spline')';
 end
else
 npts \= length(ctr);
 dl \= sqrt(sum(diff(ctr(:,\[1 1:end]),\[],2\).^2\));
 l \= cumsum(dl);
 il \= linspace(0, l(end), npts);
 \[l,I] \= unique(l);
 inds \= interp1(l, I, il);

 %newctr \= interp1(cumsum(dl), ctr(:, \[1:end 1])', il,'linear')';
 newctr \= interp1(ctr', inds, 'spline')';

 for j \= 1:length(varargin)
 x \= varargin{j};
 varargout{j} \= interp1(x', inds, 'spline')';
 end
end
\-\-\-

\#\#\# File: bezierCurvatureEnergy.m (ID: utility functions.geometry.2\)

function \[cv2, grad\_cv2, cv] \= bezierCurvatureEnergy(cpts, s)
%function \[cv2, grad\_cv2] \= bezierCurvatureEnergy(cpts, s)
%right now, grad\_cv2 is only correct for quadratic bezier (3 cpts)
%because I am lazy right now, also only produces correct values for 
%uniformly spaced s from 0 to 1
%
\[\~,Mp] \= bezierMatrix(size(cpts,2\)\-1, s);

du \= cpts\*Mp;
ddu \= diff(du,\[],2\)\*length(s); 
ddu \= 0\.5\*(ddu(:,\[1 1:end]) \+ ddu(:,\[1:end end]));
v2 \= sqrt(sum(du.^2\));

cv \= (du(1,:).\*ddu(2,:) \- du(2,:).\*ddu(1,:))./(v2\.^(1\.5\));

cv2 \= sum(cv.^2\)/length(s);

num \= (mean(du(1,:).\*ddu(2,:) \- du(2,:).\*ddu(1,:)))^2;
coeff \= 6/length(s)\*num./(v2\.^4\);
gradx \= sum((ones(size(Mp,1\),1\)\*(coeff.\*(cpts(1,:)\*Mp)).\*Mp),2\);
grady \= sum((ones(size(Mp,1\),1\)\*(coeff.\*(cpts(2,:)\*Mp)).\*Mp),2\);

grad\_cv2 \= \[gradx';grady'];
\-\-\-

\#\#\# File: testBezier.m (ID: utility functions.geometry.3\)

function testBezier

\[X,Y] \= getpts();
cpts \= \[X Y]';
pts \= bezierFromControlPoints(cpts, 100\);
plot (X,Y,'r.', X,Y,'k\-\-',pts(1,:), pts(2,:), 'b\-');

\-\-\-

\#\#\# File: intersectionPoint.m (ID: utility functions.geometry.4\)

function \[pt,inPt1Pt2,inPt3Pt4] \= intersectionPoint(pt1,pt2,pt3,pt4\)
%function pt \= intersectionPoint(pt1,pt2,pt3,pt4\)
%
%returns the location of the intersection of the two lines defined by
%pt1\-pt2 and pt3\-pt4


d \= (pt4(2\)\-pt3(2\))\*(pt2(1\)\-pt1(1\)) \- (pt4(1\)\-pt3(1\))\*(pt2(2\)\-pt1(2\));
n \= (pt4(1\)\-pt3(1\))\*(pt1(2\)\-pt3(2\)) \- (pt4(2\)\-pt3(2\))\*(pt1(1\)\-pt3(1\));
n2 \= (pt2(1\)\-pt1(1\))\*(pt1(2\)\-pt3(2\)) \- (pt2(2\)\-pt1(2\))\*(pt1(1\)\-pt3(1\));
pt \= pt1 \+ n/d\*(pt2\-pt1\);

inPt1Pt2 \= 0 \<\= n/d \&\& n/d \<\=1;
inPt3Pt4 \= 0 \<\= n2/d \&\& n2/d \<\=1;
\-\-\-

\#\#\# File: segmentsIntersect.m (ID: utility functions.geometry.5\)

function si \= segmentsIntersect(pt1,pt2,pt3,pt4\)
%function si \= segmentsIntersect(pt1,pt2,pt3,pt4\)
%
%returns true if the segments defined by pt1\-pt2 and pt3\-pt4 intersect

d \= (pt4(2,:)\-pt3(2,:)).\*(pt2(1,:)\-pt1(1,:)) \- (pt4(1,:)\-pt3(1,:)).\*(pt2(2,:)\-pt1(2,:));
n1 \= (pt4(1,:)\-pt3(1,:)).\*(pt1(2,:)\-pt3(2,:)) \- (pt4(2,:)\-pt3(2,:)).\*(pt1(1,:)\-pt3(1,:));
n2 \= (pt2(1,:)\-pt1(1,:)).\*(pt1(2,:)\-pt3(2,:)) \- (pt2(2,:)\-pt1(2,:)).\*(pt1(1,:)\-pt3(1,:));

si \= (n1\./d \<\= 1\) \& (n1\./d \>\= 0\) \& (n2\./d \<\= 1\) \& (n2\./d \>\= 0\);
si(d \=\= 0\) \= false;
inds \= d \=\= 0 \& n1 \=\= 0 \& n2 \=\= 0;
if (any(inds))
 r \= pt2\-pt1;
 d1(1,:) \= pt3(1,:)\-pt1(1,:);d1(2,:) \= pt3(2,:)\-pt1(2,:);
 d2(1,:) \= pt4(1,:)\-pt1(1,:);d2(2,:) \= pt4(2,:)\-pt1(2,:);
 si(inds) \= (dot(r(:,inds),d1(:,inds)) \<\= dot(r(:,inds),r(:,inds)) \& dot(r(:,inds),d1(:,inds))\>0\) \| ...
 (dot(r(:,inds),d2(:,inds)) \<\= dot(r(:,inds),r(:,inds)) \& dot(r(:,inds),d2(:,inds))\>0\);
end

% if (any(si))
% figure(10\)
% if (size(pt1,2\) \> 1\)
% ind1 \= find(si);
% else
% ind1 \= 1;
% end
% if (size(pt3,2\) \> 1\)
% ind2 \= find(si);
% else
% ind2 \= 1;
% end
% plot (\[pt1(1,ind1\) pt2(1,ind1\)], \[pt1(2,ind1\) pt2(2,ind1\)], 'b\-', \[pt3(1,ind2\) pt4(1,ind2\)], \[pt3(2,ind2\) pt4(2,ind2\)], 'r\-', ...
% pt1(1,ind1\), pt1(2,ind1\), 'bo', pt3(1,ind2\), pt3(2,ind2\), 'ro');
% d(si)
% n1(si)
% n2(si)
% end
\-\-\-

\#\#\# File: distanceFromPointToLineSegment.m (ID: utility functions.geometry.6\)

function d \= distanceFromPointToLineSegment(x1, x2, p)
%function d \= distanceFromPointToLineSegment(x1, x2, p)
%finds the distance from the point(s) p to the line segment defined by 
%x1, x2\. d \> 0 if p is to the right of the line from x1 to x2
%
%p is a 2xN list of points

ls \= sum((x2\-x1\).^2\);
v \= x2\-x1;
vp \= \[v(2\);\-v(1\)]; %perpendicular to the right

d \= vp(1\)\*(p(1,:) \- x1(1\)) \+ vp(2\)\*(p(2,:)\-x1(2\)); %oriented distance to infinite line

u \= (v(1\)\*(p(1,:) \- x1(1\)) \+ v(2\)\*(p(2,:)\-x1(2\)))/ls;
d(u \< 0\) \= sign(d(u\<0\)).\*sqrt((p(1,u\<0\)\-x1(1\)).^2 \+ (p(2,u\<0\)\-x1(2\)).^2\);
d(u \> 1\) \= sign(d(u\>1\)).\*sqrt((p(1,u\>1\)\-x2(1\)).^2 \+ (p(2,u\>1\)\-x2(2\)).^2\);


%{
from: http://stackoverflow.com/questions/849211/shortest\-distance\-between\-a\-point\-and\-a\-line\-segment
float minimum\_distance(vec2 v, vec2 w, vec2 p) {
 // Return minimum distance between line segment vw and point p
 const float l2 \= length\_squared(v, w); // i.e. \|w\-v\|^2 \- avoid a sqrt
 if (l2 \=\= 0\.0\) return distance(p, v); // v \=\= w case
 // Consider the line extending the segment, parameterized as v \+ t (w \- v).
 // We find projection of point p onto the line. 
 // It falls where t \= \[(p\-v) . (w\-v)] / \|w\-v\|^2
 const float t \= dot(p \- v, w \- v) / l2;
 if (t \< 0\.0\) return distance(p, v); // Beyond the 'v' end of the segment
 else if (t \> 1\.0\) return distance(p, w); // Beyond the 'w' end of the segment
 const vec2 projection \= v \+ t \* (w \- v); // Projection falls on the segment
 return distance(p, projection);
}
%}
\-\-\-

\#\#\# File: splitOutline.m (ID: utility functions.geometry.7\)

function \[midline, c1, c2] \= splitOutline(cpts, endpt1, endpt2\)
%function \[midline, c1, c2] \= splitOutline(cpts, enpt1, endpt2\)
%
%splits contour into two halves, running from endpt1 to endpt2
%midline is the mean of these halves
%enpts can either be points, or indices into cpts
%cpts is 2Xnpts

cpts \= double(cpts);
endpt1 \= double(endpt1\);
endpt2 \= double(endpt2\);


if numel(endpt1\) \=\= 1
 ind1 \= endpt1;
else
 \[\~,ind1] \= min(sum((cpts\-repmat(endpt1, 1, size(cpts,2\))).^2\));
 % ind1 \= dt.nearestNeighbor(endpt1(1\), endpt1(2\));
end
if numel(endpt2\) \=\= 1
 ind2 \= endpt2;
else
 \[\~,ind2] \= min(sum((cpts\-repmat(endpt2, 1, size(cpts,2\))).^2\));
 %ind2 \= dt.nearestNeighbor(endpt2(1\), endpt2(2\));
end

if (ind1 \< ind2\)
 c1 \= cpts(:,ind1:ind2\);
 c2 \= cpts(:,\[ind1:\-1:1 end:\-1:ind2]);
else
 c1 \= cpts(:, ind1:\-1:ind2\);
 c2 \= cpts(:,\[ind1:end 1:ind2]);
end

npts \= max(length(c1\), length(c2\));
c1 \= interp1(c1', linspace(1,length(c1\), npts))';
c2 \= interp1(c2', linspace(1,length(c2\), npts))';
c1 \= resampleContour(c1, 'closed', false);
c2 \= resampleContour(c2, 'closed', false);
midline \= resampleContour(0\.5 \* (c1 \+ c2\), 'closed', false);

\-\-\-

\#\#\# File: bezierMatrix.m (ID: utility functions.geometry.8\)

function \[MS,dMS] \= bezierMatrix(n, s)

MS \= zeros(n\+1, length(s));
a \= s;
b \= 1\-s;
for k \= 0:n
 MS(k\+1,:) \= nchoosek(n,k)\*a.^k.\*b.^(n\-k);
end
if (nargout \> 1\)
 dMS \= zeros(n\+1, length(s));
 a \= s;
 b \= 1\-s;
 dMS(1,:) \= (\-1\)^(n)\*((n)\*b.^(n\-1\));
 dMS(n\+1,:) \= n\*a.^(n\-1\);
 for k \= 1:(n\-1\)
 dMS(k\+1,:) \= (\-1\)^(n\-k)\*nchoosek(n,k)\*(k\*a.^(k\-1\).\*b.^(n\-k) \+(n\-k)\*a.^k.\*b.^(n\-k\-1\));
 end
end

\-\-\-

\#\#\# File: divideSquareByCorner.m (ID: utility functions.geometry.9\)

function \[a,pts] \= divideSquareByCorner (ll, ur, x0, x1, x2\)
%function \[a,pts] \= divideSquareByCorner (ll, ur, x0, x1, x2\)
%
%given a line between x0 and x1 and a line between x1 and x2, with x1 in the square
%defined by corners at ll, ur; ll \< ur
%
%finds the intersection points A and B between the lines x0\-x1 (A) and
%x1\-x2 (B) and the square
%
%gives the area of the polygon A, (0\-3 corners of square), B. The corners
%are chosen so that the line has a counter\-clockwise orientation.

corners \= \[\[ll(1\);ll(2\)] \[ur(1\);ll(2\)] \[ur(1\);ur(2\)] \[ll(1\);ur(2\)]];

%find points where lines intersect sides
for c1 \= 1:4
 k \= mod(c1,4\)\+1;
 \[A,in1,in2] \= intersectionPoint(corners(:,c1\), corners(:,k), x0, x1\);
 if (in1 \&\& in2\)
 break;
 end
end

for c2 \= 1:4
 k \= mod(c2,4\)\+1;
 \[B,in1,in2] \= intersectionPoint(corners(:,c2\), corners(:,k), x1, x2\);
 if (in1 \&\& in2\)
 break;
 end
end
if (c1 \=\= c2\) %intersection through the same side
 pts \= \[A x1 B];
 threepts \= true;
else
 threepts \= false;
 %make a set of points oriented counterclockwise
 %A x1 B c2:c1
 dx1 \= A \- corners(:,c1\); dx2 \= x1 \- A; 
 if (dx1(1\)\*dx2(2\)\-dx2(1\)\*dx1(2\)) \< 0
 c1 \= mod(c1,4\)\+1;
 end
 
 dx1 \= B\-x1; dx2 \= corners(:,c2\) \- B; 
 if (dx1(1\)\*dx2(2\)\-dx2(1\)\*dx1(2\)) \< 0
 c2 \= mod(c2,4\)\+1;
 end
 
 if (c2 \<\= c1\)
 pts \= \[A x1 B corners(:,c2:c1\)];
 else
 pts \= \[A x1 B corners(:,\[c2:4 1:c1])];
 end
end
 %{
plot (corners(1,:), corners(2,:), 'k.\-', corners(1,\[4 1]), corners(2,\[4 1]), 'm\-', \[x0(1\), x1(1\), x2(1\)], \[x0(2\), x1(2\), x2(2\)], 'g.\-', pts(1,:), pts(2,:), 'co', corners(1,c1\), corners(2,c1\), 'r\*', corners(1,c2\), corners(2,c2\), 'g\*'); 
text (A(1\), A(2\), 'A'); text(B(1\), B(2\), 'B'); text (x0(1\), x0(2\), 'x0'); text (x1(1\), x1(2\), 'x1');text (x2(1\), x2(2\), 'x2'); 
pause
%}
a \= polyarea\_signed(pts(1,:), pts(2,:));
if (a \< 0\)
 
 if (\~threepts)
 warning ('DSQC: produced points in wrong orientation');
% plot (corners(1,:), corners(2,:), 'k.\-', corners(1,\[4 1]), corners(2,\[4 1]), 'm\-', \[x0(1\), x1(1\), x2(1\)], \[x0(2\), x1(2\), x2(2\)], 'g.\-', pts(1,:), pts(2,:), 'co', corners(1,c1\), corners(2,c1\), 'r\*', corners(1,c2\), corners(2,c2\), 'g\*'); 
% text (A(1\), A(2\), 'A'); text(B(1\), B(2\), 'B'); text (x0(1\), x0(2\), 'x0'); text (x1(1\), x1(2\), 'x1');text (x2(1\), x2(2\), 'x2'); 
% pause
 a \= \-a;
 else
 a \= (ur(2\)\-ll(2\))\*(ur(1\)\-ll(1\)) \+ a;
 end
end

\-\-\-

\#\#\# File: medialAxis.m (ID: utility functions.geometry.10\)

function pts \= medialAxis(cpts)
constraints \= \[1:length(cpts);\[2:length(cpts) 1]];
dt \= DelaunayTri(double(cpts'), constraints');
inside \= dt.inOutStatus();
tr \= TriRep(dt(inside, :), dt.X);

% Construct a set of edges that join the circumcenters of neighboring
% triangles; the additional logic constructs a unique set of such edges.
numt \= size(tr,1\);
T \= (1:numt)';
neigh \= tr.neighbors();
cc \= tr.circumcenters();
xcc \= cc(:,1\);
ycc \= cc(:,2\);
idx1 \= T \< neigh(:,1\);
idx2 \= T \< neigh(:,2\);
idx3 \= T \< neigh(:,3\);
neigh \= \[T(idx1\) neigh(idx1,1\); T(idx2\) neigh(idx2,2\); T(idx3\) neigh(idx3,3\)]';

pts \= cc(neigh,:)';

clf;
triplot(tr, 'g');
hold on;
plot(xcc(neigh), ycc(neigh), '\-r', 'LineWidth', 1\.5\);
\-\-\-

\#\#\# File: affineFit.m (ID: utility functions.geometry.11\)

function \[xc, yc, xr, yr, A] \= affineFit (xc, yc, xr, yr)
%function \[xc, yc, xr, yr, A] \= affineFit (xc, yc, xr, yr)


midx \= mean(xc);
midy \= mean(yc);

\[\~,I] \= sort((xc \- midx).^2 \+ (yc \- midy).^2\); %find nearest points to center

ncpts \= 9;

xro \= xr(I(1\));
yro \= yr(I(1\));

xxc \= xc(I(1:ncpts));% \- xc(I(1\));
yyc \= yc(I(1:ncpts));% \- yc(I(1\));
xxr \= round(xr(I(1:ncpts)) \- xro);
yyr \= round(yr(I(1:ncpts)) \- yro);

cp \= \[xxc;yyc]'; 
rp \= \[xxr;yyr]'; 
R \= cp2tform(cp,rp, 'projective');


for j \= 1:5

 \[xxr,yyr] \= tformfwd(R, xc, yc);
 inds \= \[];
 delta \= 0\.01 \* j;
 while (length(inds) \< min(ncpts, length(xc) / 10\))
 delta \= delta \* 2;
 inds \= find(abs(xxr \- round(xxr)) \< delta \& abs(yyr \- round(yyr)) \< delta);
 end

 cp \= \[xc(inds);yc(inds)]';
 rp \= round(\[xr(inds);yr(inds)])';

 R \= cp2tform(cp,rp, 'projective');
end

\[xxr,yyr] \= tformfwd(R, xc, yc);

% delta \= 0\.4;
% inds \= find(abs(xxr \- round(xxr)) \< delta \& abs(yyr \- round(yyr)) \< delta);
% 
% xc \= xc(inds);
% yc \= yc(inds);
xr \= round(xxr) \+ round(xro);
yr \= round(yyr) \+ round(yro);

valid \= true(size(xr));
%kill duplicate points by keeping the closest
for j \= 1:length(xr)
 if nnz(xr \=\= xr(j) \& yr \=\= yr(j)) \> 1
 inds \= find(xr \=\= xr(j) \& yr \=\= yr(j));
 valid(inds) \= false;
 \[\~,I] \= min(abs(xxr(inds) \- round(xxr(inds))) \+ abs(yyr(inds) \- round(yyr(inds))));
 valid(inds(I)) \= true;
 end
end

xc \= xc(valid);
xr \= xr(valid);
yc \= yc(valid);
yr \= yr(valid);


\-\-\-

\#\#\# File: eightConnectedLine.m (ID: utility functions.geometry.12\)

function \[xout,yout] \= eightConnectedLine(x,y)

d \= ceil(sqrt((diff(x).^2 \+ diff(y).^2\)));
inds \= zeros(1,sum(d));
p \= 1;

for j \= 1:length(d)
 inds(p:(p\+d(j)\-1\)) \= linspace(j,j\+(d(j)\-1\)/d(j),d(j));
 p \= p\+d(j);
end
xout \= round(interp1(x,inds));
yout \= round(interp1(y,inds));

valid \= \[true diff(xout)\~\=0\|diff(yout)\~\=0];
xout \= xout(valid);
yout \= yout(valid);
\-\-\-

\#\#\# File: divideSquareByLine.m (ID: utility functions.geometry.13\)

function \[a,pts] \= divideSquareByLine (ll, ur, x0, x1\)
%function divideSquareByLine (ll, ur, x0, x1\)
%
%given a line between x0 and x1 and a square with corners at ll, ur; 
%ll \< ur
%
%finds the intersection points A and B between the line and the square
%A is closer to x0 than B
%
%gives the area of the polygon A, (1\-3 corners of square), B. The corners
%are chosen so that the line has a counter\-clockwise orientation.

corners \= \[\[ll(1\);ll(2\)] \[ur(1\);ll(2\)] \[ur(1\);ur(2\)] \[ll(1\);ur(2\)]];

%find corners that are opposite each other

dx \= x1 \- x0;
pdx \= repmat(\[\-dx(2\); dx(1\)],1,4\);

c \= corners \- \[x0(:) x0(:) x0(:) x0(:)];

s \= sign(dot(pdx, c));

if (all(sign(s) \>\= 0\))
 a \= (ur(2\)\-ll(2\))\*(ur(1\)\-ll(1\));
 return;
end
if (all(sign(s) \<\= 0\))
 a \= 0;
 return;
end

cp \= find(diff(s(\[1:end 1])) \~\= 0\);
if (length(cp) \~\= 2\)
 warning ('did not find exactly two crossing points!');
end

c1 \= corners(:,cp(1\));
c2 \= corners(:,cp(1\)\+1\);

c3 \= corners(:,cp(2\));
c4 \= corners(:,mod(cp(2\),4\)\+1\);

pt1 \= intersectionPoint(c1, c2, x0, x1\);
pt2 \= intersectionPoint(c3, c4, x0, x1\);

if (dot(dx, pt2\-pt1\) \> 0\)
 A \= pt1;
 B \= pt2;
 c1 \= cp(1\);
 c2 \= cp(2\);
else
 A \= pt2;
 B \= pt1;
 c2 \= cp(1\);
 c1 \= cp(2\);
end

 dx1 \= A \- corners(:,c1\); dx2 \= B \- A; 
 if (dx1(1\)\*dx2(2\)\-dx2(1\)\*dx1(2\)) \< 0
 c1 \= mod(c1,4\)\+1;
 end
 
 dx1 \= B\-A; dx2 \= corners(:,c2\) \- B;
 if (dx1(1\)\*dx2(2\)\-dx2(1\)\*dx1(2\)) \< 0
 c2 \= mod(c2,4\)\+1;
 end
 
 if (c2 \<\= c1\)
 pts \= \[A B corners(:,c2:c1\)];
 else
 pts \= \[A B corners(:,\[c2:4 1:c1])];
 end
 
 
% 
% if (dot(dx, pt2\-pt1\) \> 0\)
% pts \= \[pt1(:) corners(:,s\>0\) pt2(:)];
% else
% pts \= \[pt2(:) corners(:,s\>0\) pt1(:)];
% end
%pcolor(im); hold on; axis equal;
a \= polyarea(pts(1,:), pts(2,:));
%{
plot (corners(1,:), corners(2,:), 'k.\-', corners(1,\[4 1]), corners(2,\[4 1]), 'm\-', \[x0(1\), x1(1\)], \[x0(2\), x1(2\)], 'g\-',x0(1\),x0(2\),'g\*', pts(1,:), pts(2,:), 'co'); 
hold on;
patch(pts(1,:), pts(2,:), a);
text (A(1\), A(2\), 'A'); text(B(1\), B(2\), 'B'); text (x0(1\), x0(2\), 'x0'); text (x1(1\), x1(2\), 'x1');
%}
%hold off;
\-\-\-

\#\#\# File: momentOfInteria.m (ID: utility functions.geometry.14\)

function moi \= momentOfInteria(midline, c1, c2\)
%function moi \= momentOfInteria(midline, c1, c2\)

dt \= DelaunayTri(midline');

%dt1 \= DelaunayTri(c1');
%dt2 \= DelaunayTri(c2');

%nn1 \= dt1\.nearestNeighbor(midline');
%nn2 \= dt2\.nearestNeighbor(midline');
nn1 \= dt.nearestNeighbor(c1');
nn2 \= dt.nearestNeighbor(c2');

%compute areas
v1 \= c1 \- midline(:,nn1\);
v1 \= interp1(v1', linspace(1,length(v1\), length(v1\)\-1\))';
w1 \= diff(c1,\[],2\);
a1 \= abs(v1(1,:).\*w1(2,:) \- v1(2,:).\*w1(1,:));
d1 \= sqrt(sum(v1\.^2\));

v2 \= c2 \- midline(:,nn2\);
v2 \= interp1(v2', linspace(1,length(v2\), length(v2\)\-1\))';
w2 \= diff(c2,\[],2\);
a2 \= abs(v2(1,:).\*w2(2,:) \- v2(2,:).\*w2(1,:));
d2 \= sqrt(sum(v2\.^2\));



moi \= sum(a2\.\*d2 \+ a1\.\*d1\);

\-\-\-

\#\#\# File: refineMidline.m (ID: utility functions.geometry.15\)

function \[midline, c1, c2] \= refineMidline(midline, c1, c2\)
%function refineMidline(midline, c1, c2\)
%from an initial midline guess, finds an improved midline that 
%makes the midline perpendicular to the line between the contour halves

npts \= length(midline);
midlinetangent \= deriv(midline, npts/10\);
ind1 \= zeros(\[1 npts]);
ind2 \= ind1;
for j \= 1:npts
 d1 \= c1 \- repmat(midline(:,j), \[1 npts]);
 d2 \= c2 \- repmat(midline(:,j), \[1 npts]);
 mt \= repmat(midlinetangent(:,j), \[1 npts]);
 \[\~,I] \= min(abs(sum(d1\.\*mt)));
 ind1(j) \= I;
 \[\~,I] \= min(abs(sum(d2\.\*mt)));
 ind2(j) \= I;
end
c1 \= c1(:,ind1\);
c2 \= c2(:,ind2\);
midline \= 0\.5 \* (c1 \+ c2\);
\-\-\-

\#\#\# File: distanceFromOrientedContourImage.m (ID: utility functions.geometry.16\)

function dim \= distanceFromOrientedContourImage (cpts, imOrigin, sizeofim)
%function dim \= distanceFromOrientedContourImage (cpts, imOrigin, sizeofim)
%
%distance from edge of contour to image points; dim \> 0 if points are
%outside; dim \< 0 for points inside

if (\~all(cpts(:,1\) \=\= cpts(:,2\)))
 cpts \= cpts(:, \[1:end 1]);
end
cpts(1,:) \= cpts(1,:)\-imOrigin(1\) \+ 1;
cpts(2,:) \= cpts(2,:)\-imOrigin(2\) \+ 1;

%pm \= poly2mask(cpts(1,:), cpts(2,:), sizeofim(1\), sizeofim(2\));

\[x,y] \= meshgrid((1:sizeofim(2\)), (1:sizeofim(1\)));
allpts \= \[x(:) y(:)]';
dim \= abs(distanceFromPointToLineSegment(cpts(:,1\), cpts(:,2\), allpts));

for j \= 2:(size(cpts,2\)\-1\)
 d \= abs(distanceFromPointToLineSegment(cpts(:,j), cpts(:,j\+1\), allpts));
 dim(d \< dim) \= d(d \< dim);
end
dim \= reshape(dim, size(pm));
dim(pm) \= \-dim(pm);

\-\-\-

\#\#\# File: lightDirectionFromLines.m (ID: utility functions.geometry.17\)

function \[pt0,x,y,theta] \= lightDirectionFromLines(lines, predominantTheta, minLen)
%function \[x,y,theta] \= lightDirectionFromLines(lines, predominantTheta, minLen)
%takes the line structure from lineEdgesInImage and produces a set of x,y
%positions and the angle of light at the position
%
%predominant theta is the direction the light is coming from in general,
%and is used to resolve ambiguity without having to locate the pins
%
%pt0 is the point from which the light originates

existsAndDefault('predominantTheta', 0\);
existsAndDefault('minLen', 100\);

lines \= lines(\[lines.len] \> minLen);
x \= zeros(size(lines));
y \= x;
theta \= x;

for j \= 1:length(lines)
 th \= atan2(diff(lines(j).y), diff(lines(j).x));
 dth \= diff(unwrap(\[predominantTheta; th]));
 if (abs(dth) \> pi/2\)
 x(j) \= lines(j).x(2\);
 y(j) \= lines(j).y(2\);
 theta(j) \= th \+ pi;
 else
 x(j) \= lines(j).x(1\);
 y(j) \= lines(j).y(1\);
 theta(j) \= th;
 end
end

theta \= mod(theta \+ pi \- predominantTheta, 2\*pi) \- pi \+ predominantTheta; %recenter around predominantTheta

distsqtolines \= @(pt) sum((\-sin(theta).\*(x\-pt(1\)) \+ cos(theta).\*(y\-pt(2\))).^2\);

pt0 \= \[x(1\) y(1\)];
pt0 \= fminsearch(distsqtolines, pt0\);

\-\-\-

\#\#\# File: lineSegmentIntersect.m (ID: utility functions.geometry.18\)

function out \= lineSegmentIntersect(XY1,XY2\)
%LINESEGMENTINTERSECT Intersections of line segments.
% OUT \= LINESEGMENTINTERSECT(XY1,XY2\) finds the 2D Cartesian Coordinates of
% intersection points between the set of line segments given in XY1 and XY2\.
%
% XY1 and XY2 are N1x4 and N2x4 matrices. Rows correspond to line segments. 
% Each row is of the form \[x1 y1 x2 y2] where (x1,y1\) is the start point and 
% (x2,y2\) is the end point of a line segment:
%
% Line Segment
% o\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-o
% ^ ^
% (x1,y1\) (x2,y2\)
%
% OUT is a structure with fields:
%
% 'intAdjacencyMatrix' : N1xN2 indicator matrix where the entry (i,j) is 1 if
% line segments XY1(i,:) and XY2(j,:) intersect.
%
% 'intMatrixX' : N1xN2 matrix where the entry (i,j) is the X coordinate of the
% intersection point between line segments XY1(i,:) and XY2(j,:).
%
% 'intMatrixY' : N1xN2 matrix where the entry (i,j) is the Y coordinate of the
% intersection point between line segments XY1(i,:) and XY2(j,:).
%
% 'intNormalizedDistance1To2' : N1xN2 matrix where the (i,j) entry is the
% normalized distance from the start point of line segment XY1(i,:) to the
% intersection point with XY2(j,:).
%
% 'intNormalizedDistance2To1' : N1xN2 matrix where the (i,j) entry is the
% normalized distance from the start point of line segment XY1(j,:) to the
% intersection point with XY2(i,:).
%
% 'parAdjacencyMatrix' : N1xN2 indicator matrix where the (i,j) entry is 1 if
% line segments XY1(i,:) and XY2(j,:) are parallel.
%
% 'coincAdjacencyMatrix' : N1xN2 indicator matrix where the (i,j) entry is 1 
% if line segments XY1(i,:) and XY2(j,:) are coincident.

% Version: 1\.00, April 03, 2010
% Version: 1\.10, April 10, 2010
% Author: U. Murat Erdem

% CHANGELOG:
%
% Ver. 1\.00: 
% \-Initial release.
% 
% Ver. 1\.10:
% \- Changed the input parameters. Now the function accepts two sets of line
% segments. The intersection analysis is done between these sets and not in
% the same set.
% \- Changed and added fields of the output. Now the analysis provides more
% information about the intersections and line segments.
% \- Performance tweaks.

% I opted not to call this 'curve intersect' because it would be misleading
% unless you accept that curves are pairwise linear constructs.
% I tried to put emphasis on speed by vectorizing the code as much as possible.
% There should still be enough room to optimize the code but I left those out
% for the sake of clarity.
% The math behind is given in:
% http://local.wasp.uwa.edu.au/\~pbourke/geometry/lineline2d/
% If you really are interested in squeezing as much horse power as possible out
% of this code I would advise to remove the argument checks and tweak the
% creation of the OUT a little bit.

%%% Argument check.
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

validateattributes(XY1,{'numeric'},{'2d','finite'});
validateattributes(XY2,{'numeric'},{'2d','finite'});

\[n\_rows\_1,n\_cols\_1] \= size(XY1\);
\[n\_rows\_2,n\_cols\_2] \= size(XY2\);

if n\_cols\_1 \~\= 4 \|\| n\_cols\_2 \~\= 4
 error('Arguments must be a Nx4 matrices.');
end

%%% Prepare matrices for vectorized computation of line intersection points.
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
X1 \= repmat(XY1(:,1\),1,n\_rows\_2\);
X2 \= repmat(XY1(:,3\),1,n\_rows\_2\);
Y1 \= repmat(XY1(:,2\),1,n\_rows\_2\);
Y2 \= repmat(XY1(:,4\),1,n\_rows\_2\);

XY2 \= XY2';

X3 \= repmat(XY2(1,:),n\_rows\_1,1\);
X4 \= repmat(XY2(3,:),n\_rows\_1,1\);
Y3 \= repmat(XY2(2,:),n\_rows\_1,1\);
Y4 \= repmat(XY2(4,:),n\_rows\_1,1\);

X4\_X3 \= (X4\-X3\);
Y1\_Y3 \= (Y1\-Y3\);
Y4\_Y3 \= (Y4\-Y3\);
X1\_X3 \= (X1\-X3\);
X2\_X1 \= (X2\-X1\);
Y2\_Y1 \= (Y2\-Y1\);

numerator\_a \= X4\_X3 .\* Y1\_Y3 \- Y4\_Y3 .\* X1\_X3;
numerator\_b \= X2\_X1 .\* Y1\_Y3 \- Y2\_Y1 .\* X1\_X3;
denominator \= Y4\_Y3 .\* X2\_X1 \- X4\_X3 .\* Y2\_Y1;

u\_a \= numerator\_a ./ denominator;
u\_b \= numerator\_b ./ denominator;

% Find the adjacency matrix A of intersecting lines.
INT\_X \= X1\+X2\_X1\.\*u\_a;
INT\_Y \= Y1\+Y2\_Y1\.\*u\_a;
INT\_B \= (u\_a \>\= 0\) \& (u\_a \<\= 1\) \& (u\_b \>\= 0\) \& (u\_b \<\= 1\);
PAR\_B \= denominator \=\= 0;
COINC\_B \= (numerator\_a \=\= 0 \& numerator\_b \=\= 0 \& PAR\_B);


% Arrange output.
out.intAdjacencyMatrix \= INT\_B;
out.intMatrixX \= INT\_X .\* INT\_B;
out.intMatrixY \= INT\_Y .\* INT\_B;
out.intNormalizedDistance1To2 \= u\_a;
out.intNormalizedDistance2To1 \= u\_b;
out.parAdjacencyMatrix \= PAR\_B;
out.coincAdjacencyMatrix\= COINC\_B;

end

\-\-\-

\#\#\# File: resampleBezier.m (ID: utility functions.geometry.19\)

function q \= resampleBezier(q, nsamp)
%function q \= resampleBezier(q, nsamp)
%finds best representation of same curve, given restriction that all points
%are equally spaced; this may just create a line or some crap like that
%
if (nargin \< 2\)
 nsamp \= 100;
end
s \= linspace(0,1,nsamp);
M \= bezierMatrix(size(q,2\)\-1, s);

u \= q\*M;
l \= \[0 cumsum(sqrt(sum(diff(u,\[],2\).^2\)))];
u \= interp1(l/l(end),u',s, 'linear')';

q \= (pinv(M')\*u')';

\-\-\-

\#\#\# File: markBoundary.m (ID: utility functions.geometry.20\)

function im \= markBoundary (im, x0, y0, x1, y1\)
if (length(x0\) \> 1\)
 if (nargin \=\= 3\)
 for j \= 1:(length(x0\)\-1\)
 im \= markBoundary (im, x0(j), y0(j), x0(j\+1\), y0(j\+1\));
 end
 else
 for j \= 1:(length(x0\))
 im \= markBoundary (im, x0(j), y0(j), x1(j), y1(j));
 end
 end
 return;
end

dx \= abs(x1 \- x0\);
dy \= abs(y1 \- y0\);
x \= floor(x0\);
y \= floor(y0\);
n \= 1;
if (dx \=\= 0\)
 x\_inc \= 0;
 err \= Inf;
else
 if (x1 \> x0\)
 x\_inc \= 1;
 n \= n \+ floor(x1\) \- x;
 err \= (floor(x0\) \+ 1 \- x0\)\*dy;
 else
 x\_inc \= \-1;
 n \= n \+ x \- floor(x1\);
 err \= (x0 \- floor(x0\)) \* dy;
 end
end

if (dy \=\= 0\)
 y\_inc \= 0;
 err \= \- Inf;
else
 if (y1 \> y0\)
 y\_inc \= 1;
 n \= n \+ floor(y1\) \- y;
 err \= err \- (floor(y0\) \+ 1 \- y0\) \* dx;
 else
 y\_inc \= \-1;
 n \= n \+ y \- floor(y1\);
 err \= err \- (y0 \- floor(y0\)) \* dx;
 end
end
for m \= 1:n
 % figure(1\);
 % pcolor(im); axis equal; hold on
 if (y \>\= 1 \&\& y \<\= size(im,1\) \&\& x \>\= 1 \&\& x \<\= size(im,2\))
 im(y,x) \= divideSquareByLine(\[x;y], \[x\+1;y\+1], \[x0;y0], \[x1;y1]); 
 end
 % title (\[num2str(x) ',' num2str(y) '; ' num2str(x0\) ',' num2str(y0\) ' \- ' num2str(x1\) ',' num2str(y1\)]);
 % pause;
 if (err \> 0\) 
 y \= y \+ y\_inc;
 err \= err \- dx;
 else
 x \= x \+ x\_inc;
 err \= err \+ dy;
 end
end


%{
adaptation of:
\#include  // for infinity
void raytrace(double x0, double y0, double x1, double y1\)
{
 double dx \= fabs(x1 \- x0\);
 double dy \= fabs(y1 \- y0\);

 int x \= int(floor(x0\));
 int y \= int(floor(y0\));

 int n \= 1;
 int x\_inc, y\_inc;
 double error;

 if (dx \=\= 0\)
 {
 x\_inc \= 0;
 error \= std::numeric\_limits::infinity();
 }
 else if (x1 \> x0\)
 {
 x\_inc \= 1;
 n \+\= int(floor(x1\)) \- x;
 error \= (floor(x0\) \+ 1 \- x0\) \* dy;
 }
 else
 {
 x\_inc \= \-1;
 n \+\= x \- int(floor(x1\));
 error \= (x0 \- floor(x0\)) \* dy;
 }

 if (dy \=\= 0\)
 {
 y\_inc \= 0;
 error \-\= std::numeric\_limits::infinity();
 }
 else if (y1 \> y0\)
 {
 y\_inc \= 1;
 n \+\= int(floor(y1\)) \- y;
 error \-\= (floor(y0\) \+ 1 \- y0\) \* dx;
 }
 else
 {
 y\_inc \= \-1;
 n \+\= y \- int(floor(y1\));
 error \-\= (y0 \- floor(y0\)) \* dx;
 }

 for (; n \> 0; \-\-n)
 {
 visit(x, y);

 if (error \> 0\)
 {
 y \+\= y\_inc;
 error \-\= dx;
 }
 else
 {
 x \+\= x\_inc;
 error \+\= dy;
 }
 }
}
from http://playtechs.blogspot.com/2007/03/raytracing\-on\-grid.html
%}


\-\-\-

\#\#\# File: removeSmallLoops.m (ID: utility functions.geometry.21\)

function cpts \= removeSmallLoops(cpts)
%function cpts \= removeSmallLoops(cpts)
%
%removes any small loops (where same point appears twice in a contour) from
%a contour; it's ok if first and last point are the same (contour is
%closed)
%
%cpts is 2xNpts
npts \= size(cpts,2\);
cpmat1 \= repmat(cpts(1,:), npts, 1\);
cpmat2 \= repmat(cpts(2,:), npts, 1\);
\[j,k] \= find(cpmat1 \=\= cpmat1' \& cpmat2 \=\= cpmat2' \& triu(true(size(cpmat1\)),\+1\));

valid \= (j\~\=1 \| k\~\=npts);
j \= j(valid); k \= k(valid);

valid \= true(1,npts);
for m \= 1:length(j)
 if (k(m) \- j(m)) \< npts/2
 valid((j(m)\+1\):k(m)) \= false;
 else
 valid(\[(k(m)\+1\):npts 1:j(m)]) \= false;
 end
end

cpts \= cpts(:,valid);

\-\-\-

\#\#\# File: bezierFromControlPoints.m (ID: utility functions.geometry.22\)

function pts \= bezierFromControlPoints(cpts, npts)
%function pts \= bezierFromControlPoints(cpts, npts)
%cpts \= 2xnum ctrl points
%npts \= number of points to interpolate by
%pts \= 2xnpts bezier curve

t \= linspace(0,1,npts);
M \= bezierMatrix(size(cpts,2\)\-1, t);
pts \= cpts\*M;

% 
% x \= repmat(cpts(1,end:\-1:1\), \[npts 1])';
% y \= repmat(cpts(2,end:\-1:1\), \[npts 1])';
% for d \= size(x,1\):\-1:1
% for j \= 1:(d\-1\)
% x(j,:) \= t.\*x(j,:) \+ (1\-t).\*x(j\+1,:);
% y(j,:) \= t.\*y(j,:) \+ (1\-t).\*y(j\+1,:);
% 
% end
% end
% pts \= squeeze(\[x(1,:);y(1,:)]);
% 
% 
% end


\-\-\-

\#\#\# File: polyarea\_signed.m (ID: utility functions.geometry.23\)

function area \= polyarea\_signed(x,y,dim)
%POLYAREA\_SIGNED Area of polygon with orientation taken into account.
% POLYAREA(X,Y) returns the area of the polygon specified by
% the vertices in the vectors X and Y. If X and Y are matrices
% of the same size, then POLYAREA returns the area of
% polygons defined by the columns X and Y. If X and Y are
% arrays, POLYAREA returns the area of the polygons in the
% first non\-singleton dimension of X and Y. 
%
% The polygon edges must not intersect. If they do, POLYAREA
% returns the difference between the counterclockwise
% encircled areas and the clockwise encircled areas.
%
% area is signed and \> 0 if the points are oriented counterclockwise
% area is \< 0 if the points are oriented clockwise
%
% POLYAREA(X,Y,DIM) returns the area of the polygons specified
% by the vertices in the dimension DIM.
%
% Class support for inputs X,Y:
% float: double, single

% Copyright 1984\-2004 The MathWorks, Inc.
% $Revision: 1\.12\.4\.2 $ $Date: 2004/03/02 21:47:55 $

if nargin\=\=1 
 error('MATLAB:polyarea:NotEnoughInputs', 'Not enough inputs.'); 
end

if \~isequal(size(x),size(y)) 
 error('MATLAB:polyarea:XYSizeMismatch', 'X and Y must be the same size.'); 
end

if nargin\=\=2,
 \[x,nshifts] \= shiftdim(x);
 y \= shiftdim(y);
elseif nargin\=\=3,
 perm \= \[dim:max(length(size(x)),dim) 1:dim\-1];
 x \= permute(x,perm);
 y \= permute(y,perm);
end

siz \= size(x);
if \~isempty(x),
 area \= \-reshape(sum( (x(\[2:siz(1\) 1],:) \- x(:,:)).\* ...
 (y(\[2:siz(1\) 1],:) \+ y(:,:)))/2,\[1 siz(2:end)]);
else
 area \= sum(x); % SUM produces the right value for all empty cases
end

if nargin\=\=2,
 area \= shiftdim(area,\-nshifts);
elseif nargin\=\=3,
 area \= ipermute(area,perm);
end

\-\-\-

\#\#\# File: findPointyEnds.m (ID: utility functions.geometry.24\)

function \[inds,cv] \= findPointyEnds (cpts, varargin)
%function inds \= findPointyEnds (cpts)

sigma \= length(cpts)/10\.0;
debug \= false;
varargin \= assignApplicable(varargin);
ncp \= length(cpts);

%{
cptspad \= \[cpts cpts];

cpl \= lowpass1D(cptspad,sigma);
cpl \= circshift(cpl(:,floor(ncp/2\) \+ (1:ncp)), \[0 \-floor(ncp/2\)]);

dx \= 0\.5\*(diff(cpl(:, \[end 1:end]),\[],2\) \+ diff(cpl(:, \[1:end 1]),\[],2\));
dl \= sqrt(sum(dx.^2\));
that \= dx./\[dl;dl];
cv \= sum((diff(that(:,\[end 1:end]), \[],2\)))./(dl); %curvature
%}
cpl \= lowpass1D(cpts,sigma,'padType', 'circular');
v \= deriv(cpl, 1, 'padType', 'circular');
a \= deriv(v, 1, 'padType', 'circular');

cv \= (v(1,:).\*a(2,:) \- a(1,:).\*v(2,:))./(sum(v.^2\).^(1\.5\));

cv \= cv .\* sign(sum(cv));
\[cvmax, maxI] \= max(cv);

inds \= 1:length(cv);
inddist \= min(mod(inds\-maxI\+ncp,ncp), (mod (maxI \- inds \+ncp,ncp)));
%cvcorr \= cv./cvmax \+ inddist/ncp;
cvcorr \= cv;
\[\~,I] \= sort(cvcorr,'descend');

ind1 \= maxI;
ind2 \= find(inddist(I) \> ncp/4, 1, 'first');

inds \= \[ind1 I(ind2\)];
if (debug)
 figure(1\);
 
%cpl \= circshift(cpl(:,floor(ncp/2\) \+ (1:ncp)), \[0 \-floor(ncp/2\)]);
 plot (cpl(1,:), cpl(2,:), 'k\-'); hold on
 plot (\[cpl(1,:); cpts(1,:)], \[cpl(2,:); cpts(2,:)], 'g\-', cpts(1,:), cpts(2,:), 'b\-');
 plot (cpts(1,inds), cpts(2,inds), 'ro');
 plotColorLine(cpts(1,:), cpts(2,:), cv, jet); hold off
 axis equal
 figure(2\);
 plot (cvcorr)
end

\-\-\-

\#\#\# File: bestMidline.m (ID: utility functions.geometry.25\)

function \[midline, c1, c2, inds] \= bestMidline(cpts, endpt1, endpt2\)
%function \[midline, c1, c2, inds] \= bestMidline(cpts, enpt1, endpt2\)
%
%splits
cpts \= double(cpts);
%constraints \= \[1:length(cpts);\[2:length(cpts) 1]];
%dt \= DelaunayTri(double(cpts'), constraints');


if prod(size(endpt1\)) \=\= 1
 ind1 \= endpt1;
else
 \[\~,ind1] \= min(sum((cpts\-repmat(endpt1, 1, size(cpts,2\))).^2\));
 % ind1 \= dt.nearestNeighbor(endpt1(1\), endpt1(2\));
end
if prod(size(endpt2\)) \=\= 1
 ind2 \= endpt2;
else
 \[\~,ind2] \= min(sum((cpts\-repmat(endpt2, 1, size(cpts,2\))).^2\));
 %ind2 \= dt.nearestNeighbor(endpt2(1\), endpt2(2\));
end


for step \= \[10 5 2 1]
 while(1\)
 moi \= getmoi(ind1 \+ (\-1:1\)\*step, ind2, cpts);
 \[\~,j] \= min(moi);
 ind1 \= ind1 \+ j \- 2;
 moi \= getmoi(ind1, ind2 \+ (\-1:1\)\*step, cpts);
 \[\~,k] \= min(moi);
 ind2 \= ind2 \+ k \- 2;
 if (j \=\= 2 \&\& k \=\= 2\)
 break;
 end;
 
 end
end

\[mid,c1,c2] \= splitOutline(cpts,ind1, ind2\);
midline \= lowpass1d(mid, length(mid)/20\);
inds \= \[ind1 ind2];

function moi \= getmoi(endpt1, endpt2,cpts)
endpt1 \= mod(endpt1,length(cpts)) \+ 1;
endpt2 \= mod(endpt2,length(cpts)) \+ 1;
moi \= zeros(length(endpt1\), length(endpt2\));
for j \= 1:length(endpt1\)
 for k \= 1:length(endpt2\)
 \[mid, c1, c2] \= splitOutline(cpts,endpt1(j), endpt2(k));
 mid \= lowpass1d(mid, length(mid)/20\);
 moi(j,k) \= momentOfInteria(mid, c1, c2\);
 end
end

\-\-\-

\#\#\# File: fitLine.m (ID: utility functions.geometry.26\)

function \[midpt, dirvec, squareError, fitpts] \= fitLine (pts)
%function \[midpt, dirvec, squareError, fitpts] \= fitLine (pts)
%pts is a DxNPTSxNMEAS; midpt, dirvec are DxNMEAS, squareError is
%1xNMEAS
%(D \= dimension, often 2 or 3\); fits a line for each measurement; assumes
%that pts are evenly spaced along each line

midpt \= mean(pts, 2\);
po \= pts \- repmat(midpt, \[1 size(pts,2\) 1]);

s \= repmat(1:size(pts,2\), \[size(pts,1\), 1, size(pts,3\)]);
s \= s \- repmat(mean(s,2\), \[1, size(pts,2\), 1]);
ss \= sum(s(1,:,1\).^2\);
dir \= sum(s.\*po, 2\)/ss;
pf \= s.\*repmat(dir, \[1, size(pts,2\), 1]);
fitpts \= pf \+ repmat(midpt, \[1 size(pts,2\) 1]);
squareError \= sum(squeeze(sum((po\-pf).^2\)));

dir \= squeeze(dir);
dirlen \= sqrt(sum(dir.^2\));
dirvec \= dir./repmat(dirlen, \[size(dir,1\), 1]);

midpt \= squeeze(midpt);

%{

perpvec \= zeros(size(po));

dirvec \= zeros(size(midpt));

for j \= 1:size(pts, 3\)
 c \= cov(po(:,:,j)');
 \[v,d] \= eig(c);
 %I can't find anywhere in the documentation that says the eigenvalues
 %are sorted, so don't take a chance
 if (d(1,1\) \> d(2,2\))
 dv \= v(:,1\);
 pv \= v(:,2\);
 else
 dv \= v(:,2\);
 pv \= v(:,1\);
 end
 dirvec(:,j) \= dv;
 perpvec(:,:,j) \= repmat(pv, \[1 size(perpvec,2\)]);
end

dist \= squeeze(sum(po.\*perpvec));
squareError \= sum(dist.^2\);
 %}
\-\-\-

\#\#\# File: traceBoundarySubPixel.m (ID: utility functions.geometry.27\)

function im \= traceBoundarySubPixel (cpts, imOrigin, sizeofim)
%function im \= traceBoundarySubPixel (cpts, imOrigin, sizeofim)
%
%finds all pixels that intersect the boundary line, then labels each of
%these pixels with the fraction (between 0\.0 and 1\.0\) of the pixel
%contained within the contour. 
%
%im(i,j) represents the pixel spanning the rectangle (i \+ imOrigin(1\),j\+imOrigin(2\)) and (i\+imOrigin(1\) \+ 1,j\+imOrigin(2\)\+1\)

if (\~all(cpts(:,1\) \=\= cpts(:,2\)))
 cpts \= cpts(:, \[1:end 1]);
end
x \= cpts(1,:)\-imOrigin(1\) \+ 1;
y \= cpts(2,:)\-imOrigin(2\) \+ 1;

%close the contour
if (x(end) \~\= x(1\) \|\| y(end) \~\= y(1\))
 x(end\+1\) \= x(1\);
 y(end\+1\) \= y(1\);
end

im \= double(poly2mask(x,y,sizeofim(1\), sizeofim(2\)));
%fails at corners!
im \= markBoundary (im, x,y);

%do corners separately
xx \= x(2:end);
yy \= y(2:end);
for j \= 1:length(xx)
 if (xx(j) \< 1 \|\| floor(xx(j)) \> sizeofim(2\) \|\| yy(j) \< 1 \|\| yy(j) \> sizeofim(1\))
 continue;
 end
 ind1 \= mod(j\-2, length(xx))\+1;
 ind2 \= mod(j,length(xx)) \+ 1;
 im(floor(yy(j)),floor(xx(j))) \= divideSquareByCorner(floor(\[xx(j);yy(j)]), floor(\[xx(j);yy(j)])\+\[1;1], \[xx(ind1\);yy(ind1\)], \[xx(j);yy(j)], \[xx(ind2\);yy(ind2\)]);
end
if any(size(im) \~\= sizeofim)
 error ('something bad happened');
end

%UNTITLED3 Summary of this function goes here
% Detailed explanation goes here


end


\-\-\-

\#\#\# Folder: utility functions/pitch tracking (ID: utility functions.pitch tracking)

\-\-\-

\#\#\# File: squareDiffInWindow.m (ID: utility functions.pitch tracking.1\)

function sdf \= squareDiffInWindow (x,minshift, maxshift, winsize, gaussWindow) 
%function sdf \= squareDiffInWindow (x,minshift, maxshift, winsize, gaussWindow) 
%
%written for 1D data right now

existsAndDefault('gaussWindow', false);
minshift \= floor(minshift);
maxshift \= ceil(maxshift);
nrows \= maxshift \- minshift \+ 1;
n \= length(x);
sdf \= zeros(nrows, n);
for j \= 1:nrows
 inds \= (1:(n\-j\-minshift \+ 1\));
 sdf(j,inds) \= (x(inds)\-x(inds \+ minshift \+ j \-1\)).^2;
end

if gaussWindow
 k \= gaussKernel(winsize);
else
 k \= ones(1,ceil(winsize))/ceil(winsize);
end

for j \= 1:size(sdf, 1\)
 sdf(j,:) \= conv2(sdf(j,:), k, 'same');
end


 
\-\-\-

\#\#\# File: autocorrInWindow.m (ID: utility functions.pitch tracking.2\)

function acf \= autocorrInWindow (x,minshift, maxshift, winsize, gaussWindow) 
%function acf \= autocorrInWindow (x,minshift, maxshift, winsize, gaussWindow) 
%
%written for 1D data right now

existsAndDefault('gaussWindow', false);
minshift \= floor(minshift);
maxshift \= ceil(maxshift);
nrows \= maxshift \- minshift \+ 1;
n \= length(x);
acf \= zeros(nrows, n);
for j \= 1:nrows
 inds \= (1:(n\-j\-minshift \+ 1\));
 acf(j,inds) \= x(inds).\*x(inds \+ minshift \+ j \-1\);
end

if gaussWindow
 k \= gaussKernel(winsize);
else
 k \= ones(1,ceil(winsize))/ceil(winsize);
end

for j \= 1:size(acf, 1\)
 acf(j,:) \= conv2(acf(j,:), k, 'same');
end


 
\-\-\-

\#\#\# File: squareSumInWindow.m (ID: utility functions.pitch tracking.3\)

function ssf \= squareSumInWindow (x,minshift, maxshift, winsize, gaussWindow) 
%function ssf \= squareSumInWindow (x,minshift, maxshift, winsize, gaussWindow) 
%
%written for 1D data right now

existsAndDefault('gaussWindow', false);
minshift \= floor(minshift);
maxshift \= ceil(maxshift);
nrows \= maxshift \- minshift \+ 1;
n \= length(x);
ssf \= zeros(nrows, n);
for j \= 1:nrows
 inds \= (1:(n\-j\-minshift \+ 1\));
 ssf(j,inds) \= (x(inds)).^2\+(x(inds \+ minshift \+ j \-1\)).^2;
end

if gaussWindow
 k \= gaussKernel(winsize);
else
 k \= ones(1,ceil(winsize))/ceil(winsize);
end

for j \= 1:size(ssf, 1\)
 ssf(j,:) \= conv2(ssf(j,:), k, 'same');
end


 
\-\-\-

\#\#\# Folder: utility functions/phase extraction (ID: utility functions.phase extraction)

\-\-\-

\#\#\# File: PCAPhaseFindBlock.m (ID: utility functions.phase extraction.1\)

function \[thetaGlobal, coeffGlobal, reliabilityScoreGlobal, thetaInd, coeff, reliabilityScoreInd, ctr] \= PCAPhaseFindBlock(datacube, nptsperramp)
%UNTITLED Summary of this function goes here
% Detailed explanation goes here

thetaInd \= zeros(size(datacube,1\), size(datacube,2\), size(datacube,3\)/nptsperramp);
reliabilityScoreInd \= thetaInd;
%thetaGlobal \= thetaInd;

%blocksize \= 50;
chunksize \= 1E8;
blocksize \= floor(sqrt(chunksize / size(datacube,3\)));
nrb \= ceil(size(datacube, 1\)/blocksize);
ncb \= ceil(size(datacube, 2\)/blocksize);

dr \= (size(datacube,1\) \- blocksize)/(nrb \- 1\);
dc \= (size(datacube,2\) \- blocksize)/(ncb \- 1\);

% ctr{1} \= dc \* (0:(ncb)\-1\) \+ blocksize/2;
% ctr{2} \= dr \* (0:(nrb)\-1\) \+ blocksize/2;

ctr \= (0 \+ 0i) \* zeros(1,nrb\*ncb);
coeff \= (0 \+ 0i) \* zeros(nptsperramp, nrb\*ncb);
ind \= 1;
tic
for j \= 1:nrb
 rinds \= (1:blocksize) \+ floor((j\-1\)\*dr);
 for k \= 1:ncb
 ctr(ind) \= dc \* (k\-1\) \+ blocksize/2 \+ 1i\*(dr \* (j\-1\) \+ blocksize/2\);
 cinds \= (1:blocksize) \+ floor((k\-1\)\*dc);
 rob \= reshape(reshape(datacube(rinds,cinds,:), \[], size(datacube,3\)).',nptsperramp,\[]).';
 \[c,sc] \= pca(rob, 'NumComponents', 2\);
 magsq \= sum(rob.^2,2\);
 %z \= sc(:,1\) \+ 1i\*sc(:,2\);
 thetaInd(rinds,cinds,:) \= permute(reshape(atan2(sc(:,2\), sc(:,1\)), \[], blocksize, blocksize), \[2 3 1]);
 reliabilityScoreInd(rinds,cinds,:) \= permute(reshape(sum(sc.^2, 2\)./magsq, \[], blocksize, blocksize), \[2 3 1]);

 coeff(:,ind) \= c(:,1\) \+ 1i\*c(:,2\);
 ind \= ind\+1;
 end
 disp (\[num2str(j) ' rows of ' num2str(nrb) ' completed']);
 toc;
end
coeffGlobal \= pca(\[real(coeff) imag(coeff)]', 'NumComponents', 2\);
dcflat \= reshape(reshape(datacube, \[], size(datacube,3\)).',20,\[]).';
sc \= dcflat \* coeffGlobal; toc
magsq \= sum(dcflat.^2,2\);
reliabilityScoreGlobal \= permute(reshape(sum(sc.^2, 2\)./magsq, \[], size(datacube,1\), size(datacube,2\)), \[2 3 1]);
thetaGlobal \= permute(reshape(atan2(sc(:,2\), sc(:,1\)), \[], size(datacube,1\), size(datacube,2\)), \[2 3 1]);
end


\-\-\-

\#\#\# File: simpleLinearTimeRegistration.m (ID: utility functions.phase extraction.2\)

function \[alpha, dt, sigAligned] \= simpleLinearTimeRegistration(sig, sigRef)
% sig \= sig(:);
% sigRef \= sigRef(:);
 ncp \= floor(.9 \* length(sig));
 
 
 op \= optimoptions('fmincon', 'Display', 'off');
 x \= fmincon(@(x) \-warpProduct(x(1\), x(2\)), \[1 0], \[], \[], \[], \[], \[.5 \-length(sig)/4], \[2 length(sig)/4],\[],op);
 % x \= fmincon(@(x) \-warpProduct(x(1\),0\), \[1], \[], \[], \[], \[], .5,2\); 
 alpha \= x(1\);
 dt \= x(2\);
 %dt \= 0;
 txf \= 1:length(sig);
 tc1f \= mean(txf) \- dt;
 txw1f \= 1/alpha \* (txf \- tc1f) \+ mean(tx);
 sigAligned \= interp1(txw1f, sig, txf, 'linear', 0\);
 
 function val \= warpProduct(a, t)
 tx \= 1:length(sig);
 tc1 \= mean(tx) \- t/2;
 tc2 \= tc1 \+ t;
 txw1 \= 1/sqrt(a) \* (tx \- tc1\) \+ mean(tx);
 txw2 \= sqrt(a) \* (tx \- tc2\) \+ mean(tx);
 ti \= mean(tx) \- (ncp\+1\)/2 \+ (1:ncp);
 val \= sum(sum(interp1(txw1, sig, ti, 'linear', 0\).\*interp1(txw2, sigRef, ti, 'linear', 0\)));
 end
end
\-\-\-

\#\#\# Folder: utility functions/data analysis and description (ID: utility functions.data analysis and description)

\-\-\-

\#\#\# File: reorientationCycleMap.m (ID: utility functions.data analysis and description.1\)

function rowdata \= reorientationCycleMap (object, cyclic\_field\_name)
%function rowdata \= reorientationCycleMap (object, cyclic\_field\_name)
%
%useful for generating raster style plots
rowdata \= \[];

if (length(object) \> 1\)
 for j \= 1:length(object)
 rowdata \= \[rowdata reorientationCycleMap(object(j), cyclic\_field\_name)];%\#ok\<\*AGROW\>
 end
 return;
end
 
if (isa (object, 'ExperimentSet'))
 rowdata \= reorientationCycleMap(object.expt, cyclic\_field\_name);
 return;
end

if (isa (object, 'Experiment'))
 rowdata \= reorientationCycleMap(object.track, cyclic\_field\_name);
 return;
end

if (\~isa(object, 'Track'))
 warning ('rcm:type','reorientationCycleMap expects an experiment set, experiment, or track');
 return;
end

t \= object;

et \= t.getDerivedQuantity('eti');
cet \= t.getDerivedQuantity(cyclic\_field\_name);

run\_start \= \[t.run.startInd];
run\_end \= \[t.run.endInd];
reo\_start \= \[t.reorientation.startInd];
reo\_end \= \[t.reorientation.endInd];

if (isa (t, 'MaggotTrack'))
 hs\_start \= \[t.headSwing.startInd];
 hs\_end \= \[t.headSwing.endInd];
 hsa \= \[t.headSwing.accepted];
 nhs \= \[t.reorientation.numHS];
end

startInd \= find(cet \>\= 0, 1, 'first');
endInd \= find(diff(cet(startInd:end)) \< 0, 1, 'first');
firstrunind \= find(\[t.isrun], 1, 'first');
lastrunind \= find(\[t.isrun], 1, 'last');
j \= 1;
while (\~isempty(endInd))
 endInd \= startInd \+ endInd \- 1;
 
 rowdata(j).trackNum \= t.trackNum; 
 rowdata(j).allvalid \= cet(startInd) \<\= 2\*t.dr.interpTime \& endInd \< length(et);
 rowdata(j).startTime \= et(startInd) \- cet(startInd);
 rowdata(j).endTime \= et(endInd);
 rowdata(j).validStart \= cet(startInd);
 rowdata(j).validEnd \= cet(endInd);
 rowdata(j).startsRunning \= logical(t.isrun(startInd));
 rowdata(j).run\_start \= cet(run\_start(run\_start \>\= startInd \& run\_start \<\= endInd));
 
 rowdata(j).run\_end \= cet(run\_end(run\_end \>\= startInd \& run\_end \<\= endInd));
 
 reoinds \= find(reo\_start \>\= startInd \& reo\_end \<\= endInd);
 firstreoind \= find(reo\_start \< startInd \& reo\_end \> startInd);
 lastreoind \= find(reo\_end \> endInd \& reo\_start \< endInd);
 
 rowdata(j).reo\_start \= cet(reo\_start(reoinds));
 rowdata(j).reo\_end \= cet(reo\_end(reoinds));
 
 if (\~isempty(firstreoind))
 rowdata(j).reo\_start \= \[cet(startInd) rowdata(j).reo\_start];
 rowdata(j).reo\_end \= \[cet(reo\_end(firstreoind)) rowdata(j).reo\_end];
 end
 if (\~isempty(lastreoind))
 rowdata(j).reo\_start \= \[rowdata(j).reo\_start cet(reo\_start(lastreoind))];
 rowdata(j).reo\_end \= \[rowdata(j).reo\_end cet(endInd)];
 end
 
% rowdata(j).reo\_start \= cet(reo\_start(reo\_start \>\= startInd \& reo\_start \<\= endInd));
% rowdata(j).reo\_end \= cet(reo\_end(reo\_end \>\= startInd \& reo\_end \<\= endInd));
% 
 if (startInd \< firstrunind)
 rowdata(j).prerun\_start \= cet(startInd);
 rowdata(j).prerun\_end \= cet(min(firstrunind, endInd));
 else
 rowdata(j).prerun\_start \= \[];
 rowdata(j).prerun\_end \= \[];
 end
 if (lastrunind \< endInd)
 rowdata(j).postrun\_start \= cet(max(lastrunind,startInd));
 rowdata(j).postrun\_end \= cet(endInd);
 else
 rowdata(j).postrun\_start \= \[];
 rowdata(j).postrun\_end \= \[];
 end

 if (isa (t, 'MaggotTrack'))
 rowdata(j).ahs\_start \= cet(hs\_start(hs\_start \>\= startInd \& hs\_start \<\= endInd \& hsa));
 rowdata(j).rhs\_start \= cet(hs\_start(hs\_start \>\= startInd \& hs\_start \<\= endInd \& \~hsa));
 rowdata(j).ahs\_end \= cet(hs\_end(hs\_end \>\= startInd \& hs\_end \<\= endInd \& hsa));
 rowdata(j).rhs\_end \= cet(hs\_end(hs\_end \>\= startInd \& hs\_end \<\= endInd \& \~hsa));
% rowdata(j).reo\_start\_nhs \= nhs(reo\_start \>\= startInd \& reo\_start \<\= endInd);
% rowdata(j).reo\_end\_nhs \= nhs(reo\_end \>\= startInd \& reo\_end \<\= endInd);
 rowdata(j).reo\_start\_nhs \= nhs(\[firstreoind reoinds lastreoind]);
 rowdata(j).reo\_end\_nhs \= rowdata(j).reo\_start\_nhs;
 end
% if (\~isempty(rowdata(j).reo\_end) \&\& \~isempty(rowdata(j).reo\_start) \&\&...
% rowdata(j).reo\_end(1\) \< rowdata(j).reo\_start(1\) \&\& rowdata(j).run\_start(1\) \> rowdata(j).reo\_end(1\))
% rowdata(j).reo\_start \= \[cet(startInd) rowdata(j).reo\_start];
% rowdata(j).reo\_start\_nhs(1\) \= rowdata(j).reo\_end\_nhs(1\);
% end
% if (\~isempty(rowdata(j).reo\_end) \&\& \~isempty(rowdata(j).reo\_start) \&\&...
% rowdata(j).reo\_start(end) \> rowdata(j).reo\_end(end) \&\& rowdata(j).run\_end(end) \< rowdata(j).reo\_start(end))
% rowdata(j).reo\_end \= \[rowdata(j).reo\_end cet(endInd)];
% rowdata(j).reo\_end\_nhs(end) \= rowdata(j).reo\_start\_nhs(end);
% end
 rowdata(j).endsRunning \= logical(t.isrun(endInd));
 startInd \= endInd \+ 1;
 endInd \= find(diff(cet(startInd:end)) \< 0, 1, 'first');
 j \= j\+1;
 if (isempty(endInd) \&\& startInd \< length(et))
 endInd \= length(et) \+ 1 \- startInd;
 end
end
% if (startInd \< length(et))
% endInd \= length(et);
% rowdata(j).trackNum \= t.trackNum; 
% rowdata(j).allvalid \= false;
% rowdata(j).startTime \= et(startInd) \- cet(startInd);
% rowdata(j).endTime \= et(endInd);
% rowdata(j).validStart \= cet(startInd);
% rowdata(j).validEnd \= cet(endInd);
% rowdata(j).startsRunning \= logical(t.isrun(startInd));
% rowdata(j).run\_start \= cet(run\_start(run\_start \>\= startInd \& run\_start \<\= endInd));
% rowdata(j).reo\_start \= cet(reo\_start(reo\_start \>\= startInd \& reo\_start \<\= endInd));
% rowdata(j).run\_end \= cet(run\_end(run\_end \>\= startInd \& run\_end \<\= endInd));
% rowdata(j).reo\_end \= cet(reo\_end(reo\_end \>\= startInd \& reo\_end \<\= endInd));
% 
% if (isa (t, 'MaggotTrack'))
% rowdata(j).ahs\_start \= cet(hs\_start(hs\_start \>\= startInd \& hs\_start \<\= endInd \& hsa));
% rowdata(j).rhs\_start \= cet(hs\_start(hs\_start \>\= startInd \& hs\_start \<\= endInd \& \~hsa));
% rowdata(j).ahs\_end \= cet(hs\_end(hs\_end \>\= startInd \& hs\_end \<\= endInd \& hsa));
% rowdata(j).rhs\_end \= cet(hs\_end(hs\_end \>\= startInd \& hs\_end \<\= endInd \& \~hsa));
% rowdata(j).reo\_start\_nhs \= nhs(reo\_start \>\= startInd \& reo\_start \<\= endInd);
% rowdata(j).reo\_end\_nhs \= nhs(reo\_end \>\= startInd \& reo\_end \<\= endInd);
% end
% if (startInd \< firstrunind)
% rowdata(j).prerun\_start \= cet(startInd);
% rowdata(j).prerun\_end \= cet(min(firstrunind, endInd));
% else
% rowdata(j).prerun\_start \= \[];
% rowdata(j).prerun\_end \= \[];
% end
% if (lastrunind \< endInd)
% rowdata(j).postrun\_start \= cet(max(lastrunind,startInd));
% rowdata(j).postrun\_end \= cet(endInd);
% else
% rowdata(j).postrun\_start \= \[];
% rowdata(j).postrun\_end \= \[];
% end
% rowdata(j).endsRunning \= logical(t.isrun(endInd));
% end
\-\-\-

\#\#\# File: resample\_to\_t.m (ID: utility functions.data analysis and description.2\)

function \[y,ty] \= resample\_to\_t (tx, x, tr)
%function \[y,ty] \= resample\_to\_t (tx, x, tr)
%uses the matlab resample command to map x onto tr
%takes care of end points; tr must be evenly spaced
tx \= tx(:).';
tr \= tr(:).';
trout \= false;
if (size(x,2\) \~\= size(tx, 2\))
 x \= x.';
 trout \= true;
end
if (size(x,2\) \~\= size(tx, 2\))
 error ('length of x does not match length of tx');
end
xe \= interp1(tx, x, tr(\[1 end]), 'nearest', 'extrap');
ii \= tx \> tr(1\) \& tx \< tr(end);
txx \= \[tr(1\) tx(ii) tr(end)];
xx \= \[xe(:,1\) x(:,ii) xe(:,end)];
\[y,ty] \= resample(xx, txx, 1/mean(diff(tr)));
if (trout)
 y \= y.';
end


end


\-\-\-

\#\#\# File: histVarBW.m (ID: utility functions.data analysis and description.3\)

function \[yv, yv\_alpha] \= histVarBW (xdata, xaxis, w, kernelType, causal, alpha)
%function yv \= histVarBW (ydata, xaxis, w, kernelType, causal)
%
%adapted from ssvkernel by Hideaki Shimazaki 
% http://2000\.jukuin.keio.ac.jp/shimazaki

existsAndDefault('kernelType', 'Gauss');
existsAndDefault('causal', false);
existsAndDefault('alpha', 0\.95\);
dx \= median(diff(xaxis));

xdata \= reshape(xdata,1,numel(xdata));

if (any(abs(diff(xaxis)\-dx)/dx \> 1e\-6\))
 warning ('expected evenly spaced xbins');
end
y\_hist \= histc(xdata, binEdgesFromCenters(xaxis)); y\_hist \= y\_hist(1:end\-1\);
N \= sum(y\_hist);
L \= length(xaxis);

yv \= zeros(1,L);
yone \= ones(size(y\_hist));
nf \= zeros(1,L);

if (ischar(kernelType))
 switch lower(kernelType)
 case 'gauss'
 kf \= @Gauss;
 case 'laplace'
 kf \= @Laplace;
 case 'cauchy'
 kf \= @Cauchy;
 case 'boxcar'
 kf \= @Boxcar;
 end
else
 kf \= kernelType;
end
if causal
 fun \= @(x,ww) kf(x,ww).\*(x \>\= 0\);
else
 fun \= kf;
end
 
for k \= 1:L
 yv(k) \= sum( y\_hist.\*fun(xaxis(k)\-xaxis,w(k)) );
 nf(k) \= sum( yone.\*fun(xaxis(k)\-xaxis,w(k)) );
end
yv \= yv ./ nf;
yv \= yv / sum(yv) \* N;

if (nargout \< 2\)
 return;
end
nbs \= ceil(20/(1\-alpha)); 
yb \= zeros(nbs,length(xaxis));
for i \= 1: nbs, %disp(\[i nbs])
 Nb \= poissrnd(N); %choose a poisson distributed number of samples
 idx \= ceil(rand(1,Nb)\*N);
 xb \= xdata(idx); %randomly select Nb samples from original data
 y\_histb \= histc(xb, binEdgesFromCenters(xaxis)); y\_histb \= y\_histb(1:end\-1\); %make fine\-scaled histogram
 
 
 ybuf \= zeros(1,L);
 for k \= 1:L
 ybuf(k) \= sum( y\_histb.\*fun(xaxis(k)\-xaxis,w(k)) );
 nf(k) \= sum( yone.\*fun(xaxis(k)\-xaxis,w(k)) );
 end
 ybuf \= ybuf ./ nf;
 ybuf \= ybuf / sum(ybuf) \* Nb;
 
 yb(i,:) \= ybuf;
 
end

ybsort \= sort(yb);
y95b \= ybsort(floor((1\-alpha)/2\*nbs),:); %95 is legacy from this being a 95% confidence interval
y95u \= ybsort(floor((1\+alpha)/2\*nbs),:);

yv\_alpha \= \[y95b; y95u];



function y \= Gauss(x,w) 
y \= 1/sqrt(2\*pi)./w.\*exp(\-x.^2/2\./w.^2\);

function y \= Laplace(x,w)
y \= 1\./sqrt(2\)./w.\*exp(\-sqrt(2\)./w.\*abs(x));

function y \= Cauchy(x,w) 
y \= 1\./(pi\*w.\*(1\+ (x./w).^2\));

function y \= Boxcar(x,w)
a \= sqrt(12\)\*w;
%y \= 1\./a .\* ( x \< a/2 ) .\* ( x \> \-a/2 );
%y \= 1\./a .\* ( abs(x) \< a/2 );
y \= ones(size(x))./a; 
y(abs(x) \> a/2\) \= 0; %speed optimization

\-\-\-

\#\#\# File: etiThetaToCycleTheta.m (ID: utility functions.data analysis and description.4\)

function \[theta, w, tx] \= etiThetaToCycleTheta (theta, w, tx, tshift, period, trange)
%function \[theta, w] \= etiThetaToCycleTheta (theta, w, tx, tshift, period, trange)
%
%theta, w are mean and covariance estimates vs elapsed time; combines these
%into a mean and covariance estimate vs. cyclic time
%size theta is Ntime x ndim, size w is ndim x ndim x Ntime
deltaT \= median(diff(tx));
if (\~existsAndDefault('trange', \[]))
 trange(1\) \= tx(find(mod(tx \+ tshift, period) \<\= deltaT, 1, 'first'));
 trange \= trange(1\):period:max(tx);
 trange \= \[trange(1\) trange(end)];
end
ti \= tx \>\= min(trange) \& tx \<\= max(trange);
tx \= tx(ti);
tt \= theta(ti,:);
ww \= w(:,:,ti);
tc \= mod(tx \+ tshift, period);
ii \= round(tc / deltaT);
\[\~,tx] \= meanyvsx(ii, tc, 0:(max(ii)\+0\.5\));
theta \= zeros(length(tx), size(tt,2\));
w \= zeros(size(ww,1\), size(ww,2\), length(tx));

n\=1;
for j \= 1:length(tx)
 
 ti \= (ii \+ 1 \=\= j);
 
 
 u \= tt(ti, :)';
 wi \= ww(:,:,ti);
 
 ni(j) \= length(u);
 
 if(isempty(u) \|\| isempty(wi))
 inds(n) \= j;
 n\=n\+1;
 continue
 end
 
 for k \= 1:size(wi,3\)
 wi(:,:,k) \= inv(wi(:,:,k));
 u(:,k) \= wi(:,:,k)\*u(:,k);
 end
 w(:,:,j) \= inv(sum(wi,3\));
 theta(j,:) \= (w(:,:,j)\*sum(u,2\))';
end


return
% Stupid fix for the case when some bins have nothing in them\-\- please
% improve as you see fit \-\- Ruben 5/2017

if(n\>1\)
 for i\=1:length(inds)
 if(inds(i)\=\=1\)
 theta(inds(i),:) \= 0\.5\* ( theta(2,:) \+ theta(end,:) );
 w(:,:,inds(i)) \= 0\.5\* (w(:,:,2\) \+ w(:,:,end) );
 elseif(inds(i)\=\=length(tx))
 theta(inds(i),:) \= 0\.5 \* (theta(1,:) \+ theta(end\-1,:));
 w(:,:,inds(i)) \= 0\.5 \* ( w(:,:,1\) \+ w(:,:,end\-1\) );
 else
 theta(inds(i),:) \= 0\.5\* ( theta(inds(i)\+1,:) \+ theta(inds(i)\-1,:) );
 w(:,:,inds(i)) \= 0\.5\* ( w(:,:,inds(i)\+1\) \+ w(:,:,inds(i)\-1\) );
 end
 end
end
\-\-\-

\#\#\# File: reorientationCyclePatchFromMap.m (ID: utility functions.data analysis and description.5\)

function \[invalidpatches, runpatches, reopatches, ahspatches, rhspatches, prerunpatches, postrunpatches] \= reorientationCyclePatchFromMap(rowdata, varargin)
%function \[invalidpatches, runpatches, reopatches, ahspatches, rhspatches, prerunpatches, postrunpatches] \= reorientationCyclePatchFromMap(rowdata, varargin)
%mintime \= \-Inf;
%maxtime \= Inf;
%minhs \= 1;
%maxhs \= Inf;
% include reorientation if nhs in \[minhs,maxhs]
%includepartial \= true;
%yoffset \= 0;

%
% invalidcolor \= \[0\.1 0\.1 0\.1];
% runcolor \= \[1 1 1];
% reocolor \= \[0\.4 0\.4 0\.4];
% ahscolor \= \[0 1 0];
% rhscolor \= \[1 0 0];
mintime \= \-Inf;
maxtime \= Inf;
minhs \= 1;
maxhs \= Inf;
includepartial \= true;
yoffset \= 0;

runpatches \= \[];
reopatches \= \[];
ahspatches \= \[];
rhspatches \= \[];
prerunpatches \= \[];
postrunpatches \= \[];

if (\~isempty(varargin) \&\& isstruct(varargin{1}))
 assignFromStruct(varargin{1});
 varargin \= varargin{2:end};
else
 varargin \= assignApplicable(varargin);
end

% colornames \= {'invalidcolor', 'runcolor', 'reocolor', 'ahscolor', 'rhscolor'};
% for j \= 1:length(colornames)
% if (ischar(eval(colornames{j})))
% eval(\[colornames{j} ' \= char2rgb(' colornames{j} ');']);
% end
% end

valid \= false(size(rowdata));
reovalid \= valid;
ahsvalid \= valid;
rhsvalid \= valid;
prerunvalid \= valid;
postrunvalid \= valid;
maxx \= max(\[rowdata.validEnd]);
minx \= min(\[rowdata.validStart]);
y \= yoffset \- 1;
for j \= 1:length(rowdata) 
 if (\~includepartial \&\& \~rowdata(j).allvalid)
 continue;
 end
 if (rowdata(j).startTime \< mintime \|\| rowdata(j).endTime \> maxtime)
 continue;
 end
 if (isempty(rowdata(j).run\_start))
 if (rowdata(j).startsRunning)
 if (rowdata(j).allvalid)
 rs \= minx;
 else
 rs \= rowdata(j).validStart;
 end
 else
 continue;
 end
 else
 rs \= rowdata(j).run\_start;
 end
 if (isempty(rowdata(j).run\_end))
 if (rowdata(j).endsRunning)
 if (rowdata(j).allvalid)
 re \= maxx;
 else
 re \= rowdata(j).validEnd;
 end
 else
 continue;
 end
 else
 re \= rowdata(j).run\_end;
 end

 
 valid(j) \= true;
 y \= y\+1;
 
 if (\~rowdata(j).allvalid)
 invalidpatches(j).Vertices \= \[minx y; rowdata(j).validStart y; rowdata(j).validStart y\+1; minx y\+1; rowdata(j).validEnd y; maxx y; maxx y\+1; rowdata(j).validEnd y\+1];
 invalidpatches(j).Faces \= \[1 2 3 4; 5 6 7 8];
 end
 
 
 if (re(1\) \< rs(1\))
 if(\~rowdata(j).startsRunning)
 j
 warning('run start/end alignment error');
 else
 rs \= \[minx rs];
 end
 end
 if (re(end) \< rs(end))
 if(\~rowdata(j).endsRunning)
 j
 warning('run start/end alignment error');
 else
 re \= \[re maxx];
 end
 end
 yverts \= y\*ones(size(rs))';
 if (length(rs) \~\= length(re))
 j

 warning('run start length \~\= run end length');
 else
 runpatches(j).Vertices \= \[rs' yverts; rs' yverts\+1; re' yverts\+1; re' yverts];
 N \= length(rs);
 fv \= (1:N)';
 runpatches(j).Faces \= \[fv fv\+N fv\+2\*N fv\+3\*N];
 end
 rs \= rowdata(j).reo\_start(rowdata(j).reo\_start\_nhs \>\= minhs \& rowdata(j).reo\_start\_nhs \<\= maxhs);
 re \= rowdata(j).reo\_end(rowdata(j).reo\_end\_nhs \>\= minhs \& rowdata(j).reo\_end\_nhs \<\= maxhs);
 if (\~isempty(rs) \&\& \~isempty(re))
 reovalid(j) \= true;
 if (re(1\) \< rs(1\))
 if(rowdata(j).startsRunning)
 re \= re(2:end);
 j
 warning('reo start/end alignment error'); %\#ok\<\*WNTAG\>
 end
 rs \= \[rowdata(j).validStart rs];
 
 end
 if (re(end) \< rs(end))
 if(rowdata(j).endsRunning)
 rs(end)
 re(end)
 rs \= rs(1:(end\-1\));
 j
 warning('reo start/end alignment error');
 end
 re \= \[re rowdata(j).validEnd];
 end
 yverts \= y\*ones(size(rs))';
 if (length(rs) \~\= length(re))
 warning('reo start length \~\= reo end length');
 end
 reopatches(j).Vertices \= \[rs' yverts; rs' yverts\+1; re' yverts\+1; re' yverts]; %\#ok\<\*AGROW\>
 N \= length(rs);
 fv \= (1:N)';
 reopatches(j).Faces \= \[fv fv\+N fv\+2\*N fv\+3\*N];
 end
 rs \= rowdata(j).ahs\_start;
 re \= rowdata(j).ahs\_end;
 if (\~isempty(rs) \&\& \~isempty(re))
 
 if (re(1\) \< rs(1\))
 if(rowdata(j).startsRunning)
% j
% warning('hs start/end alignment error');
 end
 rs \= \[rowdata(j).validStart rs];
 
 end
 if (re(end) \< rs(end))
 if(rowdata(j).endsRunning)
% j
% warning('ahs start/end alignment error');
 end
 re \= \[re rowdata(j).validEnd];
 end
 yverts \= y\*ones(size(rs))';
 if (length(rs) \~\= length(re))
% j
% warning('ahs start length \~\= ahs end length');
 else
 ahspatches(j).Vertices \= \[rs' yverts; rs' yverts\+1; re' yverts\+1; re' yverts];
 N \= length(rs);
 fv \= (1:N)';
 ahspatches(j).Faces \= \[fv fv\+N fv\+2\*N fv\+3\*N];
 ahsvalid(j) \= true;
 end
 end
 rs \= rowdata(j).rhs\_start;
 re \= rowdata(j).rhs\_end;
 if (\~isempty(rs) \&\& \~isempty(re))
 
 if (re(1\) \< rs(1\))
 if(rowdata(j).startsRunning)
% j
% warning('rhs start/end alignment error');
 end
 rs \= \[rowdata(j).validStart rs];
 
 end
 if (re(end) \< rs(end))
 if(rowdata(j).endsRunning)
% j
% warning('rhs start/end alignment error');
 end
 re \= \[re rowdata(j).validEnd];
 end
 yverts \= y\*ones(size(rs))';
 if (length(rs) \~\= length(re))
% j
% warning('rhs start length \~\= rhs end length');
 
 else
 rhspatches(j).Vertices \= \[rs' yverts; rs' yverts\+1; re' yverts\+1; re' yverts];
 N \= length(rs);
 fv \= (1:N)';
 rhspatches(j).Faces \= \[fv fv\+N fv\+2\*N fv\+3\*N];
 rhsvalid(j) \= true;
 end
 rs \= rowdata(j).prerun\_start;
 re \= rowdata(j).prerun\_end;
 yverts \= y\*ones(size(rs))';
 if (\~isempty(rs) \&\& \~isempty(re))
 prerunpatches(j).Vertices \= \[rs' yverts; rs' yverts\+1; re' yverts\+1; re' yverts];
 N \= length(rs);
 fv \= (1:N)';
 prerunpatches(j).Faces \= \[fv fv\+N fv\+2\*N fv\+3\*N];
 prerunvalid(j) \= true;
 end
 rs \= rowdata(j).postrun\_start;
 re \= rowdata(j).postrun\_end;
 yverts \= y\*ones(size(rs))';
 if (\~isempty(rs) \&\& \~isempty(re))
 postrunpatches(j).Vertices \= \[rs' yverts; rs' yverts\+1; re' yverts\+1; re' yverts];
 N \= length(rs);
 fv \= (1:N)';
 postrunpatches(j).Faces \= \[fv fv\+N fv\+2\*N fv\+3\*N];
 postrunvalid(j) \= true;
 end
 end
end
if (\~exist('invalidpatches', 'var'))
 invalidpatches \= \[];
else
 invalidpatches \= invalidpatches(valid \& \~\[rowdata.allvalid]);
end
if (\~isempty(runpatches)), runpatches \= runpatches(valid); end
if (\~isempty(reopatches)),reopatches \= reopatches(reovalid); end
if (\~isempty(ahspatches)),ahspatches \= ahspatches(ahsvalid); end
if (\~isempty(rhspatches)),rhspatches \= rhspatches(rhsvalid); end
if (\~isempty(prerunpatches)), prerunpatches \= prerunpatches(prerunvalid); end
if (\~isempty(postrunpatches)), postrunpatches \= postrunpatches(postrunvalid); end

% 
% if (\~exist('prerunpatches', 'var'))
% prerunpatches \= \[];
% else
% prerunpatches \= prerunpatches(prerunvalid);
% end
% if (\~exist('postrunpatches', 'var'))
% postrunpatches \= \[];
% else
% postrunpatches \= postrunpatches(postrunvalid);
% end
\-\-\-

\#\#\# File: fitRateFunWithTemporalScaling.m (ID: utility functions.data analysis and description.6\)

function \[outputStruct] \= fitRateFunWithTemporalScaling (ratefun, dlogratefun, ddlogratefun, turnT, turnX, runT, runX, tx, deltaT, Q\_alpha, params\_0, alpha\_0, w\_0\)
%function \[alpha, valpha, staticRateParams, outputStruct] \= fitRateFunWithTemporalScaling (ratefun, dlogratefun,ddlogratefun, turnT, turnX, runT, runX, tx, deltaT, Q\_alpha, params\_0, alpha\_0, w\_0\)
%
%fitRateFunWithTemporalScaling (ratefun, dlogratefun, ddlogratefun, turnT, turnX, runT, runX, tx, deltaT, Q\_alpha, params\_0, alpha\_0, w\_0\)
%fits rate \= ratefun(staticRateParams, xdata\*alpha(t))
%logratefun \- log (lambda(params, xdata))
%dlogratefun \- d/dxdata (log (lambda(params, xdata))
%ddlogratefun \- d^2/dxdata^2 (log (lambda(params, xdata))
%turnT, turnX, time and value at turn start
%runT, runX, time and value at runs (but not turns)
%tx time axis for analysis; data is assumed to be periodic with T \=
%max(tx)\-min(tx)
%deltaT \- sampling interval for data (not related directly to tx) \- usually 1/20
%Q\_alpha \- diffusion constant for scaling constant
%params0 \- initial guess for rate function params
%slpha0 \- initial guess for alpha(t)
%
%implements stochastic point process filter from eden et al 2004
if (nargin \=\= 0\)
 pd.ratefun \= @(x, xdata) exp(polyval(x, xdata));
 pd.dlogratefun \=@(x,xdata) polyval(polyder(x), xdata);
 pd.ddlogratefun \=@(x,xdata) polyval(polyder(polyder(x)), xdata);
 pd.turnT \= \[];
 pd.turnX \= \[];
 pd.runT \= \[];
 pd.runX \= \[];
 pd.tx \= \[];
 pd.deltaT \= 1/20;
 pd.Q\_alpha \= 1e\-3;
 pd.params\_0 \= \[0 1];
 pd.alpha\_0 \= ones(size(pd.tx));
 pd.w\_0 \= 1E9;
 pd.maxreps \= 10;
 pd.pad \= true;
 outputStruct \= pd;
 return;
end

pad \= true;
maxreps \= 10;

if (nargin \=\= 1 \&\& isstruct(ratefun))
 pd \= ratefun;
 fn \= fieldnames(pd);
 for j \= 1:length(fn);
 eval(\[fn{j} ' \= pd.' fn{j} ';']);
 end
end

params \= params\_0;
alpha \= alpha\_0;
%llold \= \-Inf;
ll \= NaN(\[1 maxreps]);
T \= max(tx) \- min(tx);
tinds \= turnT \>\= min(tx) \& turnT \<\= max(tx);
if (pad)
 turnXe \= \[turnX(tinds); turnX(tinds); turnX(tinds)];
 turnTe \= \[turnT(tinds)\-T; turnT(tinds); turnT(tinds) \+ T];
 rinds \= runT \>\= min(tx) \& runT \<\= max(tx);
 runXe \= \[runX(rinds); runX(rinds); runX(rinds)];
 runTe \= \[runT(rinds)\-T; runT(rinds);runT(rinds)\+T];
 txe \= unique(\[tx\-T;tx;tx\+T]);
else
 turnXe \= turnX(tinds);
 turnTe \= turnT(tinds);
 rinds \= runT \>\= min(tx) \& runT \<\= max(tx);
 runXe \= runX(rinds);
 runTe \= runT(rinds);
 txe \= unique(tx);
end
 
\[turnTe, I] \= sort(turnTe, 'ascend');
turnXe \= turnXe(I);
\[runTe, I] \= sort(runTe, 'ascend');
runXe \= runXe(I);

\[turnT, I] \= sort(turnT, 'ascend');
turnX \= turnX(I);
\[runT, I] \= sort(runT, 'ascend');
runX \= runX(I);


for mm \= 1:maxreps
 alpha \= alpha /mean(alpha);
 \[params, ll(mm)] \= fitStaticRate (ratefun, params, turnT, turnX, runT, runX, tx, deltaT, alpha);
 fitstruct \= fitScalingFactor(ratefun, dlogratefun, ddlogratefun, turnTe, turnXe, runTe, runXe, deltaT, txe, Q\_alpha, params, alpha(1\), w\_0\);
 alpha \= interp1(txe, fitstruct.theta, tx, 'nearest');
% alpha \= alpha /mean(alpha);
 w\_0 \= interp1(txe, fitstruct.w, tx(1\), 'nearest');
 plot (ll); pause(0\.01\);
end
%'tx','alpha', 'valpha', 'alpha\_s', 'valpha\_s',
fitstruct.tx \= tx;
fitstruct.ll \= ll;
fitstruct.alpha \= interp1(txe, fitstruct.theta, tx, 'nearest'); 
fitstruct.alpha\_s \= interp1(txe, fitstruct.theta\_s, tx, 'nearest');
fitstruct.valpha \= interp1(txe, fitstruct.w, tx, 'nearest');
fitstruct.valpha\_s \= interp1(txe, fitstruct.w\_s, tx, 'nearest');

outputStruct \= fitstruct;
outputStruct.staticParams \= params;






function \[params, ll] \= fitStaticRate (ratefun, params\_0, turnT, turnX, runT, runX, tx, deltaT, alpha)
%function params \= fitStaticRate (logratefun, params\_0, turnT, turnX, runT, runX, tx, alpha)
%maximizes log(P(data\|params)) \= sum\_turn logratefun(params, turnX\*alpha) \- sum\_run exp(logratefun(params,runX\*alpha)))\*deltaT 
tval \= turnX(turnT \>\= min(tx) \& turnT \<\= max(tx)).\*interp1(tx, alpha, turnT(turnT \>\= min(tx) \& turnT \<\= max(tx)), 'linear');
rval \= runX(runT \>\= min(tx) \& runT \<\= max(tx)).\*interp1(tx, alpha, runT(runT \>\= min(tx) \& runT \<\= max(tx)), 'linear');
nlogP \= @(p) \-sum(log(ratefun(p, tval)) ) \+ sum(ratefun(p,rval)\*deltaT);

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

\[params, ll, exitflag] \= fminunc(nlogP, params\_0, op);
% nt \= length(tval)
% ntpred \= sum(ratefun(params,rval)\*deltaT)
% innov \= zeros(size(tx));
% nt \= innov;
% ntpred \= innov;
% % \[\~,\~,tbin] \= histcounts(turnT, tx);
% % \[\~,\~,rbin] \= histcounts(runT, tx);
% 
% 
% for j \= 1:(length(tx) \- 1\)
% ti \= findRangeInSortedData(turnT, tx(j), tx(j\+1\));
% ri \= findRangeInSortedData(runT, tx(j), tx(j\+1\));
% % td \= turnX(ti);
% ad \= runX(ri);
% % xt \= td\*alpha(j);
% xa \= ad\*alpha(j);
% nt(j) \= length(ti);
% ntpred(j) \= deltaT\*sum(ratefun(params, xa));
% end
% innov \= nt \- ntpred;
% mean(innov)
% plot (innov);


ll \= \-ll \+ length(tval)\*log(deltaT);
if (exitflag \<\= 0\)
 warning ('static rate fit may not have converged!');
end


function fitstruct \= fitScalingFactor (ratefun, dlogratefun,ddlogratefun, turnT, turnX, runT, runX, deltaT, txe, Q\_alpha, params, alpha\_0, w\_0\)
existsAndDefault('alpha\_0', 1\);


% allT \= \[turnT runT];
% allX \= \[turnX runX];
% isturn \= \[true(size(turnT)) false(size(runT))];
theta \= ones(size(txe));
w \= theta;
wkkm1 \= w;
innov \= zeros(size(theta));


theta(1\) \= alpha\_0;
w(1\) \= w\_0;
wkkm1(1\) \= w\_0;
% \[\~,\~,tbin] \= histcounts(turnT, txe);
% \[\~,\~,rbin] \= histcounts(runT, txe);

for j \= 1:(length(txe) \- 1\)
% t \= theta(j);
 wkkm1(j\+1\) \= w(j) \+ Q\_alpha\*(txe(j\+1\)\-txe(j)); 
 ti \= findRangeInSortedData(turnT, txe(j), txe(j\+1\));
 ri \= findRangeInSortedData(runT, txe(j), txe(j\+1\));
% ti \= tbin \=\= j;
% ri \= rbin \=\= j;
 td \= turnX(ti);
% ad \= \[td;runX(ri)];
 ad \= runX(ri);
 xt \= td\*theta(j);
 xa \= ad\*theta(j);
 w(j\+1\) \= 1 / (1/wkkm1(j\+1\) ...
 \+ deltaT\*sum(ratefun(params, xa).\*((dlogratefun(params, xa)).^2 \+ ddlogratefun(params, xa)).\*ad.^2\) ...
 \- sum(ddlogratefun(params, xt).\*td.^2\) );
 theta(j\+1\) \= theta(j) \+ w(j\+1\)\*(sum(dlogratefun(params, xt).\*td) \- deltaT\*sum(ratefun(params, xa).\*dlogratefun(params, xa).\*ad));
 innov(j) \= length(ti) \- deltaT\*sum(ratefun(params, xa));
 
end

\[theta\_s,w\_s] \= recursiveSmoothing(theta, w, wkkm1\);

fn \= { 'txe', 'theta', 'w', 'innov', 'wkkm1', 'theta\_s', 'w\_s'};
for j \= 1:length(fn)
 fitstruct.(fn{j}) \= eval(fn{j}); 
end




function \[ts, ws] \= recursiveSmoothing (t, w, wkkm1\)
%function \[ts, ws] \= recursiveSmoothing (t, w, wkkm1\)
%
%implements smoothing step from Koyama, S., Eden, U.T., Brown, E.N., and Kass, R.E. (2009\). Bayesian decoding of neural spike trains. Ann Inst Stat Math 62, 37\.
%eqn 17\-19
%assuming f \= 1
ts \= t;
ws \= w;

for j \= (length(w)\-1\):\-1:1
 h \= w(j)/wkkm1(j\+1\);
 ts(j) \= t(j) \+ h\*(ts(j\+1\) \- t(j));
 ws(j) \= ws(j) \+ h^2\*(ws(j\+1\)\-wkkm1(j\+1\));
end



\-\-\-

\#\#\# File: estimateTimeVaryingROG.m (ID: utility functions.data analysis and description.7\)

Could not read file: 'utf\-8' codec can't decode byte 0x96 in position 473: invalid start byte

\-\-\-

\#\#\# File: densityEstimate2D.m (ID: utility functions.data analysis and description.8\)

function \[density, xx, yy] \= densityEstimate2D (data, xrange, yrange, bwx, bwy, M)
%function \[density, xx, yy] \= densityEstimate2D (data, xrange, yrange, bwx, bwy, M)
%
%data is N x 2
if (size(data,2\) \> size(data,1\))
 warning('transposing data to make N x d');
 data \= data';
end
dx \= abs(diff(xrange))/M;
dy \= abs(diff(yrange))/M;

padx \= ceil(6\*bwx/dx)\+1;
pady \= ceil(6\*bwy/dy)\+1;
pad \= max(padx,pady);
MM \= M \+ 2\*pad;
data(:,1\) \= (data(:,1\)\-min(xrange\-dx\*pad))/(abs(diff(xrange)) \+ 2\*dx\*pad);
data(:,2\) \= (data(:,2\)\-min(yrange\-dy\*pad))/(abs(diff(yrange)) \+ 2\*dy\*pad);

h \= ndhist(data, MM);
hs \= conv2(gaussKernel(bwy/dy), gaussKernel(bwx/dx), h, 'same');
density \= hs(pad \+ (1:M), pad \+ (1:M));
xaxis \= min(xrange) \- 0\.5 \* dx \+ (1:M)\*dx;
yaxis \= min(yrange) \- 0\.5 \* dy \+ (1:M)\*dy;
\[xx,yy] \= meshgrid(xaxis,yaxis);


\-\-\-

\#\#\# File: fitRateFunWithTemporalScalingND.m (ID: utility functions.data analysis and description.9\)

function \[outputStruct, scaledValues] \= fitRateFunWithTemporalScalingND (pd)
%function \[outputStruct] \= fitRateFunWithTemporalScalingND (pd)
%
% pd.ratefun \= @(x, xdata) exp(x(1\)\*xdata(:,1\) \+ x(2\)\*xdata(:,2\) \+ x(3\)); %\[Nx1 rate function of NxD xdata given K params]
% pd.gradlogratefun \=@(x,xdata) \[x(1\)\*ones(size(xdata(:,1\))) x(2\)\*ones(size(xdata(:,2\)))] ; %NxD gradient of log of rate
% pd.hesslogratefun \= @(x,xdata) zeros(\[size(xdata,1\) size(xdata,2\) size(xdata,2\)]); %NxDxD hessian of log of rate;
% pd.temporalratemod \= @(x,tdata) x(1\)\*exp(\-tdata/x(2\)) \+ 1;
% pd.turnT \= \[];
% pd.turnEti \= \[];
% pd.turnX \= \[];
% pd.runT \= \[];
% pd.runEti \= \[];
% pd.runX \= \[];
% pd.tx \= \[];
% pd.etx \= \[];
% pd.deltaT \= 1/20;
% pd.Q\_alpha \= 1e\-3;
% pd.params\_0 \= \[0 0 1];
% pd.tparams\_0 \= \[0 1000];
% pd.alpha\_0 \= ones(size(pd.tx));
% pd.w\_0 \= 1E9\*ones(size(pd.turnX,2\)\*\[1 1]);
% pd.maxreps \= 10;
% pd.pad \= false;
% outputStruct \= pd;
% pd.separateExperiments \= false;
%
%implements stochastic point process filter from eden et al 2004
if (nargin \=\= 0\)
 pd.ratefun \= @(x, xdata) exp(x(1\)\*xdata(:,1\) \+ x(2\)\*xdata(:,2\) \+ x(3\)); %\[Nx1 rate function of NxD xdata given K params]
 pd.gradlogratefun \=@(x,xdata) \[x(1\)\*ones(size(xdata(:,1\))) x(2\)\*ones(size(xdata(:,2\)))] ; %NxD gradient of log of rate
 pd.hesslogratefun \= @(x,xdata) zeros(\[size(xdata,1\) size(xdata,2\) size(xdata,2\)]); %NxDxD hessian of log of rate;
 pd.temporalratemod \= @(x,tdata) x(1\)\*exp(\-tdata/x(2\)) \+ 1;
 pd.turnT \= \[];
 pd.turnEti \= \[];
 pd.turnX \= \[];
 pd.runT \= \[];
 pd.runEti \= \[];
 pd.runX \= \[];
 pd.tx \= \[];
 pd.etx \= \[];
 pd.deltaT \= 1/20;
 pd.Q\_alpha \= 1e\-3;
 pd.params\_0 \= \[0 0 1];
 pd.tparams\_0 \= \[0 1000];
 pd.alpha\_0 \= ones(size(pd.tx));
 pd.w\_0 \= 1E9\*ones(size(pd.turnX,2\)\*\[1 1]);
 pd.maxreps \= 10;
 pd.pad \= false;
 outputStruct \= pd;
 pd.separateExperiments \= false;
 return;
end
% 
% pad \= true;
% maxreps \= 10;

% if (nargin \=\= 1 \&\& isstruct(ratefun))
% pd \= ratefun;
separateExperiments \= false;
fn \= fieldnames(pd);
for j \= 1:length(fn)
 eval(\[fn{j} ' \= pd.' fn{j} ';']);
end
% end

if isempty(runEti) %\#ok\<\*NODEF\>
 runEti \= runT;
end
if isempty(turnEti)
 turnEti \= turnT;
end

tx \= tx(:);

%params \= params\_0;
alpha \= alpha\_0;
%llold \= \-Inf;
ll \= NaN(\[1 maxreps]);
T \= max(tx) \- min(tx);
tinds \= turnT \>\= min(tx) \& turnT \< max(tx);
rinds \= runT \>\= min(tx) \& runT \< max(tx);

turnT \= turnT(tinds);
runT \= runT(rinds);
turnEti \= turnEti(tinds);
runEti \= runEti(rinds);
turnX \= turnX(tinds,:);
runX \= runX(rinds,:);
turnExpnum \= turnExpnum(tinds);
runExpnum \= runExpnum(rinds);

\[turnT, I] \= sort(turnT, 'ascend');
turnEti \= turnEti(I);
turnX \= turnX(I, :);
turnExpnum \= turnExpnum(I);
\[runT, I] \= sort(runT, 'ascend');
runEti \= runEti(I);
runX \= runX(I, :);
runExpnum \= runExpnum(I);



if (pd.pad)
 turnXe \= \[turnX; turnX; turnX];
 turnEtie \= \[turnEti;turnEti;turnEti];
 turnTe \= \[turnT\-T; turnT; turnT \+ T]; 
 runXe \= \[runX; runX; runX];
 runTe \= \[runT\-T; runT;runT\+T];
 runEtie \= \[runEti;runEti;runEti];
 turnExpnume \= \[turnExpnum; turnExpnum; turnExpnum];
 runExpnume \= \[runExpnum; runExpnum; runExpnum];
 txe \= unique(\[tx\-T;tx;tx\+T]);
else
 turnXe \= turnX;
 turnTe \= turnT;
 turnEtie \= turnEti;
 runXe \= runX;
 runTe \= runT;
 runEtie \= runEti;
 turnExpnume \= turnExpnum; 
 runExpnume \= runExpnum; 
 txe \= unique(tx);
end

fn \= {'turnT', 'turnX', 'turnEti', 'runT', 'runX', 'runEti', 'tx', 'turnExpnum', 'runExpnum'};
for j \= 1:length(fn)
 data.(fn{j}) \= eval(fn{j});
 data.(\[fn{j} 'e']) \= eval(\[fn{j} 'e']);
end
data.deltaT \= deltaT;

 
funs.ratefun \= ratefun;
funs.temporalratemod \= temporalratemod;
funs.params \= params\_0;
funs.tparams \= tparams\_0;
funs.gradlogratefun \= gradlogratefun; %NxD gradient of log of rate
funs.hesslogratefun \= hesslogratefun; %DxDxN hessian of log of rate;

if(size(alpha, 2\)\>2\)
 alpha \= alpha';
end
theta\_0 \= alpha(1,:);
nr\_t \= histcounts(pd.runT, binEdgesFromCenters(pd.tx));
nt\_t \= histcounts(pd.turnT, binEdgesFromCenters(pd.tx));
wt \= (nr\_t \+ nt\_t)/sum(nr\_t \+ nt\_t);
wt \= wt(:);
norm\_factor \= sum(alpha.\*repmat(wt, \[1 size(alpha,2\)]),1\); 
alpha \= alpha ./ repmat(norm\_factor, \[size(alpha,1\) 1]);

\[data.tval, data.rval] \= stretchedValues (data.tx, alpha, data.turnT, data.turnX, data.runT, data.runX);


nr\_et \= histcounts(pd.runEti, binEdgesFromCenters(pd.etx));
nt\_et \= histcounts(pd.turnEti, binEdgesFromCenters(pd.etx));
tr \= 1/data.deltaT .\* nt\_et./nr\_et;
if (\~isempty(tparams\_0\) \&\& \~isempty(temporalratemod))
 tratefun \= @(p, td) p(1\) \* temporalratemod(p(2:end),td);
 tp \= lsqcurvefit(tratefun, \[mean(tr) tparams\_0], pd.etx, tr);
 funs.tparams \= tp(2:end);
end
tic
funs \= fitStaticRate (funs, data);
toc
if (separateExperiments)
 erange \= \[min(data.turnExpnum) max(data.turnExpnum)];
else
 erange \= 1;
end

for mm \= 1:maxreps
 for j \= min(erange):max(erange)
 if (mm \> 1\)
 w\_0 \= fitstruct(j).w\_s(:,:,1\);
 theta\_0 \= fitstruct(j).alpha\_s(1,:);
 end
 if (separateExperiments)
 fitstruct(j) \= fitScalingFactor(funs, data, Q\_alpha, theta\_0, w\_0,j); %\#ok
 else
 fitstruct \= fitScalingFactor(funs, data, Q\_alpha, theta\_0, w\_0\); 
 end
 end
 toc
 data \= addStretchedValues(data, fitstruct);
 postAlphaFit \= measuredAndPredictedTurns (funs, data, tx); 
% 
 fitstruct \= normAlpha(fitstruct, data);
 data \= addStretchedValues(data, fitstruct);
 \[funs, ll(mm), nll(mm)] \= fitStaticRate (funs, data);
 
 postRateFit \= measuredAndPredictedTurns (funs, data, tx); 
 toc
% 
 
end
%'tx','alpha', 'valpha', 'alpha\_s', 'valpha\_s',
% fitstruct.tx \= tx;
% fitstruct.ll \= ll;

outputStruct.fitstruct \= fitstruct;
outputStruct.staticParams \= funs.params;
outputStruct.temporalParams \= funs.tparams;
outputStruct.etx \= etx;
outputStruct.turnRateVsTime \= tr;
outputStruct.nll \= nll;
outputStruct.ll \= ll;
outputStruct.postAlphaFit \= postAlphaFit;
outputStruct.postRateFit \= postRateFit;

if (length(fitstruct) \=\= 1\)
 fn \= fieldnames(fitstruct);
 for j \= 1:length(fn)
 outputStruct.(fn{j}) \= fitstruct.(fn{j});
 end
else
 tx \= fitstruct(1\).tx; 
 a \= zeros(\[size(fitstruct(1\).alpha) length(fitstruct) ]);
 a\_s \= a;
 v \= zeros(\[size(fitstruct(1\).valpha) length(fitstruct) ]);
 v\_s \= v;
 for j \= 1:length(fitstruct)
 a(:,:,j) \= fitstruct(j).alpha;
 a\_s(:,:,j) \= fitstruct(j).alpha\_s;
 v(:,:,:,j) \= fitstruct(j).valpha;
 v\_s(:,:,:,j) \= fitstruct(j).valpha\_s;
 end
 alpha \= fitstruct(1\).alpha;
 alpha\_s \= alpha;
 valpha \= fitstruct(1\).valpha;
 valpha\_s \= valpha;
 for j \= 1:length(tx)
 u \= squeeze (a(j,:,:));
 if(size(u,2\) \=\= 1\) %squeezed too far
 u \= u';
 end
 wi \= zeros(\[size(v,1\) size(v,2\), size(v,4\)]); 
 for k \= 1:size(v,4\)
 wi(:,:,k) \= inv(v(:,:,j,k));
 u(:,k) \= wi(:,:,k)\*u(:,k);
 end
 valpha(:,:,j) \= inv(sum(wi,3\));
 alpha(j,:) \= (valpha(:,:,j)\*sum(u,2\))';
 
 u \= squeeze (a\_s(j,:,:));
 if(size(u,2\) \=\= 1\) %squeezed too far
 u \= u';
 end
 wi \= zeros(\[size(v,1\) size(v,2\), size(v,4\)]); 
 for k \= 1:size(v,4\)
 wi(:,:,k) \= inv(v\_s(:,:,j,k));
 u(:,k) \= wi(:,:,k)\*u(:,k);
 end
 valpha\_s(:,:,j) \= inv(sum(wi,3\));
 alpha\_s(j,:) \= (valpha\_s(:,:,j)\*sum(u,2\))';
 end
 
 outputStruct.tx \= tx;
 outputStruct.innov \= sum(\[fitstruct.innov], 2\); 
 outputStruct.alpha \= alpha;
 outputStruct.alpha\_s \= alpha\_s;
 outputStruct.valpha \= alpha;
 outputStruct.valpha\_s \= alpha\_s;
 outputStruct.pd \= pd;
 
 
end
scaledValues \= data;




function \[funs, ll, nll] \= fitStaticRate (funs, data)
%function params \= fitStaticRate (logratefun, params\_0, turnT, turnX, runT, runX, tx, alpha)
%maximizes log(P(data\|params)) \= sum\_turn logratefun(params, turnX\*alpha) \- sum\_run exp(logratefun(params,runX\*alpha)))\*deltaT 

tval \= data.tval;
rval \= data.rval;
teti \= data.turnEti;
reti \= data.runEti;

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';



if (isempty(funs.temporalratemod) \|\| isempty(funs.tparams))
 funs.tparams \= \[];
 funs.temporalratemod \= @(p,td) ones(size(td));
 ratefun \= @(p,xd, td) funs.ratefun(p, xd);
 p0 \= funs.params;
 
 nlogP \= @(p) \-sum(log(ratefun(p, tval, teti)) ) \+ sum(ratefun(p,rval, reti)\*data.deltaT);
 \[funs.params, ll, exitflag] \= fminunc(nlogP, p0, op);
else
 tparams \= funs.tparams;
 params \= funs.params;
 ratefun \= @(p,tp,xd, td) funs.ratefun(p, xd) .\* funs.temporalratemod(tp, td);
 nlogP \= @(p) \-sum(log(ratefun(p, tparams, tval, teti)) ) \+ sum(ratefun(p,tparams, rval, reti)\*data.deltaT);
 \[params, \~, exitflag] \= fminunc(nlogP, params, op);
 if (exitflag \<\= 0\)
 warning ('static rate fit may not have converged!');
 end
 nlogP \= @(tp) \-sum(log(ratefun(params, tp, tval, teti)) ) \+ sum(ratefun(params,tp, rval, reti)\*data.deltaT);
 \[tparams, \~, exitflag] \= fminunc(nlogP, tparams, op);
 if (exitflag \<\= 0\)
 warning ('static rate fit may not have converged!');
 end
 nlogP \= @(p) \-sum(log(ratefun(p(1:length(params)), p((length(params)\+1\):end), tval, teti)) ) \+ sum(ratefun(p(1:length(params)), p((length(params)\+1\):end), rval, reti)\*data.deltaT);
 p0 \= \[params tparams];
 \[p, ll, exitflag] \= fminunc(nlogP, p0, op); 
 funs.params \= p(1:length(funs.params));
 funs.tparams \= p((length(funs.params) \+ 1\):end);
 
end


nll \= ll;
ll \= \-ll \+ length(tval)\*log(data.deltaT);
if (exitflag \<\= 0\)
 warning ('static rate fit may not have converged!');
end


function fitstruct \= fitScalingFactor(funs, data, Q\_alpha, alpha\_0, w\_0, expnum) % (ratefun, dlogratefun,ddlogratefun, turnT, turnX, runT, runX, deltaT, txe, Q\_alpha, params, alpha\_0, w\_0\)
existsAndDefault('alpha\_0', 1\);


txe \= data.txe;
theta \= repmat(alpha\_0, \[length(txe), 1]);
dtheta \= theta;
%theta \= ones(size(txe));
w \= repmat(w\_0, \[1 1 length(txe)]);
wkkm1 \= w;
innov \= zeros(length(txe), 1\);

if (numel(Q\_alpha) \< numel(w\_0\))
 Q\_alpha \= Q\_alpha(1\) \* eye(size(w\_0,1\));
end

if (existsAndDefault('expnum', \[]))
 tinds \= data.turnExpnume \=\= expnum;
 rinds \= data.runExpnume \=\= expnum;
else
 tinds \= true(size(data.turnTe));
 rinds \= true(size(data.runTe));
end
turnTe \= data.turnTe(tinds);
turnEtie \= data.turnTe(tinds);
turnXe \= data.turnXe(tinds, :);


runTe \= data.runTe(rinds);
runEtie \= data.runTe(rinds);
runXe \= data.runXe(rinds, :);


for j \= 1:(length(txe) \- 1\)
% t \= theta(j);
 wkkm1(:,:,j\+1\) \= w(:,:,j) \+ Q\_alpha\*(txe(j\+1\)\-txe(j)); 
 ti \= findRangeInSortedData(turnTe, txe(j), txe(j\+1\));
 ri \= findRangeInSortedData(runTe, txe(j), txe(j\+1\));
 if (isempty(ri))
 w(:,:,j\+1\) \= wkkm1(:,:,j\+1\);
 theta(j\+1,:) \= theta(j,:);
 continue;
 end
 
 td \= turnXe(ti, :);
 rd \= runXe(ri, :);
 %ad \= runXe(ri);
 ad \= \[td;rd];
 xt \= td.\*repmat(theta(j, :), \[size(td,1\) 1]);
 xr \= rd.\*repmat(theta(j, :), \[size(rd,1\) 1]);
 xa \= ad.\*repmat(theta(j, :), \[size(ad,1\) 1]);
 
 teti \= turnEtie(ti);
 reti \= runEtie(ri);
 aeti \= \[teti;reti];
 
 %tlambda \= funs.ratefun(funs.params, xt).\*funs.temporalratemod(funs.tparams, teti);
 rlambda\_dt \= data.deltaT\*funs.ratefun(funs.params, xr).\*funs.temporalratemod(funs.tparams, reti);
 alambda\_dt \= data.deltaT\*funs.ratefun(funs.params, xa).\*funs.temporalratemod(funs.tparams, aeti);
 innov(j) \= length(ti) \- sum(rlambda\_dt);
 
 
 ahess \= funs.hesslogratefun(funs.params, xa);
 if (isempty(ahess))
 ahesstheta \= ahess;
 else
 adm \= repmat(ad, \[1 1 size(ad,2\)]);
 ahesstheta \= ahess.\*adm.\*permute(adm, \[1 3 2]); %Hij \* xi \* xj 
 end
 thess \= funs.hesslogratefun(funs.params, xt);
 if (isempty(thess))
 thesstheta \= thess;
 else
 tdm \= repmat(td, \[1 1 size(td,2\)]);
 thesstheta \= thess.\*tdm.\*permute(tdm, \[1 3 2]);
 end
 
 agrad \= funs.gradlogratefun(funs.params, xa);
 if (isempty(agrad))
 agradthetasq \= ahesstheta;
 else
 agradtheta \= agrad.\*ad;
 agradthetasq \= repmat(agradtheta, \[1 1 size(agradtheta,2\)]);
 agradthetasq \= agradthetasq.\*permute(agradthetasq, \[1 3 2]);
 end
 
% dlambdaA\_lambdaA \= zeros(size(agradtheta,2\)\*\[1 1]);
% for m \= 1:size(agradtheta,2\)
% for n \= m:size(agradtheta,2\)
% dlambdaA\_lambdaA(m,n) \= sum(agradtheta(:,m).\*agradtheta(:,n).\*alambda\_dt);
% if (m \< n)
% dlambdaA\_lambdaA(n,m) \= dlambdaA\_lambdaA(m,n);
% end
% 
% end
% end
% dlambdaA\_lambdaA\_rev \= squeeze(sum((agradthetasq).\*repmat(alambda\_dt, \[1 size(ahesstheta, 2\) size(ahesstheta,2\)]),1\));
% 
 tgrad \= funs.gradlogratefun(funs.params, xt);
 tgradtheta \= tgrad.\*td;
 
 rgrad \= funs.gradlogratefun(funs.params, xr);
 rgradtheta \= rgrad.\*rd;
 
 
 dwinv \= squeeze(sum((agradthetasq \+ ahesstheta).\*repmat(alambda\_dt, \[1 size(ahesstheta, 2\) size(ahesstheta,2\)]),1\) \- ...
 sum(thesstheta,1\));
 
 w(:,:,j\+1\) \= inv(inv(wkkm1(:,:,j\+1\)) \+ dwinv);
 dtheta(j,:) \= (w(:,:,j\+1\)\*(sum(tgradtheta,1\)\-sum(rgradtheta .\* repmat(rlambda\_dt, \[1 size(rgradtheta, 2\)]),1\))')';
 theta(j\+1,:) \= theta(j,:) \+ dtheta(j,:); 
 
 
end

\[theta\_s,w\_s] \= recursiveSmoothing(theta, w, wkkm1\); %\#ok

fn \= { 'txe', 'theta', 'w', 'innov', 'wkkm1', 'theta\_s', 'w\_s', 'dtheta'};
for j \= 1:length(fn)
 fitstruct.(fn{j}) \= eval(fn{j}); 
end
fitstruct.tx \= data.tx;
fitstruct.alpha \= interp1(txe, fitstruct.theta, data.tx, 'nearest'); 
fitstruct.alpha\_s \= interp1(txe, fitstruct.theta\_s, data.tx, 'nearest');
for j \= 1:size(fitstruct.w, 1\)
 for k \= 1:size(fitstruct.w, 2\) 
 fitstruct.valpha(j,k,:) \= interp1(txe, squeeze(fitstruct.w(j,k,:)), data.tx, 'nearest');
 fitstruct.valpha\_s(j,k,:) \= interp1(txe, squeeze(fitstruct.w\_s(j,k,:)), data.tx, 'nearest');
 end
end

function result \= measuredAndPredictedTurns (funs, data, tx)

ntpred \= zeros(size(tx));
nt \= ntpred;
nr \= ntpred;
for j \= 1:(length(tx) \- 1\)
 ti \= findRangeInSortedData(data.turnT, tx(j), tx(j\+1\));
 ri \= findRangeInSortedData(data.runT, tx(j), tx(j\+1\));
 if (isempty(ri))
 continue;
 end 
 xa \= data.rval(ri, :);
 %xa \= ad.\*repmat(alpha(j, :), \[size(ad,1\) min(size(ad,1\),1\)]);
 aeti \= data.runEtie(ri);
 nt(j) \= length(ti);
 nr(j) \= length(ri); 
 ntpred(j) \= sum(data.deltaT\*funs.ratefun(funs.params, xa).\*funs.temporalratemod(funs.tparams, aeti));
 
end

result.ntpred \= ntpred;
result.nt \= nt;
result.nr \= nr;
result.innov \= nt \- ntpred;
result.residual \= cumsum(result.innov);



function \[ts, ws] \= recursiveSmoothing (t, w, wkkm1\)
%function \[ts, ws] \= recursiveSmoothing (t, w, wkkm1\)
%
%implements smoothing step from Koyama, S., Eden, U.T., Brown, E.N., and Kass, R.E. (2009\). Bayesian decoding of neural spike trains. Ann Inst Stat Math 62, 37\.
%eqn 17\-19
%assuming F \= 1
ts \= t;
ws \= w;

for j \= (length(w)\-1\):\-1:1
 h \= w(:,:,j)/wkkm1(:,:,j\+1\);
 ts(j,:) \= t(j,:) \+ (h\*(ts(j\+1,:) \- t(j,:))')';
 ws(:,:,j) \= ws(:,:,j) \+ h\*(ws(:,:,j\+1\)\-wkkm1(:,:,j\+1\))\*h';
end

function fitstruct \= normAlpha (fitstruct, data, expnum)
if (length(fitstruct) \> 1\)
 for j \= 1:length(fitstruct)
 fitstruct(j) \= normAlpha (fitstruct(j), data, j);
 end
 return;
end
if (existsAndDefault('expnum', \[]))
 tinds \= data.turnExpnum \=\= expnum;
 rinds \= data.runExpnum \=\= expnum;
else
 tinds \= true(size(data.turnT));
 rinds \= true(size(data.runT));
end

nr\_t \= histcounts(data.runT(rinds), binEdgesFromCenters(data.tx));
nt\_t \= histcounts(data.turnT(tinds), binEdgesFromCenters(data.tx));
wt \= (nr\_t \+ nt\_t)/sum(nr\_t \+ nt\_t);
wt \= wt(:);
alpha \= fitstruct.alpha;
norm\_factor \= sum(alpha.\*repmat(wt, \[1 size(alpha,2\)]),1\);
fitstruct.alpha \= alpha ./ repmat(norm\_factor, \[size(alpha,1\) 1]);

alpha\_s \= fitstruct.alpha\_s;
norm\_factor \= sum(alpha\_s.\*repmat(wt, \[1 size(alpha,2\)]),1\);
fitstruct.alpha\_s \= alpha\_s ./ repmat(norm\_factor, \[size(alpha,1\) 1]);


function data \= addStretchedValues (data, fitstruct)
if (length(fitstruct) \=\= 1\)
 \[data.tval, data.rval] \= stretchedValues (fitstruct.tx, fitstruct.alpha, data.turnT, data.turnX, data.runT, data.runX);
else
 data.tval \= data.turnX;
 data.rval \= data.runX;
 for j \= 1:length(fitstruct)
 ti \= data.turnExpnum \=\= j;
 ri \= data.runExpnum \=\= j;
 \[tval, rval] \= stretchedValues (fitstruct(j).tx, fitstruct(j).alpha, data.turnT(ti), data.turnX(ti,:), data.runT(ri), data.runX(ri,:));
 data.tval(ti,:) \= tval;
 data.rval(ri,:) \= rval;
 end
end

function \[tval, rval] \= stretchedValues (tx, alpha, turnT, turnX, runT, runX)
tval \= turnX .\* interp1(tx, alpha, turnT, 'linear');
rval \= runX .\* interp1(tx, alpha, runT, 'linear');

\-\-\-

\#\#\# File: fitRateFunWithInverseTemporalScalingND.m (ID: utility functions.data analysis and description.10\)

function \[outputStruct, scaledValues] \= fitRateFunWithInverseTemporalScalingND (pd)
%function \[outputStruct] \= fitRateFunWithTemporalScalingND (pd)
%
% pd.ratefun \= @(x, xdata) exp(x(1\)\*xdata(:,1\) \+ x(2\)\*xdata(:,2\) \+ x(3\)); %\[Nx1 rate function of NxD xdata given K params]
% pd.gradlogratefun \=@(x,xdata) \[x(1\)\*ones(size(xdata(:,1\))) x(2\)\*ones(size(xdata(:,2\)))] ; %NxD gradient of log of rate
% pd.hesslogratefun \= @(x,xdata) zeros(\[size(xdata,1\) size(xdata,2\) size(xdata,2\)]); %NxDxD hessian of log of rate;
% pd.temporalratemod \= @(x,tdata) x(1\)\*exp(\-tdata/x(2\)) \+ 1;
% pd.turnT \= \[];
% pd.turnEti \= \[];
% pd.turnX \= \[];
% pd.runT \= \[];
% pd.runEti \= \[];
% pd.runX \= \[];
% pd.tx \= \[];
% pd.etx \= \[];
% pd.deltaT \= 1/20;
% pd.Q\_alpha \= 1e\-3;
% pd.params\_0 \= \[0 0 1];
% pd.tparams\_0 \= \[0 1000];
% pd.alpha\_0 \= ones(size(pd.tx));
% pd.w\_0 \= 1E9\*ones(size(pd.turnX,2\)\*\[1 1]);
% pd.v0 \= 1; % alpha \= 1/sqrt(s^2 \+ v0\)
% pd.maxreps \= 10;
% pd.pad \= false;
% outputStruct \= pd;
% pd.separateExperiments \= false;
%
%implements stochastic point process filter from eden et al 2004
if (nargin \=\= 0\)
 pd.ratefun \= @(x, xdata) exp(x(1\)\*xdata(:,1\) \+ x(2\)\*xdata(:,2\) \+ x(3\)); %\[Nx1 rate function of NxD xdata given K params]
 pd.gradlogratefun \=@(x,xdata) \[x(1\)\*ones(size(xdata(:,1\))) x(2\)\*ones(size(xdata(:,2\)))] ; %NxD gradient of log of rate
 pd.hesslogratefun \= @(x,xdata) zeros(\[size(xdata,1\) size(xdata,2\) size(xdata,2\)]); %NxDxD hessian of log of rate;
 pd.temporalratemod \= @(x,tdata) x(1\)\*exp(\-tdata/x(2\)) \+ 1;
 pd.turnT \= \[];
 pd.turnEti \= \[];
 pd.turnX \= \[];
 pd.runT \= \[];
 pd.runEti \= \[];
 pd.runX \= \[];
 pd.tx \= \[];
 pd.etx \= \[];
 pd.deltaT \= 1/20;
 pd.Q\_s \= 1e\-3;
 pd.params\_0 \= \[0 0 1];
 pd.tparams\_0 \= \[0 1000];
 pd.s\_0 \= ones(size(pd.tx));
 pd.w\_0 \= 1E9\*ones(size(pd.turnX,2\)\*\[1 1]);
 pd.maxreps \= 10;
 pd.pad \= false;
 pd.sigma\_0 \= 1;
 pd.separateExperiments \= false;
 pd.v0 \= 1;
 outputStruct \= pd;
 return;
end

separateExperiments \= false;
fn \= fieldnames(pd);
v0 \= 1;
for j \= 1:length(fn);
 eval(\[fn{j} ' \= pd.' fn{j} ';']);
end
% end

if isempty(runEti) %\#ok\<\*NODEF\>
 runEti \= runT;
end
if isempty(turnEti)
 turnEti \= turnT;
end

tx \= tx(:);
if (size(sigma\_0,1\) \< length(tx))
 sigma\_0 \= repmat(sigma\_0(1,:),\[size(tx,1\) 1]);
end
sigma \= sigma\_0;
ll \= NaN(\[1 maxreps]);
T \= max(tx) \- min(tx);
tinds \= turnT \>\= min(tx) \& turnT \< max(tx);
rinds \= runT \>\= min(tx) \& runT \< max(tx);

turnT \= turnT(tinds);
runT \= runT(rinds);
turnEti \= turnEti(tinds);
runEti \= runEti(rinds);
turnX \= turnX(tinds,:);
runX \= runX(rinds,:);
turnExpnum \= turnExpnum(tinds);
runExpnum \= runExpnum(rinds);

\[turnT, I] \= sort(turnT, 'ascend');
turnEti \= turnEti(I);
turnX \= turnX(I, :);
turnExpnum \= turnExpnum(I);
\[runT, I] \= sort(runT, 'ascend');
runEti \= runEti(I);
runX \= runX(I, :);
runExpnum \= runExpnum(I);



if (pad)
 turnXe \= \[turnX; turnX; turnX];
 turnEtie \= \[turnEti;turnEti;turnEti];
 turnTe \= \[turnT\-T; turnT; turnT \+ T]; 
 runXe \= \[runX; runX; runX];
 runTe \= \[runT\-T; runT;runT\+T];
 runEtie \= \[runEti;runEti;runEti];
 turnExpnume \= \[turnExpnum; turnExpnum; turnExpnum];
 runExpnume \= \[runExpnum; runExpnum; runExpnum];
 txe \= unique(\[tx\-T;tx;tx\+T]);
else
 turnXe \= turnX;
 turnTe \= turnT;
 turnEtie \= turnEti;
 runXe \= runX;
 runTe \= runT;
 runEtie \= runEti;
 turnExpnume \= turnExpnum; 
 runExpnume \= runExpnum; 
 txe \= unique(tx);
end

fn \= {'turnT', 'turnX', 'turnEti', 'runT', 'runX', 'runEti', 'tx', 'turnExpnum', 'runExpnum'};
for j \= 1:length(fn)
 data.(fn{j}) \= eval(fn{j});
 data.(\[fn{j} 'e']) \= eval(\[fn{j} 'e']);
end
data.deltaT \= deltaT;

 
funs.ratefun \= ratefun;
funs.temporalratemod \= temporalratemod;
funs.params \= params\_0;
funs.tparams \= tparams\_0;
funs.gradlogratefun \= gradlogratefun; %NxD gradient of log of rate
funs.hesslogratefun \= hesslogratefun; %DxDxN hessian of log of rate;

theta\_0 \= sigma(1,:);

\[data.tval, data.rval] \= stretchedValues (data.tx, sigma, data.turnT, data.turnX, data.runT, data.runX, v0\);


nr\_et \= histcounts(pd.runEti, binEdgesFromCenters(pd.etx));
nt\_et \= histcounts(pd.turnEti, binEdgesFromCenters(pd.etx));
tr \= 1/data.deltaT .\* nt\_et./nr\_et;
if (\~isempty(tparams\_0\) \&\& \~isempty(temporalratemod))
 tratefun \= @(p, td) p(1\) \* temporalratemod(p(2:end),td);
 tp \= lsqcurvefit(tratefun, \[mean(tr) tparams\_0], pd.etx, tr);
 funs.tparams \= tp(2:end);
end
tic
funs \= fitStaticRate (funs, data);
toc
if (separateExperiments)
 erange \= \[min(data.turnExpnum) max(data.turnExpnum)]; %\#ok
else
 erange \= 1;
end

for mm \= 1:maxreps
 for j \= min(erange):max(erange)
 if (mm \> 1\)
 w\_0 \= fitstruct(j).w\_s(:,:,1\);
 theta\_0 \= fitstruct(j).sigma\_s(1,:);
 end
 if (separateExperiments)
 fitstruct(j) \= fitScalingFactor(funs, data, Q\_s,v0, theta\_0, w\_0,j); %\#ok
 else
 fitstruct \= fitScalingFactor(funs, data, Q\_s,v0, theta\_0, w\_0\); 
 end
 end
 toc
 
 data \= addStretchedValues(data, fitstruct);
 postAlphaFit \= measuredAndPredictedTurns (funs, data, tx); 
 %data \= addStretchedValues(data, fitstruct);
 \[funs, ll(mm)] \= fitStaticRate (funs, data);
 
 postRateFit \= measuredAndPredictedTurns (funs, data, tx); 
 toc
% 
 
end
%'tx','alpha', 'valpha', 'alpha\_s', 'valpha\_s',
% fitstruct.tx \= tx;
% fitstruct.ll \= ll;

outputStruct.fitstruct \= fitstruct;
outputStruct.staticParams \= funs.params;
outputStruct.temporalParams \= funs.tparams;
outputStruct.etx \= etx;
outputStruct.turnRateVsTime \= tr;
outputStruct.ll \= ll;
outputStruct.postAlphaFit \= postAlphaFit;
outputStruct.postRateFit \= postRateFit;

if (length(fitstruct) \=\= 1\)
 fn \= fieldnames(fitstruct);
 for j \= 1:length(fn)
 outputStruct.(fn{j}) \= fitstruct.(fn{j});
 end
else
 tx \= fitstruct(1\).tx; 
 a \= zeros(\[size(fitstruct(1\).alpha) length(fitstruct) ]);
 a\_s \= a;
 v \= zeros(\[size(fitstruct(1\).valpha) length(fitstruct) ]);
 v\_s \= v;
 for j \= 1:length(fitstruct)
 a(:,:,j) \= fitstruct(j).alpha;
 a\_s(:,:,j) \= fitstruct(j).alpha\_s;
 v(:,:,:,j) \= fitstruct(j).valpha;
 v\_s(:,:,:,j) \= fitstruct(j).valpha\_s;
 end
 sigma \= fitstruct(1\).sigma;
 sigma\_s \= sigma;
 vsigma \= fitstruct(1\).vsigma;
 vsigma\_s \= vsigma;
 for j \= 1:length(tx)
 u \= squeeze (a(j,:,:));
 if(size(u,2\) \=\= 1\) %squeezed too far
 u \= u';
 end
 wi \= zeros(\[size(v,1\) size(v,2\), size(v,4\)]); 
 for k \= 1:size(v,4\)
 wi(:,:,k) \= inv(v(:,:,j,k));
 u(:,k) \= wi(:,:,k)\*u(:,k);
 end
 vsigma(:,:,j) \= inv(sum(wi,3\));
 sigma(j,:) \= (vsigma(:,:,j)\*sum(u,2\))';
 
 u \= squeeze (a\_s(j,:,:));
 if(size(u,2\) \=\= 1\) %squeezed too far
 u \= u';
 end
 wi \= zeros(\[size(v,1\) size(v,2\), size(v,4\)]); 
 for k \= 1:size(v,4\)
 wi(:,:,k) \= inv(v\_s(:,:,j,k));
 u(:,k) \= wi(:,:,k)\*u(:,k);
 end
 vsigma\_s(:,:,j) \= inv(sum(wi,3\));
 sigma\_s(j,:) \= (vsigma\_s(:,:,j)\*sum(u,2\))';
 end
 
 outputStruct.tx \= tx;
 outputStruct.innov \= sum(\[fitstruct.innov], 2\); 
 outputStruct.sigma \= sigma;
 outputStruct.sigma\_s \= sigma\_s;
 outputStruct.vsigma \= sigma;
 outputStruct.vsigma\_s \= sigma\_s;
 outputStruct.pd \= pd;
 
 
end
scaledValues \= data;

 


function \[funs, ll] \= fitStaticRate (funs, data)
%function params \= fitStaticRate (logratefun, params\_0, turnT, turnX, runT, runX, tx, s)
%maximizes log(P(data\|params)) \= sum\_turn logratefun(params, turnX\*alpha) \- sum\_run exp(logratefun(params,runX\*alpha)))\*deltaT 

tval \= data.tval;
rval \= data.rval;
teti \= data.turnEti;
reti \= data.runEti;

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';



if (isempty(funs.temporalratemod) \|\| isempty(funs.tparams))
 funs.tparams \= \[];
 funs.temporalratemod \= @(p,td) ones(size(td));
 ratefun \= @(p,xd, td) funs.ratefun(p, xd);
 p0 \= funs.params;
 
 nlogP \= @(p) \-sum(log(ratefun(p, tval, teti)) ) \+ sum(ratefun(p,rval, reti)\*data.deltaT);
 \[funs.params, ll, exitflag] \= fminunc(nlogP, p0, op);
else
 tparams \= funs.tparams;
 params \= funs.params;
 ratefun \= @(p,tp,xd, td) funs.ratefun(p, xd) .\* funs.temporalratemod(tp, td);
 nlogP \= @(p) \-sum(log(ratefun(p, tparams, tval, teti)) ) \+ sum(ratefun(p,tparams, rval, reti)\*data.deltaT);
 \[params, \~, exitflag] \= fminunc(nlogP, params, op);
 if (exitflag \<\= 0\)
 warning ('static rate fit may not have converged!');
 end
 nlogP \= @(tp) \-sum(log(ratefun(params, tp, tval, teti)) ) \+ sum(ratefun(params,tp, rval, reti)\*data.deltaT);
 \[tparams, \~, exitflag] \= fminunc(nlogP, tparams, op);
 if (exitflag \<\= 0\)
 warning ('static rate fit may not have converged!');
 end
 nlogP \= @(p) \-sum(log(ratefun(p(1:length(params)), p((length(params)\+1\):end), tval, teti)) ) \+ sum(ratefun(p(1:length(params)), p((length(params)\+1\):end), rval, reti)\*data.deltaT);
 p0 \= \[params tparams];
 \[p, ll, exitflag] \= fminunc(nlogP, p0, op); 
 funs.params \= p(1:length(funs.params));
 funs.tparams \= p((length(funs.params) \+ 1\):end);
 
end



ll \= \-ll \+ length(tval)\*log(data.deltaT);
if (exitflag \<\= 0\)
 warning ('static rate fit may not have converged!');
end

%FIX \- check for instances of fitScaling factor and insert v0 between Q\_s
%and s\_0
function fitstruct \= fitScalingFactor(funs, data, Q\_s, v0, s\_0, w\_0, expnum) % (ratefun, dlogratefun,ddlogratefun, turnT, turnX, runT, runX, deltaT, txe, Q\_alpha, params, alpha\_0, w\_0\)
existsAndDefault('s\_0', 1\);
txe \= data.txe;
theta \= repmat(s\_0, \[length(txe), 1]);
dtheta \= theta;
w \= repmat(w\_0, \[1 1 length(txe)]);
wkkm1 \= w;
innov \= zeros(length(txe), 1\);

if (numel(Q\_s) \< numel(w\_0\))
 Q\_s \= Q\_s(1\) \* eye(size(w\_0,1\));
end

if (existsAndDefault('expnum', \[]))
 tinds \= data.turnExpnume \=\= expnum;
 rinds \= data.runExpnume \=\= expnum;
else
 tinds \= true(size(data.turnTe));
 rinds \= true(size(data.runTe));
end
turnTe \= data.turnTe(tinds);
turnEtie \= data.turnTe(tinds);
turnXe \= data.turnXe(tinds, :);


runTe \= data.runTe(rinds);
runEtie \= data.runTe(rinds);
runXe \= data.runXe(rinds, :);


for j \= 1:(length(txe) \- 1\)
% t \= theta(j);
% if (j \=\= 40\)
% pause;
% end
 wkkm1(:,:,j\+1\) \= w(:,:,j) \+ Q\_s\*(txe(j\+1\)\-txe(j)); 
 ti \= findRangeInSortedData(turnTe, txe(j), txe(j\+1\));
 ri \= findRangeInSortedData(runTe, txe(j), txe(j\+1\));
 if (isempty(ri))
 w(:,:,j\+1\) \= wkkm1(:,:,j\+1\);
 theta(j\+1,:) \= theta(j,:);
 continue;
 end
 
 td \= turnXe(ti, :);
 rd \= runXe(ri, :);
 %ad \= runXe(ri);
 ad \= \[td;rd];
 alpha \= 1\./sqrt(theta(j,:).^2 \+ v0\);
 
 xt \= td.\*repmat(alpha, \[size(td,1\) 1]);
 xr \= rd.\*repmat(alpha, \[size(rd,1\) 1]);
 xa \= ad.\*repmat(alpha, \[size(ad,1\) 1]);
 
 dalpha\_dtheta \= \-theta(j,:).\*(theta(j,:).^2 \+ v0\).^(\-1\.5\);
% ddalpha\_ddtheta \= 3\*theta(j,:).^2\*(theta(j,:).^2 \+ v0\).^(\-2\.5\)\-(theta(j,:).^2 \+ v0\).^(\-1\.5\);
 teti \= turnEtie(ti);
 reti \= runEtie(ri);
 aeti \= \[teti;reti];
 
 rlambda\_dt \= data.deltaT\*funs.ratefun(funs.params, xr).\*funs.temporalratemod(funs.tparams, reti);
 alambda\_dt \= data.deltaT\*funs.ratefun(funs.params, xa).\*funs.temporalratemod(funs.tparams, aeti);
 innov(j) \= length(ti) \- sum(rlambda\_dt);
 
 
 
 agrad \= funs.gradlogratefun(funs.params, xa); %NxD gradient of log of rate
% ahess \= funs.hesslogratefun(funs.params, xa); %NxDxD hessian of log of rate;
 
 if (isempty(agrad))
 agradthetasq \= ahess; %should also be empty
 else
 agradtheta \= agrad.\*ad.\*repmat(dalpha\_dtheta, \[size(ad,1\) 1]);
 agradthetasq \= repmat(agradtheta, \[1 1 size(agradtheta,2\)]);
 agradthetasq \= agradthetasq.\*permute(agradthetasq, \[1 3 2]);
 end
 
 tgrad \= funs.gradlogratefun(funs.params, xt);
 tgradtheta \= tgrad.\*td.\*repmat(dalpha\_dtheta, \[size(td,1\) 1]);
 
 rgrad \= funs.gradlogratefun(funs.params, xr);
 rgradtheta \= rgrad.\*rd.\*repmat(dalpha\_dtheta, \[size(rd,1\) 1]);
 
% if (isempty(ahess))
% ahesstheta \= ahess;
% else
% adm \= repmat(ad.\*repmat(dalpha\_dtheta, \[size(ad,1\) 1]), \[1 1 size(ad,2\)]);
% iiterm \= agrad.\*ad.\*repmat(ddalpha\_ddtheta, \[size(ad,1\) 1]);
% ahesstheta \= ahess.\*adm.\*permute(adm, \[1 3 2]);
% iihess \= zeros(size(ahesstheta));
% for ii \= 1:size(ahesstheta,3\)
% iihess(:,ii,ii) \= iiterm(:,ii);
% end
% ahesstheta \= ahesstheta \+ iihess;
% end
% thess \= funs.hesslogratefun(funs.params, xt);
% if (isempty(thess))
% thesstheta \= thess;
% else
% tdm \= repmat(td.\*repmat(dalpha\_dtheta, \[size(td,1\) 1]), \[1 1 size(td,2\)]);
% iiterm \= tgrad.\*td.\*repmat(ddalpha\_ddtheta, \[size(td,1\) 1]);
% thesstheta \= thess.\*tdm.\*permute(tdm, \[1 3 2]);
% iihess \= zeros(size(thesstheta));
% for ii \= 1:size(thesstheta,3\)
% iihess(:,ii,ii) \= iiterm(:,ii);
% end
% thesstheta \= thesstheta \+ iihess;
% 
% end
 
 dwinv \= squeeze(sum((agradthetasq).\*repmat(alambda\_dt, \[1 size(agradthetasq, 2\) size(agradthetasq,2\)]),1\));
 % dwinv \= squeeze(sum((agradthetasq \+ ahesstheta).\*repmat(alambda\_dt, \[1 size(ahesstheta, 2\) size(ahesstheta,2\)]),1\) \- ...
 % sum(thesstheta,1\));
 
 w(:,:,j\+1\) \= inv(inv(wkkm1(:,:,j\+1\)) \+ dwinv);
 
 dtheta(j,:) \= (w(:,:,j\+1\)\*(sum(tgradtheta,1\)\-sum(rgradtheta .\* repmat(rlambda\_dt, \[1 size(rgradtheta, 2\)]),1\))')';
 theta(j\+1,:) \= theta(j,:) \+ dtheta(j,:); 
 
 
end

\[theta\_s,w\_s] \= recursiveSmoothing(theta, w, wkkm1\); %\#ok

theta \= abs(theta); %\#ok
theta\_s \= abs(theta\_s); %\#ok

fn \= {'txe', 'theta', 'w', 'innov', 'wkkm1', 'theta\_s', 'w\_s', 'dtheta', 'v0'};
for j \= 1:length(fn)
 fitstruct.(fn{j}) \= eval(fn{j}); 
end
fitstruct.tx \= data.tx;
fitstruct.sigma \= interp1(txe, fitstruct.theta, data.tx, 'nearest');
fitstruct.sigma\_s \= interp1(txe, fitstruct.theta\_s, data.tx, 'nearest'); 
for j \= 1:size(fitstruct.w, 1\)
 for k \= 1:size(fitstruct.w, 2\) 
 fitstruct.vsigma(j,k,:) \= interp1(txe, squeeze(fitstruct.w(j,k,:)), data.tx, 'nearest'); 
 fitstruct.vsigma\_s(j,k,:) \= interp1(txe, squeeze(fitstruct.w\_s(j,k,:)), data.tx, 'nearest');
 end
end
%note \- calculation of alpha is straightforward, but calculation of errors
%in alpha requires more computation

function result \= measuredAndPredictedTurns (funs, data, tx)

ntpred \= zeros(size(tx));
nt \= ntpred;
nr \= ntpred;
for j \= 1:(length(tx) \- 1\)
 ti \= findRangeInSortedData(data.turnT, tx(j), tx(j\+1\));
 ri \= findRangeInSortedData(data.runT, tx(j), tx(j\+1\));
 if (isempty(ri))
 continue;
 end 
 xa \= data.rval(ri, :);
 %xa \= ad.\*repmat(alpha(j, :), \[size(ad,1\) min(size(ad,1\),1\)]);
 aeti \= data.runEtie(ri);
 nt(j) \= length(ti);
 nr(j) \= length(ri); 
 ntpred(j) \= sum(data.deltaT\*funs.ratefun(funs.params, xa).\*funs.temporalratemod(funs.tparams, aeti));
 
end

result.ntpred \= ntpred;
result.nt \= nt;
result.nr \= nr;
result.innov \= nt \- ntpred;
result.residual \= cumsum(result.innov);



function \[ts, ws] \= recursiveSmoothing (t, w, wkkm1\)
%function \[ts, ws] \= recursiveSmoothing (t, w, wkkm1\)
%
%implements smoothing step from Koyama, S., Eden, U.T., Brown, E.N., and Kass, R.E. (2009\). Bayesian decoding of neural spike trains. Ann Inst Stat Math 62, 37\.
%eqn 17\-19
%assuming F \= 1
ts \= t;
ws \= w;

for j \= (length(w)\-1\):\-1:1
 h \= w(:,:,j)/wkkm1(:,:,j\+1\);
 ts(j,:) \= t(j,:) \+ (h\*(ts(j\+1,:) \- t(j,:))')';
 ws(:,:,j) \= ws(:,:,j) \+ h\*(ws(:,:,j\+1\)\-wkkm1(:,:,j\+1\))\*h';
end

% function fitstruct \= normAlpha (fitstruct, data, expnum)
% if (length(fitstruct) \> 1\)
% for j \= 1:length(fitstruct)
% fitstruct(j) \= normAlpha (fitstruct(j), data, j);
% end
% return;
% end
% if (existsAndDefault('expnum', \[]))
% tinds \= data.turnExpnum \=\= expnum;
% rinds \= data.runExpnum \=\= expnum;
% else
% tinds \= true(size(data.turnT));
% rinds \= true(size(data.runT));
% end
% 
% nr\_t \= histcounts(data.runT(rinds), binEdgesFromCenters(data.tx));
% nt\_t \= histcounts(data.turnT(tinds), binEdgesFromCenters(data.tx));
% wt \= (nr\_t \+ nt\_t)/sum(nr\_t \+ nt\_t);
% wt \= wt(:);
% alpha \= fitstruct.alpha;
% norm\_factor \= sum(alpha.\*repmat(wt, \[1 size(alpha,2\)]),1\);
% fitstruct.alpha \= alpha ./ repmat(norm\_factor, \[size(alpha,1\) 1]);
% 
% alpha\_s \= fitstruct.alpha\_s;
% norm\_factor \= sum(alpha\_s.\*repmat(wt, \[1 size(alpha,2\)]),1\);
% fitstruct.alpha\_s \= alpha\_s ./ repmat(norm\_factor, \[size(alpha,1\) 1]);


function data \= addStretchedValues (data, fitstruct)
if (length(fitstruct) \=\= 1\)
 \[data.tval, data.rval] \= stretchedValues (fitstruct.tx, fitstruct.sigma, data.turnT, data.turnX, data.runT, data.runX, fitstruct.v0\);
else
 data.tval \= data.turnX;
 data.rval \= data.runX;
 for j \= 1:length(fitstruct)
 ti \= data.turnExpnum \=\= j;
 ri \= data.runExpnum \=\= j;
 \[tval, rval] \= stretchedValues (fitstruct(j).tx, fitstruct(j).sigma, data.turnT(ti), data.turnX(ti,:), data.runT(ri), data.runX(ri,:), fitstruct(j).v0\);
 data.tval(ti,:) \= tval;
 data.rval(ri,:) \= rval;
 end
end

function \[tval, rval] \= stretchedValues (tx, s, turnT, turnX, runT, runX, v0\)
tval \= turnX ./ sqrt(interp1(tx, s, turnT, 'linear').^2 \+ v0\);
rval \= runX ./ sqrt(interp1(tx, s, runT, 'linear').^2\+ \+ v0\);

\-\-\-

\#\#\# File: rateAdaptiveBW.m (ID: utility functions.data analysis and description.11\)

function \[rate, xaxis, optw, rate\_ci] \= rateAdaptiveBW (eventdata, normdata, xaxis, kernelType, causal, alpha)
% function \[rate, rate\_ci] \= rateAdaptiveBW (eventdata, normdata, xaxis, kernelType, causal, alpha)
% eventdata \= xvalue of events (e.g. time of turns, heading angle at time
% of turn)
% normdata \= xvalue when event could have occurred (e.g. time animal was in
% a run)
% xaxis \= axis for making histograms (bin centers)
% rate is in terms of the time bin size at which normdata was acquired
% e.g. a rate of 1 means 1 event per time bin \- usually you will want to
% multiply this rate by the sampling rate to get the rate in hertz

existsAndDefault('xaxis', \[]);
existsAndDefault('kernelType', 'Gauss');
existsAndDefault('causal', false);
existsAndDefault('alpha', 0\.95\);


if (isempty(xaxis))
 \[\~,xaxis, optw] \= ssvkernel(eventdata);
else 
 xaxis \= linspace(min(xaxis), max(xaxis), length(xaxis));
 \[\~,t,optw] \= ssvkernel(eventdata, xaxis);
 optw \= interp1(t, optw, xaxis, 'linear', 'extrap');
end
if (nargout \> 3\)
 \[h1, h1\_ci] \= histVarBW (eventdata, xaxis, optw, kernelType, causal, alpha);
else
 h1 \= histVarBW (eventdata, xaxis, optw, kernelType, causal, alpha);
end
h2 \= histVarBW (normdata, xaxis, optw, kernelType, causal, alpha);
rate \= h1 ./ h2;
if (nargout \> 3\)
 rate\_ci(1,:) \= h1\_ci(1,:)./h2;
 rate\_ci(2,:) \= h1\_ci(2,:)./h2;
end

\-\-\-

\#\#\# File: applySmoothingGaussianFilters.m (ID: utility functions.data analysis and description.12\)

function \[theta\_s,w\_s ] \= applySmoothingGaussianFilters( theta, w, q )
%function \[theta\_s,w\_s ] \= applySmoothingGaussianFilters( theta, w, q )
%
%applies smoothing step from Koyama, S., Eden, U.T., Brown, E.N., and Kass, R.E. (2009\). Bayesian decoding of neural spike trains. Ann Inst Stat Math 62, 37\.
%assuming F\_k \= identity matrix
%q is the diffusive noise term

theta\_s \= theta;
w\_s \= w;
for k \= (length(theta\_s)\-1\):\-1:1
 if (size(q,3\) \> 1\)
 qq \= q(:,:,k); 
 else
 qq \= q;
 end
 h \= w(:,:,k)/(w(:,:,k) \+ qq);
 theta\_s(:,k) \= theta(:,k) \+ h \* (theta\_s(:,k\+1\) \- theta(:,k));
 w\_s(:,:,k) \= w(:,:,k) \+ h \* (w\_s(:,:,k\+1\)\-w(:,:,k)\-qq)\* h';
end

end


\-\-\-

\#\#\# File: divergenceKL\_perez\_cruz\_1D.m (ID: utility functions.data analysis and description.13\)

Could not read file: 'utf\-8' codec can't decode byte 0xe9 in position 220: invalid continuation byte

\-\-\-

\#\#\# File: shimazakiCostFunction.m (ID: utility functions.data analysis and description.14\)

function c \= shimazakiCostFunction(turnTimes, w)
%function c \= shimazakiCostFunction(sortedTurnTimes, w)
%c \= N/w \+ 2/w sum(i \< j) exp(\-(ti \- tj)^2/
%
tt \= repmat(turnTimes(:), \[1 length(turnTimes)]);

dtsw \= (tt \- tt').^2/(4\*w^2\);
dtsw \= dtsw(:);
c \= 1/w\*(length(turnTimes)\*2\*sqrt(2\) \+ sum(exp(\-dtsw) \- 2\*sqrt(2\)\*exp(\-2\*dtsw)));

\-\-\-

\#\#\# Folder: utility functions/im analysis (ID: utility functions.im analysis)

\-\-\-

\#\#\# File: chargeenergy.m (ID: utility functions.im analysis.1\)

function ucharge \= chargeenergy(ctr, closed)
%function ubend \= bendenergy(ctr, closed)
%closed if we should connect contour(:,1\) with contour(:,end)
%gives a 1/r potential between nearest neighbors
existsAndDefault('closed', true);
if (closed)
 dx \= diff(ctr(:, \[end 1:end]),\[],2\);
 % dxr \= diff(ctr(:, \[end 1:end]),\[],2\);
% dxf \= diff(ctr(:, \[1:end 1]),\[],2\);
 
else
 dx \= diff(ctr,\[],2\);
% dxr \= diff(ctr(:, \[1 1:end]),\[],2\);
% dxf \= diff(ctr(:, \[1:end end]),\[],2\);
end
dl \= sqrt(sum(dx.^2\));
n \= length(dl);
%dx \= deriv(ctr, sigma, 'padtype', 'circular');
ucharge \= sum(1\./dl)/n.^2;
\-\-\-

\#\#\# File: region\_seg.m (ID: utility functions.im analysis.2\)

% Region Based Active Contour Segmentation
%
% seg \= region\_seg(I,init\_mask,max\_its,alpha,display)
%
% Inputs: I 2D image
% init\_mask Initialization (1 \= foreground, 0 \= bg)
% max\_its Number of iterations to run segmentation for
% alpha (optional) Weight of smoothing term
% higer \= smoother. default \= 0\.2
% display (optional) displays intermediate outputs
% default \= true
%
% Outputs: seg Final segmentation mask (1\=fg, 0\=bg)
%
% Description: This code implements the paper: "Active Contours Without
% Edges" By Chan Vese. This is a nice way to segment images whose
% foregrounds and backgrounds are statistically different and homogeneous.
%
% Example:
% img \= imread('tire.tif');
% m \= zeros(size(img));
% m(33:33\+117,44:44\+128\) \= 1;
% seg \= region\_seg(img,m,500\);
%
% Coded by: Shawn Lankton (www.shawnlankton.com)
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
function seg \= region\_seg(I,init\_mask,max\_its,alpha,display)
 
 %\-\- default value for parameter alpha is .1
 if(\~exist('alpha','var')) 
 alpha \= .2; 
 end
 %\-\- default behavior is to display intermediate outputs
 if(\~exist('display','var'))
 display \= true;
 end
 %\-\- ensures image is 2D double matrix
 I \= im2graydouble(I); 
 
 %\-\- Create a signed distance map (SDF) from mask
 phi \= mask2phi(init\_mask);
 
 %\-\-main loop
 for its \= 1:max\_its % Note: no automatic convergence test

 idx \= find(phi \<\= 1\.2 \& phi \>\= \-1\.2\); %get the curve's narrow band
 
 %\-\- find interior and exterior mean
 upts \= find(phi\<\=0\); % interior points
 vpts \= find(phi\>0\); % exterior points
 u \= sum(I(upts))/(length(upts)\+eps); % interior mean
 v \= sum(I(vpts))/(length(vpts)\+eps); % exterior mean
 
 F \= (I(idx)\-u).^2\-(I(idx)\-v).^2; % force from image information
 curvature \= get\_curvature(phi,idx); % force from curvature penalty
 
 dphidt \= F./max(abs(F)) \+ alpha\*curvature; % gradient descent to minimize energy
 
 %\-\- maintain the CFL condition
 dt \= .45/(max(dphidt)\+eps);
 
 %\-\- evolve the curve
 phi(idx) \= phi(idx) \+ dt.\*dphidt;

 %\-\- Keep SDF smooth
 phi \= sussman(phi, .5\);

 %\-\- intermediate output
 if((display\>0\)\&\&(mod(its,20\) \=\= 0\)) 
 showCurveAndPhi(I,phi,its); 
 end
 end
 
 %\-\- final output
 if(display)
 showCurveAndPhi(I,phi,its);
 end
 
 %\-\- make mask from SDF
 seg \= phi\<\=0; %\-\- Get mask from levelset

 
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
%\-\- AUXILIARY FUNCTIONS \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 
 
%\-\- Displays the image with curve superimposed
function showCurveAndPhi(I, phi, i)
 imshow(I,'initialmagnification',200,'displayrange',\[0 255]); hold on;
 contour(phi, \[0 0], 'g','LineWidth',4\);
 contour(phi, \[0 0], 'k','LineWidth',2\);
 hold off; title(\[num2str(i) ' Iterations']); drawnow;
 
%\-\- converts a mask to a SDF
function phi \= mask2phi(init\_a)
 phi\=bwdist(init\_a)\-bwdist(1\-init\_a)\+im2double(init\_a)\-.5;
 
%\-\- compute curvature along SDF
function curvature \= get\_curvature(phi,idx)
 \[dimy, dimx] \= size(phi); 
 \[y x] \= ind2sub(\[dimy,dimx],idx); % get subscripts

 %\-\- get subscripts of neighbors
 ym1 \= y\-1; xm1 \= x\-1; yp1 \= y\+1; xp1 \= x\+1;

 %\-\- bounds checking 
 ym1(ym1\<1\) \= 1; xm1(xm1\<1\) \= 1; 
 yp1(yp1\>dimy)\=dimy; xp1(xp1\>dimx) \= dimx; 

 %\-\- get indexes for 8 neighbors
 idup \= sub2ind(size(phi),yp1,x); 
 iddn \= sub2ind(size(phi),ym1,x);
 idlt \= sub2ind(size(phi),y,xm1\);
 idrt \= sub2ind(size(phi),y,xp1\);
 idul \= sub2ind(size(phi),yp1,xm1\);
 idur \= sub2ind(size(phi),yp1,xp1\);
 iddl \= sub2ind(size(phi),ym1,xm1\);
 iddr \= sub2ind(size(phi),ym1,xp1\);
 
 %\-\- get central derivatives of SDF at x,y
 phi\_x \= \-phi(idlt)\+phi(idrt);
 phi\_y \= \-phi(iddn)\+phi(idup);
 phi\_xx \= phi(idlt)\-2\*phi(idx)\+phi(idrt);
 phi\_yy \= phi(iddn)\-2\*phi(idx)\+phi(idup);
 phi\_xy \= \-0\.25\*phi(iddl)\-0\.25\*phi(idur)...
 \+0\.25\*phi(iddr)\+0\.25\*phi(idul);
 phi\_x2 \= phi\_x.^2;
 phi\_y2 \= phi\_y.^2;
 
 %\-\- compute curvature (Kappa)
 curvature \= ((phi\_x2\.\*phi\_yy \+ phi\_y2\.\*phi\_xx \- 2\*phi\_x.\*phi\_y.\*phi\_xy)./...
 (phi\_x2 \+ phi\_y2 \+eps).^(3/2\)).\*(phi\_x2 \+ phi\_y2\).^(1/2\); 
 
%\-\- Converts image to one channel (grayscale) double
function img \= im2graydouble(img) 
 \[dimy, dimx, c] \= size(img);
 if(isfloat(img)) % image is a double
 if(c\=\=3\) 
 img \= rgb2gray(uint8(img)); 
 end
 else % image is a int
 if(c\=\=3\) 
 img \= rgb2gray(img); 
 end
 img \= double(img);
 end

%\-\- level set re\-initialization by the sussman method
function D \= sussman(D, dt)
 % forward/backward differences
 a \= D \- shiftR(D); % backward
 b \= shiftL(D) \- D; % forward
 c \= D \- shiftD(D); % backward
 d \= shiftU(D) \- D; % forward
 
 a\_p \= a; a\_n \= a; % a\+ and a\-
 b\_p \= b; b\_n \= b;
 c\_p \= c; c\_n \= c;
 d\_p \= d; d\_n \= d;
 
 a\_p(a \< 0\) \= 0;
 a\_n(a \> 0\) \= 0;
 b\_p(b \< 0\) \= 0;
 b\_n(b \> 0\) \= 0;
 c\_p(c \< 0\) \= 0;
 c\_n(c \> 0\) \= 0;
 d\_p(d \< 0\) \= 0;
 d\_n(d \> 0\) \= 0;
 
 dD \= zeros(size(D));
 D\_neg\_ind \= find(D \< 0\);
 D\_pos\_ind \= find(D \> 0\);
 dD(D\_pos\_ind) \= sqrt(max(a\_p(D\_pos\_ind).^2, b\_n(D\_pos\_ind).^2\) ...
 \+ max(c\_p(D\_pos\_ind).^2, d\_n(D\_pos\_ind).^2\)) \- 1;
 dD(D\_neg\_ind) \= sqrt(max(a\_n(D\_neg\_ind).^2, b\_p(D\_neg\_ind).^2\) ...
 \+ max(c\_n(D\_neg\_ind).^2, d\_p(D\_neg\_ind).^2\)) \- 1;
 
 D \= D \- dt .\* sussman\_sign(D) .\* dD;
 
%\-\- whole matrix derivatives
function shift \= shiftD(M)
 shift \= shiftR(M')';

function shift \= shiftL(M)
 shift \= \[ M(:,2:size(M,2\)) M(:,size(M,2\)) ];

function shift \= shiftR(M)
 shift \= \[ M(:,1\) M(:,1:size(M,2\)\-1\) ];

function shift \= shiftU(M)
 shift \= shiftL(M')';
 
function S \= sussman\_sign(D)
 S \= D ./ sqrt(D.^2 \+ 1\); 

 





\-\-\-

\#\#\# File: generateCheckerImageForPhototaxis.m (ID: utility functions.im analysis.3\)

function gradientImage \= generateCheckerImageForPhototaxis(x1, x2, y1, y2, cc, checkerSizeInCm, borderSizeInCm, varargin)
%function gradientImage \= generateGradientImageForPhototaxis(plateIm, cc, borderSizeInCm, gradstyle, varargin)

existsAndDefault('borderSizeInCm' , 0\);

rx \= linspace(min(cc.realx), max(cc.realx), 1280\);
ry \= linspace(min(cc.realy), max(cc.realy), 800\);

x0 \= (min(x1(1\),x2(1\)));
w \= (max(x2(1\),x1(1\))) \- x0;

xc \= mean(\[x1 x2]);
yc \= mean(\[y1 y2]);
\[px,py] \= meshgrid(rx,ry);
gi \= 255\*xor(mod(floor((px\-xc) / checkerSizeInCm),2\) , mod(floor((py\-yc) / checkerSizeInCm),2\));
%imagesc(rx,ry,gi); pause
%set region outside \[x1,x2,y1,y2] to 0
%set region borderSizeInCm within to 255
gi (px \< min(\[x1 x2]) \+ borderSizeInCm) \= 255;
gi (py \< min(\[y1 y2]) \+ borderSizeInCm) \= 255;
gi (px \> max(\[x1 x2]) \- borderSizeInCm) \= 255;
gi (py \> max(\[y1 y2]) \- borderSizeInCm) \= 255;
gi (px \< min(\[x1 x2])) \= 0;
gi (py \< min(\[y1 y2])) \= 0;
gi (px \> max(\[x1 x2])) \= 0;
gi (py \> max(\[y1 y2])) \= 0;


gradientImage \= cc.morphRealToCam(gi, rx, ry, 'camxaxis', min(cc.camx):max(cc.camx), 'camyaxis', min(cc.camy):max(cc.camy));
gradientImage \= uint8(gradientImage);
image(gradientImage); colormap gray(256\);
title ('checker');
pause(0\.1\);
\-\-\-

\#\#\# File: constforceenergy.m (ID: utility functions.im analysis.4\)

function uconst \= constforceenergy(ctr, closed)
%function ubend \= bendenergy(ctr, closed)
%closed if we should connect contour(:,1\) with contour(:,end)
%gives a potential equal to the distance between nearest neighbors
existsAndDefault('closed', true);
if (closed)
 dx \= diff(ctr(:, \[end 1:end]),\[],2\);
 % dxr \= diff(ctr(:, \[end 1:end]),\[],2\);
% dxf \= diff(ctr(:, \[1:end 1]),\[],2\);
 
else
 dx \= diff(ctr,\[],2\);
% dxr \= diff(ctr(:, \[1 1:end]),\[],2\);
% dxf \= diff(ctr(:, \[1:end end]),\[],2\);
end
dl \= sqrt(sum(dx.^2\));
uconst \= sum(dl);
\-\-\-

\#\#\# File: createGradientsForPhototaxis.m (ID: utility functions.im analysis.5\)

function createGradientsForPhototaxis(cbsize, checkerfn, platefn)
% creates a set of gradients that run along the x\-direction of the
% checkerboard
% function createGradientsForPhototaxis(cbsize, checkerfn, platefn)
%
% cbsize is the size of a checker in the output checkerboard image (in cm)
% defaults to 3 cm;
% if checkerfn, platefn, are not passed in, they are selected in a dialog

existsAndDefault('cbsize', 3\);
if (\~existsAndDefault('checkerfn', \[]))
 \[fn, chbasedir] \= uigetfile('\*.jpg;\*.bmp;\*.tiff;', 'Select visual image of checkerboard', fullfile('\\\\labnas1', 'Share', 'Phototaxis', 'calibrations',''));
 checkerfn \= fullfile(chbasedir, fn);
end
if (\~existsAndDefault('platefn', \[]))
 \[fn, basedir] \= uigetfile('\*.jpg;\*.bmp;\*.tiff;', 'Select visual image of plate', chbasedir);
 platefn \= fullfile(basedir, fn);
end

chim \= imread(checkerfn);
pim \= imread(platefn);

cc \= CameraCalibration(chim);

imagesc(pim); colormap (gray(256\)); caxis(\[0 128]);
while(1\)
 title ('please click on low edge of plate \& hit enter');
 \[x,y] \= getpts;
 try
 x1 \= cc.realPtsFromCamPts(\[x(1\); y(1\)]);
 catch
 continue;
 end
 break;
end
lowx \= x;
while(1\)
 title ('please click on high edge of plate \& hit enter');
 \[x,y] \= getpts;
 try
 x2 \= cc.realPtsFromCamPts(\[x(1\); y(1\)]);
 catch
 continue;
 end
 break;
end
if (abs(x \- lowx) \< 0\.9 \* size(pim,1\))
 while(1\)
 title ('please click on top and bottom of plate \& hit enter');
 \[x,y] \= getpts;
 if (length(y) \< 2\)
 continue;
 end
 try
 y \= cc.realPtsFromCamPts(\[x y]');
 catch
 continue;
 end
 end
else
 y \= cc.realPtsFromCamPts(\[mean(\[x lowx]) mean(\[x lowx]); 1, size(pim,1\)]);
end

title ('thank you \- calculating gradients, this may take a moment');
pause(0\.1\);
newdir \= fullfile(chbasedir, 'gradients','');
if (\~isdir(newdir))
 mkdir(newdir);
end

style \= {'linear', 'exponential', 'power'};
name \= {'cam target linear.tiff', 'cam target exponential.tiff', 'cam target square.tiff'};
for j \= 1:length(style)
 gi \= generateGradientImageForPhototaxis(x1(1\), x2(1\), cc, 0, style{j}, 2\);
 imwrite(gi, fullfile(newdir, name{j}), 'tiff');
end

 gi \= generateCheckerImageForPhototaxis(x1(1\), x2(1\), min(y(2,:)), max(y(2,:)), cc, cbsize, 0\);
 imwrite(gi, fullfile(newdir, 'cam target checker.tiff'), 'tiff');


\-\-\-

\#\#\# File: straightLineEdgeThruPoint.m (ID: utility functions.im analysis.6\)

function \[x,y] \= straightLineEdgeThruPoint (pt, im, xd, yd)
%function \[x,y] \= straightLineEdgeThruPoint (pt, im, xd, yd)

debug \= false;
thresh \= 0\.15;

existsAndDefault('xd', \[]);
existsAndDefault('yd', \[]);
if (isempty(xd) \|\| isempty(yd))
 \[xd,yd] \= imgradient(im,3\);
end
e \= xd.^2 \+ yd.^2;
e \= e/interp2(e, pt(1\), pt(2\), '\*linear');
th \= atan2(interp2(xd, pt(1\), pt(2\), '\*linear'),interp2(yd, pt(1\), pt(2\), '\*linear'));
left \= pt;
right \= left;
keepgoing \= true;
stepsize \= 10;
while (keepgoing)
 keepgoing \= false;
 perpx \= sin(th)\*linspace(\-2,2,5\);
 perpy \= cos(th)\*linspace(\-2,2,5\);
 parx \= cos(th)\*stepsize;
 pary \= sin(th)\*stepsize;
 rval \= interp2(e, right(1\) \+ parx \+ perpx, right(2\) \+ pary \+ perpy, '\*linear', \-1\);
 \[rmv, I] \= max(rval);
 if (rmv \> thresh)
 keepgoing \= true;
 right(1\) \= right(1\) \+ parx \+ perpx(I);
 right(2\) \= right(2\) \+ pary \+ perpy(I);
 end
 lval \= interp2(e, left(1\) \- parx \+ perpx, left(2\) \- pary \+ perpy, '\*linear', \-1\);
 \[lmv, I] \= max(lval);
 if (lmv \> thresh)
 keepgoing \= true;
 left(1\) \= left(1\) \- parx \+ perpx(I);
 left(2\) \= left(2\) \- pary \+ perpy(I);
 end
 th \= atan2(right(2\)\-left(2\), right(1\)\-left(1\));
 if (debug)
 imagesc(e); axis image; hold on
 plot (\[left(1\) right(1\)], \[left(2\) right(2\)], 'r.\-', 'LineWidth', 2, 'MarkerSize', 10\); hold off
 pause(0\.01\);
 end
 l \= sqrt((left(1\)\-right(1\))^2 \+ (left(2\)\-right(2\))^2\);
 stepsize \= max(stepsize, l/4\);
 %{
 maxv \= min(1, max(interp2(e, linspace(left(1\),right(1\), 20\), linspace(left(2\),right(2\),20\))))
 e \= e/maxv;
 e \= e.\*(e \> thresh);
 %}
end

if (all(left \=\= right))
 x \= \[];
 y \= \[];
 return
end

\[par,perp] \= meshgrid(linspace(\-0\.1,1\.1,100\), linspace(\-10,10,20\));
xx \= par(:)\*(right(1\)\-left(1\)) \+ left(1\) \+ perp(:)\*sin(th);
yy \= par(:)\*(right(2\)\-left(2\)) \+ left(2\) \+ perp(:)\*cos(th);
valid \= xx \>\= 1 \& xx \<\= size(e,2\) \& yy \>\=1 \& yy \<\= size(e,1\);
xx \= xx(valid);
yy \= yy(valid);
maxv \= max(interp2(e, xx, yy, '\*linear'));
e \= e/maxv \- thresh;
miny \= floor(min(yy));
minx \= floor(min(xx));
mye \= e(miny:ceil(max(yy)),minx:ceil(max(xx)));

op \= optimset('fminsearch');
%op.maxIter \= 20;
fun \= @(x) \-sumOfE(mye, x);
x \= \[left(1\)\-minx\+1 right(1\)\-minx\+1 left(2\)\-miny\+1 right(2\)\-miny\+1];
%imagesc(mye); axis image; hold on
%plot (x(1:2\), x(3:4\), 'r.\-', 'LineWidth', 2, 'MarkerSize', 10\); hold off

x \= fminsearch(fun,x,op);
%hold on; plot (x(1:2\), x(3:4\), 'g.\-', 'LineWidth', 2, 'MarkerSize', 10\); hold off
y \= \[x(3\) x(4\)] \+ miny \- 1;
x \= \[x(1\) x(2\)] \+ minx \- 1;

function y \= sumOfE(e, x)
l \= ceil(sqrt((x(2\)\-x(1\)).^2 \+ (x(4\)\-x(3\)).^2\));
y \= sum(interp2(e, linspace(x(1\), x(2\), l), linspace(x(3\), x(4\), l), '\*Linear', \-1000\));


\-\-\-

\#\#\# File: calibrateCheckerboard.m (ID: utility functions.im analysis.7\)

function \[realx, realy, camx, camy] \= calibrateCheckerboard(im, varargin)
%function \[realx, realy, camx, camy] \= calibrateCheckerboard(im, varargin)
%varargin)
% finds the corners of a checkerboard image, with some help
% xaxis, yaxis are the axes for the image (i.e. pcolor(axis,yaxis,im)
% makes sense)
% im must be a grayscale image (size nrowsxncolsx1\)
% checkers must be roughly aligned to axes
%optional key/value paris
%"xaxis" x\-axis of im
%"yaxis" y\-axis of im
%"flatten", true/false \-\- whether to flatten out irregularities in
%illumination
%"xinds", xi "yinds",yi only consider these indices when calibrating checkerboard
%"flipy", \[false]/true, if true, make low camera y values high real values 
%"flipx", \[false]/true, if true, make low camera x values high real values
%"tpose", \[false]/true, if true, swap x\&y coordinates \-\- equal to
%rotation plus flip
%realx,realy camx,camy mark the correspondence between real points (1
%square \= 1 unit)
%"affine", \[false]/true, if true, don't assume that checkerboard is almost
%regular when calibrating

xaxis \= \[];
yaxis \= \[];
xinds \= \[];
yinds \= \[];
flipy \= false;
flipx \= false;
tpose \= false;
flatten \= false;
harrissigma \= 3;
affine \= false;
varargin \= assignApplicable(varargin);
origimsize \= size(im);
if (\~isempty(xinds))
 xaxis \= xinds;
 if (isempty(yinds))
 im \= im(:,xinds); 
 else
 im \= im(yinds, xinds);
 yaxis \= yinds;
 end
else
 if (\~isempty(yinds))
 im \= im(yinds, :);
 yaxis \= yinds;
 end
end

if (isempty(xaxis))
 xaxis \= 1:size(im,2\);
end
if (isempty(yaxis))
 yaxis \= 1:size(im,1\);
end

if (flatten)
 \[\~, cpts] \= myharris(im, harrissigma);
 checkerSize \= sqrt(size(im,1\)\*size(im,2\)/length(cpts));
 intensityim \= blurim(imdilate(blurim(im, 4\), ones(ceil(checkerSize/1\.5\))), checkerSize/2\);
 im \= double(im) ./ double(intensityim);
 im(im \> 2\) \= 2;
% figure(9\); clf(9\); imagesc(xaxis, yaxis, intensityim);
% figure(11\); clf(11\); imagesc(xaxis, yaxis, double(im)); axis equal; colormap jet; 
end

\[cim, cpts] \= myharris(im, harrissigma);

%whos cpts

% figure(21\); clf(21\);
% imagesc(xaxis, yaxis, cim); axis equal; colormap jet

xc \= interp1(xaxis, cpts(1,:));
yc \= interp1(yaxis, cpts(2,:));

%sort into rows

\[yc,I] \= sort(yc);
xc \= xc(I);

\[\~,c] \= kmeans(diff(yc), 2, 'start', \[0; max(diff(yc))]);
height \= max(c);


jump \= unique(\[0 find(diff(yc) \> height \* 0\.5\) length(yc)]);
for j \= 1:(length(jump) \- 1\)
 xx \= xc((jump(j) \+ 1\):(jump(j\+1\)));
 yy \= yc((jump(j) \+ 1\):(jump(j\+1\)));
 \[xx,I] \= sort(xx);
 yy \= yy(I);
 row(j).xc \= xx; %\#ok
 row(j).yc \= yy; %\#ok
 dx(j) \= median(diff(row(j).xc));
 yavg(j) \= mean(row(j).yc);
end
width \= median(dx(isfinite(dx)));
height \= median(diff(yavg));

x0 \= median(mod(xc,width));
y0 \= median(mod(yc,height));

xr \= (xc \- x0\)/ width;
yr \= (yc \- y0\)/ height;

if (affine)
 \[xc, yc, xr, yr] \= affineFit(xc, yc, xr, yr);
 \[\~,I] \= sort(xc);
 \[\~,J] \= sort(yr(I));
 w \= median(diff(xc(I(J))))
 \[\~,I] \= sort(yc);
 \[\~,J] \= sort(xr(I));
 h \= median(diff(yc(I(J))))
 
else
 %remove any points that aren't within 10% of the checker size of where the
 %corner would be if the grid were perfect
 valid \= (abs(xr \- round(xr)) \< width/10\) \& (abs(yr \- round(yr)) \< height/10\);
 xrdub \= xr(valid);
 yrdub \= yr(valid);
 xc \= xc(valid);
 yc \= yc(valid);


 xr \= round(xrdub);
 yr \= round(yrdub);

 %if two or more camera points collapse to the same real point, choose the
 %closest to the actual real point
 valid \= true(size(xr));
 for j \= 1:length(xr)
 if (\~valid(j))
 continue
 end
 same \= find((xr((j\+1\):end) \=\= xr(j)) \& (yr((j\+1\):end) \=\= yr(j)));
 if (isempty(same))
 continue
 end
 inds \= \[j same\+j];
 \[\~,I] \= min((xrdub(inds)\-xr(j)).^2 \+ (yrdub(inds)\-yr(j)).^2\);
 valid(inds) \= false;
 valid(inds(I)) \= true;
 end

 xr \= xr(valid);
 yr \= yr(valid);
 xc \= xc(valid);
 yc \= yc(valid);

 %remove points within w,h of the edge
 h \= ceil(height/5\);
 w \= ceil(width/5\);
 sz \= origimsize;
 valid \= floor(xc) \> w \& ceil(xc) \< sz(2\) \- w \& floor(yc) \> h \& ceil(yc) \< sz(1\) \- h;
 xr \= xr(valid);
 yr \= yr(valid);
 xc \= xc(valid);
 yc \= yc(valid);

 %remove points that aren't at the intersection of two checkers
 %{
 \[idx,c] \= kmeans(double(im(:)), 2, 'start', double(\[min(im(:)); max(im(:))]));
 if (c(2\) \> c(1\))
 high \= 2;
 else
 high \= 1;
 end
 bwim \= reshape(idx \=\= high, size(im));
 %}
end

valid \= true(size(xc));
for j \= 1:length(xc)
 
 xim \= interp1(xaxis, 1:length(xaxis), \[xc(j)\-w, xc(j)\+w], 'nearest','extrap');
 yim \= interp1(yaxis, 1:length(yaxis), \[yc(j)\-h, yc(j)\+h], 'nearest','extrap');
 xi \= min(xim):max(xim);
 yi \= min(yim):max(yim);
% xi \= round(xc(j)\-w):round(xc(j)\+w);
% yi \= round(yc(j)\-h):round(yc(j)\+h);
 imdat \= double(im(yi,xi));
 idx \= kmeans(imdat(:), 2,'start',\[min(imdat(:)); max(imdat(:))]);
 % idxmean(j) \= mean(idx);
 valid(j) \= abs(mean(idx)\-1\.5\) \< 0\.1;
end
%figure(1\); clf; plot(idxmean);
%figure(2\); clf; hist(idxmean, 1:0\.01:2\);
%figure(3\); plotColorLine(xc, yc, idxmean);

xr \= xr(valid);
yr \= yr(valid);
xc \= xc(valid);
yc \= yc(valid);



\[xr,I] \= sort(xr, 'ascend');
yr \= yr(I);
xc \= xc(I);
yc \= yc(I);

\[yr,I] \= sort(yr, 'ascend');
xr \= xr(I);
xc \= xc(I);
yc \= yc(I);


 

camx \= xc;
camy \= yc;
realx \= xr;
realy \= yr;
if (flipy)
 realy \= \-realy;
end
if (flipx)
 realx \= \-realx;
end
if (tpose)
 temp \= realy;
 realy \= realx;
 realx \= temp;
end
%{
for j \= 1:length(row)
 row(j).xreal \= round((row(j).xc \- x0\)/width);
 row(j).yreal \= repmat(round((yavg(j)\-y0\) / height),size(row(j).xreal));
end

camx \= \[row.xc];
camy \= \[row.yc];
realx \= \[row.xreal];
realy \= \[row.yreal];
%}
figure(10\); clf(10\); 
imagesc(xaxis, yaxis, double(im)); axis equal; colormap gray(256\); 
hold on
plot (camx, camy, 'r.');
hold off
\[realx, realy, camx, camy] \= guessOutsideHull (realx, realy, camx, camy, \-1:(origimsize(2\) \+ 1\), \-1:(origimsize(1\)\+1\));
realx \= realx \- floor(min(realx));
realy \= realy \- floor(min(realy));
%camx \= camx;
%camy \= camy;

title ('result of checkerboard calibration \-\- red dots should lie on corners');

function \[x,y] \= localmaxima(im, x, y, nsize, maxiters, tol)
%function \[x,y] \= localmaxima(im, x, y, maxiters, tol)
%uses steepest ascent to move to local maxima; 
%this is really only a good idea if you're already close

debug \= false;

existsAndDefault('nsize', 10\);
existsAndDefault('maxiters', 100\);
existsAndDefault('tol', 0\.001\);

xd \= conv2(gaussKernel(nsize), dgausskernel(nsize), im, 'same');
yd \= conv2(dgausskernel(nsize), gaussKernel(nsize), im, 'same');
ds \= sqrt(xd.^2 \+ yd.^2\);
xd \= xd./ds;
yd \= yd./ds;

xx \= 1:size(im,2\);
yy \= 1:size(im,1\);

xnew \= x;
ynew \= y;
nv \= interp2(xx,yy,im,xnew,ynew);
if (debug)
 figure(1\); clf(1\); imagesc(im); 
 hold on
end
for j \= 1:maxiters
 ov \= nv;
 xdd \= interp2(xx,yy,xd,x,y,'\*linear');
 ydd \= interp2(xx,yy,yd,x,y,'\*linear');
 for k \= 1:length(x)
 xline \= x(k) \+ xdd(k)\*(0:0\.01:1\)\*nsize;
 yline \= y(k) \+ ydd(k)\*(0:0\.01:1\)\*nsize;
 valsonline \= interp2(xx,yy,im,xline,yline,'\*linear');
 \[blah,I] \= max(valsonline);
 xnew(k) \= xline(I);
 ynew(k) \= yline(I);
 end
 if (debug)
 for k \= 1:length(x)
 plot (\[x(k) xnew(k)], \[y(k) ynew(k)], 'b\-', 'LineWidth',2\);
 end
 end
 x \= xnew;
 y \= ynew;
 nv \= interp2(xx,yy,im,xnew,ynew);
 if all((nv \- ov)./ov \< tol)
 return
 end
end


 
\-\-\-

\#\#\# File: myharris.m (ID: utility functions.im analysis.8\)

function \[cim, cpts] \= myharris (im, sig)
%function \[cim, cpts] \= myharris (im, sig)
%
%if sigma is a vector, finds corners iteratively, using largest sigma first

sig \= sort(sig, 'descend');

cimbwold \= true(size(im));

for j \= 1:length(sig)
 sigma \= sig(j);

 \[x,y] \= imgradient(im, sigma);
 ix2 \= blurim(x.^2, sigma);
 iy2 \= blurim(y.^2, sigma);
 ixy \= blurim(x.\*y, sigma);

 cim \= (ix2\.\*iy2 \- ixy.^2\)./(ix2 \+ iy2 \+ eps);

 if nargout \<\= 1
 return;
 end

 \[idx,c] \= kmeans(double(cim(:)), 2, 'start', double(\[min(cim(:)); max(cim(:))]));
 if (c(2\) \> c(1\))
 high \= 2;
 else
 high \= 1;
 end
 cimbw \= cimbwold \& reshape(idx \=\= high, size(cim));
 cimbwold \= cimbw;
end
stats \= regionprops(cimbw, abs(cim), 'WeightedCentroid');
pts \= \[stats.WeightedCentroid];
cpts \= \[pts(1:2:end); pts(2:2:end)]; 
\-\-\-

\#\#\# File: springenergy.m (ID: utility functions.im analysis.9\)

function uspr \= springenergy(ctr, closed)
%function ubend \= bendenergy(ctr, closed)
%closed if we should connect contour(:,1\) with contour(:,end)
existsAndDefault('closed', true);
if (closed)
 dx \= 0\.5 \* (diff(ctr(:, \[end 1:end]),\[],2\) \+ diff(ctr(:, \[1:end 1]),\[],2\));
 
else
 dx \= 0\.5 \* (diff(ctr(:, \[1 1:end]),\[],2\) \+ diff(ctr(:, \[1:end end]),\[],2\));
 dx(:,1\) \= diff(ctr(:,\[1 2]),\[],2\);
 dx(:,end) \= diff(ctr(:, \[end\-1 end]),\[],2\);
 end
%dx \= deriv(ctr, sigma, 'padtype', 'circular');
dL \= mean(sqrt(sum(dx.^2\)));
A \= dL.^2; B \= 1/dL;
%uspr \= 0\.5 \* sum(sum(dx.^2\)) \* length(ctr);% \+ sum(1\./sqrt((sum(dx.^2\))));
%uspr \= 0\.5\*A\*sum(sum(dx.^2\)) \+ B\*sum(1\./sqrt((sum(dx.^2\)))) \- length(ctr);
uspr \= 0\.5\*sum(sum(dx.^2\));
\-\-\-

\#\#\# File: lightDirectionFromImage.m (ID: utility functions.im analysis.10\)

function \[gq, pt0, x, y, theta] \= lightDirectionFromImage (rawim, cc, varargin)
% function \[gq, pt0, x, y, theta] \= lightDirectionFromImage (rawim, cc, varargin)
%
% creates a global quantity that tells the direction to the light source at
% any point; given a pin shadow image
% if this breaks or gives bad results, try working through each subfunction
% call
%
% inputs: rawim \- an image of the pins casting shadows
% cc \< CameraCalibration \- camera calibration that converts image to real
% coords
% outputs: gq \- adds field angToLightSource
% pt0 \- the x,y, location of the light source
% x,y,theta the measured location and angles to light source (at
% ends of shadows)

predominantTheta \= 0;
minLen \= 1;
varargin \= assignApplicable(varargin);
\[im,rx,ry] \= cc.morphCamToReal(rawim);
lines \= lineEdgesInImage(im);
for j \= 1:length(lines)
 lines(j).x \= interp1(rx, lines(j).x);
 lines(j).y \= interp1(ry, lines(j).y);
 lines(j).len \= sqrt(diff(lines(j).x).^2 \+ diff(lines(j).y).^2\);
end

\[pt0,x,y,theta] \= lightDirectionFromLines(lines, predominantTheta, minLen);

gq \= GlobalQuantity();
gq.fieldname \= 'angToLightSource';
gq.xField \= 'iloc';
gq.xData \= pt0;
gq.derivationMethod \= @(xin, xData, yData) atan2(xData(2\)\-xin(2,:), xData(1\)\-xin(1,:));

\-\-\-

\#\#\# File: fitLegendrePolynomialToImage.m (ID: utility functions.im analysis.11\)

function \[x, c, ctr] \= fitLegendrePolynomialToImage (im, n)
%c \= fitLegendrePolynomialToImage (im, n)
im \= double(im);
t \= linspace(0,2\*pi,100\);
p \= zeros(n,length(t));
for j \= 1:n
 P \= legendre(j\-1,cos(t/2\));
 p(j,:) \= P(1,:);
end
c \= zeros(1, n);
xx \= repmat(1:size(im,2\), size(im,1\), 1\);
yy \= repmat((1:size(im,1\))', 1, size(im,2\));
x \= \[sum(xx(:).\*im(:)) sum(yy(:).\*im(:))]/sum(im(:));
c(1\) \= 2\*sqrt((sum((xx(:)\-x(1\)).^2\.\*im(:))\+ sum((yy(:)\-x(2\)).^2\.\*im(:)))/sum(im(:)));
c(2:end) \= c(1\)\*0\.1;
x0 \= \[x c];
myfun \= @(q) energyfun(q, im, p, t);
myfun(x0\)
x1 \= fminsearch(myfun, x0\);
x \= x1(1:2\);
c \= x1(3:end);
\[ctrx,ctry] \= lpToCtr(x,c,p,t);
ctr \= \[ctrx;ctry];
 
end

function en \= energyfun (q, im, p, t)
 \[ctrx,ctry] \= lpToCtr(q(1:2\), q(3:end), p, t);
 en \= energyInContour(im, ctrx, ctry);
end 
 
function \[ctrx,ctry] \= lpToCtr(x,c,p,t)
 r \= c\*p;
 ctrx \= x(1\) \+ r.\*cos(t);
 ctry \= x(2\) \+ r.\*sin(t);
end

function en \= energyInContour (im, ctrx,ctry)
 % bwim \= traceBoundarySubPixel(\[ctrx;ctry],\[1 1], size(im));

 % en \= sum((im(:) \- mean(im(:).\*bwim(:))).^2\.\*bwim(:)) ...
 % \+ sum((im(:) \- mean(im(:).\*(1\-bwim(:)))).^2\.\*(1\-bwim(:)));
% imagesc(bwim); axis equal; colorbar vert; pause(0\.01\);

bwim \= poly2mask(ctrx, ctry, size(im,1\), size(im,2\));
 imagesc(bwim); axis equal; colorbar vert; pause(0\.01\);
en \= sum((im(bwim)\-mean(im(bwim))).^2\) \+ sum((im(\~bwim) \- mean(im(\~bwim))).^2\); 

end
\-\-\-

\#\#\# File: marcsnake\_old.m (ID: utility functions.im analysis.12\)

function newctr \= marcsnake (alpha, beta, imxaxis, imyaxis, energyim, sigmas, oldctr)
%function newctr \= marcsnake (alpha, beta, imxaxis, imyaxis, energyim, sigmas, oldctr)
%
%works to minimize the energy of the contour \= alpha(dx^2\) \+ beta ddx^2 \+
%energyim(ctr)
%
%if sigmas is a vector, then we do successive minimizations with energyim
%blurred by sigmas(1\), then sigmas(2\), etc.
%
%oldctr is the starting position. the contour is assumed to be closed
%(derivatives are circular)
%
%ctr should be 2xNpts long

existsAndDefault('sigmas', 1\);
existsAndDefault('imxaxis', 1:size(energyim, 2\));
existsAndDefault('imyaxis', 1:size(energyim, 1\));
if (length(sigmas) \> 1\)
 newctr \= oldctr;
 for j \= 1:length(sigmas)
 newctr \= marcsnake(alpha, beta, imxaxis, imyaxis, energyim, sigmas, oldctr);
 end
 return;
end
sigma \= sigmas(1\);

energyim \= double(energyim);
\[dxim, dyim] \= imgradient(energyim, sigma);
energyim \= blurim(energyim, sigma);
dx \= diff(imxaxis(1:2\)); dy \= diff(imyaxis(1:2\));
dxim \= dxim./dx;
dyim \= dyim./dy;
energyfn \= @(x) snakeEnergy(x, alpha, beta, imxaxis, imyaxis, energyim);
gradfn \= @(x) gradEnergy(x, alpha, beta, imxaxis, imyaxis, dxim, dyim);

\[oldu, oldspr, oldbend, oldpot] \= snakeEnergy(oldctr, alpha, beta, imxaxis, imyaxis, energyim)
\[gx, gspr, gbend, gpot] \= gradEnergy(oldctr, alpha, beta, imxaxis, imyaxis, dxim, dyim);
plot(1:length(gx), gx(1,:), 1:length(gspr), gspr(1,:), 1:length(gbend), gbend(1,:), 1:length(gpot), gpot(1,:));
max(sum(gbend.^2\))
legend ('xd', 'spr', 'bend', 'pot')
return
gnorm \= sqrt(max(sum(\[gspr.^2 gbend.^2 gpot.^2], 2\)))\*5 / sqrt(diff(imxaxis(\[1 end])).^2 \+ diff(imyaxis(\[1 end])).^2\);
figure(1\); clf();
pcolor(imxaxis, imyaxis, energyim); colormap gray; shading interp; hold on;
plot (oldctr(1,:), oldctr(2,:), 'r\-','LineWidth',2\); hold on;
quiver(oldctr(1,:), oldctr(2,:), \-gx(1,:)./gnorm,\-gx(2,:)./gnorm, 0,'r');
quiver(oldctr(1,:), oldctr(2,:), \-gspr(1,:)./gnorm,\-gspr(2,:)./gnorm, 0,'g');
quiver(oldctr(1,:), oldctr(2,:), \-gbend(1,:)./gnorm,\-gbend(2,:)./gnorm, 0,'c');
quiver(oldctr(1,:), oldctr(2,:), \-gpot(1,:)./gnorm,\-gpot(2,:)./gnorm,0,'y');
hold off

newctr \= conjugateGradient(energyfn, gradfn, oldctr, 'maxiter', 1000\);
figure(2\); clf();
\[newu, newspr, newbend, newpot] \= snakeEnergy(newctr, alpha, beta, imxaxis, imyaxis, energyim)
\[gx, gspr, gbend, gpot] \= gradEnergy(newctr, alpha, beta, imxaxis, imyaxis, dxim, dyim);

gnorm \= sqrt(max(sum(\[gspr.^2 gbend.^2 gpot.^2], 2\)))\*5 / sqrt(diff(imxaxis(\[1 end])).^2 \+ diff(imyaxis(\[1 end])).^2\);
pcolor(imxaxis, imyaxis, energyim); colormap gray; shading interp; hold on;
plot (newctr(1,:), newctr(2,:), 'r\-','LineWidth',2\); hold on;
quiver(newctr(1,:), newctr(2,:), \-gx(1,:)./gnorm,\-gx(2,:)./gnorm, 0,'r');
quiver(newctr(1,:), newctr(2,:), \-gspr(1,:)./gnorm,\-gspr(2,:)./gnorm, 0,'g');
quiver(newctr(1,:), newctr(2,:), \-gbend(1,:)./gnorm,\-gbend(2,:)./gnorm, 0,'c');
quiver(newctr(1,:), newctr(2,:), \-gpot(1,:)./gnorm,\-gpot(2,:)./gnorm,0,'y');
hold off
newu \- oldu

function \[u,uspr,ubend,upot] \= snakeEnergy(ctr, alpha, beta, imxaxis, imyaxis, im)

n \= length(ctr);
dx \= diff(ctr(:, \[end 1:end]),\[],2\);
dl \= sqrt(sum(dx.^2\));
L \= sum(dl);

ddx \= diff(ctr(:, \[end\-1:end 1:end]), 2, 2\);

if (false)
 uspr \= 1/n\*alpha/2\*sum(sum(dx.^2\)/dL^2\);
 ubend \= 1/n\*beta/2\*sum(sum(ddx.^2\)/dL^4\);
 upot \= sum(1/n\*interp2(imxaxis, imyaxis, im, ctr(1,:), ctr(2,:), '\*linear', 100\*max(abs(im(:)))));
else
 uspr \= L\*alpha/2;
 %uspr \= 1/n\*alpha/2\*sum(sum(dx.^2\)/dL^2\);
 that \= dx./\[dl;dl];
 cs \= sum((diff(that(:,\[end 1:end]), \[],2\)).^2\)./(dl.^2\); %curvature squared
 ubend \= beta\*sum(cs.\*dl);
 %ubend \= beta/2\*sum(sum(ddx.^2\)./(dl.^3\));
 upot \= sum(dl.\*interp2(imxaxis, imyaxis, im, ctr(1,:), ctr(2,:), '\*linear', 100\*max(abs(im(:)))));
end
u \= uspr \+ ubend \+ upot;

function \[dx, gspr, gbend, gpot] \= gradEnergy(ctr, alpha, beta, imxaxis, imyaxis, xderivim, yderivim)
n \= length(ctr);
dx \= diff(ctr(:, \[end 1:end]),\[],2\);
dl \= sqrt(sum(dx.^2\));
dL \= sum(dl)/n;
dll \= \[dl;dl];
ddx \= diff(ctr(:, \[end 1:end 1]), 2, 2\);
d4x \= diff(ctr(:, \[end\-1:end 1:end 1:2]), 4, 2\);
if (true)
 gspr \= \-alpha\*ddx/(dL.^2\);%./(dll.^2\);
 gbend \= beta\*d4x/(dL.^4\);%./(dll.^4\);
 fx \= interp2(imxaxis, imyaxis, xderivim, ctr(1,:), ctr(2,:), '\*linear', NaN);
 fy \= interp2(imxaxis, imyaxis, yderivim, ctr(1,:), ctr(2,:), '\*linear', NaN);
else
 gspr \= \-alpha\*ddx./(dll.^2\);
 gbend \= beta\*d4x./(dll.^4\);
 fx \= interp2(imxaxis, imyaxis, xderivim, ctr(1,:), ctr(2,:), '\*linear', NaN);
 fy \= interp2(imxaxis, imyaxis, yderivim, ctr(1,:), ctr(2,:), '\*linear', NaN);
end
%nnz(\~isfinite(fx))
fx(\~isfinite(fx)) \= mean(ctr(1,:)) \- fx(\~isfinite(fx));
fy(\~isfinite(fy)) \= mean(ctr(2,:)) \- fy(\~isfinite(fy));
gpot \= \[fx;fy];
dx \= gspr\+gbend \+gpot;
\-\-\-

\#\#\# File: gradconstforceenergy.m (ID: utility functions.im analysis.13\)

function gconst \= gradconstforceenergy(ctr, closed)
%function ubend \= bendenergy(ctr, closed)
%closed if we should connect contour(:,1\) with contour(:,end)
existsAndDefault('closed', true);
if (closed)
 dxr \= diff(ctr(:, \[end 1:end]), \[], 2\); % (x\_j \- x\_(j\-1\))
 dxf \= diff(ctr(:, \[1:end 1]), \[], 2\); % x\_j\+1 \- x\_j
else
 dxr \= diff(ctr(:, \[1 1:end]), \[], 2\); % (x\_j \- x\_(j\-1\))
 dxf \= diff(ctr(:, \[1:end end]), \[], 2\); % x\_j\+1 \- x\_j
end
%dx \= deriv(ctr, sigma, 'padtype', 'circular');

dxfl \= sqrt(sum(dxf.^2\));
dxrl \= sqrt(sum(dxr.^2\));
dxfl(dxfl \=\= 0\) \= 1;
dxrl(dxrl \=\= 0\) \= 1;

gconst \= \-dxf./\[dxfl;dxfl]\+dxr./\[dxrl;dxrl];
\-\-\-

\#\#\# File: analyzeCheckerIm.m (ID: utility functions.im analysis.14\)

function analyzedIms \= analyzeCheckerIm(checkim, bordersize, cornersize)
%function analyzedIms \= analyzeCheckerIm(checkim, bordersize, cornersize)

%first we need to create a bw checkerboard \-\- let's autosegment using
%k\-means

existsAndDefault('cornersize', bordersize);

\[idx,c] \= kmeans(double(checkim(:)), 2, 'start', double(\[min(checkim(:)); max(checkim(:))]));
if (c(2\) \> c(1\))
 high \= 2;
else
 high \= 1;
end
analyzedIms.bwim \= imclose(reshape(idx \=\= high, size(checkim)),ones(5\));

analyzedIms.distToLight \= bwdist(analyzedIms.bwim);
analyzedIms.distToDark \= bwdist(\~analyzedIms.bwim);
analyzedIms.distToBorder \= \-analyzedIms.distToLight \+ analyzedIms.distToDark;

\[xd,yd] \= imgradient(analyzedIms.distToBorder, 3\);
%{
mag \= sqrt(xd.^2 \+ yd.^2\);
xd \= xd./mag;
yd \= yd./mag;
%}

analyzedIms.dirToBorder \= atan2(yd,xd);

\[cim, cpts] \= myharris(analyzedIms.bwim,3\);
analyzedIms.cornerMetric \= cim;
analyzedIms.cornerLocations \= cpts;

cpts \= max(round(cpts), 1\);
cpts(1,:) \= min(cpts(1,:), size(checkim, 2\));
cpts(2,:) \= min(cpts(2,:), size(checkim, 1\));

cim \= false(size(checkim));
tinds \= sub2ind(size(checkim), cpts(2,:), cpts(1,:));
cim(tinds) \= true;
onborder \= abs(analyzedIms.distToBorder) \<\= 1;


%detect lines to determine most likely border orientations
\[h,theta] \= hough(onborder);

%by squaring the hough transform, we emphasize points of high concentration
\[\~,I] \= sort(sum(h.^2\), 'descend');
theta \= theta(I);
thetam \= theta(1\);

%make structuring elements to dilate corner region in an X \- shape

semaj1 \= strel('line', 2\*cornersize, thetam \+ 45\);
semin1 \= strel('line', ceil(cornersize/2\), thetam \- 45\);

semaj2 \= strel('line', 2\*cornersize, thetam \- 45\);
semin2 \= strel('line', ceil(cornersize/2\), thetam \+ 45\);

cim1 \= imdilate(imdilate(cim, semaj1\), semin1\);
cim2 \= imdilate(imdilate(cim, semaj2\), semin2\);

cim \= imclose(cim1 \| cim2, ones(round(cornersize/2\)));

%use morphological operations to find border \& corner without assumptions
%about orientation of checkerboard

%se \= strel('disk', ceil(bordersize/2\), 0\);

%onborder \= imclose(imdilate(onborder,se),ones(5\));
%onborder \= imerode(imdilate(onborder,se),

onborder \= abs(blurim(analyzedIms.distToBorder,3\)) \< bordersize/2;

analyzedIms.border \= onborder \&\~ cim;
analyzedIms.oncorner \= cim \& onborder;
analyzedIms.interior \= \~(analyzedIms.border \| analyzedIms.oncorner);


end


\-\-\-

\#\#\# File: bendenergy.m (ID: utility functions.im analysis.15\)

function ubend \= bendenergy(ctr, closed)
%function ubend \= bendenergy(ctr, closed)
%closed if we should connect contour(:,1\) with contour(:,end)
existsAndDefault('closed', true);
if (closed)
 dx \= 0\.5 \* (diff(ctr(:, \[end 1:end]),\[],2\) \+ diff(ctr(:, \[1:end 1]),\[],2\));
 ddx \= diff(ctr(:, \[end 1:end 1]), 2, 2\);
 dl \= sqrt(sum(dx.^2\));
 that \= dx./\[dl;dl];
 dthat \= 0\.5 \* (diff(that(:, \[end 1:end]),\[],2\) \+ diff(that(:, \[1:end 1]),\[],2\));
else
 dx \= 0\.5 \* (diff(ctr(:, \[1 1:end]),\[],2\) \+ diff(ctr(:, \[1:end end]),\[],2\));
 dx(:,1\) \= diff(ctr(:,\[1 2]),\[],2\);
 dx(:,end) \= diff(ctr(:, \[end\-1 end]),\[],2\);
 ddx \= \[\[0;0] diff(ctr, 2, 2\) \[0;0]];
 dl \= sqrt(sum(dx.^2\));
 that \= dx./\[dl;dl];
 dthat \= 0\.5 \* (diff(that(:, \[1 1:end]),\[],2\) \+ diff(that(:, \[1:end end]),\[],2\));
 dthat(:,1\) \= diff(that(:,\[1 2]),\[],2\);
 dthat(:,end) \= diff(that(:, \[end\-1 end]),\[],2\);
 
end
%dx \= deriv(ctr, sigma, 'padtype', 'circular');
dl \= sqrt(sum(dx.^2\));
ds \= dl/sum(dl);
%figure(1\); 
%plot (1:length(ctr), sum(ddx.^2\)/max(sum(ddx.^2\)), 1:length(ctr), dl./max(dl))
%cs \= sum((ddx.^2\))./dl.^3;%./(dl.^2\));
%figure(2\);
%plotColorLine (ctr(1,:), ctr(2,:), cs, jet);
cs \= sum((dthat./\[dl;dl])).^2;

ubend \= 0\.5\*sum(cs.\*ds);
%ubend \= 0\.5\*sum(sum(ddx.^2\));
\-\-\-

\#\#\# File: generateGradientImageForPhototaxis.m (ID: utility functions.im analysis.16\)

function gradientImage \= generateGradientImageForPhototaxis(x1, x2, cc, borderSizeInCm, gradstyle, varargin)
%function gradientImage \= generateGradientImageForPhototaxis(plateIm, cc, borderSizeInCm, gradstyle, varargin)

existsAndDefault('borderSizeInCm' , 0\);
existsAndDefault('gradstyle', 'linear');

rx \= linspace(min(cc.realx), max(cc.realx), 1280\);
ry \= linspace(min(cc.realy), max(cc.realy), 800\);

x0 \= (min(x1(1\),x2(1\)));
w \= (max(x2(1\),x1(1\))) \- x0;
switch lower(gradstyle)
 case {'linear', 'lin'}
 gx \= 255\*(rx \- x0\)/w; 
 %gx(gx \> 255\) \= 0;
 case {'exponential', 'exp'}
 gx \= 255\.^((rx \- x0\)/w);
 %gx(gx \> 255\) \= 0;
 case {'power', 'pow'}
 p \= varargin{1};
 gx \= 255\*(((rx \- x0\)/w).^p);
 %gx(gx \> 255\) \= 0;
 otherwise
 disp('allowed styles are linear, exponenential, power ');
 gradientImage \= \[];
 return;
end
gi \= repmat(gx, \[length(ry) 1]);
%inds \= find(ry\-ry(1\) \< borderSizeInCm);
gi((ry\-ry(1\) \< borderSizeInCm),:) \= 255;
%inds \= find(ry(end) \- ry \< borderSizeInCm);
gi((ry(end) \- ry \< borderSizeInCm), :) \= 255;

gradientImage \= cc.morphRealToCam(gi, rx, ry, 'camxaxis', min(cc.camx):max(cc.camx), 'camyaxis', min(cc.camy):max(cc.camy));
%gradientImage \= morphImage2(gi, rx, ry, cc.camx, cc.camy, cc.realx, cc.realy, min(cc.camx):max(cc.camx), min(cc.camy):max(cc.camy));
gradientImage(gradientImage \> 255\) \= 0;
gradientImage(gradientImage \< 0\) \= 0;
gradientImage \= uint8(gradientImage);
image(gradientImage); colormap gray(256\);
title (gradstyle);
pause(0\.1\);
\-\-\-

\#\#\# File: gradchargeenergy.m (ID: utility functions.im analysis.17\)

function gcharge \= gradchargeenergy(ctr, closed)
%function ubend \= bendenergy(ctr, closed)
%closed if we should connect contour(:,1\) with contour(:,end)
existsAndDefault('closed', true);
if (closed)
 dxr \= diff(ctr(:, \[end 1:end]), \[], 2\); % (x\_j \- x\_(j\-1\))
 dxf \= diff(ctr(:, \[1:end 1]), \[], 2\); % x\_j\+1 \- x\_j
else
 dxr \= diff(ctr(:, \[1 1:end]), \[], 2\); % (x\_j \- x\_(j\-1\))
 dxf \= diff(ctr(:, \[1:end end]), \[], 2\); % x\_j\+1 \- x\_j
end
%dx \= deriv(ctr, sigma, 'padtype', 'circular');

dxfl3 \= (sum(dxf.^2\)).^(1\.5\);
dxrl3 \= (sum(dxr.^2\)).^(1\.5\);
dxfl3(dxfl3 \=\= 0\) \= 1;
dxrl3(dxrl3 \=\= 0\) \= 1;

gcharge \= (\-dxf./\[dxfl3;dxfl3]\-\+dxr./\[dxrl3;dxrl3]);
\-\-\-

\#\#\# File: marcsnake.m (ID: utility functions.im analysis.18\)

function \[newctr, newctri] \= marcsnake (alpha, beta, energyim, sigmas, oldctr)
%function newctr \= marcsnake (alpha, beta, energyim, sigmas, oldctr)
%
%works to minimize the energy of the contour \= alpha(dx^2\) \+ beta ddx^2 \+
%energyim(ctr)
%
%if sigmas is a vector, then we do successive minimizations with energyim
%blurred by sigmas(1\), then sigmas(2\), etc.
%
%oldctr is the starting position. the contour is assumed to be closed
%(derivatives are circular)
%
%ctr should be 2xNpts long

if (exist('sigmas', 'var') \&\& length(sigmas) \> 1\)
 newctr \= oldctr;
 for j \= 1:length(sigmas)
 newctr \= marcsnake(alpha, beta, energyim, sigmas(j), newctr);
 % pause
 end
 return;
end

existsAndDefault('sigmas', 1\);
sigma \= sigmas(1\);

energyim \= double(energyim);
\[dxim, dyim] \= imgradient(energyim, sigma);
energyim \= blurim(energyim, sigma);

energyfn \= @(x) snakeEnergy(x, alpha, beta, energyim, sigma);
gradfn \= @(x) gradEnergy(x, alpha, beta, dxim, dyim, sigma);

\[oldu, oldspr, oldbend, oldpot] \= snakeEnergy(oldctr, alpha, beta, energyim, sigma);
\[gx, gspr, gbend, gpot] \= gradEnergy(oldctr, alpha, beta, dxim, dyim, sigma);
figure(3\); clf();
plot(1:length(gx), gx(1,:), 1:length(gspr), gspr(1,:), 1:length(gbend), gbend(1,:), 1:length(gpot), gpot(1,:), 1:length(beta), beta);
max(sum(gbend.^2\))
legend ('xd', 'spr', 'bend', 'pot', 'beta')

gnorm \= sqrt(max(sum(\[gspr.^2 gbend.^2 gpot.^2], 2\)))\*5 / sqrt(sum(size(energyim).^2\));
figure(1\); clf();
pcolor(energyim); colormap gray; shading interp; hold on;
plot (oldctr(1,:), oldctr(2,:), 'r\-','LineWidth',2\); hold on;
quiver(oldctr(1,:), oldctr(2,:), \-gx(1,:)./gnorm,\-gx(2,:)./gnorm, 0,'r');
quiver(oldctr(1,:), oldctr(2,:), \-gspr(1,:)./gnorm,\-gspr(2,:)./gnorm, 0,'g');
quiver(oldctr(1,:), oldctr(2,:), \-gbend(1,:)./gnorm,\-gbend(2,:)./gnorm, 0,'c');
quiver(oldctr(1,:), oldctr(2,:), \-gpot(1,:)./gnorm,\-gpot(2,:)./gnorm,0,'y');
hold off

newctr \= conjugateGradientResampleContour(energyfn, gradfn, oldctr, 'maxiter', 1000, 'ftol', 1E\-12\); 
%{
perturb \= 0\.5\*\[cos(linspace(0,5\*pi,length(newctr)));sin(linspace(0,5\*pi,length(newctr)))];
newctr \= conjugateGradient(energyfn, gradfn, newctr\+perturb, 'maxiter', 1000, 'ftol', 1E\-16\);
%}
figure(2\); clf();
\[newu, newspr, newbend, newpot] \= snakeEnergy(newctr, alpha, beta, energyim, sigma);
\[gx, gspr, gbend, gpot] \= gradEnergy(newctr, alpha, beta, dxim, dyim, sigma);

%gnorm \= sqrt(max(sum(\[gspr.^2 gbend.^2 gpot.^2], 2\)))\*5 / sqrt(sum(size(energyim).^2\));
pcolor(energyim); colormap gray; shading interp; hold on;
plot (newctr(1,:), newctr(2,:), 'r.\-','LineWidth',2,'MarkerSize',30\); hold on;
quiver(newctr(1,:), newctr(2,:), \-gx(1,:)./gnorm,\-gx(2,:)./gnorm, 0,'r');
quiver(newctr(1,:), newctr(2,:), \-gspr(1,:)./gnorm,\-gspr(2,:)./gnorm, 0,'g');
quiver(newctr(1,:), newctr(2,:), \-gbend(1,:)./gnorm,\-gbend(2,:)./gnorm, 0,'c');
quiver(newctr(1,:), newctr(2,:), \-gpot(1,:)./gnorm,\-gpot(2,:)./gnorm,0,'y');
legend('im', 'ctr', 'grad', 'spr', 'bend', 'pot')
hold off
figure(4\); clf();
plot(1:length(gx), gx(1,:), 1:length(gspr), gspr(1,:), 1:length(gbend), gbend(1,:), 1:length(gpot), gpot(1,:));
figure(5\);
plot(newctr(1,:), newctr(2,:), newctr(1,:)\-10\*gx(1,:), newctr(2,:)\-10\*gx(2,:));
energyfn(newctr)
dval \= linspace(\-1, 1, 100\);
for j \= 1:length(dval)
 \[u, uspr, ubend, upot] \= snakeEnergy(newctr\+dval(j)\*gx, alpha, beta, energyim, sigma);
 uu(j) \= u;
 uuspr(j) \= uspr;
 uubend(j) \= ubend;
 uupot(j) \= upot;
 
end
figure(6\);
 plot (dval, uu\-newu, dval, uuspr\-newspr, dval, uubend\-newbend, dval, uupot\-newpot); 
 legend ('u', 'uspr', 'ubend', 'upot');
newu \- oldu

function \[u,uspr,ubend,upot] \= snakeEnergy(ctr, alpha, beta, im, sigma)
upot \= potenergy(ctr, im);
uspr \= springenergy(ctr)\*alpha;
ubend \=bendenergy(ctr)\*beta;
u \= uspr \+ ubend \+ upot;
return;

n \= length(ctr);
%dx \= diff(ctr(:, \[end 1:end]),\[],2\);
dx \= deriv(ctr, sigma, 'padtype', 'circular');
dl \= sqrt(sum(dx.^2\));
L \= sum(dl);
uspr \= L\*alpha\*sum(1\./dl)/(n^2\);
that \= dx./\[dl;dl];
%cs \= sum((diff(that(:,\[end 1:end]), \[],2\)).^2\)./(dl.^2\); %curvature squared
cs \= sum(deriv(that, sigma, 'padtype', 'circular').^2\)./(dl.^2\);
ubend \= sum(beta.\*cs)\*L/n;
upot \= sum((dl/L).\*interp2(im, ctr(1,:), ctr(2,:), '\*linear', 100\*max(abs(im(:)))));
u \= uspr \+ ubend \+ upot;

function \[dx, gspr, gbend, gpot] \= gradEnergy(ctr, alpha, beta, xderivim, yderivim, sigma)
gpot \= gradpotenergy(ctr, xderivim, yderivim);
gspr \= gradspringenergy(ctr)\*alpha;
gbend \= gradbendenergy(ctr)\*beta;

dx \= gspr\+gbend \+gpot;
magdx \= sqrt(sum(sum(dx.^2\))) \+ eps;
gpot \= gpot/magdx;
gspr \= gspr/magdx;
gbend \= gbend/magdx;
dx \= dx/magdx;

return;

n \= length(ctr);
%dx \= diff(ctr(:, \[end 1:end]),\[],2\);
dx \= deriv(ctr, sigma, 'padtype', 'circular');
dl \= sqrt(sum(dx.^2\));
L \= sum(dl);
dll \= \[dl;dl];
%{
L \= sum(dl);
dL \= sum(dl)/n;
dll \= \[dl;dl];
ddx \= diff(ctr(:, \[end 1:end 1]), 2, 2\);
d4x \= diff(ctr(:, \[end\-1:end 1:end 1:2]), 4, 2\);
%}
d4x \= dx;
for j \= 1:3
 d4x \= deriv(d4x, sigma, 'padtype', 'circular');
end
dx1 \= dx./(\[dl.^3;dl.^3]);
gspr \= alpha \* deriv(dx1, sigma, 'padtype', 'circular');
%{
dx1 \= \-dx./(\[dl.^3;dl.^3]);
dx2 \= \-dx1(:,\[2:end 1]);
gspr \= alpha \* (dx1 \+ dx2\);
%}
gbend \= \-L\*\[beta.\*d4x(1,:);beta.\*d4x(2,:)]./(dll.^4\);%./(dll.^4\);

fx \= interp2(xderivim, ctr(1,:), ctr(2,:), '\*linear', NaN);
fy \= interp2(yderivim, ctr(1,:), ctr(2,:), '\*linear', NaN);

%nnz(\~isfinite(fx))
fx(\~isfinite(fx)) \= mean(ctr(1,:)) \- fx(\~isfinite(fx));
fy(\~isfinite(fy)) \= mean(ctr(2,:)) \- fy(\~isfinite(fy));
gpot \= \[fx;fy];
dx \= gspr\+gbend \+gpot;
\-\-\-

\#\#\# File: gradbendenergy.m (ID: utility functions.im analysis.19\)

function gb \= gradbendenergy(ctr,closed)
existsAndDefault('closed', true);
if (closed)
 dx \= 0\.5 \* (diff(ctr(:, \[end 1:end]),\[],2\) \+ diff(ctr(:, \[1:end 1]),\[],2\));
 d4x \= diff(ctr(:, \[end\-1:end 1:end 1:2]), 4, 2\);
else 
 % ctr \= ctr(:, \[1 1 1:end end end]);
 % ctr \= \[2\*ctr(:,\[1 1])\-ctr(:,\[3 2]), ctr, 2\*ctr(:, \[end end])\-ctr(:, \[end\-1 end\-2])]; 
 firstpoint \= ctr(:,3\) \+ 4\*(ctr(:,3\)\-ctr(:,4\));
 secondpoint \= 1/2 \* (firstpoint \+ ctr(:,1\));
 lastpoint \= ctr(:,end\-2\) \+ 4\*(ctr(:,end\-2\) \- ctr(:,end\-3\));
 secondtolastpoint \= 1/2\*(lastpoint \+ ctr(:,end));
% ctr \= \[interp1(ctr', \[\-1 0], 'spline', 'extrap')', ctr, interp1(ctr', \[length(ctr) \+ (1:2\)], 'spline', 'extrap')'];
 newctr \= \[firstpoint secondpoint ctr secondtolastpoint lastpoint];
 dx \= 0\.5 \* (diff(newctr(:, 2:(end\-2\)),\[],2\) \+ diff(newctr(:, 3:(end\-1\)),\[],2\));
 d4x \= diff(newctr, 4, 2\); 
 
 %make forces at the end perpendicular to tangent
 that \= diff(ctr(:,\[1 2]),\[],2\); that \= that./sqrt(sum(that.^2\));
 % whos that
 % size(sum(that.\*d4x(:,1\)))
 d4x(:,1\) \= d4x(:,1\) \- that\*sum(that.\*d4x(:,1\));
 that \= diff(ctr(:,\[2 3]),\[],2\); that \= that./sqrt(sum(that.^2\));
 d4x(:,2\) \= d4x(:,2\) \- that\*sum(that.\*d4x(:,2\));
 that \= diff(ctr(:,\[end\-1 end]),\[],2\); that \= that./sqrt(sum(that.^2\));
 d4x(:,end) \= d4x(:,end) \- that\*sum(that.\*d4x(:,end));
 that \= diff(ctr(:,\[end\-2 end\-1]),\[],2\); that \= that./sqrt(sum(that.^2\));
 d4x(:,end\-1\) \= d4x(:,end\-1\) \- that\*sum(that.\*d4x(:,end\-1\));

end
dl \= sqrt(sum(dx.^2\));
denom \= \[sum(dx.^2\);sum(dx.^2\)].^(1\.5\);
ds \= dl/sum(dl) \+ eps;
%plot (ds); hold all
%plot (d4x')
%gb \= d4x./(\[ds;ds].^2\);
gb \= d4x./denom.\*\[ds;ds];

\-\-\-

\#\#\# File: gradpotenergy.m (ID: utility functions.im analysis.20\)

function gpot \= gradpotenergy (ctr, xderivim, yderivim)
%function gradpotenergy (ctr, xderivim, yderivim)
%interpolates along contour to find x derivatives and y derivatives. 
%if any part of contour is out of the image, gpot directs that point back
%towards the contour center

fx \= interp2(xderivim, ctr(1,:), ctr(2,:), '\*linear', NaN);
fy \= interp2(yderivim, ctr(1,:), ctr(2,:), '\*linear', NaN);

%nnz(\~isfinite(fx))
fx(\~isfinite(fx)) \= mean(ctr(1,:)) \- fx(\~isfinite(fx));
fy(\~isfinite(fy)) \= mean(ctr(2,:)) \- fy(\~isfinite(fy));
gpot \= \[fx;fy];
\-\-\-

\#\#\# File: gradspringenergy.m (ID: utility functions.im analysis.21\)

function gspr \= gradspringenergy(ctr, closed)
%function ubend \= bendenergy(ctr, closed)
%closed if we should connect contour(:,1\) with contour(:,end)
existsAndDefault('closed', true);
if (closed)
 dxr \= diff(ctr(:, \[end 1:end]), \[], 2\); % (x\_j \- x\_(j\-1\))
 dxf \= diff(ctr(:, \[1:end 1]), \[], 2\); % x\_j\+1 \- x\_j
 dx \= 0\.5 \* (dxr \+ dxf);
 % dx \= 0\.5 \* (diff(ctr(:, \[end 1:end]),\[],2\) \+ diff(ctr(:, \[1:end 1]),\[],2\));
 ddx \= diff(ctr(:, \[end 1:end 1]), 2, 2\);
else
 dxr \= diff(ctr(:, \[1 1:end]), \[], 2\); % (x\_j \- x\_(j\-1\))
 dxf \= diff(ctr(:, \[1:end end]), \[], 2\); % x\_j\+1 \- x\_j
 dx \= 0\.5 \* (dxr \+ dxf);
 % dx \= 0\.5 \* (diff(ctr(:, \[1 1:end]),\[],2\) \+ diff(ctr(:, \[1:end end]),\[],2\));
 dx(:,1\) \= diff(ctr(:,\[1 2]),\[],2\);
 dx(:,end) \= diff(ctr(:, \[end\-1 end]),\[],2\);
 ddx \= 0\.5 \* (diff(dx(:, \[1 1:end]),\[],2\) \+ diff(dx(:, \[1:end end]),\[],2\));

end
%dx \= deriv(ctr, sigma, 'padtype', 'circular');
dxfl3 \= (sum(dxf.^2\)).^(1\.5\);
dxrl3 \= (sum(dxr.^2\)).^(1\.5\);
gspr \= \-ddx;% \* length(ctr);% \+ dxf./\[dxfl3;dxfl3]\-dxr./\[dxrl3;dxrl3];
\-\-\-

\#\#\# File: fitFourierToImage.m (ID: utility functions.im analysis.22\)

function \[x, c, ctr] \= fitFourierToImage (im, n, x0\)
%c \= fitLegendrePolynomialToImage (im, n)
im \= double(im);
t \= linspace(0,2\*pi,100\);
p \= zeros(2\*n\+1,length(t));
p(1,:) \= 1;
for j \= 1:n
% P \= legendre(j\-1,cos(t/2\)); 
 p(2\*j,:) \= cos(j\*t);
 p(2\*j\+1,:) \= sin(j\*t);
end
op \= optimset('fminunc');
op.DiffMinChange \= 0\.25;
op.Display \= 'off';
op.LargeScale \= 'off';
if (nargin \< 3\)
 c \= zeros(1, 2\*n\+1\);
 xx \= repmat(1:size(im,2\), size(im,1\), 1\);
 yy \= repmat((1:size(im,1\))', 1, size(im,2\));
 x \= \[sum(xx(:).\*im(:)) sum(yy(:).\*im(:))]/sum(im(:));
 c(1\) \= sqrt((sum((xx(:)\-x(1\)).^2\.\*im(:))\+ sum((yy(:)\-x(2\)).^2\.\*im(:)))/sum(im(:)));
 c(2:end) \= c(1\)\*0\.1\*randn(size(c(2:end)));%c(1\)\*0\.1;
 x0 \= \[x c];
 
 for s \= \[min(size(im))/6, min(size(im))/12, 1, 0\.1]
 myfun \= @(q) energyfun(q, blurim(im,s), p, t);
 x0 \= fminunc(myfun, x0,op);
 end
end
scale \= 3;
im2 \= imresize(im,scale);
myfun \= @(q) energyfun(q, im2, p, t);
x1 \= fminunc(myfun, x0\*scale,op);
x \= x1(1:2\)/scale;
c \= x1(3:end)/scale;
\[ctrx,ctry] \= lpToCtr(x,c,p,t);
ctr \= \[ctrx;ctry]; 
end

function en \= energyfun (q, im, p, t)
 \[ctrx,ctry] \= lpToCtr(q(1:2\), q(3:end), p, t);
 en \= energyInContour(im, ctrx, ctry);
end 
 
function \[ctrx,ctry] \= lpToCtr(x,c,p,t)
 r \= c\*p;
 ctrx \= x(1\) \+ r.\*cos(t);
 ctry \= x(2\) \+ r.\*sin(t);
end

function en \= energyInContour (im, ctrx,ctry)
 % bwim \= traceBoundarySubPixel(\[ctrx;ctry],\[1 1], size(im));

 % en \= sum((im(:) \- mean(im(:).\*bwim(:))).^2\.\*bwim(:)) ...
 % \+ sum((im(:) \- mean(im(:).\*(1\-bwim(:)))).^2\.\*(1\-bwim(:)));
% imagesc(bwim); axis equal; colorbar vert; pause(0\.01\);

bwim \= poly2mask(ctrx, ctry, size(im,1\), size(im,2\));
% imagesc(im); axis equal; colorbar vert; hold on; plot(ctrx, ctry, 'r\-'); hold off; pause(0\.01\);
en \= sum((im(bwim)\-mean(im(bwim))).^2\) \+ 2\*sum((im(\~bwim) \- mean(im(\~bwim))).^2\); 

end
\-\-\-

\#\#\# File: fitBezierToImage.m (ID: utility functions.im analysis.23\)

function \[model, ctr] \= fitBezierToImage (im, model0\)
%c \= fitLegendrePolynomialToImage (im, n)
im \= double(im);

op \= optimset('fminunc');
op.Display \= 'off';
op.LargeScale \= 'off';
doplots \= true;

scale \= 1;
im2 \= imresize(im,scale);

op.DiffMinChange \= 0\.5;
model0\.spineCpts \= model0\.spineCpts\*scale;
model0\.bodyWidth \= model0\.bodyWidth\*scale;
myfun \= @(q) energyfun(q, blurim(im2,2\),model0\);
if (doplots)
 op.PlotFcns \= @(x, optimValues, state) myPlotFun(x,blurim(im2,2\),model0\);
end
x0 \= modelTo1D(model0\);
x0 \= x0(1:8\);
x1 \= fminunc(myfun, x0, op);
model \= model0;
model.spineCpts \= \[x1(1:4\); x1(5:8\)];
% 
% x0 \= \[model.spineCpts(1,:) model.spineCpts(2,:)];
% myfun \= @(q) energyfun(q, im2,model);
% op.PlotFcns \= @(x, optimValues, state) myPlotFun(x,im2,model);
% 
% op.DiffMinChange \= 0\.5;
% x1 \= fminunc(myfun, x0, op);
% model.spineCpts \= \[x1(1:4\); x1(5:8\)];
op.DiffMinChange \= 0\.1;
myfun \= @(q) energyfun(q, blurim(im2,2\));
if (doplots)
 op.PlotFcns \= @(x, optimValues, state) myPlotFun(x,blurim(im2,2\));
end
x0 \= modelTo1D(model);
x1 \= fminunc(myfun, x0, op);
model \= modelFrom1D(x1\);


op.DiffMinChange \= 0\.5;

myfun \= @(q) energyfun(q, im2,model);
if (doplots)
 op.PlotFcns \= @(x, optimValues, state) myPlotFun(x,im2,model);
end
x0 \= modelTo1D(model);
x0 \= x0(1:8\);
x1 \= fminunc(myfun, x0, op);
model.spineCpts \= \[x1(1:4\); x1(5:8\)];
% 
% x0 \= \[model.spineCpts(1,:) model.spineCpts(2,:)];
% myfun \= @(q) energyfun(q, im2,model);
% op.PlotFcns \= @(x, optimValues, state) myPlotFun(x,im2,model);
% 
% op.DiffMinChange \= 0\.5;
% x1 \= fminunc(myfun, x0, op);
% model.spineCpts \= \[x1(1:4\); x1(5:8\)];
op.DiffMinChange \= 0\.25;
myfun \= @(q) energyfun(q, im2\);
if (doplots)
 op.PlotFcns \= @(x, optimValues, state) myPlotFun(x,im2\);
end
x0 \= modelTo1D(model);
x1 \= fminunc(myfun, x0, op);
model \= modelFrom1D(x1\);



model.spineCpts \= model.spineCpts/scale;
model.bodyWidth \= model.bodyWidth/scale;
ctr \= maggotContourFromControlPoints(model);
eic \= energyInContour(im, ctr(1,:), ctr(2,:))
efie \= energyFromImageEdge(ctr,im)
ecl \= energyFromContourLength(x1\)
ers \= energyFromRigidSpine(x1\)
efss \= energyFromSpringSpine(x1\)

end

function x \= modelTo1D(model)
 x \= \[model.spineCpts(1,:) model.spineCpts(2,:) model.bodyWidth model.bodyTaper model.headalpha model.tailalpha];
end

function model \= updateSpinePoints(x,model)
 model.spineCpts \= \[x(1:4\); x(5:8\)];
end
% function spinePointEnergyFun(q,im,model)
% model \= updateSpinePoints(q,model);
% ctr \= maggotContourFromControlPoints(model);
% en \= energyInContour(im, ctr(1,:), ctr(2,:))...
% \+ 100\*sum(sqrt(sum(diff(ctr,\[],2\).^2\))) ...
% \+ 100\*sum(sum(diff(model.spineCpts,\[],2\).^2\));
% end 

function model \= modelFrom1D(x)
 model.spineCpts \= \[x(1:4\); x(5:8\)];
 model.bodyWidth \= x(9\);
 model.bodyTaper \= x(10\);
 model.headalpha \= x(11\);
 model.tailalpha \= x(12\);
end

function en \= energyfun (q, im, model)
 if (nargin \< 3\)
 model \= modelFrom1D(q);
 else
 model \= updateSpinePoints(q,model);
 end
 ctr \= maggotContourFromControlPoints(model);
 en \= energyInContour(im, ctr(1,:), ctr(2,:))...
 \+ sum(sqrt(sum(diff(ctr,\[],2\).^2\)))...
 \+ energyFromRigidSpine(q,model) ...
 \+ energyFromSpringSpine(q,model) \+ ...
 1E5\*(1\-model.tailalpha)^4 \+ 1E5\*(2\-model.headalpha)^4 \+ ...
 1E6\*(0\.8\-model.bodyTaper)^4;
% \+ sum(sum(diff(model.spineCpts,\[],2\).^2\));
% \+ energyFromImageEdge(ctr,im) ...

end 
function en \= energyFromImageEdge(ctr, im)
% if (nargin \< 3\)
% model \= modelFrom1D(q);
% else
% model \= updateSpinePoints(q,model);
% end
 edgim \= conv2(dgausskernel(1\), gaussKernel(1\), im).^2 \+ conv2(gaussKernel(1\), dgausskernel(1\), im).^2;
 en \= \-sum(interp2(edgim,ctr(1,:),ctr(2,:),'\*linear'))/sum(sqrt(sum(diff(ctr,\[],2\).^2\)));
end

function en \= energyFromContourLength(q,model)
 if (nargin \< 2\)
 model \= modelFrom1D(q);
 else
 model \= updateSpinePoints(q,model);
 end
 ctr \= maggotContourFromControlPoints(model);
 en \= sum(sqrt(sum(diff(ctr,\[],2\).^2\)));
end
% function en \= energyFromRigidSpine(q,model)
% if (nargin \< 2\)
% model \= modelFrom1D(q);
% else
% model \= updateSpinePoints(q,model);
% end
% sp \= bezierFromControlPoints(model.spineCpts, 100\);
% dx \= deriv(sp,1\);
% ddx \= deriv(dx,1\);
% ds \= sqrt(sum(dx.^2\));
% % rc \= ds.^3\./(dx(1,:).\*ddx(2,:) \- dx(2,:).\*ddx(1,:));
% % en \= sum(ds./rc);
% en \= sum(abs((dx(1,:).\*ddx(2,:) \- dx(2,:).\*ddx(1,:)))./ds.^2\);
% end

function en \= energyFromRigidSpine(q,model)
 if (nargin \< 2\)
 model \= modelFrom1D(q);
 else
 model \= updateSpinePoints(q,model);
 end
 t \= diff(model.spineCpts,\[], 2\);
 s \= sqrt(sum(t.^2\));
 t \= t./(\[1;1]\*s);
 en \= 1E5\*sum(abs((t(1,1:(end\-1\)).\*t(2,2:end) \- t(2,1:(end\-1\)).\*t(1,2:end))));
 
end
function en \= energyFromSpringSpine(q,model)
 if (nargin \< 2\)
 model \= modelFrom1D(q);
 else
 model \= updateSpinePoints(q,model);
 end
 t \= diff(model.spineCpts,\[], 2\);
 en \= sum(sum(t.^2\).^2\) \+ 100\*sum(sqrt(sum(t.^2\)))\*sum(1\./(sum(t.^2\)));
 
end

function stop \= myPlotFun (q, im, model)
 imagesc(im);axis equal; hold on
 if (nargin \< 3\)
 model \= modelFrom1D(q);
 else
 model \= updateSpinePoints(q,model);
 end
 ctr \= maggotContourFromControlPoints(model);
 plot(ctr(1,:), ctr(2,:), 'r\-', model.spineCpts(1,:), model.spineCpts(2,:), 'k\*\-\-'); 
 stop \= false;
end
function en \= energyInContour (im, ctrx,ctry)
 % bwim \= traceBoundarySubPixel(\[ctrx;ctry],\[1 1], size(im));

 % en \= sum((im(:) \- mean(im(:).\*bwim(:))).^2\.\*bwim(:)) ...
 % \+ sum((im(:) \- mean(im(:).\*(1\-bwim(:)))).^2\.\*(1\-bwim(:)));
% imagesc(bwim); axis equal; colorbar vert; pause(0\.01\);

bwim \= poly2mask(ctrx, ctry, size(im,1\), size(im,2\));
%imagesc(im); axis equal; colorbar vert; hold on; plot(ctrx, ctry, 'r\-'); hold off; pause(0\.001\);
en \= sum((im(bwim)\-mean(im(bwim))).^2\) \+ sum((im(\~bwim)\-mean(im(\~bwim))).^2\); 

end
\-\-\-

\#\#\# File: potenergy.m (ID: utility functions.im analysis.24\)

function upot \= potenergy(ctr, energyim)
%function upot \= potenergy(ctr, energyim)

upot \= sum(interp2(energyim, ctr(1,:), ctr(2,:), '\*linear', 100\*max(abs(energyim(:)))));

\-\-\-

\#\#\# File: gradcosntforceenergy.m (ID: utility functions.im analysis.25\)

function gcharge \= gradconstforceenergy(ctr, closed)
%function ubend \= bendenergy(ctr, closed)
%closed if we should connect contour(:,1\) with contour(:,end)
existsAndDefault('closed', true);
if (closed)
 dxr \= diff(ctr(:, \[end 1:end]), \[], 2\); % (x\_j \- x\_(j\-1\))
 dxf \= diff(ctr(:, \[1:end 1]), \[], 2\); % x\_j\+1 \- x\_j
else
 dxr \= diff(ctr(:, \[1 1:end]), \[], 2\); % (x\_j \- x\_(j\-1\))
 dxf \= diff(ctr(:, \[1:end end]), \[], 2\); % x\_j\+1 \- x\_j
end
%dx \= deriv(ctr, sigma, 'padtype', 'circular');

dxfl3 \= (sum(dxf.^2\)).^(1\.5\);
dxrl3 \= (sum(dxr.^2\)).^(1\.5\);
dxfl3(dxfl3 \=\= 0\) \= 1;
dxrl3(dxrl3 \=\= 0\) \= 1;
n \= length(dxfl3\);
gcharge \= 1/n^2\*(dxf./\[dxfl3;dxfl3]\-dxr./\[dxrl3;dxrl3]);
\-\-\-

\#\#\# File: calibrateCheckerboard\_old.m (ID: utility functions.im analysis.26\)

function \[realx, realy, camx, camy] \= calibrateCheckerboard(im, varargin)
%function \[realx, realy, camx, camy] \= calibrateCheckerboard(im, varargin)
%varargin)
% finds the corners of a checkerboard image, with some help
% xaxis, yaxis are the axes for the image (i.e. pcolor(axis,yaxis,im)
% makes sense)
% im must be a grayscale image (size nrowsxncolsx1\)
% checkers must be roughly aligned to axes
%optional key/value paris
%"xaxis" x\-axis of im
%"yaxis" y\-axis of im
%"flatten", true/false \-\- whether to flatten out irregularities in
%illumination
%
%
%xc,yc are coordinates of corners
%structvar follows the rules of structvar, which are
%
%about structvar
%the first rule of structvar is you do not talk about structvar
%the second rule of structvar is you do not talk about structvar
%the third rule of structvar is that it is a Nx2 array of points,
%specifying rectangles
%the fourth rule of structvar is the lower left (in image coordinates; upper left in xy coords)
%corner comes first, then the other 3 points are specified in
%counterclockwise (in image coords; clockwise in xy coords) order
%the fifth rule of structvar is you do not talk about structvar
%
%structvar specifies the boundaries of light squares

xaxis \= \[];
yaxis \= \[];
flatten \= false;
varargin \= assignApplicable(varargin);
if (isempty(xaxis))
 xaxis \= 1:size(im,2\);
end
if (isempty(yaxis))
 yaxis \= 1:size(im,1\);
end

figure(10\); clf(10\); 
imagesc(xaxis, yaxis, double(im)); axis equal; colormap gray(256\); 
title ('please select opposite corners of a single square in center');
 
while (1\)
 \[x,y] \= getpts;
 if (length(x) \< 2 \|\| length(y) \< 2\) 
 figure(10\); clf(10\); 
 imagesc(xaxis, yaxis, double(im)); axis equal; colormap gray(256\); 
 title ('please select two points');
 continue;
 end
 try 
 figure(10\); clf(10\); 
 imagesc(xaxis, yaxis, double(im)); axis equal; colormap gray(256\); 
 title ('something messed up \- try again');
 width \= diff(x(1:2\));
 height \= diff(y(1:2\));
 catch
 continue;
 end
 title ('thank you \- doing spatial calibration, this may take a moment');
 pause(0\.1\);
 break;
end
if (flatten)
 checkerSize \= ceil(max(width, height));
 intensityim \= blurim(imdilate(blurim(im, 4\), ones(ceil(checkerSize/2\))), checkerSize/3\);
 im \= double(im) ./ double(intensityim);
 im(im \> 2\) \= 2;
 figure(9\); clf(9\); imagesc(xaxis, yaxis, intensityim);
 figure(11\); clf(11\); imagesc(xaxis, yaxis, double(im)); axis equal; colormap jet; 
end
 
x \= interp1(xaxis, 1:length(xaxis), x);
y \= interp1(yaxis, 1:length(yaxis), y);

dx \= abs(diff(x(1:2\)));
dy \= abs(diff(y(1:2\)));



%look for corner locations by convolving with checker pattern

%construct kernel
ksize \= \[dy/1\.5, dx/1\.5];
%make ksize odd
ksize \= 2 \* round(ksize/2\)\+1;

kernel \= zeros(ksize);
kernel(1:floor(ksize(1\)/2\),1:floor(ksize(2\)/2\)) \= 1;
kernel(ceil(ksize(1\)/2 \+ 1\):end,1:floor(ksize(2\)/2\)) \= \-1;
kernel(ceil(ksize(1\)/2 \+ 1\):end,ceil(ksize(2\)/2 \+ 1\):end) \= 1;
kernel(1:floor(ksize(1\)/2\),ceil(ksize(2\)/2 \+ 1\):end) \= \-1;

kernel \= kernel / sum(abs(kernel(:)));
%convolve \& discard outer region 
cim \= zeros(size(im));
cimall \= conv2(double(im), kernel, 'same');
yinds \= round(ksize(1\)/3\):round(size(cim,1\) \- ksize(1\)/3\);
xinds \= round(ksize(2\)/3\):round(size(cim,2\) \- ksize(2\)/3\);
cim(yinds,xinds) \= cimall(yinds,xinds);
%pcolor(xaxis,yaxis,cim); shading flat; colormap jet;

%look for local extrema

%do a 2nd deriv filter
sd \= zeros(size(cim));
tempim \= conv2(gaussKernel(ksize(1\)/18\), gaussKernel(ksize(2\)/18\), cim, 'same') \- conv2(gaussKernel(ksize(1\)/6\), gaussKernel(ksize(2\)/6\), cim, 'same');
yinds \= round(ksize(1\)/2\):round(size(cim,1\) \- ksize(1\)/2\);
xinds \= round(ksize(2\)/2\):round(size(cim,2\) \- ksize(2\)/2\);
sd(yinds, xinds) \= tempim(yinds,xinds);
sdlg \= abs(sd) \> percentile(abs(sd), 0\.975\);
figure(12\); clf(12\);
pcolor(xaxis, yaxis, sd); shading flat; colormap jet; axis equal
figure(13\); clf(13\);
pcolor(xaxis, yaxis, sd.\*sdlg); shading flat; colormap jet; axis equal

%find the locations of the corners
stats \= regionprops(imdilate(sdlg,strel('disk',10, 0\)), abs(cim), 'WeightedCentroid');
loc \= \[stats.WeightedCentroid];
\[xl,yl] \= localmaxima(abs(cim), loc(1:2:end), loc(2:2:end),max(ksize)/4\);
%return back to coordinate system specified by xaxis,yaxis
%the extra shift of 1/2 was determined empirically
xl \= interp1(xaxis, xl \+ 1/2, 'linear');
yl \= interp1(yaxis, yl \+ 1/2, 'linear');

xc \= xl;
yc \= yl;

%sort into rows
\[yc,I] \= sort(yc);
xc \= xc(I);

jump \= \[0 find(diff(yc) \> height \* 0\.5\)];
for j \= 1:(length(jump) \- 1\)
 xx \= xc((jump(j) \+ 1\):(jump(j\+1\)));
 yy \= yc((jump(j) \+ 1\):(jump(j\+1\)));
 \[xx,I] \= sort(xx);
 yy \= yy(I);
 row(j).xc \= xx; %\#ok
 row(j).yc \= yy; %\#ok
 dx(j) \= median(diff(row(j).xc));
 yavg(j) \= mean(row(j).yc);
end
width \= median(dx);
height \= median(diff(yavg));

x0 \= min(xc);
y0 \= min(yavg);
for j \= 1:length(row)
 row(j).xreal \= round((row(j).xc \- x0\)/width);
 row(j).yreal \= repmat(round((yavg(j)\-y0\) / height),size(row(j).xreal));
end

camx \= \[row.xc];
camy \= \[row.yc];
realx \= \[row.xreal];
realy \= \[row.yreal];
figure(10\);
hold on;
colormap gray;
plot (camx, camy, 'r.');
hold off
\[realx, realy, camx, camy] \= guessOutsideHull (realx, realy, camx, camy, \-1:(size(im,2\) \+ 1\), \-1:(size(im,1\)\+1\));
realx \= realx \- floor(min(realx));
realy \= realy \- floor(min(realy));
camx \= camx;
camy \= camy;

title ('done');

function \[x,y] \= localmaxima(im, x, y, nsize, maxiters, tol)
%function \[x,y] \= localmaxima(im, x, y, maxiters, tol)
%uses steepest ascent to move to local maxima; 
%this is really only a good idea if you're already close

debug \= false;

existsAndDefault('nsize', 10\);
existsAndDefault('maxiters', 100\);
existsAndDefault('tol', 0\.001\);

xd \= conv2(gaussKernel(nsize), dgausskernel(nsize), im, 'same');
yd \= conv2(dgausskernel(nsize), gaussKernel(nsize), im, 'same');
ds \= sqrt(xd.^2 \+ yd.^2\);
xd \= xd./ds;
yd \= yd./ds;

xx \= 1:size(im,2\);
yy \= 1:size(im,1\);

xnew \= x;
ynew \= y;
nv \= interp2(xx,yy,im,xnew,ynew);
if (debug)
 figure(1\); clf(1\); imagesc(im); 
 hold on
end
for j \= 1:maxiters
 ov \= nv;
 xdd \= interp2(xx,yy,xd,x,y,'\*linear');
 ydd \= interp2(xx,yy,yd,x,y,'\*linear');
 for k \= 1:length(x)
 xline \= x(k) \+ xdd(k)\*(0:0\.01:1\)\*nsize;
 yline \= y(k) \+ ydd(k)\*(0:0\.01:1\)\*nsize;
 valsonline \= interp2(xx,yy,im,xline,yline,'\*linear');
 \[blah,I] \= max(valsonline);
 xnew(k) \= xline(I);
 ynew(k) \= yline(I);
 end
 if (debug)
 for k \= 1:length(x)
 plot (\[x(k) xnew(k)], \[y(k) ynew(k)], 'b\-', 'LineWidth',2\);
 end
 end
 x \= xnew;
 y \= ynew;
 nv \= interp2(xx,yy,im,xnew,ynew);
 if all((nv \- ov)./ov \< tol)
 return
 end
end


 
\-\-\-

\#\#\# Folder: @WormSegmentOptions (ID: @WormSegmentOptions)

\-\-\-

\#\#\# File: WormSegmentOptions.m (ID: @WormSegmentOptions.1\)

classdef WormSegmentOptions
 %options for segmenting worm tracks
 %tracks are segmented into periods of forward motion and periods of
 %reorientation
 %
 %first sharp turns are flagged as any point at which the velocity
 %direction is changing faster than DTHETATHRESH
 %any sharp turns that are less than JOINSTPTS apart are merged into a
 %single sharp turn
 %the velocity angle into a sharp turn is the angle PTBUFFER points before
 %the turn; and the velocity angle out is PTBUFFER points after
 %if the in and out velocity angles are within ALIGNEDTHETA, the sharp
 %turn is flagged as a reversal (if out is \~180 degrees from in) or a
 %blip (if in the same direction)
 %otherwise, flagged as an omega turn
 %all sharp turns within MINRUNTIME (in seconds) of each other are
 %grouped into a single reorientation
 %a reorientation ends at the point where dtheta/dt is less than
 %STRAIGHTTHETATHRESH after the last sharp turn in that reorientation
 properties
 dthetaHiThresh \= deg2rad(60\); %threshold for delta theta (rad/sec) to be considered a sharp turn
 dthetaLoThresh \= deg2rad(15\); %threshold for sharp turn to end
 reversalCovThresh \= 1\.8; %if min(covRatio) \< this threshold, not a reversal, but an omega turn
 omegaCovThresh \= 2\.0; %if min(covRatio) \> this threshold, not an omega turn \-\- assign to reversal or blip
 speedEndSTThresh \= 0\.5; %sharpturn cannot end while speed \< this threshold
 joinSTpts \= 3; %join sharp turns that are at most STpts \- 1 apart
 ptBuffer \= 3; %how many points before and after to look when computing angle into and out of turn event
 alignedTheta \= deg2rad(20\); %how closely aligned the before and after tracks should be to count as a reversal instead of an o\-turn 
 minRunTime \= 5; %minimum separation in time (in seconds) to be separate reorientations
 maxBackTime \= 10; %maximum time that an animal can go backwards without reorienting \-\- used to correct mistakes in identifying reversals
 straightThetaThresh \= deg2rad(3\); %threshold for delta theta to be considered straight after reorientation (dt \< thresh) 
 end
 
 methods
 end
 
end


\-\-\-

\#\#\# Folder: @WormSegmentOptions/@WormSharpTurn (ID: @WormSegmentOptions.@WormSharpTurn)

\-\-\-

\#\#\# File: setUserType.m (ID: @WormSegmentOptions.@WormSharpTurn.1\)

function success \= setUserType (st, charCode) 

if \~ischar(charCode)
 warningMessage();
 success \= false;
 return;
end
success \= true;
switch (upper(charCode(1\)))
 case 'O' %mega turn
 st.userCode \= \-1;
 case 'D' %ouble reverse
 st.userCode \= 0;
 case 'R' %eversal
 st.userCode \= 1;
 case {'B','P'} %blip or pause
 st.userCode \= 2;
 case 'C' %an't tell
 st.userCode \= 100;
 case 'N' %ot a turn
 st.userCode \= 250;
 case 'M' %ultiple turns 
 st.userCode \= 254;
 otherwise
 warningMessage();
 success \= false;
end

function warningMessage()

disp ('You did not enter a valid label for this turn. Choices are:')
disp ('\[O]mega turn \- forms a ball');
disp ('\[R]eversal \- changes direction about 180 degrees without curling up');
disp ('\[D]ouble reverse \- changes direction twice within this single turn without curling up');
disp ('\[M]ultiple turns \- multiple turns (other than the double reverse) incorrectly grouped together here');
disp ('\[P]ause \- it just stops moving for a moment or two');
disp ('\[C]an''t tell what''s going on here');
disp ('\[N]ot a turn \- this should not have been flagged as a turn at all');



 
\-\-\-

\#\#\# File: calculateMetrics.m (ID: @WormSegmentOptions.@WormSharpTurn.2\)

function calculateMetrics(st)
%WormSharpTurn/calculateMetrics(st)
%
%calculates the properties of the sharp turn;
track \= st.track;
track.calculateDerivedQuantity({'scovRatio','sloc','theta','deltatheta'});
wso \= track.so;

 
s \= max(st.startInd\-wso.ptBuffer, 1\);
e \= min(st.endInd\+wso.ptBuffer, length(track.dq.sloc));


st.thetaIn \= track.dq.theta(s);
st.thetaOut \= track.dq.theta(e);
st.dTheta \= diff(unwrap(\[st.thetaIn;st.thetaOut]));
 

\[\~,lm] \= max(abs(track.dq.deltatheta(st.startInd:st.endInd)));
st.centralInd \= st.startInd \- 1 \+ lm;
st.inds \= st.startInd:st.endInd;


%old: flag on total angle change
st.typeCode \= \-1;
if (abs(st.dTheta) \< wso.alignedTheta \&\& (min(track.dq.scovRatio(st.startInd:st.endInd)) \> wso.reversalCovThresh) )
 st.typeCode \= 0;
end

if (abs(st.dTheta) \> pi \- wso.alignedTheta \&\& min(track.dq.scovRatio(st.inds)) \> wso.reversalCovThresh)
 st.typeCode \= 1;
end

if (isfield(wso, 'omegaCovThresh') \&\& \~isempty(wso.omegaCovThresh))
 ct \= wso.omegaCovThresh;
else
 ct \= wso.reversalCovThresh;
end

if (min(track.dq.scovRatio(st.inds)) \> ct)
 if (abs(st.dTheta) \< pi / 2\)
 st.typeCode \= 0;
 else
 st.typeCode \= 1;
 end
end

if (st.typeCode \=\= \-1\)
 touchUpOmegaTurn(st);
end
 
if (st.typeCode \=\= 1\)
 touchUpReversal(st);
end

st.loc \= track.dq.sloc(:,st.centralInd);
st.inds \= st.startInd:st.endInd;
st.dTheta \= diff(unwrap(\[st.thetaIn;st.thetaOut]));



function touchUpOmegaTurn (st)
 
cr \= st.track.getDerivedQuantity('scovRatio');
dcr \= st.track.getDerivedQuantity('dcovRatio');
\[mcr,I] \= min(cr(st.inds));
if (isempty(I))
 st
 st.track
 pause
end
%cthresh \= 0\.5 \* mcr \+ 0\.25\*(cr(st.startInd) \+ cr(st.endInd));
cI \= I \+ st.startInd \- 1;

st.centralInd \= cI;
start \= find(dcr(1:cI) \> 0 \& cr(1:cI) \> st.track.so.reversalCovThresh \& cr(1:cI) \> cr(cI), 1, 'last');
if (isempty(start))
 start \= st.startInd;
end
stop \= find(dcr(cI:end) \< 0 \& cr(cI:end) \> st.track.so.reversalCovThresh \& cr(cI:end) \> cr(cI), 1, 'first');

if (isempty(stop))
 stop \= st.endInd;
else
 stop \= cI \+ stop \- 1;
end

st.startInd \= start;
st.endInd \= stop;
st.inds \= start:stop;
 
st.thetaIn \= st.track.dq.theta(start);
st.thetaOut \= st.track.dq.theta(stop);

function touchUpReversal(st)
 
dt \= st.track.getDerivedQuantity('deltatheta');
s \= sign(dt(st.centralInd));
ddt \= s\*st.track.getDerivedQuantity('ddtheta');

si \= find(sign(dt(1:(st.centralInd\-1\))) \~\= s \| ddt(1:(st.centralInd\-1\)) \< 0, 1, 'last');
if (\~isempty(si))
 st.startInd \= si \+ 1;
end

ei \= find(sign(dt((st.centralInd \+ 1\):end)) \~\= s \| ddt((st.centralInd \+ 1\):end) \> 0, 1, 'first');
if (\~isempty(ei))
 st.endInd \= st.centralInd \+ ei;
end

\-\-\-

\#\#\# File: type.m (ID: @WormSegmentOptions.@WormSharpTurn.3\)

function typeCode \= type(st)
%function typeCode \= type(st)
%
%gets a string interpretation of the typeCode

if (length(st) \=\= 1\)
 switch(st.typeCode)
 case \-1 
 typeCode \= 'omega turn';
 case 0
 typeCode \= 'double reverse or blip';
 case 1
 typeCode \= 'reversal';
 case 2
 typeCode \= 'second reversal';
 end
 return;
end

for j \= 1:length(st)
 typeCode{j} \= st(j).type;
end

\-\-\-

\#\#\# File: usertype.m (ID: @WormSegmentOptions.@WormSharpTurn.4\)

function typeCode \= usertype(st)
%function typeCode \= usertype(st)
%
%gets the type strings based on the type codes for sharp turns

if (length(st) \=\= 1\)
 if (\~isfinite(st.userCode))
 typeCode \= 'not labeled';
 return;
 end
 switch(st.userCode)
 case \-1 
 typeCode \= 'omega turn';
 case 0
 typeCode \= 'double reverse';
 case 1
 typeCode \= 'reversal';
 case 2
 typeCode \= 'blip or pause';
 case 100
 typeCode \= 'could not tell';
 case 250
 typeCode \= 'not a sharp turn'; 
 case 254
 typeCode \= 'multiple turns';
 end
 return;
end

for j \= 1:length(st)
 typeCode{j} \= st(j).usertype;
end

\-\-\-

\#\#\# File: symbol.m (ID: @WormSegmentOptions.@WormSharpTurn.5\)

function \[sym,color] \= symbol(st)
%function \[sym,color] \= symbol(st)
%gets a 1\-letter latex code for the type symbol

if (length(st) \=\= 1\)
 if (\~isfinite(st.userCode))
 switch(st.typeCode)
 case \-1 
 sym \= '$\\Omega$';
 color \= 'm';
 case 0
 sym \= 'b';
 color \= 'g';
 case {1,2}
 sym \= 'R';
 color \= 'r';
 end
 else
 switch(st.userCode)
 case \-1 
 sym \= '$\\mathbf{\\Omega$}';
 color \= 'm';
 case 0
 sym \= '$\\mathbf{RR}$';
 color \= 'g';
 case 1
 sym \= '$\\mathbf{R}$';
 color \= 'r';
 case 2
 sym \= '$\\mathbf{b}$';
 color \= 'g';
 case 100
 sym \= '?';
 color \= 'y'; 
 case 250
 sym \= '\\o';
 color \= 'c';
 case 254
 sym \= 'mt';
 color \= 'y';
 end
 end
 return;
end

for j \= 1:length(st)
 \[s,c] \= sym(j).symbol;
 sym{j} \= s;
 color{j} \= c;
end

\-\-\-

\#\#\# File: WormSharpTurn.m (ID: @WormSegmentOptions.@WormSharpTurn.6\)

classdef WormSharpTurn \< TrackPart
 %when a worm track makes a sharp turn, e.g. omega turn or reversal
 
 properties
 typeCode \= 0; % \-1 \= 'omega turn'; 0 \= 'double reverse or blip'; 1 \= 'reversal'; 2 \= 'second reversal';
 loc \= \[NaN;NaN];
 centralInd \= 0;
 thetaIn \= NaN;
 thetaOut \= NaN;
 dTheta \= NaN;
 userCode \= NaN; %type code assigned by user
 end
 
 methods
 calculateMetrics(st);
 typeString \= type(st);
 \[sym,color] \= symbol(st);
 userString \= usertype(st);
 setUserType (st, charCode);
 end
 
 methods %constructor
 function st \= WormSharpTurn(varargin)
 %st \= WormSharpTurn(track, startInd, endInd)
 arglist \= {'track', 'startInd', 'endInd'};
 if (nargin \> 0\)
 for j \= 1:min(nargin, length(arglist))
 st.(arglist{j}) \= varargin{j};
 end
 if (nargin \>\= length(arglist))
 %got everything we wanted, so calculate away
 st.calculateMetrics();
 end
 end
 end
 end
 
end


\-\-\-

\#\#\# Folder: @CameraCalibration (ID: @CameraCalibration)

\-\-\-

\#\#\# File: setTSI.m (ID: @CameraCalibration.1\)

function setTSI(cc)
%function setTSI(cc)
%
% used internally by CameraCalibration; do not call directly unless you know
% what you are doing
cc.camx \= makecolumn(cc.camx);
cc.camy \= makecolumn(cc.camy);
cc.realx \= makecolumn(cc.realx);
cc.realy \= makecolumn(cc.realy);

\[cx, cy, rx, ry] \= guessOutsideHull (cc.camx, cc.camy, cc.realx, cc.realy, \[min(cc.realx) max(cc.realx)], \[min(cc.realy) max(cc.realy)]);
cc.r2cX \= TriScatteredInterp (rx, ry, cx);
cc.r2cY \= TriScatteredInterp (rx, ry, cy);

%1/16 \- added 10 pixels to border region to take care of weird stuff from extraction, but
%I need to check what happened during extraction
\[rx, ry, cx, cy] \= guessOutsideHull (cc.realx, cc.realy, cc.camx, cc.camy, \[min(cc.camx)\-10 max(cc.camx)\+10], \[min(cc.camy)\-10 max(cc.camy)\+10]);
cc.c2rX \= TriScatteredInterp (cx, cy, rx);
cc.c2rY \= TriScatteredInterp (cx, cy, ry);
%cc.c2rX \= TriScatteredInterp (cc.camx, cc.camy, cc.realx);
%cc.c2rY \= TriScatteredInterp (cc.camx, cc.camy, cc.realy);


\-\-\-

\#\#\# File: .DS\_Store (ID: @CameraCalibration.2\)

Could not read file: 'utf\-8' codec can't decode byte 0x80 in position 3131: invalid start byte

\-\-\-

\#\#\# File: morphRealToCam.m (ID: @CameraCalibration.3\)

function camim \= morphRealToCam(cc, realim, realxaxis, realyaxis, varargin)
%function camin \= morphRealToCam(cc, realim, realxaxis, realyaxis, varargin)
% morphs an image defined in real space to appear as it would if the camera had taken
% a picture of it
%
% outputs: 
% CAMIM : a HxW image
% inputs:
% CC \< CameraCalibration
% REALIM \- a MxN image
% REALXAXIS \- a 1xN list of x\-locations; if realxaxis is not passed in,
% realxaxis is determined automatically to span the image and have
% the same approximate size as the camera image
% REALYAXIS \- a 1xM list of y\-locations; if realyaxis is not passed in,
% realyaxis is determined automatically to span the image and have
% the same approximate size as the camera image
%
% optional args: 
% camxaxis \- (1xW) default is to span the calibrated range
% camyaxis \- (1xH) default is to span the calibrated range
camxaxis \= min(cc.camx):max(cc.camx);
camyaxis \= min(cc.camy):max(cc.camy);
%camxaxis \= 1:size(camim,2\);
%camyaxis \= 1:size(camim,1\);

varargin \= assignApplicable(varargin);

 
\[cxp,cyp] \= meshgrid(camxaxis,camyaxis);
cxp \= cxp(:);
cyp \= cyp(:);

xr \= cc.c2rX(cxp, cyp);
yr \= cc.c2rY(cxp, cyp);

im2 \= interp2(realxaxis, realyaxis, double(realim), xr, yr, '\*linear');

camim \= reshape(im2, \[length(camyaxis) length(camxaxis)]);

\-\-\-

\#\#\# File: realPtsFromCamPts.m (ID: @CameraCalibration.4\)

function realpts \= realPtsFromCamPts(cc, campts)
%function realpts \= realPtsFromCamPts(cc, campts)
% map real locations from points on the camera sensor
% outputs:
% REALPTS \- a 2xN list of real points;
% inputs:
% CC \< CameraCalibration
% CAMPTS \- a 2xN list of pixel locations
if (\~isreal(campts))
 campts \= \[real(campts);imag(campts)];
end
campts \= double(campts);
x \= cc.c2rX(campts(1,:), campts(2,:));
y \= cc.c2rY(campts(1,:), campts(2,:));
realpts \= \[x;y];
\-\-\-

\#\#\# File: realUnitsPerPixel.m (ID: @CameraCalibration.5\)

function magfactor \= realUnitsPerPixel (cc)
%function magfactor \= realUnitsPerPixel (cc)
%
% how many real units (usually cm) per pixel
% outputs:
% MAGFACTOR \- cm per pixel
% inputs:
% CC \< CameraCalibration

I \= randperm(length(cc.camx));
cx \= cc.camx(I);
cy \= cc.camy(I);
rx \= cc.realx(I);
ry \= cc.realy(I);

dc \= sqrt(diff(cx).^2 \+ diff(cy).^2\);
dr \= sqrt(diff(rx).^2 \+ diff(ry).^2\);

mf \= dr./dc;
magfactor \= median(mf(isfinite(mf)));
\-\-\-

\#\#\# File: pixelsPerRealUnit.m (ID: @CameraCalibration.6\)

function magfactor \= pixelsPerRealUnit (cc)
%function magfactor \= pixelsPerRealUnit (cc)
%
% how many pixels \= 1 real unit (e.g. cm)
%
% outputs:
% MAGFACTOR \- pixels per cm
% inputs:
% CC \< CameraCalibration

magfactor \= 1/cc.realUnitsPerPixel;

\-\-\-

\#\#\# File: CameraCalibration.m (ID: @CameraCalibration.7\)

classdef CameraCalibration \< handle
 %CameraCalibration \< handle
 %maps points from camera to real points
 %after extraction, larva position and posture are measured in pixels
 %this provides a map from each point in the image (pixel location) to 
 %physical space (usually measured in centimeters). 
 %
 %either provide a list of real points and corresponding pixel locations
 %cc \= CameraCalibration (realx, realy, camx, camy)
 % or provide an image of a checkerboard with squares 1 cm on a side
 %cc \= CameraCalibration (im, . . .)
 % for a list of optional arguments, help calibrateCheckerboard
 
 properties
 realx;
 realy;
 camx;
 camy;
 end
 methods %constructor
 function cc \= CameraCalibration(varargin)
 %cc \= CameraCalibration(checkerim)
 %cc \= CameraCalibration (realx, realy, camx, camy);
 switch(length(varargin))
 case 0
 return;
 case 1
 
 if (isa(varargin{1}, 'CameraCalibration'))
 cc \= CameraCalibration(varargin{1}.realx, varargin{1}.realy, varargin{1}.camx, varargin{1}.camy);
 else
 %assume it's an image of a checkerboard
 \[realx, realy, camx, camy] \= calibrateCheckerboard(varargin{1}); %\#ok\<\*PROP\>
 cc \= CameraCalibration(realx, realy, camx, camy);
 end
 case 4
 cc.realx \= varargin{1};
 cc.realy \= varargin{2};
 cc.camx \= varargin{3};
 cc.camy \= varargin{4};
 cc.setTSI();
 otherwise
 try
 \[realx, realy, camx, camy] \= calibrateCheckerboard(varargin{:});
 cc \= CameraCalibration(realx, realy, camx, camy);
 catch me
 disp(me.getReport);
 disp('CameraCalibration(im) or CameraCalibration(realx, realy, camx, camy)');
 cc \= \[];
 end
 return;
 end
 end 
 end
 
 methods
 \[realim,realxaxis,realyaxis] \= morphCamToReal(cc, camim, varargin); %take a camera picture and morph it to remove lens distortion \& scale to actual size according to axes
 camim \= morphRealToCam(cc, realim, realxaxis, realyaxis, varargin); %take an image defined in real space \& morph it to appear as it would if the camera had taken a picture of it
 campts \= camPtsFromRealPts(cc, realpts); %map real locations to a points on the camera sensor
 realpts \= realPtsFromCamPts(cc, campts); %map points on the camera sensor to real locations
 magfactor \= pixelsPerRealUnit (cc); %how many pixels in a cm
 magfactor \= realUnitsPerPixel (cc); %how many cm/pixel
 setTSI(cc); %set tri scattered interpolation
 \[outerrect, innerrect, quadrilateral] \= realRectFromCamRect(cc, camrect); %map a camera rectangle to a real rectangle
 \[outerrect, innerrect, quadrilateral] \= camRectFromRealRect(cc, realect); %map a camera rectangle to a real rectangle
 
 end
 
 properties (SetAccess \= protected)
 %tri scattered interpolants
 c2rX; 
 c2rY;
 r2cX;
 r2cY;
 end
end


\-\-\-

\#\#\# File: realRectFromCamRect.m (ID: @CameraCalibration.8\)

function \[outerrect, innerrect, quadrilateral] \= realRectFromCamRect(cc, camrect)
%function \[outerrect, innerrect, quadrilateral] \= realRectFromCamRect(cc, camrect)
%cc \< CAMCALINFO
%camrect \= \[left bottom right top] (x1,y1, x2,y2\)
%
%the rectangle defined by camrect is translated into a quadrilateral in real space
%outterrect is the rectangle that contains this quadrilateral
%innerrect is the rectangle contained within this quadrilateral
%outterrect, innerrect are in the form \[left right bottom top]
%quadrilateral is a 2x4 list of corner locations

camrect \= camrect(:)';
quadrilateral \= cc.realPtsFromCamPts(\[camrect(\[1 3 3 1]);camrect(\[2 2 4 4])]);
x \= sort(quadrilateral(1,:)); 
y \= sort(quadrilateral(2,:));

outerrect \= \[x(1\) y(1\) x(4\) y(4\)];
innerrect \= \[x(2\) y(2\) x(3\) y(3\)];
\-\-\-

\#\#\# File: camRectFromRealRect.m (ID: @CameraCalibration.9\)

function \[outerrect, innerrect, quadrilateral] \= camRectFromRealRect(cc, realrect)
%function \[outerrect, innerrect, quadrilateral] \= camRectFromRealRect(cc, realrect)
%cc \< CAMCALINFO
%realrect \= \[left bottom right top] (x1,y1, x2,y2\)
%
%the rectangle defined by real coords is translated into a quadrilateral in camera space
%outterrect is the rectangle that contains this quadrilateral
%innerrect is the rectangle contained within this quadrilateral
%outterrect, innerrect are in the form \[left right bottom top]
%quadrilateral is a 2x4 list of corner locations

realrect \= realrect(:)';
quadrilateral \= cc.camPtsFromRealPts(\[realrect(\[1 3 3 1]);realrect(\[2 2 4 4])]);
x \= sort(quadrilateral(1,:)); 
y \= sort(quadrilateral(2,:));

outerrect \= \[x(1\) y(1\) x(4\) y(4\)];
innerrect \= \[x(2\) y(2\) x(3\) y(3\)];
\-\-\-

\#\#\# File: camPtsFromRealPts.m (ID: @CameraCalibration.10\)

function campts \= camPtsFromRealPts(cc, realpts)
% function campts \= camPtsFromRealPts(cc, realpts)
% map real locations to a points on the camera sensor
% outputs:
% CAMPTS \- a 2xN list of pixel locations
% inputs:
% CC \< CameraCalibration
% REALPTS \- a 2xN list of real points;
if (isempty(realpts))
 campts \= \[];
 return;
end
if (\~isreal(realpts))
 realpts \= \[real(realpts);imag(realpts)];
end
realpts \= double(realpts);
x \= cc.r2cX(realpts(1,:), realpts(2,:));
y \= cc.r2cY(realpts(1,:), realpts(2,:));
campts \= \[x;y];
\-\-\-

\#\#\# File: morphCamToReal.m (ID: @CameraCalibration.11\)

function \[realim,realxaxis,realyaxis] \= morphCamToReal(cc, camim, varargin)
% function \[realim,realxaxis,realyaxis] \= morphCamToReal(cc, camim, varargin)
% morphs an image taken by the camera to real space \-\- 
% pcolor (realxaxis, realyaxis, realim) will produce an image as it appears
% in real space with appropriate measurements on axes
% outputs:
% REALIM \- a MxN image
% REALXAXIS \- a 1xN list of x\-locations; if realxaxis is not passed in,
% realxaxis is determined automatically to span the image and have
% the same approximate size as the camera image
% REALYAXIS \- a 1xM list of y\-locations; if realyaxis is not passed in,
% realyaxis is determined automatically to span the image and have
% the same approximate size as the camera image
% inputs:
% CC \< CameraCalibration
% CAMIM : a HxW image
%
% optional args: 
% camxaxis (default 1:W)
% camyaxis (default 1:H)
% realxaxis
% realyaxis
% realresolution (if passed, realxaxis, realyaxis have spacing of
% realresolution)
%
camxaxis \= 1:size(camim,2\);
camyaxis \= 1:size(camim,1\);

realxaxis \= \[];
realyaxis \= \[];
realresolution \= \[];
varargin \= assignApplicable(varargin);
if (isempty(realxaxis) \|\| isempty(realyaxis))
 
 camleft \= \[repmat(min(camxaxis), size(camyaxis)); camyaxis];
 camright \= \[repmat(max(camxaxis), size(camyaxis)); camyaxis(end:\-1:1\)];
 camtop \= \[camxaxis; repmat(max(camyaxis), size(camxaxis))];
 cambottom \= \[camxaxis(end:\-1:1\); repmat(min(camyaxis), size(camxaxis))];
 
 realleft \= cc.realPtsFromCamPts(camleft);
 realtop \= cc.realPtsFromCamPts(camtop);
 realright \= cc.realPtsFromCamPts(camright);
 realbottom \= cc.realPtsFromCamPts(cambottom);
 
 box \= \[realleft, realtop, realright, realbottom];
 geom \= polygeom(box(1,:), box(2,:));
 xc \= geom(2\);
 yc \= geom(3\);
 
 \[\~,I] \= min(abs(realleft(1,:) \- xc));
 x1 \= realleft(1,I);
 \[\~,I] \= min(abs(realleft(2,:) \- yc));
 y1 \= realleft(2,I);
 
 \[\~,I] \= min(abs(realright(1,:) \- xc));
 x2 \= realright(1,I);
 \[\~,I] \= min(abs(realright(2,:) \- yc));
 y2 \= realright(2,I);
 
 \[\~,I] \= min(abs(realtop(1,:) \- xc));
 x3 \= realtop(1,I);
 \[\~,I] \= min(abs(realtop(2,:) \- yc));
 y3 \= realtop(2,I);
 
 \[\~,I] \= min(abs(realbottom(1,:) \- xc));
 x4 \= realbottom(1,I);
 \[\~,I] \= min(abs(realbottom(2,:) \- yc));
 y4 \= realbottom(2,I);
 
 x0 \= min(\[x1 x2 x3 x4]);
 y0 \= min(\[y1 y2 y3 y4]);
 x1 \= max(\[x1 x2 x3 x4]);
 y1 \= max(\[y1 y2 y3 y4]);
 
 
 %{
 camcorners \= \[min(camxaxis) max(camxaxis) max(camxaxis) min(camxaxis); min(camyaxis) min(camyaxis) max(camyaxis) max(camyaxis)];
 rcorners \= cc.realPtsFromCamPts(camcorners);
 x0 \= max(min(rcorners(1,:)), min(cc.realx));
 x1 \= min(max(rcorners(1,:)), max(cc.realx));
 y0 \= max(min(rcorners(2,:)), min(cc.realy));
 y1 \= min(max(rcorners(2,:)), max(cc.realy));
 %}
 
 
 if (isempty(realxaxis))
 if (isempty(realresolution))
 realxaxis \= linspace(x0, x1, size(camim,2\));
 else
 realxaxis \= x0:realresolution:x1;
 end
 end
 if (isempty(realyaxis))
 if (isempty(realresolution))
 realyaxis \= linspace(y0, y1, size(camim,1\));
 else
 realyaxis \= y0:realresolution:y1;
 end
 end
end
 
\[rxp,ryp] \= meshgrid(realxaxis,realyaxis);
rxp \= rxp(:);
ryp \= ryp(:);

xc \= cc.r2cX(rxp, ryp);
yc \= cc.r2cY(rxp, ryp);
sum(\~isfinite(xc));
sum(\~isfinite(yc));

im2 \= interp2(camxaxis, camyaxis, double(camim), xc, yc, '\*linear');

realim \= reshape(im2, \[length(realyaxis) length(realxaxis)]);

\-\-\-

\#\#\# Folder: useful extra classes (ID: useful extra classes)

\-\-\-

\#\#\# File: readme.txt (ID: useful extra classes.1\)

This directory contains useful classes that are generally specific to a particular experiment

For instance, I plan to create a checkerboard experiment class, a directional stimulus experiment class, and a temporal temperature experiment class

Classes here generally shouldn't be subclassed (if you think this is a more general application, make a new class in the main folder)

\-\-\-

\#\#\# Folder: useful extra classes/@TemporalLightExperiment (ID: useful extra classes.@TemporalLightExperiment)

\-\-\-

\#\#\# File: TemporalLightExperiment.m (ID: useful extra classes.@TemporalLightExperiment.1\)

classdef TemporalLightExperiment \< Experiment
 %an experiment that has the lights turned on and off; a la carter
 
 properties
 cycleTime \= \[]; %frames per half period
 end
 
 methods
 cycleTime \= detectCycleTime (expt, varargin);
 addCycleTime (expt, varargin);
 end
 
 methods %constructor
 function expt \= TemporalLightExperiment(varargin)
 expt \= expt@Experiment(varargin{:});
 if (nargin \> 1\)
 expt.cycleTime \= varargin{2}; 
 else
 expt.detectCycleTime();
 end
 if (nargin \> 0\)
 expt.addCycleTime();
 end
 end
 end
end


\-\-\-

\#\#\# File: addCycleTime.m (ID: useful extra classes.@TemporalLightExperiment.2\)

function addCycleTime (expt, varargin)
%expt.addCycleTime \-\- adds information about the cycle to the experiment
%and its tracks
%
%dq fields added are 
%lighton: a boolean that is true if the light is on
%timeon: the time in seconds since the light last turned on;
%timeoff: the time in seconds since the light last turned off;

period \= expt.cycleTime;
f \= 1:length(expt.elapsedTime);

%first frame is off; second frame is on 
%period \+ 1 frame is on; period \+ 2 frame is off
lighton \= mod(f\-2, 2\*period) \< period;

oninds \= find(diff(lighton) \> 0\) \+ 1;
offinds \= find(diff(lighton) \< 0\) \+ 1;
timeon \= expt.elapsedTime;
for j \= length(oninds):\-1:1
 ind1 \= oninds(j);
 if (j \< length(oninds))
 ind2 \= oninds(j\+1\) \- 1;
 else
 ind2 \= length(timeon);
 end
 timeon(ind1:ind2\) \= timeon(ind1:ind2\) \- timeon(ind1\);
end
timeon(1:oninds(1\)) \= NaN;

timeoff \= expt.elapsedTime;
for j \= length(offinds):\-1:1
 ind1 \= offinds(j);
 if (j \< length(offinds))
 ind2 \= offinds(j\+1\) \- 1;
 else
 ind2 \= length(timeoff);
 end
 timeoff(ind1:ind2\) \= timeoff(ind1:ind2\) \- timeoff(ind1\);
end
timeoff(1:offinds(1\)) \= NaN;

gq \= GlobalQuantity();
gq.xField \= 'eti';
gq.derivationMethod \= @GlobalQuantity.oneDinterpolation;
gq.xData \= expt.elapsedTime;

gq.fieldname \= 'lighton';
gq.yData \= lighton;
expt.addGlobalQuantity(gq);

gq.fieldname \= 'timeon';
gq.yData \= timeon;
expt.addGlobalQuantity(gq);

gq.fieldname \= 'timeoff';
gq.yData \= timeoff;
expt.addGlobalQuantity(gq);


\-\-\-

\#\#\# File: detectCycleTime.m (ID: useful extra classes.@TemporalLightExperiment.3\)

function cycleTime \= detectCycleTime (expt,varargin)
%function cycleTime \= detectCycleTime (expt, varargin)
%uses the fact that in current implementations, there is a 1 second delay
%whenever the slide switches to determine the cycle time
%
%the cycle time is defined as the number of frames per half period; in
%other words how many frames of light there are at one time
%
%at this point, no optional arguments

inds \= find(diff(expt.elapsedTime) \> 0\.75 \& diff (expt.elapsedTime) \< 1\.25\);
expt.cycleTime \= median(diff(inds));

if nargout \> 0
 cycleTime \= expt.cycleTime;
end



\-\-\-

\#\#\# Folder: useful extra classes/@CheckerExperiment (ID: useful extra classes.@CheckerExperiment)

\-\-\-

\#\#\# File: addSpatialInfo.m (ID: useful extra classes.@CheckerExperiment.1\)

function addSpatialInfo (expt, varargin)
%function addSpatialInfo (expt, varargin)
%
%override any of these fields with key,value pairs
%
%structvar; %There is no god but structvar and structvar is his prophe
%boundaryImage; 
%lightImage;
%imsize; 
%boundaryThickness;

structvar \= expt.structvar;
dirim \= \[];
distim \= \[];
lightim \= \[];
imsize \= \[];
boundaryThickness \= \[];

varargin \= assignApplicable(varargin);


if (isempty(dirim) \|\| isempty(distim) \|\| isempty(lightim))
 if (isempty('structvar'))
 disp('I need structvar; feed me structvar');
 return
 end
 existsAndDefault('imsize', \[1944 2592]);
 existsAndDefault('boundaryThickness', expt.boundaryThickness);
 \[dirim,distim,lightim] \= CheckerExperiment.generateBoundaryImage(imsize, structvar);
 expt.boundaryThickness \= boundaryThickness;
 expt.structvar \= structvar;
end

expt.imsize \= size(dirim);
 
expt.addBoundary(dirim,distim,lightim);

expt.calculateDerivedQuantity('theta');
expt.evaluateTrackExpression('track.dq.thetaToBound \= diff(unwrap(\[track.dq.boundarytheta;track.dq.theta]));');

\[xim,yim,igrid,jgrid] \= structvar2grid(structvar);

gq \= GlobalQuantity;
gq.derivationMethod \= @GlobalQuantity.tri2Dinterpolation;
gq.xData \= \[xim';yim'];
gq.yData \= \[igrid';jgrid'];

gq.xField \= 'sloc';
gq.fieldname \= 'gridLoc';
expt.addGlobalQuantity(gq);

gq.xField \= 'shead';
gq.fieldname \= 'gridHead';
expt.addGlobalQuantity(gq);


\-\-\-

\#\#\# File: setBoundaryThickness.m (ID: useful extra classes.@CheckerExperiment.2\)

function setBoundaryThickness(expt, thickness)
%function setBoundaryThickness(expt, thickness)
%sets whether or not a point is on the boundary based on the given
%thickness; boundaryDistance must have already been calculated 

expt.boundaryThickness \= thickness;

corners \= false(expt.imsize);
inds \= sub2ind (size(corners), round(expt.structvar(:,2\)), round(expt.structvar(:,1\)));
corners(inds) \= true;
corners \= imdilate(corners, ones(round(expt.boundaryThickness/2\)));

\[x,y] \= meshgrid(1:expt.imsize(2\),1:expt.imsize(1\));
xdata(:,:,1\) \= x;
xdata(:,:,2\) \= y;
for j \= 1:length(expt.track)
 if (isfield(expt.track(j).dq, 'boundaryDistance'))
 %expt.track(j).dq.boundaryDistance \= abs(expt.track(j).dq.boundaryDistance);
 iscorner \= GlobalQuantity.twoDinterpolation(expt.track(j).getDerivedQuantity('sloc'), xdata, corners);
 expt.track(j).dq.onboundary \= abs(expt.track(j).dq.boundaryDistance) \<\= thickness/2 \& \~iscorner;
 % expt.track(j).dq.boundaryDistance(iscorner) \= \-expt.track(j).dq.boundaryDistance(iscorner);
 end
end
\-\-\-

\#\#\# File: addBoundary.m (ID: useful extra classes.@CheckerExperiment.3\)

function addBoundary(expt, boundaryDirImage, boundaryDistImage, lightImage)
%adds boundary information to a checkerboard experiment
%im \= boundaryImage is a 2D array with the following properties
%
%\*im(y,x) \= theta (\-pi \<\= theta \<\= pi) iff x,y is a point on the boundary of
% two squares, and not on the corner (intersection of two boundaries) 
% in this case, theta is the direction from the light square to the dark
% square
%
%\*im(y,x) \> 2\*pi iff x,y is on the corner of two squares
%
%\*im(y,x) \< \-2\*pi iff x,y is in the interior of a square
%
%im \= lightingImage is an array with the property
%im(y,x) \> 0 if x,y is in the light, and im(y,x) \< 0 if x,y is in the dark
%
%boundaryImage and lightingImage must be the size of the original camera
%image
gq \= GlobalQuantity();

\[x,y] \= meshgrid(1:size(boundaryDirImage,2\),1:size(boundaryDirImage,1\));

%x \= reshape(x,1,\[]);
%y \= reshape(y,1,\[]);

expt.calculateDerivedQuantity({'sloc', 'theta'});

gq.xField \= 'sloc';
gq.xData(:,:,1\) \= uint16(x);
gq.xData(:,:,2\) \= uint16(y);
gq.derivationMethod \= @GlobalQuantity.twoDinterpolation;

corners \= false(size(boundaryDirImage));
inds \= sub2ind (size(corners), round(expt.structvar(:,2\)), round(expt.structvar(:,1\)));
corners(inds) \= true;
corners \= imdilate(corners, ones(round(expt.boundaryThickness/2\)));

gq.fieldname \= 'onboundary';
gq.yData \= logical(abs(boundaryDistImage) \<\= expt.boundaryThickness/2 \& \~corners);
expt.addGlobalQuantity(gq);

gq.fieldname \= 'ininterior';
gq.yData \= logical(abs(boundaryDistImage) \> expt.boundaryThickness/2 \& \~corners);
expt.addGlobalQuantity(gq);

gq.fieldname \= 'boundarytheta';
gq.yData \= boundaryDirImage;
expt.addGlobalQuantity(gq);

gq.fieldname \= 'inlight';
gq.yData \= lightImage;
expt.addGlobalQuantity(gq);

gq.fieldname \= 'boundaryDistance';
gq.yData \= boundaryDistImage;
%gq.yData(corners) \= \- boundaryDistImage(corners);
expt.addGlobalQuantity(gq);

gq.xField \= 'shead';
gq.fieldname \= 'headBoundaryDistance';
expt.addGlobalQuantity(gq);

gq.fieldname \= 'headInLight';
gq.yData \= lightImage;
expt.addGlobalQuantity(gq);

gq.fieldname \= 'headOnBoundary';
gq.yData \= logical(abs(boundaryDistImage) \<\= expt.boundaryThickness/2 \& \~corners);
expt.addGlobalQuantity(gq);


%because these images are generally so large (btw 5 \& 40 MB depending on
%whether double, int, etc.) we delete all gq fields now, rather than save
%them

expt.globalQuantity \= \[];

end


\-\-\-

\#\#\# File: CheckerExperiment.m (ID: useful extra classes.@CheckerExperiment.4\)

classdef CheckerExperiment \< Experiment
 %A class that includes some special functions for setting up the
 %analysis of one of Ashley and Liz's famous checkerboard experiments
 %also, cures cancer
 
 properties
 structvar; %There is no god but structvar and structvar is his prophet
 boundaryThickness \= 30;
 imsize \= \[1944 2592];
 end
 
 methods
 addSpatialInfo(expt, varargin);
 addBoundary(expt, dirim,distim,lightim);
 setBoundaryThickness(expt, thickness);
 end
 
 methods %constructor
 function expt \= CheckerExperiment(varargin)
 expt \= expt@Experiment(varargin{:});
 if (length(varargin) \> 1 \&\& ischar(varargin{2}))
 try
 d \= dir(varargin{2});
 catch %\#ok
 return;
 end
 if (length(d) \=\= 1\)
 load(varargin{2}, 'structvar');
 expt.structvar \= structvar; %\#ok
 end
 end
 
 end
 end
 methods (Static)
 \[dirim,distim,interior] \= generateBoundaryImage(imsize, boundaryThickness, structvar);
 end
end


\-\-\-

\#\#\# File: generateBoundaryImage.m (ID: useful extra classes.@CheckerExperiment.5\)

function \[dirim,distim, interior] \= generateBoundaryImage(imsize, structvar)
%generates images of size imsize with the boundaries specified in
%structvar
%
%dirim gives the angle (in radians \-pi to pi) of the normal to the boundary
%distim gives the oriented distance to the nearest boundary
%distim \< 0 if the point is inside the squares
%interior is a logical array that is true for points inside the rectangle
%
%points that are not on any boundary have a distance of infinity and a 
%direction of \-100
%
%about structvar
%the first rule of structvar is you do not talk about structvar
%the second rule of structvar is you do not talk about structvar
%the third rule of structvar is that it is a Nx2 array of points,
%specifying rectangles
%the fourth rule of structvar is the lower left (in image coordinates; upper left in xy coords)
%corner comes first, then the other 3 points are specified in
%counterclockwise (in image coords; clockwise in xy coords) order
%the fifth rule of structvar is you do not talk about structvar
%

dirim \= zeros(imsize) \- 100;
distim \= Inf(imsize);

pt1 \= structvar(1:4:end,:);
pt2 \= structvar(2:4:end,:);
pt3 \= structvar(3:4:end,:);
pt4 \= structvar(4:4:end,:);

v \= pt2 \- pt1;
dir \= atan2(\-v(:,1\),v(:,2\));
\[distim,dirim] \= drawLineDistanceOnImage(distim, pt1, pt2, dirim, dir);
 
v \= pt3 \- pt2;
dir \= atan2(\-v(:,1\),v(:,2\));
\[distim,dirim] \= drawLineDistanceOnImage(distim, pt2, pt3, dirim, dir);
 
v \= pt4 \- pt3;
dir \= atan2(\-v(:,1\),v(:,2\));
\[distim,dirim] \= drawLineDistanceOnImage(distim, pt3, pt4, dirim, dir);
 
v \= pt1 \- pt4;
dir \= atan2(\-v(:,1\),v(:,2\));
\[distim,dirim] \= drawLineDistanceOnImage(distim, pt4, pt1, dirim, dir);
 
interior \= false(imsize);
\[x,y] \= meshgrid(1:size(dirim,2\),1:size(dirim,1\));
x \= reshape(x,1,\[]);
y \= reshape(y,1,\[]);
for j \= 0:(length(pt1\)\-1\)
 r \= structvar((1:4\)\+4\*j, :);
 interior(inpolygon(x,y,r(:,1\), r(:,2\))) \= true;
end
distim(interior) \= \-distim(interior);

\-\-\-

\#\#\# Folder: useful extra classes/@CheckerExperimentCalculator (ID: useful extra classes.@CheckerExperimentCalculator)

\-\-\-

\#\#\# File: assignGlobals.m (ID: useful extra classes.@CheckerExperimentCalculator.1\)

function assignGlobals(cec, expt,varargin)
%reassigns all tracked global quantities to all tracks
%function assignGlobalQuantities(expt,varargin)
%expt.assignGlobalQuantities
%
%reassigns all tracked global quantities (see expt.globalQuantity)
%to all tracks
%'fields', {fieldnames} only assings globals with given field names

if (length(expt) \> 1\)
 for j \= 1:length(expt)
 assignGlobals(cec, expt(j), varargin{:});
 disp (\[num2str(j) '/' num2str(length(expt)) ' experiments assigned']);
 end
 return;
end

fieldnames \= {};
varargin \= assignApplicable(varargin);
ts0 \= tic;

if (isempty(fieldnames))
 kinds \= 1:length(cec.globalQuantities);
else
 \[\~,kinds] \= intersect({cec.globalQuantities.fieldname}, fieldnames);
end
 

for k \= kinds
 ts1 \= tic;
 lasttime \= toc(ts1\); 
 gq \= cec.globalQuantities(k);
 %{
 for j \= 1:length(expt.track)
 gq.addQuantityToTrack(expt.track(j));
 if (toc(ts1\) \- lasttime \> 60\)
 disp (\[num2str(j) ' \- ' num2str(toc(ts1\))]); 
 lasttime \= toc(ts1\);
 end
 end
 %}
 expt.addGlobalQuantity(gq);
 if (toc(ts0\) \> 60\)
 disp (\[num2str(k) ' / ' num2str(length(kinds)) ' assigned']);
 ts0 \= tic;
 end
end

\-\-\-

\#\#\# File: CheckerExperimentCalculator.m (ID: useful extra classes.@CheckerExperimentCalculator.2\)

classdef CheckerExperimentCalculator \< handle
 %Calculates Parameters for Checker Experiments, based on provided image
 %of checkerboard and camera calibration
 % CheckerExperimentCalculator(pictureOfProjectedCheckerboard,
 % pictureOf1cmCheckerboard)
 % or
 % CheckerExperimentCalculator(pictureOfProjectedCheckerboard,
 % viscamcalibration)
 
 properties
 cc \= \[];
 borderSizeInCm \= 0\.2; %total width of border, in cm
 rx \= \[]; %real x axis (in cm) for morphedCheckerIm
 ry \= \[]; %real y axis (in cm) for morphedCheckerIm
 morphedCheckerIm \= \[]; %image of projected checkerboard, 
 %as it would appear if camera were
 %distortion\-free and calibrated in cm
 initialCheckerIm \= \[]; %picture of projected checkerboard, as taken by camera
 imageResolution \= 0\.01; %resolution of image, in cm
 globalQuantities \= \[];
 ai \= \[];
 end
 
 properties (Access \= protected)
 calculated \= false;
 end
 
 methods %set
 function set.borderSizeInCm(cec, value)
 if (cec.borderSizeInCm \~\= value)
 cec.calculated \= false; %\#ok
 end
 cec.borderSizeInCm \= value;
 end
 function set.imageResolution(cec, value)
 if (cec.imageResolution \~\= value)
 cec.calculated \= false; %\#ok
 end
 cec.imageResolution \= value;
 end
 end
 
 
 methods %constructor
 function cec \= CheckerExperimentCalculator(picOfChecker, picOfCBoard)
 if isa (picOfCBoard, 'CameraCalibration')
 cec.cc \= picOfCBoard;
 else
 cec.cc \= CameraCalibration(picOfCBoard);
 end
 cec.initialCheckerIm \= picOfChecker;
 end
 
 end
 
 methods
 calculate(cec);
 gq \= getGlobals(cec, varargin);
 assignGlobals(cec, expt, varargin);
 end
 
end


\-\-\-

\#\#\# File: calculate.m (ID: useful extra classes.@CheckerExperimentCalculator.3\)

function calculate(cec)
%function calculate(cec)

\[im,rxa,rya] \= cec.cc.morphCamToReal(cec.initialCheckerIm,'realresolution',cec.imageResolution);

cec.morphedCheckerIm \= im;
cec.rx \= rxa;
cec.ry \= rya;

borderpts \= cec.borderSizeInCm/cec.imageResolution;
cornerpts \= borderpts\*1\.5;
cec.ai \= analyzeCheckerIm(cec.morphedCheckerIm, borderpts, cornerpts);
cec.ai.distToBorder \= cec.imageResolution \* cec.ai.distToBorder;
cec.ai.distToDark \= cec.imageResolution \* cec.ai.distToDark;
cec.ai.distToLight \= cec.imageResolution \* cec.ai.distToLight;

cec.globalQuantities \= cec.getGlobals;


cec.calculated \= true;
\-\-\-

\#\#\# File: getGlobals.m (ID: useful extra classes.@CheckerExperimentCalculator.4\)

function gq \= getGlobals(cec, varargin)
%calculates global quantities to add to experiments based on checkerboard
%layout and cec settings
%
% optional args:
% locfield
% prefix
% example use: 
% cec.globalQuantities \= \[cec.getGlobals() cec.getGlobals('locfield', 'shead', 'prefix', 'head\_')];
% to get border quanties vs. position and head position
% note that thetaToBorder is only calculated if prefix is empty

locfield \= 'sloc';
prefix \= ''; %use prefix in combination with locfield to do e.g. head distance to border
varargin \= assignApplicable(varargin);

borderpts \= cec.borderSizeInCm/cec.imageResolution;
cornerpts \= borderpts\*1\.5;


%do logical fields
gq \= GlobalQuantity();
gq.xField \= locfield;
gq.derivationMethod \= @GlobalQuantity.interpLogicalIm;

aifields \= {'bwim', 'border', 'oncorner', 'interior'};
gqnames \= {'inlight', 'onborder', 'oncorner', 'interior'};
gq \= repmat(gq, \[1 length(aifields)]);
for j \= 1:length(aifields)
 gq(j).yData \= bwpack(cec.ai.(aifields{j}));
 upi \= bwunpack(gq(j).yData);
 rx \= interp1(cec.rx, 1:size(upi,2\), 'linear', 'extrap');
 ry \= interp1(cec.ry, 1:size(upi,1\), 'linear', 'extrap');
 xdata.x \= rx;
 xdata.y \= ry;
 gq(j).xData \= xdata;
 gq(j).fieldname \= \[prefix gqnames{j}];
end
gqlog \= gq;


maxval \= max(cec.ai.distToBorder(:)) \- borderpts;
minval \= min(cec.ai.distToBorder(:)) \+ borderpts;

bp \= ceil(borderpts);
zmid \= \[\-2\*bp:bp/5:\-bp \-bp:2:bp bp:bp/5:2\*bp];
ztop \= 2\*bp:2\*bp:maxval;
zbottom \= \-2\*bp:\-2\*bp:minval;


z \= unique(\[zbottom ztop zmid]);
c \= contourc(double(cec.ai.distToBorder),double(z));

ind \= \[];
nextind \= 1;
while (nextind \< length(c))
 ind \= \[ind, nextind]; %\#ok
 nextind \= nextind \+ c(2,nextind) \+ 1;
end
inds \= setdiff(1:length(c), ind);
cpts \= round(c(:,inds));
%{
datainds \= unique(sub2ind(size(cec.ai.distToDark), cpts(2,:), cpts(1,:)));

\[xx,yy] \= meshgrid(cec.rx, cec.ry);
edgeinds \= (find(xx \=\= min(xx(:)) \| xx \=\= max(xx(:)) \| yy \=\= min(yy(:)) \| yy \=\= max(yy(:))))';

datainds \= unique(\[datainds edgeinds]);
xx \= xx(datainds);
yy \= yy(datainds);
xData \= \[xx;yy];
%}
gq \= GlobalQuantity();
gq.xField \= locfield;
\[xx,yy] \= meshgrid(cec.rx, cec.ry);
xdata.x \= xx;
xdata.y \= yy;
gq.xData \= xdata;
gq.derivationMethod \= @GlobalQuantity.twoDinterpolation;

gq \= repmat(gq, 1, 3\);

gq(1\).fieldname \= \[prefix 'distToBorder'];
gq(1\).yData \= cec.ai.distToBorder;

gq(2\).fieldname \= \[prefix 'dirToBorder'];
gq(2\).yData \= cec.ai.dirToBorder;
gq(2\).derivationMethod \= @GlobalQuantity.interpAngleIm;
%gq(2\).yData \= cat(3,cos(cec.ai.dirToBorder), sin(cec.ai.dirToBorder));

gq(3\).fieldname \= \[prefix 'borderNum'];
gq(3\).xData \= \[];
gq(3\).yData \= \[];
onb \= \[prefix 'onborder'];
dtb \= gq(2\).fieldname;
gq(3\).xField \= {onb, dtb};
eval (\['gq(3\).derivationMethod \= @(xin, xdata, ydata) \-1\*(\~xin.' onb ') \+ xin.' onb '.\*(mod(round(mod(xin.' dtb ', 2\*pi)\*2/pi), 4\));']);
n \= length(gq);
if (isempty(prefix))
 gq(n\+1\).xField \= {gq(2\).fieldname, 'theta'};
 gq(n\+1\).yData \= \[];
 gq(n\+1\).xData \= \[];
 gq(n\+1\).derivationMethod \= @(xin, xdata, ydata) diff(unwrap(\[xin.dirToBorder;xin.theta]));
 gq(n\+1\).fieldname \= 'thetaToBorder';
end

gq \= \[gqlog gq];

\-\-\-

\#\#\# Folder: @TrackPart (ID: @TrackPart)

\-\-\-

\#\#\# File: myMovie.m (ID: @TrackPart.1\)

function myMovie (tp, mtype, varargin) 
%function myMovie (tp, mtype, varargin) 
%
%plays movie, or sequence of movies, for the segments of trackpart
%tp can be a single trackpart or an array of trackparts
%
%in addition to the argument pairs that can be passed to track.playMovie 
%you can additionally pass
%
%'nreps', n (default 1\): number of times to repeat playing each trackpart
%movie
%'ptbuffer', n (default 10\): number of points before and after inds to play
%
%'nopause', t/f (default false): if true, don't pause between trackparts if
%tp is an array

nopause \= false;
showind \= false;
varargin \= assignApplicable(varargin);

if (length(tp) \> 1\)
 for j \= 1:length(tp)
 if (showind)
 disp(num2str(j));
 end
 tp(j).myMovie(mtype, varargin{:});
 if (\~nopause)
 pause;
 end
 end
 return;
end

nreps \= 1;
ptbuffer \= 10;
delayTime \= 0\.05;
%class(tp)
if (isa(tp, 'HeadSwing'))
 delayTime \= 0\.15;
 ptbuffer \= 3;
end
if (isa(tp, 'MaggotReorientation'))
 delayTime \= 0\.1;
 ptbuffer \= 3;
end

varargin \= assignApplicable(varargin);
p2i \= tp.track.getDerivedQuantity('mapInterpedToPts');

si \= max(p2i(tp.startInd) \- ptbuffer, 1\);
ei \= min(p2i(tp.endInd) \+ ptbuffer, tp.track.npts);
 
figure(gcf);
for j \= 1:nreps
 tp.track.(mtype)('inds', si:ei, 'delayTime', delayTime, 'highlightInds', tp.startInd:tp.endInd, varargin{:});
end
\-\-\-

\#\#\# File: TrackPart.m (ID: @TrackPart.2\)

classdef TrackPart \< handle
 %Basic superclass for anything that labels a section of track
 %for instance, runs, reorientations, headswings, potty breaks
 
 properties(Transient \= true, AbortSet \= true)
 track;
 end
 
 properties
 
 startInd \= 0;
 endInd \= 0;
 inds \= \[];
 valid \= true; %note, not the same as isvalid
 end
 
 methods
 qvec \= getDerivedQuantity (tp, field, varargin);
 \[qv, datamatrix] \= averageDerivedQuantity (tp, field, centerpos, offsetinds, varargin);
 
 playMovie (tp, varargin);
 movieOps \= makeMovie(track, movieOps, varargin);
 prettyMovie (tp, varargin);
 tf \= containsIndex(tp, ind); 
 str \= getReport(tp, varargin);
 h \= plotFields (tp, xfield, yfields, varargin);
 plotPath(tp, pathType, linetype, varargin);
 end
 methods (Access \= protected)
 myMovie (tp, mtype, varargin);
 
 function atp \= getAdjacent(tp, direction, fieldname)
 if (isempty(tp.track) \|\| \~isa(tp.track, 'Track'))
 disp ('trackpart doesn''t point to track');
 atp \= \[];
 return;
 end
 t \= tp.track;
 f \= \[t.(fieldname)];
 if (\~isa(f, 'TrackPart'))
 %disp ('desired field isn''t a trackpart');
 atp \= \[];
 return
 end
 \[\~,I] \= sort(\[f.startInd]);
 f \= f(I);
 if (direction(1\) \=\= 'n')
 ind \= find(\[f.endInd] \> tp.endInd, 1, 'first');
 atp \= f(ind);
 else
 ind \= find(\[f.startInd] \< tp.startInd, 1, 'last');
 atp \= f(ind);
 end
 
 end
 
 
 end
 
end


\-\-\-

\#\#\# File: averageDerivedQuantity.m (ID: @TrackPart.3\)

function \[qv, datamatrix] \= averageDerivedQuantity (tp, field, centerpos, offsetinds, varargin)
%function \[qv, datamatrix] \= averageDerivedQuantity (tp, field, centerpos, offsetinds, varargin)
%
%gets derived quantity field from tp.track, subject to the following
%parameter/value pairs
%'position', pos
%pos \= 'first' or 'start' \-\- value at tp.startInd
%pos \= 'last' or 'end' \-\- value at tp.endInd
%pos \= fieldname \-\- value at tp.fieldname (e.g. fieldname \= startInd,
% centralInd)
%pos \= 'atMax' \-\- value at tp.maxInd : only valid for head swings
%pos \= 'mean' \-\- mean of all values
%pos \= 'all' \-\- all values, this is the default behavior
%pos \= 'min' or 'minimum' \-\- minimum of all values
%pos \= 'max' or 'maximum' \-\- maximum of all values
%pos \= 'maxabs' or 'minabs' \-\- value that is farthest or closest from 0
%
%'posoffset', m
% gets the value at the index offset by m points from position
% (just adds m to inds); m can be positive or negative
% if posoffset causes ind to be outside track values, the inds are coerced to the nearest valid value 
%
%'reltpfield', rtpf
%relative track part field: calls tp.(rtpf).getDerivedQuantity(field,
%varargin(:))
%e.g. 'reltpfield', 'prevRun', 'pos', 'end' will get the last point from
%the previous run
%
%'trimpct', f fraction btwn 0 and 0\.5; only take the part of the trackpart
% between f and 1\-f
%'trimpts', npts; only take the part of the track between npts and
% end\-npts; if this would be no points, then the return is empty
%'operation', op
%applied to quantity before position is applied (i.e. before taking
%min, max, mean, etc.)
%newquantity \= op(quantity) 
%examples \-\- 'operation', 'abs' or 'operation', @abs

datamatrix \= NaN(length(tp), length(offsetinds));
for j \= 1:length(tp)
 fv \= tp(j).getDerivedQuantity(field, 'position', centerpos, 'posoffset', offsetinds, varargin{:});
 if (length(fv) \< size(datamatrix,2\))
 inds \= tp(j).getDerivedQuantity('validinds', 'position', centerpos, 'posoffset', offsetinds, varargin{:});
 datamatrix(j,inds) \= fv;
 else
 datamatrix(j,:) \= fv;
 end
 datamatrix2 \= datamatrix;
 datamatrix2(\~isfinite(datamatrix)) \= 0; %replace unknown values with 0
end
qv \= sum(datamatrix2\)./sum(isfinite(datamatrix)); %average is sum of known values / number of known values
 

 

\-\-\-

\#\#\# File: plotPath.m (ID: @TrackPart.4\)

function plotPath(tp, pathType, linetype, varargin)
%function plotPath(tp, pathType, linetype, varargin)
%
%optional args, in addition to those passed to Track.plotPath
%'ptbuffer', n (default 10\): number of points before and after inds to plot
%

Axes \= \[];
varargin \= assignApplicable (varargin);
if (isempty(Axes))
 Axes \= gca;
end 

existsAndDefault('linetype', 'k\-');
existsAndDefault('pathType', 'sloc');
 
if (length(tp) \> 1\)
 ih \= ishold(Axes);
 for j \= 1:length(tp)
 tp(j).plotPath(pathType, linetype, 'Axes', Axes, varargin{:});
 hold (Axes,'on');
 end
 if (\~ih)
 hold (Axes,'off');
 end
 return;
end
ptbuffer \= 10;
highlightlinetype \= 'r\-';
varargin \= assignApplicable(varargin);

si \= max(tp.startInd \- ptbuffer, 1\);
ei \= min(tp.endInd \+ ptbuffer, length(tp.track.getDerivedQuantity('eti')));

tp.track.plotPath(pathType, linetype, 'inds', si:ei, 'highlightinds', tp.startInd:tp.endInd, 'highlightlinetype', highlightlinetype, ...
 'Axes', Axes, varargin{:});

\-\-\-

\#\#\# File: getReport.m (ID: @TrackPart.5\)

function str \= getReport(tp, varargin)
%generates a text report about a track part
%function str \= getReport(tp, varargin)
%
%output: STR (a string, or cell of strings if multiple trackparts)
%input: TP \< TrackPart
%optional arguments:
% meanFields: default {'speed'}: fields over which to display a mean
% value

if (length(tp) \> 1\)
 for j \= 1:length(tp)
 str{j} \= tp(j).getReport(varargin{:});
 end
 return;
end

meanFields \= {'speed'};
precision \= '%.1f';
varargin \= assignApplicable(varargin);

time \= tp.track.getDerivedQuantity('eti', false, \[tp.startInd tp.endInd]);
loc \= tp.track.getDerivedQuantity('iloc', false, \[tp.startInd tp.endInd]);
displacement \= diff(tp.track.getDerivedQuantity('pathLength', false, \[tp.startInd tp.endInd]));

locStr \= {\['Start: time \= ' num2str(time(1\), precision) ' x \= ' num2str(loc(1,1\), precision) ', y \= ' num2str(loc(2,1\), precision)],...
 \['End: time \= ' num2str(time(2\), precision) ' x \= ' num2str(loc(1,2\), precision) ', y \= ' num2str(loc(2,2\), precision)]};
 
dx \= diff(loc,\[],2\);

straightDist \= sqrt(sum(dx.^2\));
straightAngle \= rad2deg(atan2(dx(2\), dx(1\)));
displacementStr \= \['Elapsed time: ' num2str(diff(time), precision) ' s. Straight line distance \= ' num2str(straightDist, precision) ...
 ' angle \= ' num2str(straightAngle, precision) '(d) Path length \= ' num2str(displacement, precision)];
 
 
meanstr \= {};

for j \= 1:length(meanFields)
 meanstr \= \[meanstr \['mean ' meanFields{j} ': ' num2str(tp.getDerivedQuantity(meanFields{j}, 'position', 'mean'), precision)]]; %\#ok
end
 
str \= \[locStr, {displacementStr}, meanstr];
\-\-\-

\#\#\# File: playMovie.m (ID: @TrackPart.6\)

function playMovie (tp, varargin) 
%function playMovie (tp, varargin) 
%
%plays movie, or sequence of movies, for the segments of trackpart
%tp can be a single trackpart or an array of trackparts
%
%in addition to the argument pairs that can be passed to track.playMovie 
%you can additionally pass
%
%'nreps', n (default 1\): number of times to repeat playing each trackpart
%movie
%'ptbuffer', n (default 10\): number of points before and after inds to play
%
%'nopause', t/f (default false): if true, don't pause between trackparts if
%tp is an array

tp.myMovie('playMovie', varargin{:});

%{
nopause \= false;
varargin \= assignApplicable(varargin);

if (length(tp) \> 1\)
 for j \= 1:length(tp)
 tp(j).playMovie(varargin{:});
 if (\~nopause)
 pause;
 end
 end
end

nreps \= 1;
ptbuffer \= 10;
varargin \= assignApplicable(varargin);

p2i \= tp.track.getDerivedQuantity('mapInterpedToPts');

si \= max(p2i(tp.startInd) \- ptbuffer, 1\);
ei \= min(p2i(tp.endInd) \+ ptbuffer, tp.track.npts);
 
figure(gcf);
for j \= 1:nreps
 tp.track.playMovie('inds', si:ei, varargin{:});
end
%}
\-\-\-

\#\#\# File: plotFields.m (ID: @TrackPart.7\)

function h \= plotFields (tp, xfield, yfields, varargin)
% plots relevant fields from track part 
% see Track.plotFields
% tp \< TrackPart
% xfield \< field that forms x axis
% yfields \< field(s) to plot vs. xfield
% varargin:
% 'Axes', axes to plot in (default gca)
% anything that can be passed to plot
% 'ptbuffer' \= 30: number of points on either side to plot

Axes \= \[];
ptbuffer \= 30;
varargin \= assignApplicable(varargin);
if (isempty(Axes))
 Axes \= gca;
end



si \= max(tp.startInd \- ptbuffer, 1\);
ei \= min(tp.endInd \+ ptbuffer, length(tp.track.getDerivedQuantity('eti')));

ih \= ishold (Axes);
h{1} \= tp.track.plotFields(xfield, yfields, 'inds', si:ei, 'LineWidth', 1, 'Axes', Axes, varargin{:});
hold (Axes, 'on');
h{2} \= tp.track.plotFields(xfield, yfields, 'inds', tp.startInd:tp.endInd, 'LineWidth', 3, 'Axes', Axes, varargin{:}, 'makeLegend', false);
if (\~ih)
 hold(Axes, 'off');
end
\-\-\-

\#\#\# File: containsIndex.m (ID: @TrackPart.8\)

function tf \= containsIndex(tp, ind) 
%returns a vector of logical indices indicating whether ind is in tp(j)
%function tf \= containsIndex(tp, ind) 
%
% TP \< trackPart
% ind \< positive integer 
if (isempty(tp))
 tf \= \[];
 return;
end
if (length(tp) \> 1\)
 tf \= false(size(tp));
 for j \= 1:length(tp)
 tf(j) \= tp(j).containsIndex(ind);
 end
 return;
end

tf \= ind \>\= tp.startInd \&\& ind \<\= tp.endInd;

\-\-\-

\#\#\# File: prettyMovie.m (ID: @TrackPart.9\)

function prettyMovie (tp, varargin) 
%function prettyMovie (tp, varargin) 
%
%plays movie, or sequence of movies, for the segments of trackpart
%tp can be a single trackpart or an array of trackparts
%
%in addition to the argument pairs that can be passed to track.playMovie 
%you can additionally pass
%
%'nreps', n (default 1\): number of times to repeat playing each trackpart
%movie
%'ptbuffer', n (default 10\): number of points before and after inds to play
%
%'nopause', t/f (default false): if true, don't pause between trackparts if
%tp is an array

tp.myMovie('prettyMovie', varargin{:});

\-\-\-

\#\#\# File: getDerivedQuantity.m (ID: @TrackPart.10\)

function qv \= getDerivedQuantity (tp, field, varargin)
%function qv \= getDerivedQuantity (tp, field, varargin)
%
%gets derived quantity field from tp.track, subject to the following
%parameter/value pairs
%'position', pos
%pos \= 'first' or 'start' \-\- value at tp.startInd
%pos \= 'last' or 'end' \-\- value at tp.endInd
%pos \= fieldname \-\- value at tp.fieldname (e.g. fieldname \= startInd,
% centralInd)
%pos \= 'atMax' \-\- value at tp.maxInd : only valid for head swings
%pos \= 'mean' \-\- mean of all values
%pos \= 'all' \-\- all values, this is the default behavior
%pos \= 'min' or 'minimum' \-\- minimum of all values
%pos \= 'max' or 'maximum' \-\- maximum of all values
%pos \= 'maxabs' or 'minabs' \-\- value that is farthest or closest from 0
%
%'posoffset', m
% gets the value at the index offset by m points from position
% (just adds m to inds); m can be positive or negative
% if posoffset causes ind to be outside track values, the inds are coerced to the nearest valid value 
%
%'reltpfield', rtpf
%relative track part field: calls tp.(rtpf).getDerivedQuantity(field,
%varargin(:))
%e.g. 'reltpfield', 'prevRun', 'pos', 'end' will get the last point from
%the previous run
%
%'trimpct', f fraction btwn 0 and 0\.5; only take the part of the trackpart
% between f and 1\-f
%'trimpts', npts; only take the part of the track between npts and
% end\-npts; if this would be no points, then the return is empty
%'operation', op
%applied to quantity before position is applied (i.e. before taking
%min, max, mean, etc.)
%newquantity \= op(quantity) 
%examples \-\- 'operation', 'abs' or 'operation', @abs

if (length(tp) \> 1\)
 qv \= \[];
 for j \= 1:length(tp)
 
 qv \= \[qv tp(j).getDerivedQuantity(field, varargin{:})];
 
 end
 return;
end

reltpfield \= \[];
varargin \= assignApplicable(varargin);
if (\~isempty(reltpfield))
 qv \= tp.(reltpfield).getDerivedQuantity(field, varargin{:});
 return;
end

position \= 'all';
operation \= \[];
trimpct \= \-1;
trimpts \= \-1;
posoffset \= 0;
varargin \= assignApplicable (varargin);



if (tp.startInd \> tp.endInd)
% warning ('TP:GDQ', 'trackpart indices are out of order!');
 temp \= tp.startInd;
 tp.startInd \= tp.endInd;
 tp.endInd \= temp;
 tp.inds \= tp.startInd:tp.endInd;
end
if (iscell(position))
 qv \= tp.(position{1}).getDerivedQuantity(field, 'position', position{2});
 return;
end

if (any(strcmp(field, fieldnames(tp.track))) \&\& \~(strcmpi(field, 'isrun') \|\| strcmpi(field, 'iscollision')))
 qv \= tp.track.(field);
 return;
end

switch (lower(position))
 case {'first','start'}
 inds \= tp.startInd;
 case {'last', 'end'}
 inds \= tp.endInd;
 case {'atmax'}
 inds \= tp.maxInd;
 otherwise
 if (any(strcmp(properties(tp), position)))
 inds \= tp.(position);
 else
 inds \= tp.inds;
 %inds \= tp.startInd:tp.endInd;
 end
end
maxind \= length(tp.track.getDerivedQuantity('eti'));
%remove invalid indices before the offset math
inds \= inds(inds \> 0 \& inds \<\= maxind); 

if (\~isempty(inds)) 
 inds \= inds \+ posoffset;
 %inds(inds \< 1\) \= 1;
 %inds(inds \> maxind) \= maxind;
end
if (trimpct \> 0 \&\& trimpts \> 0\)
 warning('TP:QGD', 'trackpart.getDerivedQuantity: you cannot ask me to trim both by percent and by points');
end
if (trimpct \> 0\)
 if (trimpct \> 0\.5\)
 warning('TP:QGD', 'trackpart.getDerivedQuantity: trimpct must be \< 0\.5');
 else
 npts \= tp.endInd \- tp.startInd;
 inds \= floor(tp.startInd \+ trimpct \* npts) : ceil(tp.endInd \- trimpct\*npts);
 end
end
if (trimpts \> 0\)
 inds \= (tp.startInd \+ trimpts):(tp.endInd \- trimpts);
end

if (\~isempty(tp.track) \&\& \~isempty(inds))
 tr \= tp.track;
 if (strcmpi(field, 'validinds')) 
 qv \= (inds \>\= 1 \& inds \<\= length(tr.getDerivedQuantity('eti')));
 else
 tr.calculateDerivedQuantity({'eti', field}); 
 inds \= inds(inds \>\= 1 \& inds \<\= length(tp.track.dq.eti));
 qv \= tr.getDerivedQuantity(field, false, inds);
 end
else
% warning('TP:GDQ', 'trackpart.getDerivedQuantity: trackpart has no track or empty indices');
 % tp
% tp.track
 qv \= \[];
 return;
end
if (\~isempty(operation))
 if (ischar(operation))
 operation \= str2func(operation);
 end
 if (isa (operation, 'function\_handle'))
 qv \= operation(qv);
 end
end

switch (lower(position))
 case 'mean'
 qv \= mean(qv, 2\);
 case {'min', 'minimum'}
 qv \= min(qv,\[], 2\);
 case {'max', 'maximum'}
 qv \= max(qv,\[],2\);
 case {'maxabs', 'minabs'}
 if (size(qv,1\) \> 1\)
 qv2 \= sum(qv.^2\);
 else
 qv2 \= abs(qv);
 end
 if (strcmpi(position, 'maxabs'))
 \[\~,I] \= max(qv2\);
 else
 \[\~,I] \= min(qv2\);
 end
 qv \= qv(:,I);
end
end

 

\-\-\-

\#\#\# Folder: @WormTrack (ID: @WormTrack)

\-\-\-

\#\#\# File: segmentTrack.m (ID: @WormTrack.1\)

function segmentTrack (track, wormSegmentOptions, varargin)
% segments TRACK into runs \& reorientations using WORMSEGMENTOPTIONS
% function segmentTrack (track, wormSegmentOptions)
%
% worm track segmentation
% outputs: none
% inputs:
% TRACK \< Track
% WORMSEGMENTOPTIONS \< WormSegmentOptions
%
% for explanation of segment options, doc WormSegmentOptions
%
% 'UseExistingSharpTurns', \[false]/true, if true, don't find new
% sharp turns \-\- so that when we load them from file, we don't nuke
% existing sharp turns \-\- if false, we overwrite existing turns, unless
% user has already started flagging
%
% 'OverwriteExistingSharpTurns', \[false]/true, if true, we
% overwrite existing turns EVEN IF USER HAS ALREADY FLAGGED THEM,
% eliminating user codes

existsAndDefault('wormSegmentOptions', track.so);
wso \= wormSegmentOptions;
track.so \= wso;
track.run \= \[];
track.reorientation \= \[];
track.sharpTurn \= \[];
track.flagReorientations(wso, varargin{:});

if (isempty(track.reorientation))
 runstart \= 1;
 runend \= length(track.dq.eti);
else

 %kill first reorientation if it does not follow a run
 if (track.dq.eti(track.reorientation(1\).startInd) \- track.dq.eti(1\) \< wso.minRunTime)
 rs0 \= track.reorientation(1\).endInd \+ 1;
 track.reorientation \= track.reorientation(2:end);
 else
 rs0 \= 1;
 end
 
 %kill last reorientation if it does not precede a run
 if (isempty(track.reorientation))
 runstart \= 1;
 runend \= length(track.dq.eti);
 else
 if (track.dq.eti(end) \- track.dq.eti(track.reorientation(end).endInd) \< wso.minRunTime)
 relast \= track.reorientation(end).startInd \- 1;
 track.reorientation \= track.reorientation(1:(end\-1\));
 else
 relast \= length(track.dq.eti);
 end
 runstart \= \[rs0 (\[track.reorientation.endInd]\+1\)];
 runend \= \[(\[track.reorientation.startInd]\-1\) relast];
 end
end
%run(1\) has no previous reorientation
%run(1\): next reorientation is reorientation(1\)
for j \= 1:length(runstart)
 run(j) \= Run(track, runstart(j), runend(j));
 %{
 if (j \> 1\)
 run(j).previousRun \= run(j\-1\);
 run(j).prevReorientation \= track.reorientation(j\-1\);
 run(j\-1\).nextRun \= run(j);
 run(j\-1\).nextReorientation \= track.reorientation(j\-1\);
 end
 %}
end

track.run \= run;
track.isrun \= false(size(track.dq.eti));
track.isrun(\[track.run.inds]) \= true;
track.reorientation.calculateMetrics;

\-\-\-

\#\#\# File: plotSegmentation.m (ID: @WormTrack.2\)

function plotSegmentation(track, varargin)
% plots the segments of the track (runs \& reorientations) graphically
% function plotSegmentation(track, varargin)
%
% outputs: none
% inputs:
% TRACK \< Track;
% VARARGIN: optional parameter/value pairs
% 'Axes', ax : which axes to plot to, default gca
% 'fieldName', fieldName : what field to plot, default 'sloc'
% 'stMarkerSize', pts : size in points of the markers for sharp turns,
% default 10
% 'multicolor', tf : default true, whether to plot each track in a
% different color
% anything that can be passed to PLOT, affects plotting of runs only

Axes \= \[];
fieldName \= 'sloc';
stMarkerSize \= 10;
multicolor \= true;
varargin \= assignApplicable(varargin);
if (isempty(Axes))
 Axes \= gca;
end

ih \= ishold(Axes);

for j \= 1:length(track.run)
 if (multicolor)
 col \= nthcolor(j);
 else
 col \= 'b\-';
 end
 track.plotPath(fieldName, col, 'inds', track.run(j).inds, 'Axes', Axes, varargin{:});
 hold(Axes, 'on');
end

axes(Axes);
for j \= 1:length(track.sharpTurn)
 switch(track.sharpTurn(j).typeCode)
 case \-1
 letter \= '\\Omega';
 col \= 'm';
 case 0
 letter \= 'b';
 col \= 'g';
 case 1
 letter \= 'R';
 col \= 'r';
 case 2
 letter \= 'R2';
 col \= 'g';
 end
 loc \= double(track.dq.sloc(:,track.sharpTurn(j).centralInd));
 text(loc(1\), loc(2\), letter, 'Color', col, 'HorizontalAlignment', 'Center');
% track.plotPath(fieldName, mc, 'inds', track.sharpTurn(j).centralInd, 'Axes', Axes, 'MarkerSize', stMarkerSize);
end

for j \= 1:length(track.reorientation)
 track.plotPath(fieldName, 'k\-', 'inds', track.reorientation(j).inds,'Axes',Axes,'Color', \[0\.7 0\.7 0\.7]);
end
if (\~ih)
 hold(Axes,'off');
end
%for j \= 1:length(

\-\-\-

\#\#\# File: restoreSaveData.m (ID: @WormTrack.3\)

function track \= restoreSaveData(track)
%function track \= restoreSaveData(track)

sd \= track.saveData;

 
if isempty(sd) \|\| \~all(isfield(sd, {'sharpTurnStart', 'sharpTurnEnd', 'sharpTurnTypeCode', 'sharpTurnUserCode'})) \|\| isempty(sd.sharpTurnStart) \|\| isempty(sd.sharpTurnEnd) \|\| isempty(sd.sharpTurnTypeCode)
 return;
end


for j \= 1:length(sd.sharpTurnStart)
 sharpTurn(j) \= WormSharpTurn(track, sd.sharpTurnStart(j), sd.sharpTurnEnd(j)); %\#ok\<\*AGROW\>
 sharpTurn(j).userCode \= sd.sharpTurnUserCode(j);
 if (sign(sharpTurn(j).typeCode) \~\= sign(sd.sharpTurnTypeCode(j)))
 disp (\['on load, calculated sharp turn type code ' num2str(sharpTurn(j).typeCode) ...
 ' disagrees with saved type code ' num2str(sd.sharpTurnTypeCode(j))]);
 end
 sharpTurn(j).typeCode \= sd.sharpTurnTypeCode(j);
 
end

track.sharpTurn \= sharpTurn;
track.segmentTrack(track.so, 'UseExistingSharpTurns', true);
%{
sd.sharpTurnStart \= \[track.sharpTurn.startInd];
sd.sharpTurnEnd \= \[track.sharpTurn.endInd];
sd.sharpTurnTypeCode \= \[track.sharpTurn.typeCode];
sd.sharpTurnUserCode \= \[track.sharpTurn.userCode];
track.saveData \= sd;
%}

\-\-\-

\#\#\# File: flagReorientations.m (ID: @WormTrack.4\)

function flagReorientations (track, wormSegmentOptions, varargin)
% groups sharp turns into periods of reorientation
% function flagReorientations (track, wormSegmentOptions)
%
% called by SegmentTrack; not usually used directly by end user
%
% outputs: none
% inputs: 
% TRACK: member of the track class (note MaggotTrack segmentation
% proceeds differently)
% WORMSEGMENTOPTIONS: segmentation options, see WormSegmentOptions class
% for details
% optional: 'UseExistingSharpTurns', \[false]/true, if true, don't find new
% sharp turns \-\- so that when we load them from file, we don't nuke
% existing sharp turns
% optional: 'OverwriteExistingSharpTurns', \[false]/true, if true, we
% overwrite existing turns EVEN IF USER HAS ALREADY FLAGGED THEM,
% eliminating user codes


existsAndDefault('wormSegmentOptions', track.so);
wso \= wormSegmentOptions;
track.so \= wso;
UseExistingSharpTurns \= false;
OverwriteExistingSharpTurns \= false;
varargin \= assignApplicable(varargin);


track.calculateDerivedQuantity({'eti', 'sloc', 'theta', 'deltatheta', 'ddtheta'});
if (isempty(track.sharpTurn) \|\| ((OverwriteExistingSharpTurns \|\| \~any(isfinite(\[track.sharpTurn.userCode]))) \&\& \~UseExistingSharpTurns))
 flagOmegaTurnsAndReversals (track, wso, varargin{:});
end
reoind \= 0;
st \= track.sharpTurn;
%group reorientations
%if two sharp turns are less than minRunTime apart (in seconds), they're
%part of the same reorientation
eti \= track.getDerivedQuantity('eti');
inreverse \= false;
for j \= 1:length(st)
 switch st(j).typeCode
 case {\-1,0}
 if (inreverse \&\& eti(st(j).startInd) \- eti(st(j\-1\).endInd) \< wso.maxBackTime)
 nextreo \= false;
 else
 nextreo \= (j \=\= 1 \|\| (eti(st(j).startInd) \- eti(st(j\-1\).endInd) \> wso.minRunTime));
 end
 inreverse \= false;
 case {1,2}
 if (inreverse \&\& eti(st(j).startInd) \- eti(st(j\-1\).endInd) \< wso.maxBackTime)
 st(j).typeCode \= 2;
 nextreo \= false;
 inreverse \= false;
 else
 nextreo \= (j \=\= 1 \|\| (eti(st(j).startInd) \- eti(st(j\-1\).endInd) \> wso.minRunTime));
 inreverse \= true;
 end
 otherwise
 j
 st(j)
 st(j).type
 pause
 end
 if (nextreo) % change from difference in central ind to difference from end to start
 if (reoind \> 0\)
 reo(reoind).calculateMetrics;
 end
 reoind \= reoind\+1;
 reo(reoind) \= WormReorientation(); %\#ok
 end
 reo(reoind).addTurn(st(j)); 
 reo(reoind).calculateMetrics();
end

track.reorientation \= reo;
\-\-\-

\#\#\# File: playMovie.m (ID: @WormTrack.5\)

function playMovie(track, varargin)
% plays a movie of the track with annotation
% function playMovie(track, varargin)
% outputs, none
% inputs:
% TRACK \< Track;
% VARARGIN:
% enter options as pairs, caps matter
% options, with defaults
%
% ptbuffer \= 200; \-\- how many points on either side of the current point
% to plot in annotations
% delayTime \= 0\.05; \-\- interframe delay
% axisSize (size of image or 50\) \-\- size of axes containing image
% inds \= 1:length(track.pt); \-\- inds to play
% iinds \= \[]; interped inds; if passed, we find inds \=
% gdq(mapinterpedtopts,iinds)
% startLoc \= \[];
% stopLoc \= \[]; if startLoc \& stopLoc are both not empty, we run the movie
% between these two points
% startTime \= \[];
% stopTime \= \[]; if startTime \& stopTime are both not empty, we run the
% movie between these times
% locField \= 'sloc'; what field to use to plot the path over the movie
% image
% Axes, subplot(2,2,1:4\) \-\- if passed in, we use these axes. 
% if Axes has length 1, we only draw the movie part, not the data
% fields
% LabelTurns \= true \-\- if false, we don't mark sharp turns on the graph
% highlightInds \= \[]; \-\- specify (interped) inds to draw over movie
% highlightLineType \= 'r.'; 

ptbuffer \= 200;
delayTime \= 0\.1;
cc \= track.expt.camcalinfo;
axisSize \= max(size(track.pt(1\).imData));
if (axisSize \<\= 0\)
 axisSize \= 20;
end
if (\~isempty(cc))
 axisSize \= axisSize \* cc.realUnitsPerPixel;
end
iinds \= \[];
inds \= 1:length(track.pt);
startLoc \= \[];
stopLoc \= \[];
startTime \= \[];
stopTime \= \[];
track.expt.openDataFile;
fid \= track.expt.fid;
locField \= 'sloc';
Axes \= \[];
highlightInds \= \[];
highlightLineType \= 'r.';
LabelTurns \= true;
varargin \= assignApplicable(varargin);
if (isempty(Axes))
 for j \= 1:4
 Axes(j) \= subplot(2,2,j);
 end
end

if (\~isempty(iinds))
 inds \= track.getDerivedQuantity('mapinterpedtopts', false,iinds);
end
if (\~isempty(startLoc) \&\& \~isempty(stopLoc))
 \[\~,s] \= track.nearestPoint (startLoc);
 \[\~,e] \= track.nearestPoint (stopLoc);
 if (s \> e)
 inds \= e:s;
 else
 inds \= s:e;
 end
end
pt \= \[track.pt];
if (\~isempty(startTime) \&\& \~isempty(stopTime))
 s \= find(\[pt.et] \>\= startTime, 1, 'first');
 e \= find(\[pt.et] \<\= stopTime, 1, 'last');
 inds \= s:e;
end
loc \= \[pt.loc];
sloc \= double(track.getDerivedQuantity(locField));
sind \= track.getDerivedQuantity('mapptstointerped');
track.calculateDerivedQuantity({'speed', 'deltatheta', 'ddtheta'});
sstart \= sind(1\) \- ptbuffer;
send \= sind(end) \+ ptbuffer;


if (sstart \< 1\)
 sstart \= 1;
end
if (send \> length(sloc))
 send \= length(sloc);
end
st \= \[track.sharpTurn];
if (\~isempty(st))
 st \= st(\[st.endInd] \> sstart \& \[st.startInd] \< send);
 revinds \= \[st(\[st.typeCode] \> 0\).centralInd];
 omegainds \= \[st(\[st.typeCode] \< 0\).centralInd];
 blipinds \= \[st(\[st.typeCode] \=\= 0\).centralInd];
else
 revinds \= \[];
 omegainds \= \[];
 blipinds \= \[];
end
if (length(Axes) \>\= 4\)
 datafields(track, sstart:send, Axes(2:4\));
end
handles \= \[];
for j \= inds
 ts1 \= tic();
 %subplot(2,2,1\); hold off; cla
 cla(Axes(1\));
 pt(j).drawTrackImage(cc,'fid', fid, 'Axes', Axes(1\), varargin{:}); 
 
 %pause
 
 hold (Axes(1\), 'on');
 sstart \= sind(j) \- ptbuffer;
 send \= sind(j) \+ ptbuffer;
 if (sstart \< 1\)
 sstart \= 1;
 end
 if (send \> length(sloc))
 send \= length(sloc);
 end
 
 plot (Axes(1\), sloc(1,sstart:send), sloc(2,sstart:send), 'b.\-');
 plot (Axes(1\), sloc(1,sind(j)), sloc(2,sind(j)), 'bo', 'MarkerSize', 5\);
 if (\~isempty(highlightInds))
 plot (Axes(1\), sloc(1,highlightInds), sloc(2,highlightInds),highlightLineType);
 end
 % pause
 if (LabelTurns)
 rloc \= sloc(:,revinds(revinds \> sstart \& revinds \< send));
 oloc \= sloc(:,omegainds(omegainds \> sstart \& omegainds \< send));
 bloc \= sloc(:,blipinds(blipinds \> sstart \& blipinds \< send));
 rloc \= rloc(:,abs(rloc(1,:) \- loc(1,j)) \< axisSize/2 \& abs(rloc(2,:) \- loc(2,j)) \< axisSize/2\);
 oloc \= oloc(:,abs(oloc(1,:) \- loc(1,j)) \< axisSize/2 \& abs(oloc(2,:) \- loc(2,j)) \< axisSize/2\);
 bloc \= bloc(:,abs(bloc(1,:) \- loc(1,j)) \< axisSize/2 \& abs(bloc(2,:) \- loc(2,j)) \< axisSize/2\);
 
 axes(Axes(1\));
 if (\~isempty(rloc))
 text(rloc(1,:), rloc(2,:), 'R', 'Color', 'r', 'HorizontalAlignment', 'Center');
 end
 if (\~isempty(oloc))
 text(oloc(1,:), oloc(2,:), '\\Omega', 'Color', 'm', 'HorizontalAlignment', 'Center');
 end
 if (\~isempty(bloc))
 text(bloc(1,:), bloc(2,:), 'b', 'Color', 'g', 'HorizontalAlignment', 'Center');
 end
 %plot (sloc(1,ri), sloc(2,ri), 'r.', sloc(1,oi), sloc(2,oi), 'm.', sloc(1,bi), sloc(2,bi), 'g.',...
 % 'MarkerSize', 10\);
 
 % pause
 end
 axis (Axes(1\), \[loc(1,j) \+ \[\-axisSize/2 axisSize/2], loc(2,j) \+ \[\-axisSize/2 axisSize/2]]);
 axis (Axes(1\), 'equal'); 
 axis (Axes(1\), \[loc(1,j) \+ \[\-axisSize/2 axisSize/2], loc(2,j) \+ \[\-axisSize/2 axisSize/2]]);
 hold (Axes(1\), 'off');
 set(Axes(1\), 'XTick', \[], 'YTick', \[]);
 if (\~isempty(track.run))
 t \= \[];
 if (track.isrun(sind(j)))
 t \= 'run';
 end

 if (\~isempty(track.reorientation) \&\& any(\[track.reorientation.inds] \=\= sind(j)))
 t \= 'reorientation';
 end
 title (Axes(1\), t);
 end
 
 % pause
 if (length(Axes) \>\= 4\)
 handles \= updateCenter(handles, track, sind(j), sstart, send, Axes(2:4\));
 end
 
 timeleft \= delayTime \- toc(ts1\);
 if (timeleft \> 0\)
 pause(timeleft);
 else
 pause(0\.01\);
 end
 
 % pause
end
%{
drawtime
tracktime
otherplotstime
%}
end

function datafields(track, inds, Axes)
 fields \= {'deltatheta','scovRatio','speed'};
 track.calculateDerivedQuantity(fields);
 mult \= \[rad2deg(1\), 1, 1];
 for k \= 1:3
 %subplot(2,2,k\+1\); hold off
 hold (Axes(k), 'off');
 plot (Axes(k), track.dq.eti(inds), mult(k)\*track.dq.(fields{k})(inds), 'k.', 'MarkerSize', 5\);
 hold (Axes(k), 'on');
 
 
 if (\~isempty(track.run))
 runinds \= find(\[track.run.endInd] \> inds(1\) \& \[track.run.startInd] \< inds(end));
 else
 runinds \= \[];
 end
 for j \= runinds;
 plot (Axes(k), track.dq.eti(track.run(j).inds), mult(k)\*track.dq.(fields{k})(track.run(j).inds), 'm\-','LineWidth',2\);
 end
 title(Axes(k), fields{k});
 end

 spfields \= {{'dthetaHiThresh', 'dthetaLoThresh','straightThetaThresh'},{}, {}};
 spcolors \= {{'r\-','g\-','m\-'},{}, {}};
 spmirror \= \[1 0 0];
 for k \= 1:3
 %subplot(2,2,k\+1\);
 x \= track.dq.eti(inds);
 for j \= 1:length(spfields{k})
 f \= spfields{k}{j};
 c \= spcolors{k}{j};
 y \= repmat (mult(k)\*track.so.(f), size(x));
 plot (Axes(k), x,y,c);
 if (spmirror(k));
 plot (Axes(k), x,\-y,c);
 end
 end
 end
end

function handles \= updateCenter(handles, track, cind, start, stop, Axes)
 if \~isempty(handles)
 for j \= 1:length(handles)
 delete(handles(j));
 end
 end
 fields \= {'deltatheta','scovRatio','speed'};
 mult \= \[rad2deg(1\), 1, 1];
 for k \= 1:3
 % subplot(2,2,k\+1\); hold on
 %ih \= ishold;
 handles(k) \= plot (Axes(k), track.dq.eti(cind), mult(k)\*track.dq.(fields{k})(cind), 'c.','MarkerSize',25\);
 xlim(Axes(k), \[min(track.dq.eti(start)) max(track.dq.eti(stop))]);
 %if (\~ih)
 % hold off
 %end
 if (k \=\= 2\)
 ylim(Axes(k), \[1 4]);
 end
 end
end 





\-\-\-

\#\#\# File: makeMovieTrackSpecific.m (ID: @WormTrack.6\)

function mo \= makeMovieTrackSpecific(track, mo, pt, iind) 

if (mo.labelSharpTurns \&\& \~isempty(track.sharpTurn))
 xl \= get(mo.Axes(1\), 'XLim');
 yl \= get(mo.Axes(1\), 'YLim');
 r \= \[xl yl];
 st \= track.sharpTurn;
 start \= \[st.startInd];
 stop \= \[st.endInd];
 st \= st(stop \>\= iind \- mo.ptbuffer \& start \<\= iind \+ mo.ptbuffer);
 loc \= double(st.getDerivedQuantity(mo.locField, 'position', 'centralInd'));
 validinds \= (insideRect(r, loc));
 st \= st(validinds);
 loc \= loc(:,validinds);
 s \= find(\[st.endInd] \< iind, 1, 'last');
 if (isempty(s))
 s \= 1;
 end
 e \= find(\[st.startInd] \> iind, 1, 'first');
 if (isempty(e))
 e \= length(st);
 end
 s \= max(s \- mo.stbuffer, 1\);
 e \= min(e \+ mo.stbuffer, length(st));
 for j \= s:e
 \[s,c] \= st(j).symbol;
 text(loc(1,j), loc(2,j),s, 'Color', c, 'Parent', mo.Axes(1\), 'HorizontalAlignment', 'center', ...
 'VerticalAlignment', 'middle');
 end
 
 ind \= find(st.containsIndex(iind), 1, 'first');
 if \~isempty(ind)
 \[\~,c] \= st(ind).symbol;
 if (isfinite(st(ind).userCode))
 str \= \[st(ind).usertype ' (hand)'];
 else
 str \= \[st(ind).type ' (auto)'];
 end
 text(xl(1\), yl(2\), str, 'Color', c, 'Parent', mo.Axes(1\), 'HorizontalAlignment', 'left', ...
 'VerticalAlignment', 'top');
 end
end
 
 
\-\-\-

\#\#\# File: flagOmegaTurnsAndReversals.m (ID: @WormTrack.7\)

function flagOmegaTurnsAndReversals (track, wormSegmentOptions)
% flags sharp turns in a worm track
% function flagOmegaTurnsAndReversals (track, wormSegmentOptions)
%
% called by flagReorientations which is called by SegmentTrack
% usually not called directly by end user
%
% outputs: none
% inputs: 
% TRACK: member of the track class (note MaggotTrack segmentation
% proceeds differently)
% WORMSEGMENTOPTIONS: segmentation options, see WormSegmentOptions class
% for details
wso \= wormSegmentOptions;

dt \= track.getDerivedQuantity ('deltatheta');
sp \= track.getDerivedQuantity('speed');
sharpTurns \= abs(dt) \> wso.dthetaHiThresh;
%{ 
%old
%using imclose to link close together sharp turns
sz \= size(sharpTurns);
sz(sz \> 1\) \= wso.joinSTpts;
if (wso.joinSTpts \> 1\)
 sharpTurns \= imclose(sharpTurns, ones(sz));
end
%}

%expand from regions of high delta theta until hitting a low delta theta
%combined with a higher speed
while(1\)
 sz \= size(sharpTurns);
 sz(sz \> 1\) \= 3;
 newst \= imdilate(sharpTurns, ones(sz)) \& (abs(dt) \> wso.dthetaLoThresh \| sp \< wso.speedEndSTThresh);
 if (all (newst \=\= sharpTurns))
 break;
 else
 sharpTurns \= newst;
 end
end

start \= find (diff(\[0 sharpTurns]) \> 0\);
stop \= find (diff(\[sharpTurns 0]) \< 0\);



if (isempty(start))
 start \= 1;
end
if (isempty(stop))
 stop \= length(track.dq.deltatheta);
end
%should never happen, but safety first
if (stop(1\) \< start(1\))
 stop \= stop(2:end);
end
if (start(end) \> stop(end))
 start \= start(1:(end\-1\));
end

for j \= 1:length(start)
 sharpTurn(j) \= WormSharpTurn(track, start(j), stop(j)); 
end

track.sharpTurn \= sharpTurn;

\-\-\-

\#\#\# File: fillOutSaveData.m (ID: @WormTrack.8\)

function track \= fillOutSaveData(track)
%function fillOutSaveData(track)



if (\~isempty(track.sharpTurn))
 try
 sd.sharpTurnStart \= \[track.sharpTurn.startInd];
 sd.sharpTurnEnd \= \[track.sharpTurn.endInd];
 sd.sharpTurnTypeCode \= \[track.sharpTurn.typeCode];
 sd.sharpTurnUserCode \= \[track.sharpTurn.userCode];
 catch me
 disp(me.getReport);
 sd.sharpTurnStart \= \[];
 sd.sharpTurnEnd \= \[];
 sd.sharpTurnTypeCode \= \[];
 sd.sharpTurnUserCode \= \[];
 end
else
 sd.sharpTurnStart \= \[];
 sd.sharpTurnEnd \= \[];
 sd.sharpTurnTypeCode \= \[];
 sd.sharpTurnUserCode \= \[];
end

track.saveData \= sd;

\-\-\-

\#\#\# File: WormTrack.m (ID: @WormTrack.9\)

classdef WormTrack \< Track
 %Tracks from c. elegans
 
 properties (Transient \= true, AbortSet \= true) %no longer save segmentation
 sharpTurn \= \[]; %information about sharp turns in the track (worm only)
 end
 methods %constructor
 function t \= WormTrack(varargin)
 %constructor
 if (nargin \>\= 1 \&\& isa(varargin{1}, 'Track'))
 t.clone(varargin{1});
 end
 end
 end
 % save and load methods
 methods
 function track \= saveobj(track)
 track \= track.fillOutSaveData;
 end
 
 end
 methods (Static)
 function track \= loadobj(track)
 % disp ('loadobj called on worm track');
 try
 if (\~isempty(track.saveData))
 track \= track.restoreSaveData;
 end
 catch me
 disp(me.getReport);
 end
 end
 end
 
 methods %access methods
 function set.sharpTurn(obj, value)
 if (\~isempty(value) \&\& isa(value, 'TrackPart'))
 \[value.track] \= deal(obj);
 end
 obj.sharpTurn \= value;
 end
 end
 methods 
 plotSegmentation(track, varargin); 
 segmentTrack (track, wormSegmentOptions, varargin);
 flagOmegaTurnsAndReversals (track, wormSegmentOptions, varargin);
 flagReorientations (track, wormSegmentOptions, varargin)

 playMovie(track, varargin)
 track \= fillOutSaveData(track);
 track \= restoreSaveData(track);
 end
 methods(Access \= protected)
 mo \= makeMovieTrackSpecific(track, mo, pt, iind) 
 end
 
end


\-\-\-

\#\#\# Folder: @BehaviorTriggeredData (ID: @BehaviorTriggeredData)

\-\-\-

\#\#\# File: simulateVarSwitchFromPrevFit.m (ID: @BehaviorTriggeredData.1\)

function problemDescription \= simulateVarSwitchFromPrevFit (btdstruct, osfit, oldpd, alphaLow, alphaHigh, nlarvae)
% problemDescription \= simulateVarSwitchFromPrevFit (btdstruct, osfit, oldpd, alphaLow, alphaHigh, nlarvae)
%

btd \= btdstruct.btd(min(oldpd.exprange):max(oldpd.exprange));
opstruct \= btdstruct.varops;
opstruct.taxis \= min(oldpd.runEti):oldpd.deltaT:max(oldpd.runEti);
opstruct.alphaLow \= alphaLow;
opstruct.alphaHigh \= alphaHigh;

problemDescription \= simulateVarSwitch (btd, opstruct, oldpd, oldpd.timeField, oldpd.timeRange, osfit.staticParams, nlarvae);

problemDescription.params\_0 \= osfit.staticParams;
problemDescription.alpha\_0 \= osfit.alpha;
problemDescription.tx \= osfit.tx;
% problemDescription.tparams\_0 \= osfit.temporalParams;
fn \= {'pad', 'Q\_alpha', 'v0', 'w\_0', 'maxreps', 'separateExperiments', 'period', 'tshift'};
for j \= 1:length(fn)
 problemDescription.(fn{j}) \= oldpd.(fn{j});
end
\-\-\-

\#\#\# File: createProblemStructForRateFunFitting.m (ID: @BehaviorTriggeredData.2\)

function pd \= createProblemStructForRateFunFitting (vs, timeField, polynomialDegree, trange, exprange, deltaT)
%function pd \= createProblemStructForRateFunFitting (vs, timeField, polynomialDegree, trange, exprange, deltaT)
%vs \= var struct as created by prepVarianceSwitchingAnalysis
ndim \= length(vs);
if (ndim \=\= 1\)
 pd.ratefun \= @(x, xdata) exp(polyval(x, xdata)); %\[Nx1 rate function of NxD xdata given \[1xK] params]
 pd.gradlogratefun \=@(x,xdata) polyval(polyder(x), xdata); %NxD gradient of log of rate
 pd.hesslogratefun \=@(x,xdata) polyval(polyder(polyder(x)), xdata); %NxDxD hessian of log of rate;
 pd.params\_0 \= zeros(1,polynomialDegree\+1\);
 pd.params\_0(end) \= 1;
else
 switch (polynomialDegree)
 case 1
 pd.ratefun \= @(x, xdata) exp(xdata \* x(1:(end\-1\))' \+ x(end)); %\[Nx1 rate function of NxD xdata given \[1xK] params]
 pd.gradlogratefun \= @(x,xdata) repmat(x(1:(end\-1\)), \[size(xdata,1\), 1]); %NxD gradient of log of rate
 pd.hesslogratefun \= @(x,xdata) zeros(\[size(xdata,1\) size(xdata,2\) size(xdata,2\)]); %NxDxD hessian of log of rate;
 pd.params\_0 \= zeros(1,ndim\+1\);
 for j \= 1:ndim
 pd.params\_0(j) \= mean(vs(j).turn.x\_conv)/var(vs(j).noturn.x\_conv);
 end
 pd.params\_0(end) \= 1;
 case 2
 if (ndim \=\= 2\)
 pd.ratefun \= @(x,xdata) exp(x(1\)\*xdata(:,1\).^2 \+ x(2\)\*xdata(:,1\).\*xdata(:,2\) \+ x(3\)\*xdata(:,2\).^2 \+ x(4\)\*xdata(:,1\) \+ x(5\)\*xdata(:,2\) \+ x(6\));
 pd.gradlogratefun \= @(x,xdata) \[2\*x(1\)\*xdata(:,1\) \+ x(2\)\*xdata(:,2\) \+ x(4\);x(2\)\*xdata(:,2\) \+ 2\*x(3\)\*xdata(:,2\) \+ x(5\)];
 pd.hesslogratefun \= @twobytwohess; 
 pd.params\_0 \= zeros(1,6\);
 pd.params\_0(end) \= 1;
 else
 error ('polynomial of degree \> 1 not supported for data of dimenion \> 2');
 end
 otherwise
 error ('polynomial of degree \> 2 not supported for data of dimension \> 1');
 end
end
pd.timeField \= timeField;
pd.temporalratemod \= @(x,tdata) x(1\)\*exp(\-tdata/x(2\)) \+ 1;

turn \= \[vs.turn];
run \= \[vs.noturn];
if (length(turn) \> 1\) \&\& any(any(diff(\[turn.eti],\[],2\))) \|\| any(any(diff(\[run.eti], \[], 2\)))
 error ('I expect that data in the different var structures should be temporally aligned');
end

pd.turnT \= turn(1\).(timeField);
pd.turnEti \= turn(1\).eti;
pd.turnX \= \[turn.x\_conv];
pd.turnExpnum \= turn(1\).expnum;

pd.runT \= run(1\).(timeField);
pd.runEti \= run(1\).eti;
pd.runX \= \[run.x\_conv];
pd.runExpnum \= run(1\).expnum;

existsAndDefault('deltaT', median(diff(pd.runEti)));
pd.deltaT \= deltaT;
%pd.deltaT \= median(diff(pd.runEti));

period \= vs(1\).period;

if (strcmpi(timeField, 'ton') \|\| strcmpi(timeField, 'toff'))
 pd.tx \= 0:pd.deltaT:period; 
 pd.pad \= true;
 if (\~exist('trange', 'var') \|\| isempty('trange'))
 minTime \= min(run(1\).eti(run(1\).ton \>\= 0 \& run(1\).toff \>\= 0\));
 trange \= minTime:period:max(run(1\).eti \+ pd.deltaT); trange \= trange(\[1 end]);
 end
 trange(1\) \= max(trange(1\),min(pd.runEti));
 trange(2\) \= min(trange(2\),max(pd.runEti));
else
 existsAndDefault('trange', \[max(vs(1\).period \- vs(1\).tshift,min(pd.runEti)) max(pd.runEti)\+pd.deltaT]);
 trange(1\) \= max(trange(1\),min(pd.runEti));
 trange(2\) \= min(trange(2\),max(pd.runEti));
 pd.tx \= (trange(1\):pd.deltaT:trange(end))';
 pd.pad \= false;
end
existsAndDefault ('exprange', \[min(pd.runExpnum) max(pd.runExpnum)]);
pd.exprange \= exprange;

pd.timeRange \= trange;
pd.etx \= linspace(min(trange), max(trange), 100\);

ti \= pd.turnEti \>\= min(trange) \& pd.turnEti \< max(trange) \& pd.turnExpnum \>\= min(exprange) \& pd.turnExpnum \<\= max(exprange);
pd.turnT \= pd.turnT(ti);
pd.turnEti \= pd.turnEti(ti);
pd.turnX \= pd.turnX(ti,:);
pd.turnExpnum \= pd.turnExpnum(ti);

ri \= pd.runEti \>\= min(trange) \& pd.runEti \< max(trange) \& pd.runExpnum \>\= min(exprange) \& pd.runExpnum \<\= max(exprange);
pd.runT \= pd.runT(ri);
pd.runEti \= pd.runEti(ri);
pd.runX \= pd.runX(ri,:);
pd.runExpnum \= pd.runExpnum(ri);

%pd.runX \= pd.runX \- mean(pd.runX);
%pd.turnX \= pd.turnX \- mean(pd.turnX);

pd.params\_0(end) \= log(length(pd.turnT)/(length(pd.runT)\*pd.deltaT));

pd.Q\_alpha \= 0\.2\*eye(ndim);
pd.Q\_s \= pd.Q\_alpha;

pd.tparams\_0 \= \[0 1000];
pd.alpha\_0 \= ones(length(pd.tx), ndim);
pd.sigma\_0 \= 10\*ones(length(pd.tx), ndim);
pd.v0 \= 1;
pd.w\_0 \= pd.Q\_alpha\*1000\*eye(ndim);
pd.maxreps \= 3;

pd.separateExperiments \= false;
pd.period \= vs(1\).period;
pd.tshift \= vs(1\).tshift;

function hess \= twobytwohess (x, xdata)
hess \= zeros(size(xdata,1\), 2, 2\);
hess(:,1,1\) \= 2\*x(1\);
hess(:,1,2\) \= x(2\);
hess(:,2,1\) \= x(2\);
hess(:,2,2\) \= x(3\);
\-\-\-

\#\#\# File: analyzeBTDDirectory\_twosource.m (ID: @BehaviorTriggeredData.3\)

function btdstruct \= analyzeBTDDirectory\_twosource (btdstruct, stim1name, stim2name, varargin)
%function makeBTDFiguresBasic (basedir)

taxis \= \-30:0\.1:10;
kernelTime \= 7; %s
kernelDt \= 0\.1;
turnSizeRange \= \[\-15 \-3];
headSweepAcceptRange \= \[0 1\.25];

vallist \= {'led1Val', 'led2Val'};
varargin \= assignApplicable(varargin);

if (\~isstruct(btdstruct))
 if (ischar(btdstruct))
 btdstruct \= BehaviorTriggeredData.loadBTDDirectory(btdstruct);
 else
 error ('first argument must be btdstruct or basedir');
 end
else
 if (isfield(btdstruct, 'stimnames'))
 existsAndDefault('stim1name', btdstruct.stimnames{1});
 existsAndDefault('stim2name', btdstruct.stimnames{2});
 end
 
end
% 
% turnSizeRange \= \[\-15 \-3];
% headSweepAcceptRange \= \[0 1\.25];
btdstruct.turnSizeRange \= turnSizeRange;
btdstruct.headSweepAcceptRange \= headSweepAcceptRange;

btdstruct.kernelTime \= kernelTime;
btdstruct.kernelDt \= kernelDt;
btdstruct.taxis \= taxis;

btd \= btdstruct.btd;

kname1 \= \[stim1name 'TurnLin'];
kname2 \= \[stim2name 'TurnLin'];

inrun.name \= 'isrun';
inrun.validop \= @(x) logical(x);

\[btdstruct.convkernels, btd] \= btd.createBTAKernel('turn', 'start', {stim1name, stim2name}, kernelTime, kernelDt, 'newFieldName', {kname1, kname2}, 'normalizeStd', false, 'abbott', true);
aa \= \[btd.all];
eti \= \[aa.eti];
l1 \= btd.behaviorTriggeredDataMatrix ('all', '', kname1, 0\);
s \= std(l1(eti \> kernelTime));
btdstruct.convkernels(1,:) \= btdstruct.convkernels(1,:) / s;
btd \= btd.addConvolvedFields(stim1name, kname1, btdstruct.convkernels(1,:), kernelDt, 'scaleToSqr', true);

l2 \= btd.behaviorTriggeredDataMatrix ('all', '', kname2, 0\);
s \= std(l2(eti \> kernelTime));
btdstruct.convkernels(2,:) \= btdstruct.convkernels(2,:) / s;
btd \= btd.addConvolvedFields(stim2name, kname2, btdstruct.convkernels(2,:), kernelDt, 'scaleToSqr', true);

xyall \= btd.behaviorTriggeredDataMatrix('all', 'start', {kname1, kname2}, 0\);
mx \= mean(xyall(eti\>kernelTime,1\)); my \= mean(xyall(eti\>kernelTime,1\));
sx \= std(xyall(eti\>kernelTime,2\)); sy \= std(xyall(eti\>kernelTime,2\));

lin\_xy\_all \= btd.behaviorTriggeredDataMatrix('all', 'start', {kname1, kname2}, 0,'conditions', inrun);
lin\_xy\_all(:,1\) \= (lin\_xy\_all(:,1\)\-mx)/sx;
lin\_xy\_all(:,2\) \= (lin\_xy\_all(:,2\)\-my)/sy;


btdstruct.lin\_xy \= btd.behaviorTriggeredDataMatrix('turn', 'start', {kname1, kname2}, 0\);
btdstruct.lin\_xy\_all \= lin\_xy\_all;

theta \= atan2(mean(btdstruct.lin\_xy(:,2\)), mean(btdstruct.lin\_xy(:,1\)));

btdstruct.theta \= theta;

btdstruct.linUOp \= @(yd) cos(theta)\*(yd{1}\-mx)/sx \+ sin(theta)\*(yd{2}\-my)/sy;
btdstruct.linVOp \= @(yd) cos(theta)\*(yd{2}\-my)/sy \- sin(theta)\*(yd{1}\-mx)/sx;
% btd \= addOperationFields (btd, gltname, newname, operation)
btd \= btd.addOperationFields({kname1, kname2}, 'linU',btdstruct.linUOp);
btd \= btd.addOperationFields({kname1, kname2}, 'linV', btdstruct.linVOp );

m \= sign(sum(btdstruct.convkernels, 2\));

btd \= btd.addOperationFields({stim1name, stim2name}, 'ufieldsum', @(yd) m(1\) \* cos(theta)\*yd{1} \+ m(2\)\*sin(theta)\*yd{2});
btd \= btd.addOperationFields({stim1name, stim2name}, 'vfieldsum', @(yd) m(1\) \*cos(theta)\*yd{2} \- m(2\)\*sin(theta)\*yd{1});


btdstruct.lin\_uv \= btd.behaviorTriggeredDataMatrix('turn', 'start', {'linU', 'linV'}, 0\);
%btdstruct.lin\_uv\_all \= btd.behaviorTriggeredDataMatrix('all', 'start', {'linU', 'linV'}, 0, 'conditions', inrun);
% scale \= repmat(std(lin\_xy\_all), \[length(btdstruct.lin\_xy) 1]);
% lin\_xy \= btdstruct.lin\_xy./scale;

lin\_xy(:,1\) \= (btdstruct.lin\_xy(:,1\)\-mx)/sx;
lin\_xy(:,2\) \= (btdstruct.lin\_xy(:,2\)\-my)/sy;
lin\_uv \= btdstruct.lin\_uv;


u \= mean(lin\_xy);
c \= cov(lin\_xy);
btdstruct.kl\_xy \= 0\.5\*(trace(c)\-log(det(c))\+u\*u' \- 2\);

c \= cov(lin\_xy(:,1\));
btdstruct.kl\_x \= 0\.5\*(trace(c)\-log(det(c))\+u(1\).^2 \- 1\);

c \= cov(lin\_xy(:,2\));
btdstruct.kl\_y \= 0\.5\*(trace(c)\-log(det(c))\+u(2\).^2 \- 1\);


u \= mean(lin\_uv);
c \= cov(lin\_uv);
btdstruct.kl\_uv \= 0\.5\*(trace(c)\-log(det(c))\+u\*u' \- 2\);

c \= cov(lin\_uv(:,1\));
btdstruct.kl\_u \= 0\.5\*(trace(c)\-log(det(c))\+u(1\).^2 \- 1\);

c \= cov(lin\_uv(:,2\));
btdstruct.kl\_v \= 0\.5\*(trace(c)\-log(det(c))\+u(2\).^2 \- 1\);
%find theta by minimizing u\*v
minfun \= @(t) (mean((cos(t)\*lin\_xy(:,1\) \+ sin(t)\*lin\_xy(:,2\)).\*(\-sin(t)\*lin\_xy(:,1\) \+ cos(t)\*lin\_xy(:,2\))))^2;
theta \= fminunc(minfun, btdstruct.theta);

btdstruct.thetaAlt \= theta;

btdstruct.linUOpAlt \= @(yd) cos(theta)\*(yd{1}\-mx)/sx \+ sin(theta)\*(yd{2}\-my)/sy;
btdstruct.linVOpAlt \= @(yd) cos(theta)\*(yd{2}\-my)/sy \- sin(theta)\*(yd{1}\-mx)/sx;
% btd \= addOperationFields (btd, gltname, newname, operation)
btd \= btd.addOperationFields({kname1, kname2}, 'linUAlt',btdstruct.linUOpAlt);
btd \= btd.addOperationFields({kname1, kname2}, 'linVAlt', btdstruct.linVOpAlt );

% btd \= btd.addOperationFields({stim1name, stim2name}, 'ufieldsum', @(yd) cos(theta)\*yd{1} \+ sin(theta)\*yd{2});
% btd \= btd.addOperationFields({stim1name, stim2name}, 'vfieldsum', @(yd) cos(theta)\*yd{2} \- sin(theta)\*yd{1});


btdstruct.lin\_uvAlt \= btd.behaviorTriggeredDataMatrix('turn', 'start', {'linUAlt', 'linVAlt'}, 0\);
%btdstruct.lin\_uv\_all \= btd.behaviorTriggeredDataMatrix('all', 'start', {'linU', 'linV'}, 0, 'conditions', inrun);
% scale \= repmat(std(lin\_xy\_all), \[length(btdstruct.lin\_xy) 1]);
% lin\_xy \= btdstruct.lin\_xy./scale;

lin\_uv \= btdstruct.lin\_uvAlt;


u \= mean(lin\_uv);
c \= cov(lin\_uv);
btdstruct.kl\_uvAlt \= 0\.5\*(trace(c)\-log(det(c))\+u\*u' \- 2\);

c \= cov(lin\_uv(:,1\));
btdstruct.kl\_uAlt \= 0\.5\*(trace(c)\-log(det(c))\+u(1\).^2 \- 1\);

c \= cov(lin\_uv(:,2\));
btdstruct.kl\_vAlt \= 0\.5\*(trace(c)\-log(det(c))\+u(2\).^2 \- 1\);



fieldlist \= {kname1, kname2, 'linU', 'linV'};
ratenames \= {'rateX', 'rateY', 'rateU', 'rateV'};
%cumnames \= {'cumX', 'cumY', 'cumU', 'cumV'};
turndata \= btd.behaviorTriggeredDataMatrix('turn', 'start', fieldlist, 0\);
alldata \= btd.behaviorTriggeredDataMatrix('all', 'start', fieldlist, 0, 'conditions', inrun);
nr \= size(turndata, 1\);
na \= size(alldata,1\);
mu \= mean(turndata);
mu\_a \= mean(alldata);
s \= std(turndata);
s\_a \= std(alldata);
dt \= median(diff(btd(1\).all.eti)); %assuming all movies were captured at same frame rate!

for j \= 1:size(turndata, 2\)
 ratefun \= @(ydata) nr/(na\*dt)\*normpdf(ydata,mu(j),s(j))./normpdf(ydata, mu\_a(j), s\_a(j));
 btdstruct.ratefun{j} \= ratefun;
 btd \= btd.addOperationFields(fieldlist{j}, ratenames{j}, ratefun);
% 
% for k \= 1:length(btd)
% glt \= btd(k).glt(btd(k).findField(ratenames{j}));
% glt.fieldname \= cumnames{j};
% glt.yData \= cumsum(\[0 diff(glt.xData)].\*glt.yData);
% ind \= btd(k).findField(cumnames{j});
% if (ind \<\= 0\)
% btd(k).glt \= \[btd(k).glt glt];
% else
% btd(k).glt(ind) \= glt;
% end
% end
end


inrun.name \= 'isrun';
inrun.validop \= @(x) logical(x);


allxy \= btd.behaviorTriggeredDataMatrix('all', '', {kname1, kname2}, 0, 'conditions', inrun);
turnxy \= btd.behaviorTriggeredDataMatrix('turn', 'start', {kname1, kname2}, 0\);

dt \= median(diff(btd(1\).all.eti));

ratefun1 \= @(x,xdata) x(1\) \* normpdf(xdata(:,1\), x(2\), x(3\))./normpdf(xdata(:,1\), 0, 1\) \+ x(4\)\*normpdf(xdata(:,2\), x(5\), x(6\))./normpdf(xdata(:,2\), 0, 1\);
initguess1 \= \[0\.5\*length(turnxy)/length(allxy) mean(turnxy(:,1\)) std(turnxy(:,1\)) 0\.5\*length(turnxy)/length(allxy) mean(turnxy(:,2\)) std(turnxy(:,2\))];

ratefun2 \= @(x, xdata) x(1\) \* normpdf(cos(x(4\))\*xdata(:,1\) \+ sin(x(4\))\*xdata(:,2\), x(2\), x(3\)) ./ normpdf(cos(x(4\))\*xdata(:,1\) \+ sin(x(4\))\*xdata(:,2\), 0, 1\); %fit rate, not theta
initguess2 \= \[0\.5\*length(turnxy)/length(allxy) mean(lin\_uv(:,1\)) std(lin\_uv(:,1\)) btdstruct.theta];

ratefun3 \= @(x,xdata) x(1\) \* ( normpdf(xdata(:,1\), x(2\), x(3\))./normpdf(xdata(:,1\), 0, 1\) ) .\* ( normpdf(xdata(:,2\), x(4\), x(5\))./normpdf(xdata(:,2\), 0, 1\) );
initguess3 \= \[0\.5\*length(turnxy)/length(allxy) mean(turnxy(:,1\)) std(turnxy(:,1\)) mean(turnxy(:,2\)) std(turnxy(:,2\))];



%if we assume rdt \<\< 1
fitfun1 \= @(x) \-sum(log(max(ratefun1(x,turnxy),1E\-100\))) \+ sum(max(0,ratefun1(x,allxy)));
fitfun2 \= @(x) \-sum(log(max(ratefun2(x,turnxy),1E\-100\))) \+ sum(max(0,ratefun2(x,allxy)));
fitfun3 \= @(x) \-sum(log(max(ratefun3(x,turnxy),1E\-100\))) \+ sum(max(0,ratefun3(x,allxy)));

op \= optimset('fmincon');
op.Algorithm \= 'active\-set';
%op.LargeScale \= 'off';
problem.objective \= fitfun2;
problem.solver \= 'fmincon';
problem.x0 \= initguess2;
problem.lb \= \[0 \-Inf 0 0];
problem.ub \= \[Inf Inf Inf pi];
problem.options \= op;
fitParams2 \= fmincon(problem);
btdstruct.ratefun2 \= ratefun2;
btdstruct.fitParams2 \= fitParams2 .\* \[1/dt 1 1 1];
btdstruct.llAll2 \= \-fitfun2(fitParams2\);

op \= optimset('fmincon');
op.Algorithm \= 'active\-set';
%op.LargeScale \= 'off';
problem.objective \= fitfun1;
problem.solver \= 'fmincon';
problem.x0 \= initguess1;
problem.lb \= \[0 \-Inf 0 0 \-Inf 0];
problem.ub \= \[Inf Inf Inf Inf Inf Inf];
problem.options \= op;
fitParams1 \= fmincon(problem);
btdstruct.ratefun1 \= ratefun1;
btdstruct.fitParams1 \= fitParams1\.\*\[1/dt 1 1 1/dt 1 1];
btdstruct.llAll1 \= \-fitfun1(fitParams1\);

op \= optimset('fmincon');
op.Algorithm \= 'active\-set';
%op.LargeScale \= 'off';
problem.objective \= fitfun3;
problem.solver \= 'fmincon';
problem.x0 \= initguess3;
problem.lb \= \[0 \-Inf 0 \-Inf 0];
problem.ub \= \[Inf Inf Inf Inf Inf];
problem.options \= op;
fitParams3 \= fmincon(problem);
btdstruct.ratefun3 \= ratefun3;
btdstruct.fitParams3 \= fitParams3\.\*\[1/dt 1 1 1 1];
btdstruct.llAll3 \= \-fitfun3(fitParams3\);
 
 

btdstruct.btd \= btd;
btdstruct.fieldlist \= fieldlist;
btdstruct.ratenames \= ratenames;
% btdstruct.cumnames \= cumnames;
% 
% dm \= btd.behaviorTriggeredDataMatrix('turn', 'start', cumnames, 0\);
% tt \= \[btd.turn]; tn \= \[tt.tnum]; 
% valid \= (diff(tn) \=\= 0\);
% dm \= diff(dm);
% % 
% for j \= 1:length(cumnames)
% btdstruct.lambda(:,j) \= dm(valid,j);
% end


%link \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', {kname1, kname2}, 0\);

firsths.name \= 'hsnum';
firsths.validop \= @(x) x \=\= 1;


quadrant(1\).condition(1\).name \= kname1;
quadrant(1\).condition(1\).validop \= @(x) x \> 0;
quadrant(1\).condition(2\).name \= kname2;
quadrant(1\).condition(2\).validop \= @(x) x \> 0;

%changed quadrants 10/28 to align with normal cartesian labels
quadrant(2\) \= quadrant(1\);
quadrant(2\).condition(1\).validop \= @(x) x \< 0;

quadrant(3\) \= quadrant(2\);
quadrant(3\).condition(2\).validop \= @(x) x \< 0;

quadrant(4\) \= quadrant(1\);
quadrant(4\).condition(2\).validop \= @(x) x \< 0;


plane(1\).condition.name \= kname1;
plane(1\).condition.validop \= @(x) x\>0;
plane(2\).condition.name \= kname1;
plane(2\).condition.validop \= @(x) x\<0;
plane(3:4\) \= plane(1:2\);
plane(3\).condition.name \= kname2;
plane(4\).condition.name \= kname2;

btdstruct.taxis \= taxis;


btdstruct.stimnames \= {stim1name stim2name};
btdstruct.linnames \= {kname1, kname2};

t \= \[btd.turn]; 
btdstruct.meanSquaredTurn \= mean(\[t.dtheta].^2\);
ms \= btdstruct.meanSquaredTurn;
bigturn.name \= 'dtheta';
bigturn.validop \= @(x) x.^2 \> ms;
smallturn.name \= 'dtheta';
smallturn.validop \= @(x) x.^2 \< ms;
onehs.name \= 'numhs';
onehs.validop \= @(x) x \=\= 1;
stimlist \= {stim1name,stim2name, 'ufieldsum', 'vfieldsum'};%,'linU', 'linV',kname1, kname2};
wholelist \= \[stimlist vallist];

num\_tspts \= 200;

\[dm,stimnum] \= btd.behaviorTriggeredDataMatrix('turn', 'start', stimlist, linspace(turnSizeRange(1\), turnSizeRange(2\), num\_tspts));
turnmc \= zeros(size(dm,1\), length(stimlist));

for j \= 1:length(stimlist)
 dm2 \= reshape(dm(stimnum \=\= j), size(dm,1\),\[]); dm2(\~isfinite(dm2\)) \= 0;
 turnmc(:,j) \= mean(dm2, 2\); %rate per second
end
t \= \[btd.turn]; 
isbigturn \= (\[t.dtheta].^2 \> btdstruct.meanSquaredTurn);
issmallturn \= \~isbigturn;
hasonehs \= \[t.numhs] \=\= 1;

btdstruct.all.meanChangeBeforeTurn \= mean(turnmc, 1\);
btdstruct.all.meanChangeBeforeTurn\_eb \= std(turnmc, 1\)./sqrt(length(turnmc));

btdstruct.all.meanChangeBeforeTurn\_onehs \= sum(turnmc(hasonehs,:), 1\)./nnz(hasonehs);
btdstruct.all.meanChangeBeforeTurn\_onehs\_eb \= std(turnmc(hasonehs,:), 1\)./sqrt(nnz(hasonehs));

btdstruct.all.meanChangeBeforeBigTurn \= sum(turnmc(isbigturn,:), 1\)./nnz(isbigturn);
btdstruct.all.meanChangeBeforeBigTurn\_eb \= std(turnmc(isbigturn,:), 1\)./sqrt(nnz(isbigturn));

btdstruct.all.meanChangeBeforeSmallTurn \= sum(turnmc(issmallturn,:), 1\)./nnz(issmallturn);
btdstruct.all.meanChangeBeforeSmallTurn\_eb \= std(turnmc(issmallturn,:), 1\)./sqrt(nnz(issmallturn));

btdstruct.all.meanChangeBeforeBigTurn\_onehs \= sum(turnmc(isbigturn \& hasonehs,:), 1\)./nnz(isbigturn \& hasonehs);
btdstruct.all.meanChangeBeforeBigTurn\_onehs\_eb \= std(turnmc(isbigturn \& hasonehs,:), 1\)./sqrt(nnz(isbigturn \& hasonehs));

btdstruct.all.meanChangeBeforeSmallTurn\_onehs \= sum(turnmc(issmallturn \& hasonehs,:), 1\)./nnz(issmallturn \& hasonehs);
btdstruct.all.meanChangeBeforeSmallTurn\_onehs\_eb \= std(turnmc(issmallturn \& hasonehs,:), 1\)./sqrt(nnz(issmallturn \& hasonehs));

hs \= \[btd.hs];
acc \= logical(\[hs.accepted]);
rej \= \~acc;
isfirsths \= \[hs.hsnum] \=\= 1;

firstacc \= acc(isfirsths);
firstrej \= rej(isfirsths);

num\_hspts \= 40;
\[dm,stimnum] \= btd.behaviorTriggeredDataMatrix('hs', 'start', stimlist, linspace(headSweepAcceptRange(1\), headSweepAcceptRange(2\), num\_hspts));
hsmc \= zeros(size(dm,1\), length(stimlist));
firsthsmc \= zeros(nnz(isfirsths), length(stimlist));
for j \= 1:length(stimlist)
 dm2 \= reshape(dm(stimnum \=\= j), size(dm,1\),\[]); dm2(\~isfinite(dm2\)) \= 0;
 hsmc(:,j) \= mean(dm2, 2\); %rate per second
 firsthsmc(:,j) \= hsmc(isfirsths, j);
end

btdstruct.all.meanChangeAfterHeadsweep \= mean(hsmc,1\);
btdstruct.all.meanChangeAfterHeadsweep\_eb \= std(hsmc, 1\)./sqrt(length(hsmc));
btdstruct.all.meanChangeAfterFirstHeadsweep \= sum(hsmc(isfirsths,:), 1\)./nnz(isfirsths);
btdstruct.all.meanChangeAfterFirstHeadsweep\_eb \= std(hsmc(isfirsths,:), 1\)./sqrt(nnz(isfirsths));


btdstruct.all.meanChangeAfterAcceptedHeadsweep \= sum(hsmc(acc,:), 1\)./nnz(acc);
btdstruct.all.meanChangeAfterAcceptedHeadsweep\_eb \= std(hsmc(acc,:), 1\)./sqrt(nnz(acc));

btdstruct.all.meanChangeAfterRejectedHeadsweep \= sum(hsmc(rej,:), 1\)./nnz(rej);
btdstruct.all.meanChangeAfterRejectedHeadsweep\_eb \= std(hsmc(rej,:), 1\)./sqrt(nnz(rej));

btdstruct.all.meanChangeAfterFirstAcceptedHeadsweep \= sum(hsmc(acc \& isfirsths,:), 1\)./nnz(acc \& isfirsths);
btdstruct.all.meanChangeAfterFirstAcceptedHeadsweep\_eb \= std(hsmc(acc \& isfirsths,:), 1\)./sqrt(nnz(acc \& isfirsths));

btdstruct.all.meanChangeAfterFirstRejectedHeadsweep \= sum(hsmc(rej \& isfirsths,:), 1\)./nnz(rej \& isfirsths);
btdstruct.all.meanChangeAfterFirstRejectedHeadsweep\_eb \= std(hsmc(rej \& isfirsths,:), 1\)./sqrt(nnz(rej \& isfirsths));

fields \= {'turn', 'acchs', 'rejhs'};% 'acchs', 'rejhs','acchs', 'rejhs'};
pos \= {'start', 'start', 'start'};% 'atmax', 'atmax', 'end', 'end'};

for j \= 1:length(fields)
 \[bta, \~] \= btd.behaviorTriggeredAverage(fields{j}, pos{j},wholelist, taxis); 
 btdstruct.all.(\[fields{j} '\_' pos{j}]) \= reshape(bta, \[], length(wholelist));
end
\[bta,\~,eb] \= btd.behaviorTriggeredAverage('turn', 'start',wholelist, taxis, 'conditions', \[bigturn onehs]);
btdstruct.all.bigturn\_start\_onehs \= reshape(bta,\[],length(wholelist));
btdstruct.all.bigturn\_start\_onehs\_eb \= reshape(eb,\[],length(wholelist));
\[bta,\~,eb] \= btd.behaviorTriggeredAverage('turn', 'start',wholelist, taxis, 'conditions', \[smallturn onehs]);
btdstruct.all.smallturn\_start\_onehs \= reshape(bta,\[],length(wholelist));
btdstruct.all.smallturn\_start\_onehs\_eb \= reshape(eb,\[],length(wholelist));
\[bta,\~,eb] \= btd.behaviorTriggeredAverage('turn', 'start',wholelist, taxis, 'conditions', bigturn );
btdstruct.all.bigturn\_start \= reshape(bta,\[],length(wholelist));
btdstruct.all.bigturn\_start\_eb \= reshape(eb,\[],length(wholelist));
\[bta,\~,eb] \= btd.behaviorTriggeredAverage('turn', 'start',wholelist, taxis, 'conditions', smallturn );
btdstruct.all.smallturn\_start \= reshape(bta,\[],length(wholelist));
btdstruct.all.smallturn\_start\_eb \= reshape(eb,\[],length(wholelist));

fields \= {'turn'};% 'acchs', 'rejhs','acchs', 'rejhs'};
pos \= {'start'};% 'atmax', 'atmax', 'end', 'end'};

for k \= 1:length(btd)
 
 for j \= 1:length(fields)
 btdstruct.exp(k).(\[fields{j} '\_' pos{j}]) \= reshape(btd(k).behaviorTriggeredAverage(fields{j}, pos{j}, wholelist, taxis),\[],length(wholelist));
 end
end
% 
% btdstruct.all.smallturn\_start\_onehs \= reshape(btd.behaviorTriggeredAverage('turn', 'start',wholelist, taxis, 'conditions', \[smallturn onehs]),\[],length(wholelist));
% btdstruct.all.bigturn\_start \= reshape(btd.behaviorTriggeredAverage('turn', 'start',wholelist, taxis, 'conditions', bigturn),\[],length(wholelist));
% btdstruct.all.smallturn\_start \= reshape(btd.behaviorTriggeredAverage('turn', 'start',wholelist, taxis, 'conditions', smallturn),\[],length(wholelist));


fields \= {'acchs', 'rejhs'};%, 'acchs', 'rejhs','acchs', 'rejhs'};
pos \= {'start', 'start'};%, 'atmax', 'atmax', 'end', 'end'};

% function \[bta, dm] \= behaviorTriggeredAverage (btd, tp, position, gltname, displacementAxis, varargin)
for j \= 1:length(fields)
 \[bta, \~] \= btd.behaviorTriggeredAverage(fields{j}, pos{j},wholelist, taxis, 'conditions', firsths);
 %btdstruct.(\[fields{j} '\_' pos{j} '\_dm']) \= dm; %this takes up a lot of space!
 btdstruct.all.(\['first\_' fields{j} '\_' pos{j}]) \= reshape(bta, \[], length(wholelist));
end


btdstruct.all.weightedTurnStart\_onehs \= reshape(btd.behaviorTriggeredWeightedAverage('turn', 'start', 'dtheta', wholelist, taxis, 'weightedOp', @abs, 'conditions', onehs), \[], length(wholelist));
btdstruct.all.weightedTurnStart\_all \= reshape(btd.behaviorTriggeredWeightedAverage('turn', 'start', 'dtheta', wholelist, taxis, 'weightedOp', @abs), \[], length(wholelist));

firsths.name \= 'hsnum';
firsths.validop \= @(x) x \=\= 1;
btdstruct.all.weightedFirstHeadsweep \= reshape(btd.behaviorTriggeredWeightedAverage('hs', 'start', 'accepted', wholelist, taxis, 'conditions', firsths), \[], length(wholelist));


kv \= btd.behaviorTriggeredDataMatrix('turn', 'start', {quadrant(1\).condition.name}, 0\);

% for j \= 1:length(quadrant(1\).condition)
% kv(:,j) \= btd.behaviorTriggeredDataMatrix('turn', 'start', quadrant(1\).condition(j).name, 0\);
% end
qq \= zeros(size(kv,1\), 1\);
for k \= 1:length(quadrant)
 valid \= true(size(qq));
 for j \= 1:length(quadrant(k).condition)
 valid \= valid \& quadrant(k).condition(j).validop(kv(:,j));
 end
 if (any(nnz(qq(valid))))
 warning('same point satisfies multiple quadrants'); %\#ok
 end
 qq(valid) \= k;
end
 
qq \= qq';

for k \= 1:length(quadrant)
 

 fields \= {'turn', 'acchs', 'rejhs'};% 'acchs', 'rejhs','acchs', 'rejhs'};
 pos \= {'start', 'start', 'start'};% 'atmax', 'atmax', 'end', 'end'};


 for j \= 1:length(fields)
 \[bta, \~, eb] \= btd.behaviorTriggeredAverage(fields{j}, pos{j}, wholelist, taxis, 'conditions', quadrant(k).condition); 
 quadrant(k).(\[fields{j} '\_' pos{j}]) \= reshape(bta, \[], length(wholelist));
 quadrant(k).(\[fields{j} '\_' pos{j} '\_eb']) \= reshape(eb, \[], length(wholelist));
 end
 
 fields \= {'acchs', 'rejhs'};%, 'acchs', 'rejhs','acchs', 'rejhs'};
 pos \= {'start', 'start'};%, 'atmax', 'atmax', 'end', 'end'};

 % function \[bta, dm] \= behaviorTriggeredAverage (btd, tp, position, gltname, displacementAxis, varargin)
 for j \= 1:length(fields)
 \[bta, \~, eb] \= btd.behaviorTriggeredAverage(fields{j}, pos{j}, wholelist, taxis, 'conditions', \[quadrant(k).condition firsths]);
 %btdstruct.(\[fields{j} '\_' pos{j} '\_dm']) \= dm; %this takes up a lot of space!
 quadrant(k).(\['first\_' fields{j} '\_' pos{j}]) \= reshape(bta, \[], length(wholelist));
 quadrant(k).(\['first\_' fields{j} '\_' pos{j} '\_eb']) \= reshape(eb, \[], length(wholelist));
 end

 \[bta,\~,eb] \= btd.behaviorTriggeredAverage('turn', 'start',wholelist, taxis, 'conditions', \[quadrant(k).condition bigturn onehs]);
 quadrant(k).bigturn\_start\_onehs \= reshape(bta,\[],length(wholelist));
 quadrant(k).bigturn\_start\_onehs\_eb \= reshape(eb,\[],length(wholelist));
 \[bta,\~,eb] \= btd.behaviorTriggeredAverage('turn', 'start',wholelist, taxis, 'conditions', \[quadrant(k).condition smallturn onehs]);
 quadrant(k).smallturn\_start\_onehs \= reshape(bta,\[],length(wholelist));
 quadrant(k).smallturn\_start\_onehs\_eb \= reshape(eb,\[],length(wholelist));
 \[bta,\~,eb] \= btd.behaviorTriggeredAverage('turn', 'start',wholelist, taxis, 'conditions', \[quadrant(k).condition bigturn] );
 quadrant(k).bigturn\_start \= reshape(bta,\[],length(wholelist));
 quadrant(k).bigturn\_start\_eb \= reshape(eb,\[],length(wholelist));
 \[bta,\~,eb] \= btd.behaviorTriggeredAverage('turn', 'start',wholelist, taxis, 'conditions', \[quadrant(k).condition smallturn] );
 quadrant(k).smallturn\_start \= reshape(bta,\[],length(wholelist));
 quadrant(k).smallturn\_start\_eb \= reshape(eb,\[],length(wholelist));
% quadrant(k).bigturn\_start\_onehs \= reshape(btd.behaviorTriggeredAverage('turn', 'start', wholelist, taxis, 'conditions', \[quadrant(k).condition bigturn onehs]),\[],length(wholelist));
% quadrant(k).smallturn\_start\_onehs \= reshape(btd.behaviorTriggeredAverage('turn', 'start', wholelist, taxis, 'conditions', \[quadrant(k).condition smallturn onehs]),\[],length(wholelist));
% quadrant(k).weightedTurnStart\_onehs \= reshape(btd.behaviorTriggeredWeightedAverage('turn', 'start', 'dtheta', wholelist, taxis, 'weightedOp', @abs, 'conditions', \[quadrant(k).condition onehs]),\[],length(wholelist));
 quadrant(k).weightedFirstHeadsweep \= reshape(btd.behaviorTriggeredWeightedAverage('hs', 'start', 'accepted', wholelist, taxis, 'conditions', \[quadrant(k).condition firsths]),\[],length(wholelist));
 
 quadrant(k).meanChangeBeforeTurn \= sum(turnmc(qq \=\= k,:), 1\)./nnz(qq \=\= k);
 quadrant(k).meanChangeBeforeTurn\_eb \= std(turnmc(qq \=\= k,:), 1\)./sqrt(nnz(qq \=\= k));
 quadrant(k).meanChangeBeforeTurn\_onehs \= sum(turnmc(hasonehs \& qq \=\= k,:), 1\)./nnz(hasonehs \& qq \=\= k);
 quadrant(k).meanChangeBeforeTurn\_onehs\_eb \= std(turnmc(hasonehs \& qq \=\= k,:), 1\)./sqrt(nnz(hasonehs \& qq \=\= k));

 
 quadrant(k).meanChangeBeforeBigTurn \= sum(turnmc(isbigturn \& qq \=\= k,:), 1\)./nnz(isbigturn \& qq \=\= k);
 quadrant(k).meanChangeBeforeBigTurn\_eb \= std(turnmc(isbigturn \& qq \=\= k,:), 1\)./sqrt(nnz(isbigturn \& qq \=\= k));

 quadrant(k).meanChangeBeforeSmallTurn \= sum(turnmc(issmallturn \& qq \=\= k,:), 1\)./nnz(issmallturn \& qq \=\= k);
 quadrant(k).meanChangeBeforeSmallTurn\_eb \= std(turnmc(issmallturn \& qq \=\= k,:), 1\)./sqrt(nnz(issmallturn \& qq \=\= k));

 quadrant(k).meanChangeBeforeBigTurn\_onehs \= sum(turnmc(isbigturn \& hasonehs \& qq \=\= k,:), 1\)./nnz(isbigturn \& hasonehs \& qq \=\= k);
 quadrant(k).meanChangeBeforeBigTurn\_onehs\_eb \= std(turnmc(isbigturn \& hasonehs \& qq \=\= k,:), 1\)./sqrt(nnz(isbigturn \& hasonehs \& qq \=\= k));

 quadrant(k).meanChangeBeforeSmallTurn\_onehs \= sum(turnmc(issmallturn \& hasonehs \& qq \=\= k,:), 1\)./nnz(issmallturn \& hasonehs \& qq \=\= k);
 quadrant(k).meanChangeBeforeSmallTurn\_onehs\_eb \= std(turnmc(issmallturn \& hasonehs \& qq \=\= k,:), 1\)./sqrt(nnz(issmallturn \& hasonehs \& qq \=\= k));

 quadrant(k).meanChangeAfterFirstHeadsweep \= sum(firsthsmc(qq \=\= k,:), 1\)./nnz(qq \=\= k);
 quadrant(k).meanChangeAfterFirstHeadsweep\_eb \= std(firsthsmc(qq \=\= k,:), 1\)./sqrt(nnz(qq \=\= k));
 
 quadrant(k).meanChangeAfterFirstAcceptedHeadsweep \= sum(firsthsmc(firstacc \& qq \=\= k,:), 1\)./nnz(firstacc \& qq \=\= k);
 quadrant(k).meanChangeAfterFirstAcceptedHeadsweep\_eb \= std(firsthsmc(firstacc \& qq \=\= k,:), 1\)./sqrt(nnz(firstacc \& qq \=\= k));

 quadrant(k).meanChangeAfterFirstRejectedHeadsweep \= sum(firsthsmc(firstrej \& qq \=\= k,:), 1\)./nnz(firstrej \& qq \=\= k);
 quadrant(k).meanChangeAfterFirstRejectedHeadsweep\_eb \= std(firsthsmc(firstrej \& qq \=\= k,:), 1\)./sqrt(nnz(firstrej \& qq \=\= k));

end

btdstruct.quadrant \= quadrant;

return;
for k \= 1:length(plane)
 

 fields \= {'turn', 'acchs', 'rejhs'};% 'acchs', 'rejhs','acchs', 'rejhs'};
 pos \= {'start', 'start', 'start'};% 'atmax', 'atmax', 'end', 'end'};


 for j \= 1:length(fields)
 \[bta, \~,eb] \= btd.behaviorTriggeredAverage(fields{j}, pos{j}, wholelist, taxis, 'conditions', plane(k).condition); 
 plane(k).(\[fields{j} '\_' pos{j}]) \= reshape(bta, \[], length(wholelist));
 plane(k).(\[fields{j} '\_' pos{j} '\_eb']) \= reshape(eb, \[], length(wholelist));
 end
 
 fields \= {'acchs', 'rejhs'};%, 'acchs', 'rejhs','acchs', 'rejhs'};
 pos \= {'start', 'start'};%, 'atmax', 'atmax', 'end', 'end'};

 % function \[bta, dm] \= behaviorTriggeredAverage (btd, tp, position, gltname, displacementAxis, varargin)
 for j \= 1:length(fields)
 \[bta, \~,eb] \= btd.behaviorTriggeredAverage(fields{j}, pos{j}, wholelist, taxis, 'conditions', \[plane(k).condition firsths]);
 %btdstruct.(\[fields{j} '\_' pos{j} '\_dm']) \= dm; %this takes up a lot of space!
 plane(k).(\['first\_' fields{j} '\_' pos{j}]) \= reshape(bta, \[], length(wholelist));
 plane(k).(\['first\_' fields{j} '\_' pos{j} '\_eb']) \= reshape(eb, \[], length(wholelist));
 
 end

 
 plane(k).bigturn\_start\_onehs \= reshape(btd.behaviorTriggeredAverage('turn', 'start', wholelist, taxis, 'conditions', \[plane(k).condition bigturn onehs]),\[],length(wholelist));
 plane(k).smallturn\_start\_onehs \= reshape(btd.behaviorTriggeredAverage('turn', 'start', wholelist, taxis, 'conditions', \[plane(k).condition smallturn onehs]),\[],length(wholelist));
 plane(k).weightedTurnStart\_onehs \= reshape(btd.behaviorTriggeredWeightedAverage('turn', 'start', 'dtheta', wholelist, taxis, 'weightedOp', @abs, 'conditions', \[plane(k).condition onehs]),\[],length(wholelist));
 plane(k).weightedFirstHeadsweep \= reshape(btd.behaviorTriggeredWeightedAverage('hs', 'start', 'accepted', wholelist, taxis, 'conditions', \[plane(k).condition firsths]),\[],length(wholelist));

end

btdstruct.plane \= plane;

%

% 

% 
% 
% theta \= atan2(mean(btdstruct.lin\_xy(:,2\)), mean(btdstruct.lin\_xy(:,1\)));
% 
% btdstruct.theta\_old \= theta;
% 
% btdstruct.linUOpOld \= @(yd) cos(theta)\*(yd{1}\-mx)/sx \+ sin(theta)\*(yd{2}\-my)/sy;
% btdstruct.linVOpOld \= @(yd) cos(theta)\*(yd{2}\-my)/sy \- sin(theta)\*(yd{1}\-mx)/sx;
% % btd \= addOperationFields (btd, gltname, newname, operation)
% btd \= btd.addOperationFields({kname1, kname2}, 'linUOld',btdstruct.linUOpOld);
% btd \= btd.addOperationFields({kname1, kname2}, 'linVOld', btdstruct.linVOpOld);
% 
% % btd \= btd.addOperationFields({stim1name, stim2name}, 'ufieldsum', @(yd) cos(theta)\*yd{1} \+ sin(theta)\*yd{2});
% % btd \= btd.addOperationFields({stim1name, stim2name}, 'vfieldsum', @(yd) cos(theta)\*yd{2} \- sin(theta)\*yd{1});
% 
% 
% btdstruct.lin\_uv\_old \= btd.behaviorTriggeredDataMatrix('turn', 'start', {'linUOld', 'linVOld'}, 0\);
% %btdstruct.lin\_uv\_all \= btd.behaviorTriggeredDataMatrix('all', 'start', {'linU', 'linV'}, 0, 'conditions', inrun);
% % scale \= repmat(std(lin\_xy\_all), \[length(btdstruct.lin\_xy) 1]);
% % lin\_xy \= btdstruct.lin\_xy./scale;
% 
% lin\_xy(:,1\) \= (btdstruct.lin\_xy(:,1\)\-mx)/sx;
% lin\_xy(:,2\) \= (btdstruct.lin\_xy(:,2\)\-my)/sy;
% lin\_uv \= btdstruct.lin\_uv\_old;
% 
% 
% u \= mean(lin\_xy);
% c \= cov(lin\_xy);
% btdstruct.kl\_xy \= 0\.5\*(trace(c)\-log(det(c))\+u\*u' \- 2\);
% 
% c \= cov(lin\_xy(:,1\));
% btdstruct.kl\_x \= 0\.5\*(trace(c)\-log(det(c))\+u(1\).^2 \- 1\);
% 
% c \= cov(lin\_xy(:,2\));
% btdstruct.kl\_y \= 0\.5\*(trace(c)\-log(det(c))\+u(2\).^2 \- 1\);
% 
% 
% u \= mean(lin\_uv);
% c \= cov(lin\_uv);
% btdstruct.kl\_uv\_old \= 0\.5\*(trace(c)\-log(det(c))\+u\*u' \- 2\);
% 
% c \= cov(lin\_uv(:,1\));
% btdstruct.kl\_u\_old \= 0\.5\*(trace(c)\-log(det(c))\+u(1\).^2 \- 1\);
% 
% c \= cov(lin\_uv(:,2\));
% btdstruct.kl\_v\_old \= 0\.5\*(trace(c)\-log(det(c))\+u(2\).^2 \- 1\);
\-\-\-

\#\#\# File: prepVarianceSwitchingAnalysis\_Gepner.m (ID: @BehaviorTriggeredData.4\)

function btdstruct \= prepVarianceSwitchingAnalysis\_Gepner(btdstruct, opstruct)
%btdstruct \= prepVarianceSwitchingAnalysis(btdstruct, opstruct)
%

if (nargin \< 1\)
 opstruct.stim(1\).gqname \= 'led1ValDiff';
 opstruct.stim(1\).iswn \= true;
 opstruct.stim(1\).ramptype \= 'square';
 opstruct.stim(1\).switch \= true;
 opstruct.stim(1\).period \= \[];
 opstruct.stim(2\).gqname \= 'led2ValDiff';
 opstruct.stim(2\).iswn \= true;
 opstruct.stim(2\).ramptype \= 'square';
 opstruct.stim(2\).switch \= false;
 opstruct.stim(2\).period \= \[];
 opstruct.timeRange \= \[\-Inf Inf];
 opstruct.redogq \= true;
 opstruct.kernelTime \= 7;
 opstruct.kernelDt \= 0\.1;
 btdstruct \= opstruct;
 disp ('ramp types are square, triangle, sine, and constant');
 return;
end

if (nargin \< 2 \|\| \~isfield(btdstruct, 'btd'))
 warning ('first argument must be a btdstruct and second argument contains options');
 return;
end

for j \= find(\[opstruct.stim.iswn])
 
 if (opstruct.stim(j).switch \=\= 1\)
 if(strcmpi(opstruct.stim(j).gqname, 'led2m1ValDiff')) 
 if(strcmpi(opstruct.stim(1\).gqname, 'led1ValDiff'))
 stims{1} \= 'led1Val';
 stimdiffs{1} \= 'led1ValDiff';
 else
 stims{1} \= 'ledVal';
 stimdiffs{1} \= 'ledValDiff';
 end
 if(strcmpi(opstruct.stim(2\).gqname, 'led2ValDiff'))
 stims{2} \= 'led2Val';
 stimdiffs{2} \= 'led2ValDiff';
 else
 stims{2} \= 'ledVal';
 stimdiffs{2} \= 'ledValDiff';
 end
 OdorPlusLight \= @(yd) 1/sqrt(2\) \* (yd{1} \- yd{2});
 btdstruct.btd \= btdstruct.btd.addOperationFields({stims{2}, stims{1}}, 'led2m1Val', OdorPlusLight);
 btdstruct.btd \= btdstruct.btd.addOperationFields({stimdiffs{2}, stimdiffs{1}}, opstruct.stim(j).gqname, OdorPlusLight);
 end
 if (any(btdstruct.btd.findField(\[opstruct.stim(j).gqname '\_var\_ton']) \<\= 0\))
 btdstruct.btd \= btdstruct.btd.addVarianceGQs(opstruct.stim(j).gqname, opstruct.stim(j).ramptype, 'fixedPeriod', opstruct.stim(j).period);
 end
 end
 
end

for j \= 1:length(opstruct.stim)
 % if (opstruct.stim(j).iswn \&\& \~strcmpi(opstruct.stim(j).gqname, 'led2m1ValDiff') \&\& (opstruct.redogq \|\| any(btdstruct.btd.findField(\[opstruct.stim(j).gqname 'TurnLin']) \<\= 0\)))
 if ( \~strcmpi(opstruct.stim(j).gqname, 'led2m1ValDiff') \&\& (opstruct.redogq \|\| any(btdstruct.btd.findField(\[opstruct.stim(j).gqname 'TurnLin']) \<\= 0\)))
 btdstruct \= addScaledVarianceTurnLin (btdstruct, opstruct, j);
 end
end


for j \= find(\~\[opstruct.stim.iswn] \& \[opstruct.stim.switch])
 %if (opstruct.redogq \|\| any(btdstruct.btd.findField(\[opstruct.stim(j).gqname '\_ton']) \<\= 0\))
 btdstruct.btd \= btdstruct.btd.addTonToffGQs(opstruct.stim(j).gqname, opstruct.stim(j).ramptype, 'fixedPeriod', opstruct.stim(j).period);
 %end
end

for j \= find(\~\[opstruct.stim.iswn] \& \[opstruct.stim.switch])
 disp (\['stim ' \- num2str(j) ' is not switching or noisy \- so I am ignoring it']);
end

varswitch \= \[opstruct.stim.iswn] \& \[opstruct.stim.switch];
switchstim \= 0;
switch (nnz(varswitch))
 case 0
 if (any(\[opstruct.stim.switch]))
 switchstim \= find(\[opstruct.stim.switch], 1, 'first');
 gq\_switch \= opstruct.stim(switchstim).gqname;
 end
 case 1
% gq\_switch \= opstruct.stim(varswitch).gqname;
 switchstim \= find(varswitch);
% if (any(btdstruct.btd.findField(\[gq\_switch '\_ratePredROG\_var\_low']) \<\= 0\) \|\| any(btdstruct.btd.findField(\[gq\_switch '\_ratePredROG\_var\_low\_last'])\<\=0\) )
% btdstruct \= ratefunGQVariance(btdstruct, opstruct);
% end
 gq\_switch \= \[opstruct.stim(switchstim).gqname '\_var'];
 otherwise
 warning ('I don''t know how to handle multiple variances switching simultaneously');
 return;
end

opstruct.switchstim \= switchstim;
btdstruct.varops \= opstruct;

btdstruct \= gatherVarianceFields(btdstruct, opstruct);

end

function \[btdstruct, var] \= gatherVarianceFields (btdstruct, opstruct)

btd \= btdstruct.btd;

switchstim \= btdstruct.varops.switchstim;

aa \= \[btd.all]';
alleti \= \[aa.eti]';
tt \= \[btd.turn]';
turneti \= \[tt.start\_eti]';
isrun \= \[aa.isrun]';

acchs \= \[btd.acchs]';
rejhs \= \[btd.rejhs]';
acchseti \= \[acchs.start\_eti]';
rejhseti \= \[rejhs.start\_eti]';

accnhs \= \[acchs.hsnum]';
rejnhs \= \[rejhs.hsnum]';
firstacchs \= accnhs \=\= 1;
firstrejhs \= rejnhs \=\= 1;

if (switchstim \> 0\)
 if (btdstruct.varops.stim(switchstim).iswn)
 gqswitch \= \[btdstruct.varops.stim(switchstim).gqname '\_var'];
 else
 gqswitch \= btdstruct.varops.stim(switchstim).gqname;
 end
 
 
 if(strcmpi(btdstruct.varops.stim(switchstim).ramptype, 'square'))
 gq\_varh \= strcat(gqswitch, '\_high');
% gq\_varl \= strcat(gqswitch, '\_low');
 else
 gq\_varh \= strcat(gqswitch, '\_rising');
% gq\_varl \= strcat(gqswitch, '\_falling');
 end
 
 ii \= btd(1\).findField(gq\_varh);
 xd \= btd(1\).glt(ii).xData;
 yd \= double(btd(1\).glt(ii).yData);
 \[freq, phase] \= fitWave(xd, yd, 'square');
 period \= 2\*pi/freq;
 tshift \= phase/freq;
 
 gq\_ton \= \[gqswitch,'\_ton'];
 gq\_toff \= \[gqswitch,'\_toff'];
 
 firsths.name \= 'hsnum';
 firsths.validop \= @(x) x \=\= 1;

 all\_ton \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_ton, 0\);
 all\_toff \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_toff, 0\);
 turn\_ton \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_ton, 0\);
 turn\_toff \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_toff, 0\);
 acchs\_ton \= btd.behaviorTriggeredDataMatrix('acchs', 'start', gq\_ton, 0\);
 rejhs\_ton \= btd.behaviorTriggeredDataMatrix('rejhs', 'start', gq\_ton, 0\);
 acchs\_toff \= btd.behaviorTriggeredDataMatrix('acchs', 'start', gq\_toff, 0\);
 rejhs\_toff \= btd.behaviorTriggeredDataMatrix('rejhs', 'start', gq\_toff, 0\);
 
else
 all\_ton \= \[];
 all\_toff \= \[];
 turn\_ton \= \[];
 turn\_toff \= \[];
end

if (switchstim\>0 \&\& isempty(btdstruct.varops.stim(switchstim).period))
 btdstruct.varops.stim(switchstim).period \= max(max(all\_ton), max(all\_toff));
 period \= btdstruct.varops.stim(switchstim).period;
end
 

mintime \= min(alleti(all\_ton \> 0 \& all\_toff \> 0\));
if(\~isempty(mintime))
 btdstruct.varops.timeRange(1\) \= min(btdstruct.varops.timeRange(1\), mintime);
end
 
turnvalid \= turneti \>\= min(btdstruct.varops.timeRange) \& turneti \< max(btdstruct.varops.timeRange);
allvalid \= alleti \>\= min(btdstruct.varops.timeRange) \& alleti \< max(btdstruct.varops.timeRange);
acchsvalid \= acchseti \>\= min(btdstruct.varops.timeRange) \& acchseti \< max(btdstruct.varops.timeRange);
rejhsvalid \= rejhseti \>\= min(btdstruct.varops.timeRange) \& rejhseti \< max(btdstruct.varops.timeRange);

for whichStim \= 1:length(btdstruct.varops.stim)
 
 if(strcmpi(btdstruct.varops.stim(whichStim).gqname, 'led2m1ValDiff'))
 continue
 end
 
 gq \= btdstruct.varops.stim(whichStim).gqname;
 gq\_conv \= strcat(gq, 'TurnLin');
 if(any(btdstruct.btd.findField(gq\_conv) \<\= 0\)) %for the case where gq is led1Val or led2Val
 \[turndata,\~,texpnum] \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq, 0\);
 \[alldata,\~,aexpnum] \= btd.behaviorTriggeredDataMatrix('all', 'start', gq, 0\);
 else
 \[turndata,\~,texpnum] \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_conv, 0\);
 \[alldata,\~,aexpnum] \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_conv, 0\);
 end
 var(whichStim).gqname \= btdstruct.varops.stim(whichStim).gqname;
 var(whichStim).fullensemble.x\_conv \= alldata(allvalid);
 var(whichStim).fullensemble.eti \= alleti (allvalid);

 var(whichStim).fullensemble.expnum \= aexpnum (allvalid); 
 var(whichStim).noturn.x\_conv \= alldata(isrun \& allvalid);
 var(whichStim).noturn.eti \= alleti (isrun \& allvalid);

 var(whichStim).noturn.expnum \= aexpnum (isrun \& allvalid);
 var(whichStim).turn.x\_conv \= turndata(turnvalid);
 var(whichStim).turn.eti \= turneti (turnvalid);
 var(whichStim).turn.expnum \= texpnum (turnvalid);

 var(whichStim).acchs.eti \= acchseti(acchsvalid \& firstacchs);
 var(whichStim).rejhs.eti \= rejhseti(rejhsvalid \& firstrejhs);
 
 if(switchstim \> 0\)
 var(whichStim).fullensemble.ton \= all\_ton (allvalid);
 var(whichStim).fullensemble.toff \= all\_toff (allvalid);
 var(whichStim).noturn.ton \= all\_ton (isrun \& allvalid);
 var(whichStim).noturn.toff \= all\_toff (isrun \& allvalid);
 var(whichStim).turn.ton \= turn\_ton (turnvalid);
 var(whichStim).turn.toff \= turn\_toff (turnvalid);
 
 var(whichStim).acchs.ton \= acchs\_ton(acchsvalid \& firstacchs);
 var(whichStim).acchs.toff \= acchs\_toff(acchsvalid \& firstacchs);
 var(whichStim).rejhs.ton \= rejhs\_ton(rejhsvalid \& firstrejhs);
 var(whichStim).rejhs.toff \= rejhs\_toff(rejhsvalid \& firstrejhs);
 
 var(whichStim).period \= period;
 var(whichStim).tshift \= tshift;
 end
 
 btdstruct.var \= var;
end

if(switchstim\>0\)
 if(strcmpi(btdstruct.varops.stim(switchstim).gqname, 'led2m1ValDiff'))
 kname\_uv \= {'linU', 'linV'};
 
 stimnames \= {opstruct.stim(1\).gqname, opstruct.stim(2\).gqname};
 kname1 \= \[stimnames{1} 'TurnLin'];
 kname2 \= \[stimnames{2} 'TurnLin'];

 if(isfield(opstruct, 'thetaUV') \&\& \~isfield(opstruct.thetaUV, 'low') )
 
 theta\_all \= opstruct.thetaUV \* ones(size(all\_ton));
 theta\_turn \= opstruct.thetaUV \* ones(size(turn\_ton));
 
 elseif(isfield(btdstruct, 'theta\_all'))
 theta\_all \= btdstruct.theta\_all;
 elseif(isfield(opstruct, 'thetaUV') \&\& isfield(opstruct.thetaUV, 'low') )
 
 if(strcmpi(opstruct.stim(switchstim).ramptype, 'square'))
 theta\_all \= zeros(size(all\_ton));
 theta\_all(all\_ton(period/2\-opstruct.adaptationTime) \& all\_ton\<(period/2\+opstruct.adaptationTime)) \= opstruct.thetaUV.high;
 theta\_all(all\_toff\>(period/2\-opstruct.adaptationTime) \& all\_toff\<(period/2\+opstruct.adaptationTime)) \= opstruct.thetaUV.low;
 if(isfield(opstruct.thetaUV, 'up'))
 theta\_all(all\_ton\>opstruct.adaptationTime) \= opstruct.thetaUV.up;
 theta\_all(all\_toff\>opstruct.adaptationTime) \= opstruct.thetaUV.down;
 end
 theta\_all(theta\_all\=\=0\) \= pi/4;
 
 theta\_turn \= zeros(size(turn\_ton));
 theta\_turn(turn\_ton\>(period/2\-opstruct.adaptationTime) \& turn\_ton\<(period/2\+opstruct.adaptationTime)) \= opstruct.thetaUV.high;
 theta\_turn(turn\_toff\>(period/2\-opstruct.adaptationTime) \& turn\_toff\<(period/2\+opstruct.adaptationTime)) \= opstruct.thetaUV.low;
 if(isfield(opstruct.thetaUV, 'up'))
 theta\_turn(turn\_ton\>opstruct.adaptationTime) \= opstruct.thetaUV.up;
 theta\_turn(turn\_toff\>opstruct.adaptationTime) \= opstruct.thetaUV.down;
 end
 theta\_turn(theta\_turn\=\=0\) \= pi/4;
 end
 
 end
 
 alldata \= btd.behaviorTriggeredDataMatrix('all', 'start', {kname1, kname2}, 0\);
 turndata \= btd.behaviorTriggeredDataMatrix('turn', 'start', {kname1, kname2}, 0\);
 ad(:,1\) \= cos(theta\_all).\*alldata(:,1\) \+ sin(theta\_all).\*alldata(:,2\);
 td(:,1\) \= cos(theta\_turn).\*turndata(:,1\) \+ sin(theta\_turn).\*turndata(:,2\);
 ad(:,2\) \= cos(theta\_all).\*alldata(:,2\) \- sin(theta\_all).\*alldata(:,1\);
 td(:,2\) \= cos(theta\_turn).\*turndata(:,2\) \- sin(theta\_turn).\*turndata(:,1\);
 
 for whichStim\=1:2
 
% \[td,\~,texpnum] \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', kname\_uv{whichStim}, 0\);
% \[ad,\~,aexpnum] \= btdstruct.btd.behaviorTriggeredDataMatrix('all', 'start', kname\_uv{whichStim}, 0\);
 btdstruct.var\_uv(whichStim).gqname \= kname\_uv{whichStim};

 btdstruct.var\_uv(whichStim).fullensemble.theta \= theta\_all(allvalid);
 btdstruct.var\_uv(whichStim).fullensemble.x\_conv \= ad(allvalid, whichStim);
 btdstruct.var\_uv(whichStim).fullensemble.eti \= alleti (allvalid);
 btdstruct.var\_uv(whichStim).fullensemble.ton \= all\_ton (allvalid);
 btdstruct.var\_uv(whichStim).fullensemble.toff \= all\_toff (allvalid);
 btdstruct.var\_uv(whichStim).fullensemble.expnum \= aexpnum (allvalid);
 
 btdstruct.var\_uv(whichStim).noturn.theta \= theta\_all(isrun \& allvalid);
 btdstruct.var\_uv(whichStim).noturn.x\_conv \= ad(isrun \& allvalid, whichStim);
 btdstruct.var\_uv(whichStim).noturn.eti \= alleti (isrun \& allvalid);
 btdstruct.var\_uv(whichStim).noturn.ton \= all\_ton (isrun \& allvalid);
 btdstruct.var\_uv(whichStim).noturn.toff \= all\_toff (isrun \& allvalid);
 btdstruct.var\_uv(whichStim).noturn.expnum \= aexpnum (isrun \& allvalid);
 
 btdstruct.var\_uv(whichStim).turn.theta \= theta\_turn(turnvalid);
 btdstruct.var\_uv(whichStim).turn.x\_conv \= td(turnvalid, whichStim);
 btdstruct.var\_uv(whichStim).turn.eti \= turneti (turnvalid);
 btdstruct.var\_uv(whichStim).turn.ton \= turn\_ton (turnvalid);
 btdstruct.var\_uv(whichStim).turn.toff \= turn\_toff (turnvalid);
 btdstruct.var\_uv(whichStim).turn.expnum \= texpnum (turnvalid);
 btdstruct.var\_uv(whichStim).period \= period;
 btdstruct.var\_uv(whichStim).tshift \= tshift;
 
 end
 end
end

% for whichStim \= find(\[btdstruct.varops.stim.iswn])




end

function btdstruct \= addScaledVarianceTurnLin (btdstruct,opstruct,j)

switchstim \= find(\[opstruct.stim.switch], 1, 'first');
if(\~isempty(switchstim))
 switchname \= opstruct.stim(switchstim).gqname;
end
btd \= btdstruct.btd;
gqname \= opstruct.stim(j).gqname;
if(opstruct.stim(j).isstep)
 gqname \= \[gqname '\_nostep'];
end
kname \= \[gqname 'TurnLin'];
kname\_low \= \[gqname 'TurnLin\_var\_low'];
kname\_high \= \[gqname 'TurnLin\_var\_high'];

kernelTime \= opstruct.kernelTime;
kernelDt \= opstruct.kernelDt;
btdstruct.kernelTime \= kernelTime;
btdstruct.kernelDt \= kernelDt;

taxis \= \-(0:kernelDt:kernelTime);

 if( (nnz(\[opstruct.stim.iswn]) \=\= 1 \&\& opstruct.stim(j).switch \=\= 1 \&\& strcmpi(opstruct.stim(j).ramptype, 'square')) \|\| nnz(\[opstruct.stim.switch])\=\=0 \|\| (nnz(\[opstruct.stim.iswn]) \=\= 2 \&\& \~isfield(opstruct, 'convkernels')) )
%if( (nnz(\[opstruct.stim.iswn]) \=\= 1 \&\& opstruct.stim(j).switch \=\= 1 \&\& strcmpi(opstruct.stim(j).ramptype, 'square')) \|\| (nnz(\[opstruct.stim.iswn]) \=\= 2 \&\& \~isfield(opstruct, 'convkernels')) )

 if(\~isempty(switchstim))
 stimTon \= btd.behaviorTriggeredDataMatrix ('all', '', \[switchname '\_var\_ton'],0\);
 stimToff \= btd.behaviorTriggeredDataMatrix ('all', '', \[switchname '\_var\_toff'],0\);
 turnTon \= btd.behaviorTriggeredDataMatrix ('turn', 'start', \[switchname '\_var\_ton'],0\);
 turnToff \= btd.behaviorTriggeredDataMatrix ('turn', 'start', \[switchname '\_var\_toff'],0\);
 
 islow \= turnToff \< turnTon \& turnToff \> 0;
 ishigh \= turnToff \> turnTon \& turnToff \> 0;
 islow\_all \= stimToff \< stimTon \& stimToff \> 0;
 ishigh\_all \= stimToff \> stimTon \& stimToff \> 0;
 end
 %using only one kernel
 
 btdstruct.linname{j} \= kname;
 \[convkernel, btd] \= btdstruct.btd.createBTAKernel('turn', 'start', gqname, kernelTime, kernelDt, 'newFieldName',kname, 'abbott', false);
 stimInput \= btd.behaviorTriggeredDataMatrix ('all', '', kname, 0\);
 turnInput \= btd.behaviorTriggeredDataMatrix('turn', 'start', gqname, taxis);
 
 if(opstruct.stim(j).switch)
 inds\_low \= islow\_all \& stimToff \> kernelTime; %guarantee only in low variance portion
 inds\_high \= ishigh\_all \& stimTon\>kernelTime;
 sl \= std(stimInput(inds\_low));
 sh \= std(stimInput(inds\_high));
 s \= sl;
 btdstruct.kernelScaling(j) \= s;
 else
 s \= std(stimInput) / opstruct.stim(j).var;
% s \= std(stimInput);
 end
 
 convkernel \= convkernel / s;

 
 % using high and low kernels
 
 % aa \= \[btd.all];
 % alleti \= \[aa.eti];
 % tt \= \[btd.turn]';
 % turneti \= \[tt.start\_eti]';
 %
 % mintime \= min(alleti(stimTon \> 0 \& stimToff \> 0\));
 % turnvalid \= turneti \>\= mintime;
 % allvalid \= alleti \>\= mintime;
 %
 % ishigh \= ishigh(turnvalid);
 % islow \= islow(turnvalid);
 %
 % dm\_all \= turnInput(turnvalid, :);
 %
 % dm\_high \= dm\_all(ishigh, :);
 % dm2 \= dm\_high; dm2(\~isfinite(dm2\)) \= 0;
 % bta\_high \= sum(dm2\)./sum(isfinite(dm\_high));
 %
 % dm\_low \= dm\_all(islow, :);
 % dm2 \= dm\_low; dm2(\~isfinite(dm2\)) \= 0;
 % bta\_low \= sum(dm2\)./sum(isfinite(dm\_low));
 % bta\_low \= bta\_low \* max(abs(bta\_high))/max(abs(bta\_low));
 %
 % abbottfun \= @(x,t) (x(3\)\*exp(\-x(2\)\*t)/(x(1\)\-x(2\)) \- x(5\)\*exp(\-x(4\)\*t)/(x(1\)\-x(4\)) \+ (x(3\)\*(x(4\)\-x(1\)) \- x(5\)\*(x(2\)\-x(1\)))\*exp(\-x(1\)\*t)/((x(1\)\-x(2\))\*(x(1\)\-x(4\)))) .\* (t \<\= 0\);
 %
 % \[\~,I] \= max(abs(bta\_low));
 % mv \= bta\_low(I);
 % x0 \= \[\-1\.5 \-1 mv \-0\.5 mv\*1\.5];
 % op \= optimset('lsqcurvefit');
 % op.MaxFunEvals \= 1E4;
 % op.MaxIter \= 1e4;
 % x \= lsqcurvefit(abbottfun, x0, taxis, bta\_low,\[],\[],op);
 % convkernel\_low \= abbottfun(x,taxis);
 %
 %
 % \[\~,I] \= max(abs(bta\_high));
 % mv \= bta\_high(I);
 % x0 \= \[\-1\.5 \-1 mv \-0\.5 mv\*1\.5];
 % op \= optimset('lsqcurvefit');
 % op.MaxFunEvals \= 1E5;
 % op.MaxIter \= 1e4;
 % x \= lsqcurvefit(abbottfun, x0, taxis, bta\_high,\[],\[],op);
 % convkernel\_high \= abbottfun(x,taxis);
 %
 % convkernel\_low \= convkernel\_low \* max(abs(convkernel))/max(abs(convkernel\_low));
 % convkernel\_high \= convkernel\_high \* max(abs(convkernel))/max(abs(convkernel\_high));
 %
 % btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, kname\_low, convkernel\_low, kernelDt, 'scaleToSqr', true);
 % btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, kname\_high, convkernel\_high, kernelDt, 'scaleToSqr', true);
 %
 % btdstruct.convkernels\_low{j} \= convkernel\_low;
 % btdstruct.convkernels\_high{j} \= convkernel\_high;
 
else

 convkernel \= opstruct.convkernels{j};

 
end

btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, kname, convkernel, kernelDt, 'scaleToSqr', true);

btdstruct.convkernels{j} \= convkernel;


end




\-\-\-

\#\#\# File: analyzeVarianceSwitchingExperiment\_Gepner.m (ID: @BehaviorTriggeredData.5\)

function btdstruct \= analyzeVarianceSwitchingExperiment\_Gepner(btdstruct, opstruct, qfactor)
%btdstruct \= analyzeVarianceSwitchingExperiment(btdstruct, opstruct)
%

if (nargin \< 1\)
 opstruct.stim(1\).gqname \= 'led1ValDiff';
 opstruct.stim(1\).iswn \= true;
 opstruct.stim(1\).isstep \= false;
 opstruct.stim(1\).ramptype \= 'square';
 opstruct.stim(1\).switch \= true;
 opstruct.stim(1\).period \= \[];
 opstruct.stim(2\).gqname \= 'led2ValDiff';
 opstruct.stim(2\).iswn \= true;
 opstruct.stim(2\).isstep \= false;
 opstruct.stim(2\).ramptype \= 'square';
 opstruct.stim(2\).switch \= false;
 opstruct.stim(2\).period \= \[];
 opstruct.timeRange \= \[60 Inf];
 opstruct.numTimeBins \= 120; %time bin size \= period/numTimeBins
 opstruct.redogq \= false;
 opstruct.numLxBins \= 10;
 opstruct.kernelTime \= 7;
 opstruct.kernelDt \= 0\.1;
 opstruct.adaptationTime \= 10; %first T seconds to exclude from high/low cycles in analysis
 opstruct.Q\_alpha \= 0\.2;
 opstruct.pdegree \= 1;
 btdstruct \= opstruct;
 disp ('ramp types are square, triangle, sine, and constant');
 return;
end

if (nargin \< 2\)
 error ('first argument must be a btdstruct and second argument contains options');
end
% 
% opstruct.kalmanNoiseDiffusion1D \= qfactor\*eye(3\);
% opstruct.kalmanNoiseDiffusion2D \= qfactor\*eye(6\);

if(\~isfield(btdstruct,'varops'))
 btdstruct.varops \= opstruct;
else
 btdstruct.varops.kalmanNoiseDiffusion1D \= qfactor\*eye(3\);
 btdstruct.varops.kalmanNoiseDiffusion2D \= qfactor\*eye(6\);
 opstruct \= btdstruct.varops;
end


n \= find(\[opstruct.stim.varswitch]);
gq\_switch \= opstruct.stim(n).gqname;

% if(\~isfield(btdstruct, 'btd'))
% 
% period \= btdstruct.varops.stim.period;
% 
% turnToff \= btdstruct.var.turn.toff;
% turnTon \= btdstruct.var.turn.ton;
% turnX \= btdstruct.var.turn.x\_conv;
% runToff \= btdstruct.var.noturn.toff;
% runTon \= btdstruct.var.noturn.ton;
% runX \= btdstruct.var.noturn.x\_conv;
% samplingInterval \= median(diff(btdstruct.var.fullensemble.eti));
% qrate \= btdstruct.varops.kalmanNoiseDiffusion;
% 
% btdstruct.var.rateEst\_on \= estimateRateVsTime(turnTon, turnX, runTon, runX, period, samplingInterval, qrate);
% btdstruct.var.rateEst\_off \= estimateRateVsTime(turnToff, turnX, runToff, runX, period, samplingInterval, qrate);
% return;
% end


if (\~opstruct.stim(1\).iswn \|\| strcmpi(opstruct.stim(1\).ramptype, 'constant'))
 error ('reorder options so that first argument is a white noise signal with time varying variance');
end


for j \= find(\[opstruct.stim.iswn])
 gqname \= opstruct.stim(j).gqname;
 
 if(opstruct.stim(j).isstep) %take out the step from the stimulus
 gq\_nostep \= strcat(gqname, '\_nostep');
 for i\=1:length(btd)
 ind \= btd(i).findField(gqname);
 old \= btd(i).glt(ind);
 new \= old;
 new.fieldname \= gq\_nostep;
 new.yData(abs(new.yData)\>7\*std(new.yData))\=0;
 btdstruct.btd(i).glt(end\+1\) \= new;
 end
 gqname \= gq\_nostep;
 end
 
 if (opstruct.stim(j).varswitch \=\= 1\)
 if (any(btdstruct.btd.findField(\[gqname '\_var\_high']) \<\= 0\))
 btdstruct.btd \= btdstruct.btd.addVarianceGQs(gqname, opstruct.stim(j).ramptype);
 end
 end
 if ( j\<3 \&\& (opstruct.redogq \|\| any(btdstruct.btd.findField(\[gqname 'TurnLin']) \<\= 0\)))
 btdstruct \= addScaledVarianceTurnLin (btdstruct, opstruct, j);
 end
 
end


% for j \= find(\~\[opstruct.stim.iswn])
% if (opstruct.redogq \|\| any(btdstruct.btd.findField(\[opstruct.stim(j).gqname '\_ton']) \<\= 0\))
% btdstruct.btd \= btdstruct.btd.addTonToffGQs(opstruct.stim(j).gqname, opstruct.stim(j).ramptype, 'fixedPeriod', opstruct.stim(j).period);
% end
% end
% 
% if (any(btdstruct.btd.findField(\[gq\_switch '\_ratePredROG\_var\_low']) \<\= 0\) \|\| any(btdstruct.btd.findField(\[gq\_switch '\_ratePredROG\_var\_low\_last'])\<\=0\) )
% btdstruct \= ratefunGQVariance(btdstruct, opstruct);
% end


if (length(opstruct.stim) \=\= 1\)
 btdstruct \= analyzeVariance1Source (btdstruct);
% btdstruct \= VarInnovations(btdstruct);
 return
end


if (nnz(\[opstruct.stim.iswn]) \> 1\)
 btdstruct \= analyzeVariancePlusNoise (btdstruct, n);
% btdstruct \= VarInnovations(btdstruct);
 return;
end
end

function btdstruct \= addScaledVarianceTurnLin (btdstruct,opstruct,j)

btd \= btdstruct.btd;
gqname \= opstruct.stim(j).gqname;
if(opstruct.stim(j).isstep)
 gqname \= \[gqname '\_nostep'];
end
kname \= \[gqname 'TurnLin'];
kname\_low \= \[gqname 'TurnLin\_var\_low'];
kname\_high \= \[gqname 'TurnLin\_var\_high'];

kernelTime \= opstruct.kernelTime;
kernelDt \= opstruct.kernelDt;
btdstruct.kernelTime \= kernelTime;
btdstruct.kernelDt \= kernelDt;

taxis \= \-(0:kernelDt:kernelTime);
 
if( nnz(\[opstruct.stim.iswn]) \=\= 1 \&\& opstruct.stim(j).varswitch \=\= 1 \&\& strcmpi(opstruct.stim(j).ramptype, 'square'))
 
 
 stimTon \= btd.behaviorTriggeredDataMatrix ('all', '', \[gqname '\_var\_ton'],0\);
 stimToff \= btd.behaviorTriggeredDataMatrix ('all', '', \[gqname '\_var\_toff'],0\);
 turnTon \= btd.behaviorTriggeredDataMatrix ('turn', 'start', \[gqname '\_var\_ton'],0\);
 turnToff \= btd.behaviorTriggeredDataMatrix ('turn', 'start', \[gqname '\_var\_toff'],0\);
 
 islow \= turnToff \< turnTon \& turnToff \> 0;
 ishigh \= turnToff \> turnTon \& turnToff \> 0;
 islow\_all \= stimToff \< stimTon \& stimToff \> 0;
 ishigh\_all \= stimToff \> stimTon \& stimToff \> 0;
 
 %using only one kernel

 btdstruct.linname{j} \= kname;
 \[convkernel, btd] \= btdstruct.btd.createBTAKernel('turn', 'start', gqname, kernelTime, kernelDt, 'newFieldName',kname, 'abbott', true);
 stimInput \= btd.behaviorTriggeredDataMatrix ('all', '', kname, 0\);
 turnInput \= btd.behaviorTriggeredDataMatrix('turn', 'start', gqname, taxis);
 
 inds\_low \= islow\_all \& stimToff \> kernelTime; %guarantee only in low variance portion
 inds\_high \= ishigh\_all \& stimTon\>kernelTime;
 sl \= std(stimInput(inds\_low));
 sh \= std(stimInput(inds\_high));
 s \= sl;
 
 btdstruct.kernelScaling(j) \= s;
 convkernel \= convkernel / s;
 
 
 % using high and low kernels
 
% aa \= \[btd.all];
% alleti \= \[aa.eti];
% tt \= \[btd.turn]';
% turneti \= \[tt.start\_eti]';
% 
% mintime \= min(alleti(stimTon \> 0 \& stimToff \> 0\));
% turnvalid \= turneti \>\= mintime;
% allvalid \= alleti \>\= mintime;
% 
% ishigh \= ishigh(turnvalid);
% islow \= islow(turnvalid);
% 
% dm\_all \= turnInput(turnvalid, :);
% 
% dm\_high \= dm\_all(ishigh, :);
% dm2 \= dm\_high; dm2(\~isfinite(dm2\)) \= 0;
% bta\_high \= sum(dm2\)./sum(isfinite(dm\_high));
% 
% dm\_low \= dm\_all(islow, :);
% dm2 \= dm\_low; dm2(\~isfinite(dm2\)) \= 0;
% bta\_low \= sum(dm2\)./sum(isfinite(dm\_low));
% bta\_low \= bta\_low \* max(abs(bta\_high))/max(abs(bta\_low));
% 
% abbottfun \= @(x,t) (x(3\)\*exp(\-x(2\)\*t)/(x(1\)\-x(2\)) \- x(5\)\*exp(\-x(4\)\*t)/(x(1\)\-x(4\)) \+ (x(3\)\*(x(4\)\-x(1\)) \- x(5\)\*(x(2\)\-x(1\)))\*exp(\-x(1\)\*t)/((x(1\)\-x(2\))\*(x(1\)\-x(4\)))) .\* (t \<\= 0\);
% 
% \[\~,I] \= max(abs(bta\_low));
% mv \= bta\_low(I);
% x0 \= \[\-1\.5 \-1 mv \-0\.5 mv\*1\.5];
% op \= optimset('lsqcurvefit');
% op.MaxFunEvals \= 1E4;
% op.MaxIter \= 1e4;
% x \= lsqcurvefit(abbottfun, x0, taxis, bta\_low,\[],\[],op);
% convkernel\_low \= abbottfun(x,taxis);
% 
% 
% \[\~,I] \= max(abs(bta\_high));
% mv \= bta\_high(I);
% x0 \= \[\-1\.5 \-1 mv \-0\.5 mv\*1\.5];
% op \= optimset('lsqcurvefit');
% op.MaxFunEvals \= 1E5;
% op.MaxIter \= 1e4;
% x \= lsqcurvefit(abbottfun, x0, taxis, bta\_high,\[],\[],op);
% convkernel\_high \= abbottfun(x,taxis);
% 
% convkernel\_low \= convkernel\_low \* max(abs(convkernel))/max(abs(convkernel\_low));
% convkernel\_high \= convkernel\_high \* max(abs(convkernel))/max(abs(convkernel\_high));
% 
% btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, kname\_low, convkernel\_low, kernelDt, 'scaleToSqr', true);
% btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, kname\_high, convkernel\_high, kernelDt, 'scaleToSqr', true);
% 
% btdstruct.convkernels\_low{j} \= convkernel\_low;
% btdstruct.convkernels\_high{j} \= convkernel\_high;
 
else
 btd \= btdstruct.btd;
 btdstruct.kernelScaling(j) \= opstruct.kernelScaling(j);
 convkernel \= opstruct.convkernels{j};
end

btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, kname, convkernel, kernelDt, 'scaleToSqr', true);

btdstruct.convkernels{j} \= convkernel;


end


function rateEstimate \= estimateRateVsTime (turnT, turnT\_modT, turnX, runT, runT\_modT, runX, allT, allT\_modT, allX, period, samplingInterval, qrate, opstruct)

turnT \= turnT';
turnX \= turnX';
allT \= allT';
runT \= runT';
runX \= runX';

allX \= \[turnX, runX];


ratefun\_names \= {'rateExp1', 'rateExp2', 'rateExp1\_rescale', 'rateExp2\_rescale'};

if(length(qrate)\=\=3\)
 nstim \= 1;
 rateExp1 \= @(x, xdata) exp( x(1\)\*xdata \+ x(2\) );
 rateExp2 \= @(x, xdata) exp( x(1\)\*xdata.^2 \+ x(2\)\*xdata \+ x(3\) );
elseif(length(qrate)\=\=6\)
 nstim \= 2;
 rateExp1 \= @(x, xdata) exp(x(1\) \* xdata(1,:) \+ x(2\) \* xdata(2,:) \+ x(3\));
 rateExp2 \= @(x, xdata) exp( x(1\)\*xdata(1,:).^2 \+ x(2\)\*xdata(2,:).^2 \+ x(3\)\*xdata(1,:).\*xdata(2,:) \+ x(4\)\*xdata(1,:) \+ x(5\)\*xdata(2,:) \+ x(6\) );
end

ratefuns \= {rateExp1, rateExp2};

% using exponential(k\=\=1\) and ROG (k\=\=2\) fits for r(x)
% for k\=1:2
%
%
% \[\~, \~, theta0,w0] \= PointProcessFilter\_Gepner(ratefun\_names{k}, \[], turnT, turnX, runT, runX, qrate, samplingInterval,(0:1:period));
% \[\~, \~, theta0,w0,etx] \= PointProcessFilter\_Gepner(ratefun\_names{k}, \[], turnT, turnX, runT, runX, qrate, samplingInterval,(0:.5:period),theta0(:,end), w0(:,:,end));
% ind0 \= find(etx \>\= 0\.75\*period, 1, 'first');
% \[dkl, dkl\_eb, theta, w, est\_tx, diagnostics] \= PointProcessFilter\_Gepner(ratefun\_names{k}, \[], turnT, turnX, runT, runX, qrate, samplingInterval,0:dtfinal:period,theta0(:,ind0\), w0(:,:,ind0\));
% \[theta\_s, w\_s] \= applySmoothingGaussianFilters(theta, w, qrate\*dtfinal);
%
%
%
% inds \= est\_tx \>\= 0 \& est\_tx \<\= period;
% rateEstimate.rateExp{k}.tx \= est\_tx(inds);
% rateEstimate.rateExp{k}.theta \= theta(:,inds);
% rateEstimate.rateExp{k}.theta\_s \= theta\_s(:,inds);
% rateEstimate.rateExp{k}.w \= w(:,:,inds);
% rateEstimate.rateExp{k}.w\_s \= w\_s(:,:,inds);
%
% if (size(theta,1\)\=\=3\)
% rateEstimate.rateExp{k}.dkl \= dkl(inds);
% rateEstimate.rateExp{k}.dkl\_eb \= dkl\_eb(inds);
% % rateEstimate.rateExp{k}.dkl\_s \= dkl\_s(inds);
% % rateEstimate.rateExp{k}.dkl\_eb\_s \= dkl\_eb\_s(inds);
%
% elseif (size(theta,1\)\=\=6\)
%
% rateEstimate.rateExp{k}.dkl \= dkl{1}(inds); rateEstimate.dkl\_s \= dkl\_s{1}(inds);
% rateEstimate.rateExp{k}.dkl\_l \= dkl{2}(inds); rateEstimate.dkl\_l\_s \= dkl\_s{2}(inds);
% rateEstimate.rateExp{k}.dkl\_o \= dkl{3}(inds); rateEstimate.dkl\_o\_s \= dkl\_s{3}(inds);
%
% rateEstimate.rateExp{k}.dkl\_eb \= dkl\_eb(inds);
%
%
% end
%
% rateEstimate.rateExp{k}.logP \= diagnostics.logP(inds);
% rateEstimate.rateExp{k}.innovation \= diagnostics.innovation(inds);
% rateEstimate.rateExp{k}.innovation\_scaled \= diagnostics.innovation\_scaled(inds);
% rateEstimate.rateExp{k}.innovation\_scaled\_alt \= diagnostics.innovation\_scaled\_alt(inds);
% end


% Gain rescaling only: r(t) \= r(a(t)\*x) or r(t) \= r(a(t)\*x1, b(t)\*x2\)

tolerance \= 1e\-4;

dtfinal \= 0\.2;

r0 \= log(size(turnX, 2\))\-log(samplingInterval\*size(runX, 2\));

tmin \= min(allT);
tmax \= max(allT);

tx1 \= (tmin:1:tmax);
tx2 \= (tmin:0\.5:tmax);
txf \= tmin:dtfinal:tmax;

taxis1 \= 0:1:period;
taxis2 \= 0:.5:period;
taxisf \= 0:dtfinal:period;

histaxis \= linspace(\-5, 5, 20\);

for k\=1:1
 
 clear params fitParams dParams dt alpha beta theta0 theta;
 
 %initialize rate\-function fit\-parameters
 if (nstim\=\=1 \&\& k\=\=1\)
 p0 \= \[0 r0 0];
 fitParams \= fitRate(ratefuns{k}, p0(1:2\), turnX, runX, samplingInterval, opstruct.numLxBins );
 p1 \= \[fitParams 0];
 elseif(nstim\=\=1 \&\& k\=\=2\)
 p0 \= \[0 0 r0];
 fitParams \= fitRate(ratefuns{k}, p0, turnX, runX, samplingInterval, opstruct.numLxBins );
 p1 \= fitParams;
 elseif(nstim\=\=2 \&\& k\=\=1\)
 p0 \= \[0 0 r0 0 0 0];
 fitParams \= fitRate(ratefuns{k}, p0(1:3\), turnX, runX, samplingInterval, opstruct.numLxBins );
 p1 \= \[fitParams 0 0 0];
 elseif(nstim\=\=2 \&\& k\=\=2\)
 p0 \= \[0 0 0 0 0 r0];
 fitParams \= fitRate(ratefuns{k}, p0, turnX, runX, samplingInterval, opstruct.numLxBins );
 p1 \= fitParams;
 end
 
 if(max(allT) \=\= max(allT\_modT))
 
 turnX\_rescaled \= zeros(size(turnX)) ;
 runX\_rescaled \= zeros(size(runX)) ;
 allX\_rescaled \= zeros(size(allX)) ;

 params{1} \= p1;
 dParams{1} \= p1 \- p0;
 
 %estimate time\-evolution of rescaling parameters:
 %(theta(1\) for 1\-stim. expts., theta(1\) and theta(2\) for 2\-stim. expts.
 % then fit rate\-function params again using rescaled stimulus

 
 n\=1;
 while( sum(dParams{n}.^2\) \> tolerance )
 clear dt alpha beta theta0 theta w0 w turnX\_rescaled runX\_rescaled allX\_rescaled;
 
 tx \= tx1;
 taxis \= taxis1;
 \[\~, \~, theta] \= PointProcessFilter\_Gepner(ratefun\_names{k\+2}, p1', turnT, turnX, runT, runX, qrate, samplingInterval,tx, p0');
 
 
 alpha \= theta(1,:)./mean(theta(1,:));
 %\[\~, malpha] \= meanyvsx(mod(tx, period), alpha, binEdgesFromCenters(taxis));
 
 if(nstim\=\=2\)
 beta \= theta(2,:)./mean(theta(2,:));
 %\[\~, mbeta] \= meanyvsx(mod(tx, period), beta, binEdgesFromCenters(taxis));
 end
 
 \[\~,\~,turnBin] \= histcounts(turnT\_modT, binEdgesFromCenters(tx));
 \[\~,\~,runBin] \= histcounts(runT\_modT, binEdgesFromCenters(tx));
 \[\~,\~,allBin] \= histcounts(allT\_modT, binEdgesFromCenters(tx));
 
 
 dt \= diff(binEdgesFromCenters(tx));
 for j \= 1:length(dt)
 
 turninds \= turnBin \=\= j;
 runinds \= runBin \=\= j;
 allinds \= allBin \=\= j;
 turnX\_rescaled(1,turninds) \= alpha(j) \* turnX(1,turninds) ;
 runX\_rescaled(1,runinds) \= alpha(j) \* runX(1,runinds);
 if(nstim\=\=2\)
 turnX\_rescaled(2,turninds) \= beta(j) \* turnX(2,turninds);
 runX\_rescaled(2,runinds) \= beta(j) \* runX(2,runinds);
 end
 end
 
 if(k\=\=1\)
 fitParams \= fitRate(ratefuns{k}, p1(1:nstim\+1\), turnX\_rescaled, runX\_rescaled, samplingInterval, opstruct.numLxBins);
 if(nstim\=\=1\), p2 \= \[fitParams 0];
 elseif(nstim\=\=2\), p2 \= \[fitParams 0 0 0];
 end
 elseif(k\=\=2\)
 fitParams \= fitRate(ratefuns{k}, p1, turnX\_rescaled, runX\_rescaled, samplingInterval, opstruct.numLxBins);
 p2 \= fitParams;
 end
 
 dParams{n\+1} \= p2 \- p1;
 params{n\+1} \= p2;
 
 p0 \= theta(:,end);
 p1 \= p2;
 n \= n\+1;
 
 end
 rateEstimate.rateExp{k}.theta0 \= theta;
 rateEstimate.rateExp{k}.rateParams \= params;
 
 else
 
 
 rP \= opstruct.rateExp{k}.rateParams;
 
 tx \= tx2;
 \[\~, \~, theta, w, \~, diagnostics] \= PointProcessFilter\_Gepner(ratefun\_names{k\+2}, rP', turnT, turnX, runT, runX, qrate, samplingInterval,tx, p0');
 
% t0 \= theta(:,end);
% 
% tx \= txf;
% \[\~, \~, theta, w, \~, diagnostics] \= PointProcessFilter\_Gepner(ratefun\_names{k\+2}, rP', turnT, turnX, runT, runX, qrate, samplingInterval,tx, t0');
% 
 \[theta\_s, w\_s] \= applySmoothingGaussianFilters(theta, w, qrate\*median(diff(tx)));
 
 
 tshift \= opstruct.timeRange(1\) \- period/2;
 if(tshift\<0\)
 tshift \= \-tshift;
 end
 
 \[thetamodT, thetamodT\_eb, tmodT] \= etiThetaToCycleTheta(theta', w, tx, \-tshift, period);
 \[thetamodT\_s, thetamodT\_eb\_s, \~] \= etiThetaToCycleTheta(theta\_s', w\_s, tx, \-tshift, period);
 
 rateEstimate.rateExp{k}.tx \= tx;
 rateEstimate.rateExp{k}.theta \= theta;
 rateEstimate.rateExp{k}.w \= w;
 rateEstimate.rateExp{k}.theta\_s \= theta\_s;
 rateEstimate.rateExp{k}.w\_s \= w\_s;
 
 rateEstimate.rateExp{k}.tmodT \= tmodT;
 rateEstimate.rateExp{k}.alpha \= thetamodT(:,1\)'./mean(thetamodT(:,1\));
 rateEstimate.rateExp{k}.alpha\_eb \= squeeze(thetamodT\_eb(1,1,:))';
 rateEstimate.rateExp{k}.alpha\_s \= thetamodT\_s(:,1\)'./mean(thetamodT\_s(:,1\));
 rateEstimate.rateExp{k}.alpha\_eb\_s \= squeeze(thetamodT\_eb\_s(1,1,:))';
 
 rateEstimate.rateExp{k}.logP\_rescaling \= diagnostics.logP;
 rateEstimate.rateExp{k}.innovations \= diagnostics.innovation;
 rateEstimate.rateExp{k}.innovations\_scaled \= diagnostics.innovation\_scaled;
 
 if(nstim\=\=2\)
 rateEstimate.rateExp{k}.beta \= thetamodT(:,2\)'./mean(thetamodT(:,2\));
 rateEstimate.rateExp{k}.beta\_eb \= squeeze(thetamodT\_eb(2,2,:))';
 rateEstimate.rateExp{k}.beta\_s \= thetamodT\_s(:,2\)'./mean(thetamodT\_s(:,2\));
 rateEstimate.rateExp{k}.beta\_eb\_s \= squeeze(thetamodT\_eb\_s(2,2,:))';
 end
 end
end

end


function btdstruct \= analyzeVariance1Source (btdstruct, whichStim)

existsAndDefault ('whichStim', 1\);

btd \= btdstruct.btd;
gq \= btdstruct.varops.stim(whichStim).gqname;
gq\_conv \= strcat(gq, 'TurnLin');

if(strcmpi(btdstruct.varops.stim(whichStim).ramptype, 'square'))
 gq\_varh \= strcat(gq, '\_var\_high');
 gq\_varl \= strcat(gq, '\_var\_low');
else
 gq\_varh \= strcat(gq, '\_var\_rising');
 gq\_varl \= strcat(gq, '\_var\_falling');
end

gq\_ton \= \[gq,'\_var\_ton'];
gq\_toff \= \[gq,'\_var\_toff'];


if (isempty(btdstruct.varops.stim(whichStim).period))
 btdstruct.varops.stim(whichStim).period \= max(btd.behaviorTriggeredDataMatrix('all',\[], gq\_ton, 0\));
end
period \= btdstruct.varops.stim(whichStim).period;

if (\~isfield(btdstruct, 'var') \|\| length(btdstruct.var) \< whichStim)
 
 aa \= \[btd.all]';
 alleti \= \[aa.eti]';
 tt \= \[btd.turn]';
 turneti \= \[tt.start\_eti]';
 isrun \= \[aa.isrun]';
 
 all\_ton \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_ton, 0\);
 all\_toff \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_toff, 0\);
 turn\_ton \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_ton, 0\);
 turn\_toff \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_toff, 0\);
 
 mintime \= min(alleti(all\_ton \> 0 \& all\_toff \> 0\));
 btdstruct.varops.timeRange(1\) \= max(btdstruct.varops.timeRange(1\), mintime);
 
 turnvalid \= turneti \>\= min(btdstruct.varops.timeRange) \& turneti \< max(btdstruct.varops.timeRange);
 allvalid \= alleti \>\= min(btdstruct.varops.timeRange) \& alleti \< max(btdstruct.varops.timeRange);
 
 turndata \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_conv, 0\);
 alldata \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_conv, 0\);

 btdstruct.var(whichStim).all.x\_conv \= alldata(allvalid);
 btdstruct.var(whichStim).all.eti \= alleti (allvalid);
 btdstruct.var(whichStim).all.ton \= all\_ton (allvalid);
 btdstruct.var(whichStim).all.toff \= all\_toff (allvalid);
 
 
 btdstruct.var(whichStim).run.x\_conv \= alldata(isrun \& allvalid);
 btdstruct.var(whichStim).run.eti \= alleti (isrun \& allvalid);
 btdstruct.var(whichStim).run.ton \= all\_ton (isrun \& allvalid);
 btdstruct.var(whichStim).run.toff \= all\_toff (isrun \& allvalid);
 
 btdstruct.var(whichStim).turn.x\_conv \= turndata(turnvalid);
 btdstruct.var(whichStim).turn.eti \= turneti (turnvalid);
 btdstruct.var(whichStim).turn.ton \= turn\_ton (turnvalid);
 btdstruct.var(whichStim).turn.toff \= turn\_toff (turnvalid);
 
% if(strcmpi(btdstruct.varops.stim(whichStim).ramptype, 'square'))
% 
% turndata\_low \= btd.behaviorTriggeredDataMatrix('turn', 'start', \[gq\_conv '\_var\_low'], 0\);
% turndata\_high \= btd.behaviorTriggeredDataMatrix('turn', 'start', \[gq\_conv '\_var\_high'], 0\);
% alldata\_low \= btd.behaviorTriggeredDataMatrix('all', 'start', \[gq\_conv '\_var\_low'], 0\);
% alldata\_high \= btd.behaviorTriggeredDataMatrix('all', 'start', \[gq\_conv '\_var\_high'], 0\);
% btdstruct.var(whichStim).all.x\_conv\_low \= alldata\_low(allvalid);
% btdstruct.var(whichStim).all.x\_conv\_high \= alldata\_high(allvalid);
% btdstruct.var(whichStim).run.x\_conv\_low \= alldata\_low(isrun \& allvalid);
% btdstruct.var(whichStim).run.x\_conv\_high \= alldata\_high(isrun \& allvalid);
% btdstruct.var(whichStim).turn.x\_conv\_low \= turndata\_low(turnvalid);
% btdstruct.var(whichStim).turn.x\_conv\_high \= turndata\_high(turnvalid);
% end

end


turnToff \= btdstruct.var(whichStim).turn.toff;
turnTon \= btdstruct.var(whichStim).turn.ton;
turnEti \= btdstruct.var(whichStim).turn.eti;
turnX \= btdstruct.var(whichStim).turn.x\_conv;
runToff \= btdstruct.var(whichStim).run.toff;
runTon \= btdstruct.var(whichStim).run.ton;
runEti \= btdstruct.var(whichStim).run.eti;
runX \= btdstruct.var(whichStim).run.x\_conv;
allToff \= btdstruct.var(whichStim).all.toff;
allTon \= btdstruct.var(whichStim).all.ton;
allEti \= btdstruct.var(whichStim).all.eti;
allX \= btdstruct.var(whichStim).all.x\_conv;
samplingInterval \= median(diff(btdstruct.var(whichStim).all.eti));
qrate \= btdstruct.varops.kalmanNoiseDiffusion1D;

if(\~isfield(btdstruct.varops, 'rateExp'))
 rateEst\_off \= estimateRateVsTime(turnToff, turnToff, turnX, runToff, runToff, runX, allToff, allToff, allX, period, samplingInterval, qrate, btdstruct.varops);
 for k\=1:length(rateEst\_off.rateExp)
 btdstruct.varops.rateExp{k}.rateParams \= rateEst\_off.rateExp{k}.rateParams{end};
 btdstruct.varops.rateExp{k}.theta0 \= rateEst\_off.rateExp{k}.theta0;
 end
end

btdstruct.var(whichStim).rateEst\_off \= estimateRateVsTime(turnEti, turnToff, turnX, runEti, runToff, runX, allEti, allToff, allX, period, samplingInterval, qrate, btdstruct.varops);
for k\=1:length(btdstruct.var(whichStim).rateEst\_off.rateExp)
 btdstruct.var(whichStim).rateEst\_off.rateExp{k}.rateParams \= btdstruct.varops.rateExp{k}.rateParams;
 btdstruct.var(whichStim).rateEst\_off.rateExp{k}.theta0 \= btdstruct.varops.rateExp{k}.theta0;
end


%btdstruct.var(whichStim).rateEst\_on \= estimateRateVsTime(turnTon, turnX, runTon, runX, allTon, allX, period, samplingInterval, qrate, btdstruct.varops);

% if(strcmpi(btdstruct.varops.stim(whichStim).ramptype, 'square'))
% runX\_low \= btdstruct.var(whichStim).noturn.x\_conv\_low;
% runX\_high \= btdstruct.var(whichStim).noturn.x\_conv\_high;
% turnX\_low \= btdstruct.var(whichStim).turn.x\_conv\_low;
% turnX\_high \= btdstruct.var(whichStim).turn.x\_conv\_high;
% btdstruct.var(whichStim).rateEst\_on\_lowK \= estimateRateVsTime(turnTon, turnX\_low, runTon, runX\_low, period, samplingInterval, qrate, opstruct);
% btdstruct.var(whichStim).rateEst\_off\_lowK \= estimateRateVsTime(turnToff, turnX\_low, runToff, runX\_low, period, samplingInterval, qrate, opstruct);
% 
% btdstruct.var(whichStim).rateEst\_on\_highK \= estimateRateVsTime(turnTon, turnX\_high, runTon, runX\_high, period, samplingInterval, qrate, opstruct);
% btdstruct.var(whichStim).rateEst\_off\_highK \= estimateRateVsTime(turnToff, turnX\_high, runToff, runX\_high, period, samplingInterval, qrate, opstruct);
% end


end




function btdstruct \= analyzeVariancePlusNoise (btdstruct, whichStim)

btd \= btdstruct.btd; 

kernelTime \= btdstruct.varops.kernelTime;

gq\_switch \= btdstruct.varops.stim(whichStim).gqname;

if(strcmpi(btdstruct.varops.stim(whichStim).ramptype, 'square'))
 gq\_varh \= strcat(gq\_switch, '\_var\_high');
 gq\_varl \= strcat(gq\_switch, '\_var\_low');
else
 gq\_varh \= strcat(gq\_switch, '\_var\_rising');
 gq\_varl \= strcat(gq\_switch, '\_var\_falling');
end

gq\_ton \= \[gq\_switch,'\_var\_ton'];
gq\_toff \= \[gq\_switch,'\_var\_toff'];

aa \= \[btd.all]';
alleti \= \[aa.eti]';
tt \= \[btd.turn]';
turneti \= \[tt.start\_eti]';
isrun \= \[aa.isrun]';

all\_ton \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_ton, 0\);
all\_toff \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_toff, 0\);
turn\_ton \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_ton, 0\);
turn\_toff \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_toff, 0\);

mintime \= min(alleti(all\_ton \> 0 \& all\_toff \> 0\));
btdstruct.varops.timeRange(1\) \= max(btdstruct.varops.timeRange(1\), mintime);

turnvalid \= turneti \>\= min(btdstruct.varops.timeRange) \& turneti \< max(btdstruct.varops.timeRange);
allvalid \= alleti \>\= min(btdstruct.varops.timeRange) \& alleti \< max(btdstruct.varops.timeRange);

if (isempty(btdstruct.varops.stim(whichStim).period))
 btdstruct.varops.stim(whichStim).period \= max(btd.behaviorTriggeredDataMatrix('all',\[], gq\_ton, 0\));
end

period \= btdstruct.varops.stim(whichStim).period;


stimnames \= {btdstruct.varops.stim(1\).gqname, btdstruct.varops.stim(2\).gqname};
kname1 \= \[stimnames{1} 'TurnLin'];
kname2 \= \[stimnames{2} 'TurnLin'];

xyall \= btd.behaviorTriggeredDataMatrix('all', 'start', {kname1, kname2}, 0\);
xyturn \= btd.behaviorTriggeredDataMatrix('turn', 'start', {kname1, kname2}, 0\);

turnX(:,1\) \= xyturn(turnvalid, 1\); 
turnX(:,2\) \= xyturn(turnvalid, 2\); 
runX(:,1\) \= xyall(isrun \& allvalid, 1\);
runX(:,2\) \= xyall(isrun \& allvalid, 2\);
allX(:,1\) \= xyall(allvalid, 1\);
allX(:,2\) \= xyall(allvalid, 2\);

% if(isfield(btdstruct, 'periods'))
% 
% % n \= find(strcmpi(btdstruct.periods, 'low'));
% % theta\_uv \= btdstruct.theta{n};
% % 
% % linUOp \= @(yd) cos(theta\_uv).\*yd{1} \+ sin(theta\_uv).\*yd{2};
% % linVOp \= @(yd) cos(theta\_uv).\*yd{2} \- sin(theta\_uv).\*yd{1};
% % 
% % btd \= btd.addOperationFields({kname1, kname2}, 'linU', linUOp);
% % btd \= btd.addOperationFields({kname1, kname2}, 'linV', linVOp );
% % btdstruct.btd \= btd;
% 
% % uvall \= btd.behaviorTriggeredDataMatrix('all', 'start', {'linU', 'linV'}, 0\);
% % uvturn \= btd.behaviorTriggeredDataMatrix('turn', 'start', {'linU', 'linV'}, 0\);
% 
% turnU(:,1\) \= cos(theta)\*turnX(:,1\)\+sin(theta)\*turnX(:,2\);
% turnU(:,2\) \= \-sin(theta)\*turnX(:,1\)\+cos(theta)\*turnX(:,2\);
% runU(:,1\) \= cos(theta)\*runX(:,1\)\+sin(theta)\*runX(:,2\);
% runU(:,2\) \= \-sin(theta)\*runX(:,1\)\+cos(theta)\*runX(:,2\);
% 
% allU \= \[turnU; runU];
% 
% end

allEti \= alleti(allvalid);
runEti \= alleti (isrun \& allvalid);
turnEti \= turneti(turnvalid);
turnToff \= turn\_toff(turnvalid);
turnTon \= turn\_ton(turnvalid);
runToff \= all\_toff(isrun \& allvalid);
runTon \= all\_ton(isrun \& allvalid);
allToff \= all\_toff(allvalid);
allTon \= all\_ton(allvalid);
samplingInterval \= median(diff(alleti(allvalid)));
qrate \= btdstruct.varops.kalmanNoiseDiffusion2D;
qrate\_sep \= btdstruct.varops.kalmanNoiseDiffusion1D;

% for j\=1:2
% btdstruct.var\_sep(j).turnX \= turnX(:,j);
% btdstruct.var\_sep(j).runX \= runX(:,j);
% btdstruct.var\_sep(j).allX \= allX(:,j);
% btdstruct.var\_sep(j).rateEst\_on \= estimateRateVsTime(turnTon, turnX(:,j), runTon, runX(:,j), period, samplingInterval, qrate\_sep, btdstruct.varops);
% btdstruct.var\_sep(j).rateEst\_off \= estimateRateVsTime(turnToff, turnX(:,j), runToff, runX(:,j), period, samplingInterval, qrate\_sep, btdstruct.varops);
% end


% btdstruct.var\_comb.turnX \= turnX;
% btdstruct.var\_comb.runX \= runX;
% btdstruct.var\_comb.allX \= allX;
% btdstruct.var\_comb.turnTon \= turnTon;
% btdstruct.var\_comb.turnToff \= turnToff;
% btdstruct.var\_comb.runTon \= runTon;
% btdstruct.var\_comb.runToff \= runToff;
% btdstruct.var\_comb.allTon \= allTon;
% btdstruct.var\_comb.allToff \= allToff;
% btdstruct.var\_comb.alleti \= alleti(allvalid);

if(\~isfield(btdstruct.varops, 'rateExp'))
 rateEst\_off \= estimateRateVsTime(turnToff, turnToff, turnX, runToff, runToff, runX, allToff, allToff, allX, period, samplingInterval, qrate, btdstruct.varops);
 for k\=1:length(rateEst\_off.rateExp)
 if(\~isempty(rateEst\_off.rateExp{k}))
 btdstruct.varops.rateExp{k}.rateParams \= rateEst\_off.rateExp{k}.rateParams{end};
 btdstruct.varops.rateExp{k}.theta0 \= rateEst\_off.rateExp{k}.theta0;
 end
 end
end

btdstruct.PPFtoff \= estimateRateVsTime(turnEti, turnToff, turnX, runEti, runToff, runX, allEti, allToff, allX, period, samplingInterval, qrate, btdstruct.varops);
for k\=1:length(btdstruct.PPFtoff.rateExp)
 if(\~isempty(btdstruct.PPFtoff.rateExp{k}))
 btdstruct.PPFtoff.rateExp{k}.rateParams \= btdstruct.varops.rateExp{k}.rateParams;
 btdstruct.PPFtoff.rateExp{k}.theta0 \= btdstruct.varops.rateExp{k}.theta0;
 end
end



end

function btdstruct \= ratefunGQVariance (btdstruct, opstruct, varargin)

taxis \= \-(0:opstruct.kernelDt:opstruct.kernelTime);

n \= find(\[opstruct.stim.varswitch]);
gq\_switch \= opstruct.stim(n).gqname;
gq\_conv \= strcat(gq\_switch, 'TurnLin');

if(strcmpi(opstruct.stim(n).ramptype, 'square'))
 gq\_varh \= strcat(gq\_switch, '\_var\_high');
 gq\_varl \= strcat(gq\_switch, '\_var\_low');
elseif(strcmpi(opstruct.stim(n).ramptype, 'triangle'))
 gq\_varh \= strcat(gq\_switch, '\_var\_rising');
 gq\_varl \= strcat(gq\_switch, '\_var\_falling');
end

gq\_ton \= \[gq\_switch, '\_var\_ton'];
gq\_toff \= \[gq\_switch '\_var\_toff'];

if (any(btdstruct.btd.findField(gq\_ton) \<\= 0\))
 btdstruct.btd \= btdstruct.btd.addVarianceGQs(gq\_switch, opstruct.stim(n).ramptype);
end

if (isempty(btdstruct.varops.stim(n).period))
 btdstruct.varops.stim(n).period \= max(btdstruct.btd.behaviorTriggeredDataMatrix('all',\[], gq\_ton, 0\));
end

switch\_period \= btdstruct.varops.stim(n).period;

btd \= btdstruct.btd;

%add no\-step glt

% gq\_nostep \= strcat(gq, '\_nostep');
% gq\_conv\_nostep \= strcat(gq\_conv, '\_nostep');
%
% for i\=1:length(btd)
% ind \= btd(i).findField(gq);
% old \= btd(i).glt(ind);
% new \= old;
% new.fieldname \= gq\_nostep;
% new.yData(abs(new.yData)\>7\*std(new.yData))\=0;
% btd(i).glt(end\+1\) \= new;
% btd(i) \= btd(i).addConvolvedFields(gq\_nostep, gq\_conv\_nostep, btdstruct.convkernels, btdstruct.kernelDt, 'scaleToSqr', true);
% end
%
% btdstruct.btd \= btd;

aa \= \[btd.all];
alleti \= \[aa.eti];
tt \= \[btd.turn]';
turneti \= \[tt.start\_eti]';
isrun \= \[aa.isrun]';
dt \= median(diff(alleti));

allton \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_ton, 0\);
alltoff \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_toff, 0\);
turnton \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_ton, 0\);
turntoff \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_toff, 0\);

mintime \= min(alleti(allton \> 0 \& alltoff \> 0\));
turnvalid \= turneti \>\= mintime;
allvalid \= alleti \>\= mintime;
runvalid \= allvalid \& isrun;

inrun.name \= 'isrun';
inrun.validop \= @(x) logical(x);

ishigh \= logical(btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_varh, 0\));
islow \= logical(btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_varl, 0\));
ishigh\_all \= logical(btd.behaviorTriggeredDataMatrix('all', 'start', gq\_varh, 0\));
islow\_all \= logical(btd.behaviorTriggeredDataMatrix('all', 'start', gq\_varl, 0\));
ishigh\_all \= ishigh\_all(runvalid);
islow\_all \= islow\_all(runvalid);
ishigh \= ishigh(turnvalid);
islow \= islow(turnvalid);

% For last (tau) seconds of each cycle

tau \= 5;
t1 \= switch\_period/2 \- tau;
t2 \= switch\_period/2;

allton \= allton(runvalid);
alltoff \= alltoff(runvalid);
turnton \= turnton(turnvalid);
turntoff \= turntoff(turnvalid);

high\_all \= find(allton\>\=t1 \& allton\<\=t2\);
low\_all \= find(alltoff\>\=t1 \& alltoff\<\=t2\);
high \= find(turnton\>\=t1 \& turnton\<\=t2\);
low \= find(turntoff\>\=t1 \& turntoff\<\=t2\);


for j \= find(\[opstruct.stim.iswn])
 

 
 gq \= opstruct.stim(j).gqname;
 gq\_conv \= \[gq 'TurnLin'];
 
 dm\_all \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', gq, taxis);
 dm\_all \= dm\_all(turnvalid, :);
 dm\_high \= dm\_all(ishigh, :);
 dm2 \= dm\_high; dm2(\~isfinite(dm2\)) \= 0;
 btdstruct.varRF(j).bta\_high \= sum(dm2\)./sum(isfinite(dm\_high));
 
 dm\_low \= dm\_all(islow, :);
 dm2 \= dm\_low; dm2(\~isfinite(dm2\)) \= 0;
 btdstruct.varRF(j).bta\_low \= sum(dm2\)./sum(isfinite(dm\_low));
 
 turndata \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_conv, 0\);
 alldata \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_conv, 0\);
 turndata \= turndata(turnvalid);
 alldata \= alldata(runvalid);
 
 nr \= size(turndata, 1\);
 na \= size(alldata,1\);
 mu \= mean(turndata);
 mu\_a \= mean(alldata);
 s \= std(turndata);
 s\_a \= std(alldata);
 
 nrh \= nnz(ishigh);
 nrl \= nnz(islow);
 nah \= nnz(ishigh\_all);
 nal \= nnz(islow\_all);
 
 muh \= mean(turndata(ishigh));
 mul \= mean(turndata(islow));
 mu\_ah \= mean(alldata(ishigh\_all));
 mu\_al \= mean(alldata(islow\_all));
 
 sh \= std(turndata(ishigh));
 sl \= std(turndata(islow));
 s\_ah \= std(alldata(ishigh\_all));
 s\_al \= std(alldata(islow\_all));
 
 ratefun \= @(ydata) nr/(na\*dt)\*normpdf(ydata,mu,s)./normpdf(ydata, 1\.0\*mu\_a, s\_a);
 
 ratefun\_high \= @(ydata) nrh/(nah\*dt) \* normpdf(ydata, muh, sh)./normpdf(ydata, mu\_ah, s\_ah);
 btdstruct.btd \= btdstruct.btd.addOperationFields(gq\_conv, \[gq '\_ratePredROG\_var\_high'], ratefun\_high);
 
 ratefun\_low \= @(ydata) nrl/(nal\*dt) \* normpdf(ydata, mul, sl)./normpdf(ydata, mu\_al, s\_al);
 btdstruct.btd \= btdstruct.btd.addOperationFields(gq\_conv, \[gq '\_ratePredROG\_var\_low'], ratefun\_low);
 
 %btdstruct.btd \= btdstruct.btd.addOperationFields(gq\_conv\_nostep, \[gq\_nostep '\_ratePredROG'], ratefun);
 %btdstruct.btd \= btdstruct.btd.addOperationFields(gq\_conv\_nostep, \[gq\_nostep '\_ratePredROG\_var\_high'], ratefun\_high);
 %btdstruct.btd \= btdstruct.btd.addOperationFields(gq\_conv\_nostep, \[gq\_nostep '\_ratePredROG\_var\_low'], ratefun\_low);
 
 
 cv\_high \= alldata(high\_all);
 cv\_low \= alldata(low\_all);
 cvt\_high \= turndata(high);
 cvt\_low \= turndata(low);
 
 nrh\_last \= nnz(high);
 nrl\_last \= nnz(low);
 nah\_last \= nnz(high\_all);
 nal\_last \= nnz(low\_all);
 
 muh\_last \= mean(cvt\_high);
 mul\_last \= mean(cvt\_low);
 mu\_ah\_last \= mean(cv\_high);
 mu\_al\_last \= mean(cv\_low);
 
 sh\_last \= std(cvt\_high);
 sl\_last \= std(cvt\_low);
 s\_ah\_last \= std(cv\_high);
 s\_al\_last \= std(cv\_low);
 
 ratefun\_high\_last \= @(ydata) nrh\_last/(nah\_last\*dt) \* normpdf(ydata, muh\_last, sh\_last)./normpdf(ydata, mu\_ah\_last, s\_ah\_last);
 btdstruct.btd \= btdstruct.btd.addOperationFields(gq\_conv, \[gq '\_ratePredROG\_var\_high\_last'], ratefun\_high\_last);
 
 ratefun\_low\_last \= @(ydata) nrl\_last/(nal\_last\*dt) \* normpdf(ydata, mul\_last, sl\_last)./normpdf(ydata, mu\_al\_last, s\_al\_last);
 btdstruct.btd \= btdstruct.btd.addOperationFields(gq\_conv, \[gq '\_ratePredROG\_var\_low\_last'], ratefun\_low\_last);
 
 lx\_h\_last \= linspace(percentile(alldata(high\_all),0\.01\), percentile(alldata(high\_all),.99\), opstruct.numLxBins);
 lx\_l\_last \= linspace(percentile(alldata(low\_all),0\.01\), percentile(alldata(low\_all),.99\), opstruct.numLxBins);
 lx\_h \= linspace(percentile(alldata(ishigh\_all),0\.01\), percentile(alldata(ishigh\_all),.99\), opstruct.numLxBins);
 lx\_l \= linspace(percentile(alldata(islow\_all),0\.01\), percentile(alldata(islow\_all),.99\), opstruct.numLxBins);
 
 h\_high \= histc(alldata(ishigh\_all), binEdgesFromCenters(lx\_h));
 h\_low \= histc(alldata(islow\_all), binEdgesFromCenters(lx\_l));
 ht\_high \= histc(turndata(ishigh), binEdgesFromCenters(lx\_h));
 ht\_low \= histc(turndata(islow), binEdgesFromCenters(lx\_l));
 h\_high\_last \= histc(alldata(high\_all), binEdgesFromCenters(lx\_h\_last));
 h\_low\_last \= histc(alldata(low\_all), binEdgesFromCenters(lx\_l\_last));
 ht\_high\_last \= histc(turndata(high), binEdgesFromCenters(lx\_h\_last));
 ht\_low\_last \= histc(turndata(low), binEdgesFromCenters(lx\_l\_last));
 
 btdstruct.varRF(j).gqname \= opstruct.stim(j).gqname;
 
 btdstruct.varRF(j).xh \= lx\_h;
 btdstruct.varRF(j).xh\_last \= lx\_h\_last;
 btdstruct.varRF(j).xl \= lx\_l;
 btdstruct.varRF(j).xl\_last \= lx\_l\_last;
 
 btdstruct.varRF(j).rog\_params\_high \= \[nrh/(nah\*dt) muh, sh, mu\_ah, s\_ah];
 btdstruct.varRF(j).rog\_params\_low \= \[nrl/(nal\*dt) mul, sl, mu\_al, s\_al];
 btdstruct.varRF(j).rog\_params\_high\_last \= \[nrh\_last/(nah\_last\*dt), muh\_last, sh\_last, mu\_ah\_last, s\_ah\_last];
 btdstruct.varRF(j).rog\_params\_low\_last \= \[nrl\_last/(nal\_last\*dt), mul\_last, sl\_last, mu\_al\_last, s\_al\_last];
 
 btdstruct.varRF(j).rate\_rog\_high \= 60\*ratefun\_high(lx\_h);
 btdstruct.varRF(j).rate\_rog\_low \= 60\*ratefun\_low(lx\_l);
 btdstruct.varRF(j).rate\_rog\_high\_last \= 60\*ratefun\_high\_last(lx\_h\_last);
 btdstruct.varRF(j).rate\_rog\_low\_last \= 60\*ratefun\_low\_last(lx\_l\_last);
 
 btdstruct.varRF(j).rate\_high \= 60\*ht\_high(1:end\-1\)./ h\_high(1:end\-1\) / dt;
 btdstruct.varRF(j).rate\_low \= 60\*ht\_low(1:end\-1\)./ h\_low(1:end\-1\) / dt;
 btdstruct.varRF(j).rate\_high\_last \= 60\*ht\_high\_last(1:end\-1\)./ h\_high\_last(1:end\-1\) / dt;
 btdstruct.varRF(j).rate\_low\_last \= 60\*ht\_low\_last(1:end\-1\)./ h\_low\_last(1:end\-1\) / dt;
 
end


end




\-\-\-

\#\#\# File: BehaviorTriggeredData.m (ID: @BehaviorTriggeredData.6\)

classdef BehaviorTriggeredData
 %UNTITLED3 Summary of this class goes here
 % Detailed explanation goes here
 
 properties
 fname;
 es; %experiment statistics
 gq;
 glt;
 hs;
 reo;
 run;
 turn;
 acchs;
 rejhs;
 pause;
 all;
 end
 methods(Static)
 btdstruct \= analyzeBTDDirectory\_onesource (btdstruct, gqname, varargin);
 btdstruct \= loadBTDDirectory (basedir, varargin);
 btdstruct \= analyzeBTDDirectory\_twosource (btdstruct, stim1name, stim2name, varargin);
 btdstruct \= analyzeVarianceSwitchingExperiment(btdstruct, opstruct);
 btdstruct \= analyzeVarianceSwitchingExperiment\_Gepner(btdstruct, opstruct, qfactor);
 %problemDescription \= createProblemStructForRateFunFitting (var, timeField, polynomialDegree, period, trange);
 problemDescription \= createProblemStructForRateFunFitting (vs, timeField, polynomialDegree, trange, exprange, deltaT);
 problemDescription \= simulateVarSwitchFromPrevFit (btdstruct, osfit, oldpd, alphaLow, alphaHigh, nlarvae);
 btdstruct \= prepVarianceSwitchingAnalysis(btdstruct, opstruct);
 btdstruct \= prepVarianceSwitchingAnalysis\_Gepner(btdstruct, opstruct);
 btdstruct \= prepVarianceSwitchingAnalysis\_Wolk(btdstruct, opstruct);
 ah \= summaryFigure(bdstruct, varargin); 
 
 function \[dkl12, tcent, bit\_rate, tstart] \= klDivergenceBetweenDM (taxis, dm1, dm2, tbinEdges, varargin)
 %function \[dkl12, tcent] \= klDivergenceBetweenDM (taxis, dm1, dm2, tbinEdges, varargin)
 %function \[dkl12, tcent] \= klDivergenceBetweenDM (taxis, dm1, dm2, binWidth, varargin)
 %dkl \= dkl(x1\|\|x2\)
 method \= 'gauss';
 varargin \= assignApplicable(varargin);
 
 if (size(tbinEdges,1\) \=\= 1\)
 if (size(tbinEdges,2\) \=\= 1\) %it's a bin width rather than edges
 bw \= tbinEdges;
 tbinEdges \= taxis(taxis \< max(taxis \- bw));
 tbinEdges(2,:) \= tbinEdges(1,:) \+ bw;
 else
 tbinEdges(2,:) \= \[tbinEdges(2:end) tbinEdges(end)\+eps];
 end
 end
 
 %\[\~,bin] \= histc(taxis, tbinEdges);
 dkl12 \= zeros(1, size(tbinEdges,2\)\-1\);
 tcent \= dkl12;
 for j \= 1:(size(tbinEdges,2\)\-1\)
 inds \= taxis \>\= tbinEdges(1,j) \& taxis \< tbinEdges(2,j);
 tcent(j) \= mean(taxis(inds));
 x1 \= dm1(:, inds);
 x2 \= dm2(:, inds);
 x1 \= x1(all(isfinite(x1\),2\), :); %\#ok all is also a property; function meant here
 x2 \= x2(all(isfinite(x2\),2\), :); %\#ok all is also a property; function meant here
 if (isempty(x1\) \|\| isempty(x2\))
 continue;
 end
 switch (lower(method))
 case 'gauss'
 dkl12(j) \= DKL\_gauss\_est(x1, x2\);
 case 'knnti'
 if (j \=\= 1\)
 co \= DKL\_kNN\_kiTi\_initialization(1, {'kNNmethod', 'knnFP1'});
 end
 dkl12(j) \= DKL\_kNN\_kiTi\_estimation(x1', x2', co);
 otherwise
 error(\['unknown method: ' method]);
 end
 end
 bit\_rate \= (dkl12/log(2\)) ./ diff(tbinEdges(:,1:end\-1\));
 tstart \= tbinEdges(1,1:end\-1\);
 end
 
 
 
 function \[mi, tcent, bit\_rate, tstart] \= miDiscreteVsTime (taxis, dms, tbinEdges, varargin)
 %function \[mi, tcent] \= miDiscreteVsTime (taxis, dms, tbinEdges, varargin)
 %dms should be a cell of datamatrices, each corresponding to a
 %discrete state
 dmall \= vertcat(dms{:});
 ntotal \= size(dmall, 1\);
 \[mi,tcent, bit\_rate, tstart] \= BehaviorTriggeredData.klDivergenceBetweenDM(taxis, dms{1}, dmall, tbinEdges, varargin{:});
 mi \= mi\*size(dms{1},1\)/ntotal;
 bit\_rate \= bit\_rate\*size(dms{1},1\)/ntotal;
 for j \= 2:length(dms)
 \[mitemp, \~,brtemp] \= BehaviorTriggeredData.klDivergenceBetweenDM(taxis, dms{j}, dmall, tbinEdges, varargin{:});
 mi \= mi \+ size(dms{j},1\)/ntotal\*mitemp;
 bit\_rate \= bit\_rate \+ size(dms{j},1\)/ntotal\*brtemp; 
 end
 
 end
 
 
 
 end
 
 methods
 function btd \= BehaviorTriggeredData(expt, varargin)

 %note \-\- this is fine syntax, but for some reason causes MATLAB
 %to run exceedingly slow. run loop elsewhere
 % if (length(expt) \> 1\)
 % ts1 \= tic;
 % for j \= 1:length(expt)
 % btd(j) \= BehaviorTriggeredData(expt(j), varargin{:}); %\#ok
 % end
 % disp (\[num2str(j) '/' num2str(length(expt)) ' ' num2str(toc(ts1\),3\)]); 
 % return;
 % end

 %Gather all the fields from the experiment
 fields \= {};
 
 varargin \= assignApplicable(varargin);

 fields \= union(fields, {'eti', 'speed', 'spineTheta', 'curv', 'deltatheta', 'vel\_dp', 'lrdtheta', 'vhead', 'vheadperp', 'acc'});


 btd.fname \= expt.fname;
 btd.glt \= expt.globalLookupTable;
 %btd.gq \= expt.globalQuantity;
 for j \= 1:length(btd.glt)
 fields \= union(fields, btd.glt(j).xField);
 end
 
 btd.es \= expt.getExperimentStatistics();
% 
% tx \= min(expt.gatherField('eti')):(100\*expt.dr.interptime):max(expt.gatherField('eti'));
% btd.numAnimals \= max(

 btd.hs.tnum \= expt.gatherFromSubField('headSwing', 'trackNum');
 btd.reo.tnum \= expt.gatherFromSubField('reorientation', 'trackNum');
 btd.run.tnum \= expt.gatherFromSubField('run', 'trackNum');

 rs \= expt.gatherSubField('run', 'startTheta');
 re \= expt.gatherSubField('run', 'endTheta');
 rt \= expt.gatherSubField('run', 'runTime');
 rmt \= expt.gatherSubField('run', 'meanTheta');

 dt \= diff(unwrap(\[rs;re]));

 btd.run.startTheta \= rs;
 btd.run.endTheta \= re;
 btd.run.time \= rt;
 btd.run.meanTheta \= rmt;
 btd.run.deltaTheta \= dt;
 btd.run.length \= expt.gatherSubField('run', 'pathLength');
 btd.run.euclidLength \= expt.gatherSubField('run', 'euclidLength');

 btd.reo.numhs \= expt.gatherSubField('reorientation', 'numHS');
 btd.reo.nextdir \= expt.gatherSubField('reorientation', 'nextDir');
 btd.reo.prevdir \= expt.gatherSubField('reorientation', 'prevDir');
 btd.reo.dtheta \= diff(unwrap(\[btd.reo.prevdir;btd.reo.nextdir]));
 
% r \= expt.gatherField('reorientation');
% dr \= \[expt.track.dr]; 
% preReoTime \= 5; %seconds
% npts \= ceil(preReoTime/median(\[dr.interpTime]));
% btd.reo.periPhaseMatrix \= zeros(length(r), npts);
% btd.reo.periPhaseMatrixAdj \= zeros(length(r), npts);
% btd.reo.timeMatrix \= zeros(length(r), npts);
% px \= 0:(\-1\):(1\-npts);
% for j \= 1:length(r)
% pp \= r(j).getDerivedQuantity('periPhase', 'position', 'startInd', 'posoffset', px);
% dpp \= diff(pp);
% ind1 \= find(dpp \< 0, 1, 'first');
% ind2 \= find(dpp(ind1:end) \> 4, 1, 'first') \+ ind1;
% ppadj \= unwrap(pp);
% ppadj \= ppadj \- ppadj(ind2\);
% btd.reo.periPhaseMatrix(j,:) \= pp;
% btd.reo.periPhaseMatrixAdj(j,:) \= ppadj;
% btd.reo.timeMatrix(j,:) \= r(j).getDerivedQuantity('eti', 'position', 'startInd', 'posoffset', px);
% end
% 
 
 btd.hs.taildir \= expt.gatherSubField('headSwing', 'tailDir');
 btd.hs.headdir \= expt.gatherSubField('headSwing', 'headDir');
 btd.hs.accepted \= expt.gatherSubField('headSwing', 'accepted');
 btd.hs.sign \= expt.gatherSubField('headSwing', 'sign');
 btd.hs.htv \= logical(expt.gatherSubField('headSwing', 'valid'));
 btd.hs.maxtheta \= expt.gatherSubField('headSwing', 'maxTheta');
 btd.hs.hsnum \= expt.gatherSubField('headSwing', 'num');

 for j \= 1:length(fields)
 btd.run.(\['start\_' fields{j}]) \= expt.gatherFromSubField('run', fields{j}, 'position', 'start');
 btd.run.(\['end\_' fields{j}]) \= expt.gatherFromSubField('run', fields{j}, 'position', 'end');
 btd.reo.(\['start\_' fields{j}]) \= expt.gatherFromSubField('reorientation', fields{j}, 'position', 'start');
 btd.reo.(\['end\_' fields{j}]) \= expt.gatherFromSubField('reorientation', fields{j}, 'position', 'end');
 btd.hs.(\['start\_' fields{j}]) \= expt.gatherFromSubField('headSwing', fields{j}, 'position', 'start');
 btd.hs.(\['end\_' fields{j}]) \= expt.gatherFromSubField('headSwing', fields{j}, 'position', 'end');
 btd.hs.(\['atmax\_' fields{j}]) \= expt.gatherFromSubField('headSwing', fields{j}, 'position', 'atmax');
 btd.all.(fields{j}) \= expt.gatherField(fields{j});
 end
 btd.all.tnum \= expt.gatherField('trackNum', 'expandToInterped', true);
 btd.all.isrun \= expt.gatherField('isrun');

 %Separate the turns and pauses from the reorientations
 inds \= \[btd.reo.numhs] \> 0;
 fn \= fieldnames(btd.reo);
 for j \= 1:length(fn)
 btd.turn.(fn{j}) \= btd.reo.(fn{j})(:,inds);
 end

 for j \= 1:length(fn)
 btd.pause.(fn{j}) \= btd.reo.(fn{j})(:,\~inds);
 end

 %Separate the accepted and rejected head sweeps
 inds \= btd.hs.accepted;
 fn \= fieldnames(btd.hs);
 for j \= 1:length(fn)
 btd.acchs.(fn{j}) \= btd.hs.(fn{j})(inds);
 end
 for j \= 1:length(fn)
 btd.rejhs.(fn{j}) \= btd.hs.(fn{j})(\~inds);
 end
 
 end%function
 
 function btd \= addTonToffGQs (btd, fieldname, ramptype, varargin)
 existsAndDefault('ramptype', 'square');
 for j \= 1:length(btd)
 ind \= btd(j).findField(fieldname);
 if (ind \<\= 0\)
 error (\[fieldname ' not a global lookup table in btd']);
 end
 
 btd(j) \= btd(j).addGlobalLookupTable(btd(j).glt(ind).timeOnOffGQs(ramptype, varargin{:}));
 
 end
 end
 
 function btd \= addVarianceGQs (btd, fieldname, ramptype, varargin)
 existsAndDefault('ramptype', 'square');
 for j \= 1:length(btd)
% if (btd(j).findField(\[fieldname '\_var\_ton']) \> 0\)
% continue;
% end
 
 ind \= btd(j).findField(fieldname);
 if (ind \<\= 0\)
 error (\[fieldname ' not a global lookup table in btd']);
 end
 
 btd(j) \= btd(j).addGlobalLookupTable(btd(j).glt(ind).timeOnOffGQsVariance(ramptype, varargin{:}));
 
 end
 end

 function centers \= getBTDMCenters (btd, tp, position, gltname, varargin) 
 gltind \= btd.findField(gltname);
 conditions \= \[];
 varargin \= assignApplicable(varargin);
 
 if (strcmpi(tp, 'all'))
 centers \= btd.(tp).(btd.glt(gltind).xField);
 else
 centers \= btd.(tp).(\[position '\_' btd.glt(gltind).xField]);
 end
 if (\~isempty(conditions))
 if (\~isfield(conditions, 'name') \|\| \~isfield(conditions, 'validop'))
 warning ('conditions must have field name and validop; valid \= validop(btd.tp.name)');
 else
 valid \= true(size(centers));
 for j \= 1:length(conditions)
 if (isfield(btd.(tp), conditions(j).name))
 valid \= valid \& conditions(j).validop(btd.(tp).(conditions(j).name));
 else
 vind \= btd.findField(conditions(j).name);
 if (vind \> 0\)
 
 if (strcmpi(tp, 'all'))
 c2 \= btd.(tp).(btd.glt(vind).xField);
 else
 c2 \= btd.(tp).(\[position '\_' btd.glt(vind).xField]);
 end
 valid \= valid \& conditions(j).validop(btd.glt(vind).highResDerivationMethod(c2, btd.glt(vind).xData, btd.glt(vind).yData));
 else
 warning (\[conditions(j).name ' does not name a field in ' tp ' or a glt field']);
 end
 end
 end
 centers \= centers(valid);
 end
 end
 end
 
 %Takes data in btd for a given track part and reformats it as a dataMatrix
 function \[datamatrix, stimnum, btdnum] \= behaviorTriggeredDataMatrix (btd, tp, position, gltname, displacementAxis, varargin)
 %function \[datamatrix, stimnum] \= behaviorTriggeredDataMatrix (btd, tp, position, gltname, displacementAxis, varargin)
 %tp\=track part (run,reo,etc)
 %position\=position within the track part (start, end, max,
 %etc.)
 
 if (length(btd) \> 1\)
 \[datamatrix, stimnum, btdnum] \= behaviorTriggeredDataMatrix (btd(1\), tp, position, gltname, displacementAxis, varargin{:});
 for j \= 2:length(btd)
 if (isempty(btd(j).glt))
 continue;
 end
 \[dm,sn,bn] \= behaviorTriggeredDataMatrix(btd(j), tp, position, gltname, displacementAxis, varargin{:});
 datamatrix \= \[datamatrix;dm]; %\#ok
 stimnum \= \[stimnum;sn];%\#ok
 btdnum \= \[btdnum;j\*ones(size(bn))]; %\#ok %btdnum is just 1 number per line
 end
 return;
 end
 
 if (iscell(gltname))
 \[datamatrix,\~,btdnum] \= behaviorTriggeredDataMatrix(btd, tp, position, gltname{1}, displacementAxis, varargin{:});
 stimnum \= ones(size(datamatrix));
 for k \= 2:length(gltname)
 dm \= behaviorTriggeredDataMatrix(btd, tp, position, gltname{k} , displacementAxis, varargin{:});
 datamatrix \= \[datamatrix dm]; %\#ok
 stimnum \= \[stimnum k\*ones(size(dm))]; %\#ok
 %{
 datamatrix \= \[datamatrix behaviorTriggeredDataMatrix(btd, tp, position, gltname{k} , displacementAxis, varargin{:})]; %\#ok
 stimnum \= \[stimnum k\*ones(size(datamatrix))]; %\#ok
 %}
 end
 return;
 end
 btdnum \= \[];
 stimnum \= \[];
 conditions \= \[];
 shift \= \[];
 %conditions.name \= 'hsnum';
 %conditions.validop \= @(x) x \=\= 1;
 %this will get first headsweep
 
 varargin \= assignApplicable(varargin);
 
 
 %Make a datamatrix from the glt
 if (isempty(btd.glt))
 datamatrix \= \[];
 return;
 end
 try
 gltind \= find(strcmpi(gltname, {btd.glt.fieldname}),1,'first');
 catch
 datamatrix \= \[];
 return;
 end
 if (isempty(gltind))
 datamatrix \= \[];
 return;
 end
 try
 centers \= btd.getBTDMCenters(tp, position, gltname, 'conditions', conditions, varargin{:});
 if (\~isempty(shift))
 trange \= \[min(centers) max(centers)];
 centers \= mod(centers \+ shift \- trange(1\), diff(trange)) \+ trange(1\);
 end
 datamatrix \= btd.glt(gltind).makeDataMatrix(centers, displacementAxis, varargin{:});
% if (strcmpi(tp, 'all'))
% centers \= btd.(tp).(btd.glt(gltind).xField);
% else
% centers \= btd.(tp).(\[position '\_' btd.glt(gltind).xField]);
% end
% if (\~isempty(conditions))
% if (\~isfield(conditions, 'name') \|\| \~isfield(conditions, 'validop'))
% warning ('conditions must have field name and validop; valid \= validop(btd.tp.name)');
% else
% valid \= true(size(centers));
% for j \= 1:length(conditions)
% if (isfield(btd.(tp), conditions(j).name)) 
% valid \= valid \& conditions(j).validop(btd.(tp).(conditions(j).name));
% else
% vind \= btd.findField(conditions(j).name);
% if (vind \> 0\)
% 
% if (strcmpi(tp, 'all'))
% c2 \= btd.(tp).(btd.glt(vind).xField);
% else
% c2 \= btd.(tp).(\[position '\_' btd.glt(vind).xField]);
% end
% valid \= valid \& conditions(j).validop(btd.glt(vind).highResDerivationMethod(c2, btd.glt(vind).xData, btd.glt(vind).yData));
% else
% warning (\[conditions(j).name ' does not name a field in ' tp ' or a glt field']);
% end
% end
% end
% centers \= centers(valid);
% end
% end
 
 
 catch me
 disp(me.getReport());
 datamatrix \= \[];
 end
 stimnum \= ones(size(datamatrix));
 btdnum \= ones(\[size(datamatrix,1\) 1]);
 end
 
 %Takes data in btd for a given track part and reformats it as a dataMatrix
 function \[datamatrix, stimnum] \= behaviorTriggeredDataMatrixCompensator (btd, tp, position, gltname, gltnameCompensation, displacementAxis, varargin)
 %function \[datamatrix, stimnum] \= behaviorTriggeredDataMatrixCompensator (btd, tp, position, gltname, displacementAxis, varargin)
 %tp\=track part (run,reo,etc)
 %
 %finds value of gltnameCompensation at tp.position, subject to conditions then
 %randomly picks nreps (default \= 10\) other time points with same value of
 %gltnameCompensation (\+/\- max(epsilon\_val, epsilon\_pct\*value), default epsilon\_pct \= 0\.01, epsilon\_val \= 1\)
 %returns data matrix for these centers
 %
 %additional args: 'epsilon\_pct', 0\.01, 'epsilon\_val', 1; 'nreps', 10
 
 if (length(btd) \> 1\)
 \[datamatrix, stimnum] \= behaviorTriggeredDataMatrixCompensator (btd(1\), tp, position, gltname, gltnameCompensation, displacementAxis, varargin{:});
 for j \= 2:length(btd)
 if (isempty(btd(j).glt))
 continue;
 end
 \[dm,sn] \= behaviorTriggeredDataMatrixCompensator(btd(j), tp, position, gltname, gltnameCompensation, displacementAxis, varargin{:});
 datamatrix \= \[datamatrix;dm]; %\#ok
 stimnum \= \[stimnum;sn];%\#ok
 end
 return;
 end
 
 if (iscell(gltname))
 datamatrix \= behaviorTriggeredDataMatrixCompensator(btd, tp, position, gltname{1}, gltnameCompensation, displacementAxis, varargin{:});
 stimnum \= ones(size(datamatrix));
 for k \= 2:length(gltname)
 dm \= behaviorTriggeredDataMatrixCompensator(btd, tp, position, gltname{k}, gltnameCompensation, displacementAxis, varargin{:});
 datamatrix \= \[datamatrix dm]; %\#ok
 stimnum \= \[stimnum k\*ones(size(dm))]; %\#ok
 %{
 datamatrix \= \[datamatrix behaviorTriggeredDataMatrix(btd, tp, position, gltname{k} , displacementAxis, varargin{:})]; %\#ok
 stimnum \= \[stimnum k\*ones(size(datamatrix))]; %\#ok
 %}
 end
 return;
 end
 nreps \= 10;
 epsilon\_pct \= 0\.01;
 epsilon\_val \= 1;
 varargin \= assignApplicable(varargin);
 if (isempty(btd.glt))
 datamatrix \= \[];
 stimnum \= \[];
 return;
 end
 compval \= behaviorTriggeredDataMatrix(btd, tp, position, gltnameCompensation, 0, varargin{:});
 compval \= compval(isfinite(compval));
 if (isempty(compval))
 datamatrix \= \[];
 stimnum \= \[];
 return;
 end
 compind \= btd.findField(gltnameCompensation);
 gltind \= btd.findField(gltname);
 if (compind \<\= 0 \|\| gltind \<\= 0\)
 datamatrix \= \[];
 stimnum \= \[];
 return;
 end
 
 
 %Make a datamatrix from the glt
 xdata \= btd.glt(compind).xData;
 ydata \= btd.glt(compind).yData;
 centers \= zeros(length(compval), nreps);
 for j \= 1:length(compval)
 inds \= find(abs(compval(j)\-ydata) \<\= max(epsilon\_val, epsilon\_pct\*compval(j)));
 centers(j,:) \= xdata(inds(ceil(rand(\[1 nreps])\*length(inds)))); 
 end
 
 datamatrix \= btd.glt(gltind).makeDataMatrix(centers(:), displacementAxis, varargin{:});
 stimnum \= ones(size(datamatrix));
 end
 
 function ind \= findField(btd, fieldname)
 %function ind \= findField(btd, fieldname)
 %ind \= 0 on failure, otherwise 
 %strcmpi(btd.glt(ind).fieldname, fieldname) is true
 if (length(btd) \> 1\)
 ind \= zeros(size(btd));
 for j \= 1:length(btd)
 ind(j) \= btd(j).findField(fieldname);
 end
 return;
 end
 if (isempty(btd) \|\| isempty(btd.glt)) %\|\| \~isa(btd.glt, 'GlobalQuantity'))
 ind \= 0;
 return;
 end
 fn \= {btd.glt.fieldname};
 ind \= find(strcmpi(fieldname, fn), 1, 'first');
 if (isempty(ind))
 ind \= 0;
 %warning ('BTD:findField', \[fieldname ' not a valid glt name']);
 end
 
 end
 function glts \= gatherGlt (btd, fieldname)
 inds \= btd.findField(fieldname);
 if (any (inds \<\= 0\))
 glts \= \[];
 return;
 end
 for j \= 1:length(inds)
 glts(j) \= btd(j).glt(inds(j)); %\#ok
 end
 end
 
 
 function btd \= addGlobalLookupTable (btd, glt)
 %function btd \= addGlobalLookupTable (btd, glt)
 for j \= 1:length(glt)
 ind \= btd.findField(glt(j).fieldname);
 if (ind \<\= 0\)
 btd.glt \= \[btd.glt glt(j)];
 else
 btd.glt(ind) \= glt(j);
 end
 end
 end
 
 %Takes data in btd for a given track part and reformats it as a stretched dataMatrix
 function datamatrix \= behaviorTriggeredDataMatrixStretched (btd, tp, positionStart, positionEnd, gltname, npoints, varargin)
 %function datamatrix \= behaviorTriggeredDataMatrix (btd, tp, position, gltname, displacementAxis, varargin)
 disp ('warning: not sure this works correctly \-\- should be checked more carefully');
 
 if (length(btd) \> 1\)
 datamatrix \= behaviorTriggeredDataMatrixStretched (btd(1\), tp, positionStart, positionEnd, gltname, npoints, varargin{:});
 for j \= 2:length(btd)
 dm \= behaviorTriggeredDataMatrixStretched(btd(j), tp, positionStart, positionEnd, gltname, npoints, varargin{:});
 datamatrix \= \[datamatrix;dm]; %\#ok
 end
 return;
 end
 
 conditions \= \[];
 %conditions.name \= 'hsnum';
 %conditions.validop \= @(x) x \=\= 1;
 %this will get first headsweep
 varargin \= assignApplicable(varargin);
 
 if (isempty(btd.glt))
 datamatrix \= \[];
 return;
 end
 try
 gltind \= find(strcmpi(gltname, {btd.glt.fieldname}),1,'first');
 catch
 datamatrix \= \[];
 return;
 end
 if (isempty(gltind))
 datamatrix \= \[];
 return;
 end
 
 try
 starts \= btd.(tp).(\[positionStart '\_' btd.glt(gltind).xField]);
 stops \= btd.(tp).(\[positionEnd '\_' btd.glt(gltind).xField]);
 if (\~isempty(conditions))
 if (\~isfield(conditions, 'name') \|\| \~isfield(conditions, 'validop'))
 warning ('conditions must have field name and validop; valid \= validop(btd.tp.name)');
 else
 valid \= true(size(starts));
 for j \= 1:length(conditions)
 valid \= valid \& conditions(j).validop(btd.(tp).(conditions(j).name));
 end
 starts \= starts(valid);
 stops \= stops(valid);
 end
 end
 
 datamatrix \= btd.glt(gltind).makeDataMatrixStretched(starts, stops, npoints, varargin{:});
 catch
 datamatrix \= \[];
 end
 end
 
 
 %Takes the average of the behavior triggered data, returning the
 %average and the data matrix
 function \[bta, dm, stimnum, sem, sd] \= behaviorTriggeredAverage (btd, tp, position, gltname, displacementAxis, varargin)
 % function \[bta, dm] \= behaviorTriggeredAverage (btd, tp, position, gltname, displacementAxis, varargin)
 \[dm,stimnum] \= btd.behaviorTriggeredDataMatrix(tp, position, gltname, displacementAxis, varargin{:});
 dm2 \= dm; dm2(\~isfinite(dm2\)) \= 0;
 bta \= sum(dm2\)./sum(isfinite(dm));
 
 
 stimnum \= mean(stimnum);
 
 if (nargout \> 3\)
 btmat \= repmat(bta, \[size(dm,1\), 1]);
 
 dm2 \= dm \- btmat; dm2(\~isfinite(dm2\)) \= 0;
 sd \= sqrt(sum(dm2\.^2\)./sum(isfinite(dm)));
 sem \= sd./sqrt(sum(isfinite(dm)));
 end
 
 end
 %Takes the average of the behavior triggered data, returning the
 %average and the data matrix
 function \[bta, dm, stimnum, sem, sd] \= behaviorTriggeredAverageCompensator (btd, tp, position, gltname, gltnameCompensation, displacementAxis, varargin)
 % function \[bta, dm] \= behaviorTriggeredAverage (btd, tp, position, gltname, displacementAxis, varargin)
 \[dm,stimnum] \= btd.behaviorTriggeredDataMatrixCompensator(tp, position, gltname, gltnameCompensation, displacementAxis, varargin{:});
 dm2 \= dm; dm2(\~isfinite(dm2\)) \= 0;
 bta \= sum(dm2\)./sum(isfinite(dm));
 
 
 stimnum \= mean(stimnum);
 
 if (nargout \> 3\)
 btmat \= repmat(bta, \[size(dm,1\), 1]);
 dm2 \= dm \- btmat; dm2(\~isfinite(dm2\)) \= 0;
 sd \= sqrt(sum(dm2\.^2\)./sum(isfinite(dm)));
 sem \= sd./sqrt(sum(isfinite(dm)));
 end
 
 end
 function \[convkernel,btd] \= createBTAKernel (btd, tp, position, gltname, t0, dt, varargin)
 %function convkernel \= createBTAKernel (btd, tp, position, gltname, displacementAxis, varargin)
 %note: t0 should be less than 0; if t0 \> 0, we assume you mean t0 \< 0 and invert
 %kernel is created at points t0:dt:0
 %
 %kernel is normalized so that sum(convkernel.^2\) \= 1;

 newFieldName \= {};
 abbott \= false;
 loadKernel \= false;
 varargin \= assignApplicable(varargin);
 
 displacementAxis \= \-(0:dt:abs(t0\));

 \[bta,\~,stimnum] \= behaviorTriggeredAverage (btd, tp, position, gltname, displacementAxis, varargin{:});
 convkernel \= zeros(max(stimnum),length(displacementAxis));
 % alldata \= btd.behaviorTriggeredDataMatrix('all', \[], gltname,0\);
 for j \= 1:max(stimnum)
 if (abbott)
 t \= displacementAxis;
 if (loadKernel)
 load('E:\\Variance Adaptation\\MID\_pillcbf1\_ber17\_51\_120\_diff.mat'); %load kernel from file. loaded kernel must match displacementAxis \-(0:dt:abs(t0\))
 btaj \= MID\_pillcbf1\_ber17\_51\_120\_diff'; %load kernel from file. loaded kernel must match displacementAxis \-(0:dt:abs(t0\))
 else
 btaj \= bta(stimnum \=\= j);
 end

 abbottfun \= @(x,t) (x(3\)\*exp(\-x(2\)\*t)/(x(1\)\-x(2\)) \- x(5\)\*exp(\-x(4\)\*t)/(x(1\)\-x(4\)) \+ (x(3\)\*(x(4\)\-x(1\)) \- x(5\)\*(x(2\)\-x(1\)))\*exp(\-x(1\)\*t)/((x(1\)\-x(2\))\*(x(1\)\-x(4\)))) .\* (t \<\= 0\);
 
 
 \[\~,I] \= max(abs(btaj));
 mv \= btaj(I);
 x0 \= \[\-1\.5 \-1 mv \-0\.5 mv\*1\.5];
 
 op \= optimset('lsqcurvefit');
 op.MaxFunEvals \= 5E4;
 op.MaxIter \= 5000;
 
 % op.Display \= 'none';
 
 x \= lsqcurvefit(abbottfun, x0, displacementAxis, btaj,\[],\[],op);
 convkernel(j,:) \= abbottfun(x,displacementAxis);
 else
 if (loadKernel)
 load('E:\\Variance Adaptation\\MID\_pillcbf1\_ber17\_51\_120\_diff.mat');
 ck \= MID\_pillcbf1\_ber17\_51\_120\_diff';
 else
 ck \= bta(stimnum \=\= j);
 end
 
 ck \= csaps(1:length(ck), ck, dt, 1:length(ck));
 convkernel(j,:) \= ck./sqrt(sum(ck.^2\));%/std(alldata(isfinite(alldata(:,j)),j));
 end
 end
 if (\~iscell(gltname))
 gltname \= {gltname};
 end
 if (\~iscell(newFieldName))
 if (iscell(gltname) \&\& length(gltname) \> 1\)
 return;
 end
 newFieldName \= {newFieldName};
 
 end
 for j \= 1:length(newFieldName)
 if (ischar(newFieldName{j}) \&\& \~isempty(newFieldName{j}))
 btd \= btd.addConvolvedFields (gltname{j}, newFieldName{j}, convkernel(j,:), dt, 'scaleToSqr', true, varargin{:});
 end
 end
 end
 
 function \[stim, sp, delta\_t] \= getPillowData (btd, tp, position, gltname, delta\_t, varargin) 
 %function \[stim, sp] \= getPillowData (btd, tp, position, gltname) 
 %gets data for use in pillow routine simpleSTC
 
 conditions \= \[];
 existsAndDefault('delta\_t', \[]);
 
 if (length(btd) \> 1\)
 \[stim, sp, delta\_t] \= getPillowData(btd(1\), tp, position, gltname, delta\_t, varargin{:});
 for j \= 2:length(btd)
 \[s,p, delta\_t] \= getPillowData(btd(j), tp, position, gltname, delta\_t, varargin{:});
 p \= p \+ length(stim);
 stim \= \[stim;s]; %\#ok
 sp \= \[sp p]; %\#ok
 end
 return;
 end
 xt \= \[];
 xte \= \[];
 if (\~iscell(gltname))
 gltname \= {gltname};
 end
 for k \= 1:length(gltname)
 ind \= btd.findField(gltname{k});
 if (ind \<\= 0\)
 warning ('btd:getPillowData', \[gltname{k} ' not a valid field']);
 stim \= \[];
 sp \= \[];
 return;
 end
 lt \= btd.glt(ind);
 if (\~any(strcmpi(lt.xField, {'eti', 'et'}))) % add other timing fields here if needed
 warning ('btd:getPillowData', \[gltname{k} ' xField may not be time']);
 end

 if (isempty(delta\_t))
 delta\_t \= median(diff(lt.xData));
 end
 if (isempty(xt)) 
 xt \= min(lt.xData):(delta\_t):max(lt.xData);
 xte \= min(lt.xData\-delta\_t/2\):delta\_t:max(lt.xData\+delta\_t/2\);
 end
 % stim \= interp1(lt.xData, lt.yData, xt, 'linear');
 \[\~,stim(:,k)] \= meanyvsx(lt.xData, lt.yData, xte);
 %whos stim
 end
 if (strcmpi(tp, 'all'))
 centers \= btd.(tp).(lt.xField);
 else
 centers \= btd.(tp).(\[position '\_' lt.xField]);
 end
 
 if (\~isempty(conditions))
 if (\~isfield(conditions, 'name') \|\| \~isfield(conditions, 'validop'))
 warning ('conditions must have field name and validop; valid \= validop(btd.tp.name)');
 else
 valid \= true(size(centers));
 for j \= 1:length(conditions)
 if (isfield(btd.(tp), conditions(j).name)) 
 valid \= valid \& conditions(j).validop(btd.(tp).(conditions(j).name));
 else
 vind \= btd.findField(conditions(j).name);
 if (vind \> 0\)
 
 if (strcmpi(tp, 'all'))
 c2 \= btd.(tp).(btd.glt(vind).xField);
 else
 c2 \= btd.(tp).(\[position '\_' btd.glt(vind).xField]);
 end
 valid \= valid \& conditions(j).validop(btd.glt(vind).highResDerivationMethod(c2, btd.glt(vind).xData, btd.glt(vind).yData));
 else
 warning (\[conditions(j).name ' does not name a field in ' tp ' or a glt field']);
 end
 end
 end
 centers \= centers(valid);
 end
 end
 
 sp \= interp1(xt, 1:length(xt), centers);
 
 end
 
 
 % function \[bta, dm, stimnum] \= behaviorTriggeredWeightedAverage (btd, tp, position, gltname, displacementAxis, varargin)
 % as with behavior triggered average, but weighted by
 % tp.(weightField)
 %optional: weightedOp \-\- weight is weightedOp(tp.weightField)
 function \[bta, dm, stimnum] \= behaviorTriggeredWeightedAverage (btd, tp, position, weightField, gltname, displacementAxis, varargin)
 % function \[bta, dm] \= behaviorTriggeredWeightedAverage (btd, tp, position, weightField, gltname, displacementAxis, varargin)
 weightedOp \= @(x) x;
 conditions \= \[];
 varargin \= assignApplicable(varargin);
 \[dm,stimnum] \= btd.behaviorTriggeredDataMatrix(tp, position, gltname, displacementAxis, 'conditions', conditions, varargin{:});
 btp \= \[btd.(tp)];
 wf \= \[btp.(weightField)];
 valid \= true(size(wf)); 
 for j \= 1:length(conditions)
 %valid \= valid \& conditions(j).validop(\[tp.(conditions(j).name)]);
 if (isfield(btp, conditions(j).name))
 valid \= valid \& conditions(j).validop(\[btp.(conditions(j).name)]);
 else
 val\_field \= btd.behaviorTriggeredDataMatrix(tp, position, conditions(j).name, 0, varargin{:});
 valid \= valid \& conditions(j).validop(val\_field');
 end
 end
 wf \= weightedOp(wf(valid));
 if (all(wf \=\= mean(wf))) %\#ok
 ww \= ones(size(dm,2\));
 else
% wf \= (wf\-mean(wf))/std(wf); stdev removed 10/26 by MHG to
% facilitate comparisons between data sets
 wf \= (wf\-mean(wf));
 ww \= repmat(wf',\[1, size(dm,2\)]);
 end
 dm2 \= dm.\*ww; 
% ww(\~isfinite(dm2\)) \= 0;
 dm2(\~isfinite(dm2\)) \= 0;
 
 bta \= sum(dm2\)./(sum(isfinite(dm)));
 
% dm2 \= dm; dm2(\~isfinite(dm2\)) \= 0;
% bta \= bta \- sum(dm2\)./sum(isfinite(dm));
% 
 stimnum \= mean(stimnum);
 
 end
 
 %Takes the average of the behavior triggered data, returning the
 %average and the stretched 
 function \[bta, dm] \= behaviorTriggeredStretchedAverage (btd, tp, positionStart, positionEnd, gltname, npoints, varargin)
 % function \[bta, dm] \= behaviorTriggeredAverage (btd, tp, position, gltname, displacementAxis, varargin)
 dm \= btd.behaviorTriggeredDataMatrixStretched(tp, positionStart, positionEnd, gltname, npoints, varargin{:});
 dm2 \= dm; dm2(\~isfinite(dm2\)) \= 0;
 bta \= sum(dm2\)./sum(isfinite(dm));
 end
 
 function \[r,reb, fieldAxis] \= rateVsField(btd, tp, position, gltname, fieldAxis, varargin)
 %function \[r,reb, fieldAxis] \= rateVsField(btd, tp, position, gltname, fieldAxis, varargin)
 %
 % r \- rate of tp.position occuring vs. gltname (in Hz)
 % reb \- error bar due to counting statistics
 %
 %varargin:
 % conditions: applied to tp and all
 % tpconditions: only to tp
 % allconditions: onl to all: default isrun \-\- if you pass
 % allconditions, make sure to include isrun if needed
 % allconditions.name \= 'isrun';allconditions.validop \= @(x) logical(x);
 conditions \= \[];
 tpconditions \= conditions;
 allconditions.name \= 'isrun';allconditions.validop \= @(x) logical(x);
 %conditions.name \= 'hsnum';
 %conditions.validop \= @(x) x \=\= 1;
 %this will get first headsweep
 varargin \= assignApplicable(varargin);
 
 yy \= btd.behaviorTriggeredDataMatrix(tp, position, gltname, 0, 'conditions', \[conditions tpconditions], varargin{:});
 aa \= btd.behaviorTriggeredDataMatrix('all', \[], gltname, 0, 'conditions', \[conditions allconditions], varargin{:});
 
 dt \= median(diff(btd(1\).all.eti));
 
 existsAndDefault('fieldAxis', linspace(percentile(aa,0\.01\), percentile(aa,.99\), 20\));
 
 xx \= binEdgesFromCenters(fieldAxis);
 
 h1 \= histc(yy,xx);
 h2 \= histc(aa,xx);
 rr \= 1/dt\*h1(1:(end\-1\))./h2(1:(end\-1\));
 reb \= 1/dt\*sqrt(h1(1:(end\-1\)))./h2(1:(end\-1\));
 rr\= rr';
 reb \= reb';
 if (nargout \=\= 0\)
 shadedErrorPlot(fieldAxis, rr, reb); ylabel(\[tp ' ' position ' rate (Hz)']); xlabel (gltname);
 else
 r \= rr;
 end
 end
 
 function fitParams \= fitRateFun(btd, tp, position, gltname, fitfun, initGuess, varargin)
 % function fitParams \= fitRateFun(btd, tp, position, gltname, fitfun, initGuess, varargin)
 %
 % r \- rate of tp.position occuring vs. gltname (in Hz)
 % reb \- error bar due to counting statistics
 %
 %varargin:
 % conditions: applied to tp and all
 % tpconditions: only to tp
 % allconditions: only to all 
 %
 % gltname is field name or string of field names
 % fitfun \= f (x, data)
 % if gltname is a cell, then data will also be a cell
 % note this behavior was revised on 9/20/2014 \-\- old scripts
 % may be unhappy and need to be updated
 
 conditions \= \[];
 tpconditions \= conditions;
 allconditions.name \= 'isrun';allconditions.validop \= @(x) logical(x);
 %conditions.name \= 'hsnum';
 %conditions.validop \= @(x) x \=\= 1;
 %this will get first headsweep
 varargin \= assignApplicable(varargin);
 op \= optimset('fminunc');
 op.Display \= 'off';
 op.LargeScale \= 'off';
 if (iscell(gltname)) 
 for j \= 1:length(gltname)
 yy{j} \= btd.behaviorTriggeredDataMatrix(tp, position, gltname{j}, 0, 'conditions', \[conditions tpconditions], varargin{:}); %\#ok
 aa{j} \= btd.behaviorTriggeredDataMatrix('all', \[], gltname{j}, 0, 'conditions', \[conditions allconditions], varargin{:}); %\#ok
 end
 else
 yy \= btd.behaviorTriggeredDataMatrix(tp, position, gltname, 0, 'conditions', \[conditions tpconditions], varargin{:});
 aa \= btd.behaviorTriggeredDataMatrix('all', \[], gltname, 0, 'conditions', \[conditions allconditions], varargin{:});
 end
% if (iscell(gltname))
% if (\~iscell(fitfun) \|\| \~iscell(initGuess))
% error ('all gltname, fitfun, initGuess must be cells, or none');
% end
% for j \= 1:length(gltname)
% nargs(j) \= length(initGuess{j});
% end
% 
% else
 
 myfun \= @(x) \-sum(log(max(1E\-100,1\-exp(\-fitfun(x,yy))))) \+ sum(max(0,fitfun(x,aa)));
 
 fitParams \= fminunc(myfun, initGuess, op);
% return;
% end
% function val \= globalfitfun(x)
% argc \= 0;
% rturn \= zeros(size(yy));
% rall \= zeros(size(aa));
% 
% for k \= 1:length(gltname)
% args \= x(argc \+ (1:nargs(k)));
% argc \= argc \+ nargs(k);
% rturn(:,k) \= fitfun{k}(args, yy(:,k));
% rall(:,k) \= fitfun{k}(args, aa(:,k));
% end
% val \= \-sum(log(max(1E\-100, 1 \- exp(prod(rturn, 2\))))) \+ sum(max(0, prod(rall,2\)));
% end
% x0 \= \[initGuess{:}];
% globalfitfun(x0\)
% x1 \= fminunc(@globalfitfun, x0, op);
% globalfitfun(x1\)
% argc \= 0;
% for j \= 1:length(initGuess)
% fitParams{j} \= x1(argc \+ (1:nargs(j)));
% argc \= argc \+ nargs(j);
% end
 
 end
 
 
 function btd \= addConvolvedFields (btd, gltname, newname, convkernel, convkernel\_dt, varargin)
 %btd \= addConvolvedFields (btd, gltname, newname, convkernel, convkernel\_dt, varargin)
 %NOTE: does not reverse kernel for you (e.g. convolution is in
 %normal sense)
 %NOTE: default is result of convolution is entirely causal
 % to make convolution symmetric, pass 'symmetric', true
 if \~(iscell(gltname))
 gltname \= {gltname};
 end
 if \~(iscell(newname))
 newname \= {newname};
 end
 existsAndDefault('convkernel\_dt', \[]);
 symmetric \= false;
 normalizeStd \= false;
 existsAndDefault('scaleToSqr', false);
 varargin \= assignApplicable(varargin);
 
 for j \= 1:length(btd)
 if (isempty(btd(j).glt))
 continue;
 end
 
 for k \= 1:length(gltname)
 gltind \= find(strcmpi(gltname{k}, {btd(j).glt.fieldname}),1,'first');
 if (\~isempty(gltind))
 newglt \= btd(j).glt(gltind);
 newglt.fieldname \= newname{k};
 if (isempty(convkernel\_dt))
 ck \= convkernel;
 else
 dt \= convkernel\_dt(min(k, length(convkernel\_dt)));
 ck \= interp1(convkernel, 1:(median(diff(newglt.xData))/dt):length(convkernel), 'linear');
 if (scaleToSqr)
 ck \= ck\*sqrt(length(convkernel)/length(ck));
 else
 ck \= ck\*length(convkernel)/length(ck);
 end
% ck \= interp1((1:length(convkernel))\*dt, convkernel, 1::
 end
 if symmetric
 newglt.yData \= conv(newglt.yData, ck, 'same');
 else
 yy \= conv(newglt.yData, ck, 'full');
 newglt.yData \= yy(1:length(newglt.yData));
 end
% if (normalizeStd)
% newglt.yData \= newglt.yData / std(newglt.yData);
% end
 gltind \= find(strcmpi(newglt.fieldname, {btd(j).glt.fieldname}),1,'first');
 
 if (isempty(gltind))
 btd(j).glt \= \[btd(j).glt newglt];
 else
 btd(j).glt(gltind) \= newglt; 
 end
 end
 end
 end
 if (normalizeStd)
 for k \= 1:length(newname) %\#ok
 snorm \= std(btd.behaviorTriggeredDataMatrix('all', '', newname{k}, 0\));
 if (isempty(snorm) \|\| \~isfinite(snorm))
 warning ('btd:addconvfield', 'bad data matrix, not normalizing');
 continue;
 end
 for j \= 1:length(btd)
 gltind \= btd(j).findField(newname{k});
 btd(j).glt(gltind).yData \= btd(j).glt(gltind).yData/snorm;
 end
 end
 end
 end
 
 function btd \= addLowpassFields (btd, gltname, sigmaTime)
 if \~(iscell(gltname))
 gltname \= {gltname};
 end
 
 for j \= 1:length(btd)
 if (isempty(btd(j).glt))
 continue;
 end
 for k \= 1:length(gltname)
 gltind \= find(strcmpi(gltname{k}, {btd(j).glt.fieldname}),1,'first');
 if (\~isempty(gltind))
 newglt \= btd(j).glt(gltind);
 newglt.fieldname \= \[gltname{k} '\_LOWPASS'];
 sigma \= sigmaTime./median(diff(newglt.xData));
 newglt.yData \= lowpass1D(newglt.yData, sigma);
 gltind \= find(strcmpi(newglt.fieldname, {btd(j).glt.fieldname}),1,'first');
 if (isempty(gltind))
 btd(j).glt \= \[btd(j).glt newglt];
 else
 btd(j).glt(gltind) \= newglt;
 end
 end
 end
 end
 end
 
 
 function btd \= addOperationFields (btd, gltname, newname, operation)
 % function btd \= addOperationFields (btd, gltname, newname, operation)
 % if gltname and newname are both single names of fields
 % or if gltname and newname are cells of the same length
 % we create fields s.t. newname{j}.yData \= operation(gltname{j}.yData)
 % if gltname is a cell and newname is a single field, then
 % newname \= operation({gltname{1}.yData, gltname{2}.yData,
 % ...})
 % in this case, operation should take a cell of data
 % TODO: REVISE TO BE CORRECT FUNCTION FOR several glt, 1
 % newname
 if \~(iscell(gltname))
 gltname \= {gltname};
 end
 if \~(iscell(newname))
 newname \= {newname};
 end
 
 for j \= 1:length(btd)
 if (isempty(btd(j).glt))
 continue;
 end
 
 if (length(newname) \=\= length(gltname))
 for k \= 1:length(gltname)
 gltind \= find(strcmpi(gltname{k}, {btd(j).glt.fieldname}),1,'first');
 if (\~isempty(gltind))
 newglt \= btd(j).glt(gltind);
 newglt.fieldname \= newname{k};
 newglt.yData \= operation(newglt.yData); 
 else
 warning ('btd:addoperation', \[gltname{k} ' not found']);
 continue;
 end
 gltind \= find(strcmpi(newglt.fieldname, {btd(j).glt.fieldname}),1,'first');
 if (isempty(gltind))
 btd(j).glt \= \[btd(j).glt newglt];
 else
 btd(j).glt(gltind) \= newglt;
 end
 end
 else
 gltind \= btd(j).findField(gltname{1});
 if (gltind \<\= 0\)
 error (\[gltname{1} ' not found']);
 end
 newglt \= btd(j).glt(gltind);
 
 newglt.fieldname \= newname{1};
 yData{1} \= newglt.yData;
 
 for k \= 2:length(gltname)
 gltind \= btd(j).findField(gltname{k});
 if (gltind \<\= 0\)
 error (\[gltname{k} ' not found']);
 end
 yData{k} \= interp1(btd(j).glt(gltind).xData, btd(j).glt(gltind).yData, newglt.xData, 'linear', 'extrap'); %\#ok
 end
 newglt.yData \= operation(yData);
 gltind \= find(strcmpi(newglt.fieldname, {btd(j).glt.fieldname}),1,'first');
 if (isempty(gltind))
 btd(j).glt \= \[btd(j).glt newglt];
 else
 btd(j).glt(gltind) \= newglt;
 end
 end
 
 
 end
 
 end
 
 function \[datamatrix, stimnum] \= baseConditionedDataMatrix(btd, gltname, conditions, displacementAxis,varargin)
 %function \[datamatrix, stimnum] \= baseConditionedDataMatrix(btd, gltname, conditions, displacementAxis,varargin)
 %
 % datamatrix of gltname centered on points chosen from gltname.xData satisfying
 % conditions(j).validop(conditions(j).name at point) is true for all j
 % btd \< BehaviorTriggeredData
 % gltname \< name of a glt in btd
 % conditions \< array of conditions: 
 % conditions(j).name is name of a glt in btd
 % conditions(j).validop is operation that takes yData from glt and
 % returns true/false
 % displacementAxis \- axis to take average relative to chosen center
 % points
 % optional arg: maxDmElems, \[1E7]
 % to avoid taking forever, center points are decimated to keep
 % datamatrix under maxDmElems per btd per gltname

 if (length(btd) \> 1\)
 \[datamatrix, stimnum] \= baseConditionedDataMatrix (btd(1\), gltname, conditions, displacementAxis, varargin{:});
 for j \= 2:length(btd)
 if (isempty(btd(j).glt))
 continue;
 end
 \[dm,sn] \= baseConditionedDataMatrix (btd(j), gltname, conditions, displacementAxis, varargin{:});
 datamatrix \= \[datamatrix;dm]; %\#ok
 stimnum \= \[stimnum;sn];%\#ok
 end
 return;
 end
 
 if (iscell(gltname))
 datamatrix \= baseConditionedDataMatrix (btd, gltname{1}, conditions, displacementAxis, varargin{:});
 stimnum \= ones(size(datamatrix));
 for k \= 2:length(gltname)
 datamatrix \= \[datamatrix baseConditionedDataMatrix(btd, gltname{k}, conditions, displacementAxis, varargin{:})]; %\#ok
 stimnum \= \[stimnum k\*ones(size(datamatrix))]; %\#ok
 end
 return;
 end
 maxDmElems \= 1E7;
 varargin \= assignApplicable(varargin);
 maxCenterPoints \= ceil(maxDmElems/length(displacementAxis));
 
 %Make a datamatrix from the glt
 ind \= btd.findField(gltname);
 if (ind \<\= 0\)
 datamatrix \= \[];
 stimnum \= \[];
 return;
 end
 xd \= btd.glt(ind).xData;
 valid \= true(size(xd));
 
 try
 for j \= 1:length(conditions)
 cind \= btd.findField(conditions(j).name);
 yd \= btd.glt(cind).highResDerivationMethod(xd, btd.glt(cind).xData, btd.glt(cind).yData);
 valid \= valid \& conditions(cind).validop(yd);
 end
 catch me
 disp(me.getReport());
 datamatrix \= \[];
 stimnum \= \[];
 return;
 end
 
 centers \= xd(valid);
 if (length(centers) \> maxCenterPoints)
 centers \= centers(randperm(length(centers), maxCenterPoints));
 end
 datamatrix \= btd.glt(ind).makeDataMatrix(centers, displacementAxis, varargin{:});
 stimnum \= ones(size(datamatrix));
 end
 
 function \[bca, dm, stimnum] \= baseConditionedAverage(btd, gltname, conditions, displacementAxis,varargin)
 %function \[bca, datamatrix, stimnum] \= baseConditionedAverage(btd, gltname, conditions, displacementAxis,varargin)
 %
 % average of gltname centered on points chosen from gltname.xData satisfying
 % conditions(j).validop(conditions(j).name at point) is true for all j
 \[dm, stimnum] \= baseConditionedDataMatrix(btd, gltname, conditions, displacementAxis,varargin{:});
 dm2 \= dm; dm2(\~isfinite(dm2\)) \= 0;
 bca \= sum(dm2\)./sum(isfinite(dm));
 stimnum \= mean(stimnum);
 end
 
 function \[cm, cm\_stim, stimnum, dm] \= behaviorTriggeredCovarianceMatrix (btd, tp, position, gltname, displacementAxis, varargin)
 
 if \~(iscell(gltname))
 gltname \= {gltname};
 end
 
 dm \= behaviorTriggeredDataMatrix(btd, tp, position, gltname, displacementAxis, varargin{:});
 
 dm2 \= dm; dm2(\~isfinite(dm)) \= 0;
 cm \= dm2'\*dm2 / size(dm2,1\);
 cm\_stim \= zeros(size(cm));
 
 stimnum \= zeros(size(dm));
 for j \= 1:length(gltname)
 dl \= length(displacementAxis);
 stimnum(:, (j\-1\)\*dl \+ (1:dl)) \= j;
 end
 
 %estimate covariance matrices of signal
 btdw \= zeros(size(btd));
 for j \= 1:length(btd)
 if (isempty(btd(j).glt))
 continue;
 end
 btdw(j) \= length(btd(j).all.eti);
 for k \= 1:length(gltname)
 for m \= 1:length(gltname)
 glt1 \= btd(j).glt(find(strcmpi(\[gltname{k}], {btd(j).glt.fieldname}),1,'first'));
 glt2 \= btd(j).glt(find(strcmpi(\[gltname{m}], {btd(j).glt.fieldname}),1,'first'));
 
 yd2 \= interp1(glt2\.xData, glt2\.yData, glt1\.xData, 'linear', 0\);
 dt \= median(diff(glt1\.xData));
 maxlag \= ceil(2\*max(abs(displacementAxis))/dt);
 \[xc, lags] \= xcorr(glt1\.yData, yd2, maxlag, 'unbiased');
 off1 \= (k\-1\)\*length(displacementAxis);
 off2 \= (m\-1\)\*length(displacementAxis);
 for n \= 1:length(displacementAxis)
 cm\_stim (off1 \+ n, off2 \+ (1:length(displacementAxis))) \= cm\_stim (off1 \+ n, off2 \+ (1:length(displacementAxis))) \+ btdw(j)\*interp1(lags\*dt, xc, displacementAxis \- displacementAxis(n));
 end
 
 end
 end
 end
 cm\_stim \= cm\_stim / sum(btdw);
 end
 
 function \[k0,k1,k2] \= wienerKernels(btd, gltname, dqname, displacementAxis, varargin)
 %function \[k0,k1,k2] \= wienerKernels(gltname, dqname, displacementAxis, varargin)

 da \= sort(unique(displacementAxis), 'ascend');
 dt \= min(diff(da));
 dtf \= dt/2;
 aa \= \[btd.all];
 
 for j \= 1:length(aa)
 y{j} \= aa(j).(dqname); 
 eti{j} \= aa(j).eti;
 dtf \= max(dtf, median(diff(aa(j).eti)));
 end
 k0 \= mean(\[y{:}]);
 if (nargout \< 2\)
 return;
 end
 maxlag \= ceil((max(da) \- min(da))/(2\*dtf)) \+ 1;
 c \= zeros(length(aa), 2\*maxlag \+ 1\);
 ns \= c;
 v \= zeros(1,length(aa));
 for j \= 1:length(aa)
 ind \= btd(j).findField(gltname);
 if (ind \<\= 0\)
 warning ('btd:wienerKernels', \[gltname ' is not a glt']);
 k1 \= \[]; k2 \= \[];
 return;
 end
 glt \= btd(j).glt(ind); %\#ok

 midtime \= median(da);
 txf \= max(min(eti{j} \- midtime/2\), min(glt.xData \+ midtime/2\)):dtf:min(max(eti{j} \-midtime/2\),max(glt.xData \+ midtime/2\)); %\#ok
 \[xx,\~,sumy, numx] \= meanyvsxFast(eti{j} \- midtime/2, y{j}\-k0, txf);
 
 u \= GlobalLookupTable.averageInPrecedingBin(xx, glt.xData \+ midtime/2, glt.yData); 
 
 
 \[c(j,:),lags] \= xcorr(sumy,u,maxlag,'none');
 ns(j,:) \= xcorr(numx, ones(size(u)), maxlag, 'none');
 v(j) \= var(glt.yData);
 end
 cc \= sum(c, 1\)./sum(ns, 1\);
 n2 \= sum(ns, 2\);
 vu \= v\*n2/sum(n2\);

 k1 \= interp1(lags\*dtf \+ midtime, cc/vu, displacementAxis, 'linear');
 
 %only do the convolution in the causal direction \-\- we should
 %really clean this code up
 da \= displacementAxis(displacementAxis \>\= 0\);
 kcausal \= k1(displacementAxis \>\= 0\);
 %y1 \= conv(yd, cc, 'full'); y1 \= y1(1:length(yd)); sppred \= interp1(xd, y1, btd(1\).all.eti);\[\~,my2] \= meanyvsxFast(btd(1\).all.eti,sppred, 0:0\.1:1200\);\[c,lags] \= xcorr(my, my2, 300\); plot (lags/10, c)
 
 %vu2
 if (nargout \< 3\)
 return;
 end
 
 warning ('k2 not implemented yet'); 
 
 
 return;
 
 end

 function \[mi, tcent, bit\_rate, tstart] \= miFieldSignalVsTime (btd, tp, field, position, gltname, taxis, tbinEdges, varargin)
 %function \[mi, tcent, bit\_rate, tstart] \= miFieldSignalVsTime (btd, tp, field, position, gltname, conditions, taxis, tbinEdges, varargin)
 conditions \= \[];
 operation \= @(x) double(x);
 method \= 'Shannon\_Edgeworth';
 varargin \= assignApplicable(varargin);
 aa \= \[btd.(tp)];
 fd \= operation(\[aa.(field)]);
 valid \= true(size(fd));
 for j \= 1:length(conditions)
 valid \= valid \& conditions(j).validop(\[aa.(conditions(j).name)]);
 end
 fd \= fd(:,valid);
 dm \= btd.behaviorTriggeredDataMatrix(tp, position, gltname, taxis, 'conditions', conditions, varargin{:});
 
 if (size(tbinEdges,1\) \=\= 1\)
 if (size(tbinEdges,2\) \=\= 1\) %it's a bin width rather than edges
 bw \= tbinEdges;
 tbinEdges \= taxis(taxis \< max(taxis \- bw));
 tbinEdges(2,:) \= tbinEdges(1,:) \+ bw;
 else
 tbinEdges(2,:) \= \[tbinEdges(2:end) tbinEdges(end)\+eps];
 end
 end
 
 
 mi \= zeros(1, size(tbinEdges,2\)\-1\);
 tcent \= mi;
 co \= IShannon\_HShannon\_initialization(1, {'member\_name', method});
 for j \= 1:(size(tbinEdges,2\)\-1\)
 inds \= taxis \>\= tbinEdges(1,j) \& taxis \< tbinEdges(2,j);
 tcent(j) \= mean(taxis(inds));
 ds \= \[size(fd,1\) nnz(inds)];
 yy \= \[fd' dm(:,inds)];
 yy \= yy(all(isfinite(yy),2\), :); %\#ok all is also a property; function meant here
 if (isempty(yy))
 continue;
 end
 mi(j) \= IShannon\_HShannon\_estimation(yy', ds, co);
 end
 bit\_rate \= (mi/log(2\)) ./ diff(tbinEdges(:,1:end\-1\));
 tstart \= tbinEdges(1,1:end\-1\);
 
 end
 
 function \[mi, tcent, bit\_rate, tstart] \= miVsTime (btd, items, taxis, tbinEdges, varargin)
 %function \[mi, tcent] \= miVsTime (btd, items, taxis, tbinEdges, varargin)
 %finds the mutual information between signals defined by
 %items.gltname and states defined by different items
 %see static function miDiscreteVsTime
 %
 %example
 % firsths.name \= 'hsnum';
 % firsths.validop \= @(x) x \=\= 1;
 % items(1\).tp \= 'rejhs';
 % items(1\).position \= 'acchs';
 % items(1\).gltname \= 'led1ValDiff';
 % items(1\).conditions \= firsths;
 % items(2\) \= items(1\);
 % items(2\).tp \= 'acchs';
 %
 % binWidth \= 0\.5;
 % \[mi,tcent] \= btd.miVsTime(items, \-4:0\.05:4, binWidth);
 % mi\_rate \= mi/(log(2\)\*binWidth); %information rate about hs rejection/acceptance in bits/sec about tcent
 
 if (\~exist('items', 'var'))
 items.tp \= '';
 items.position \= '';
 items.gltname \= '';
 items.conditions.name \= '';
 items.conditions.validop \= '';
 mi \= items;
 return;
 end
 if \~isfield(items, 'conditions')
 \[items.conditions] \= deal(\[]);
 end
 for j \= 1:length(items)
 %(btd, tp, position, gltname, displacementAxis, varargin)
 dm{j} \= btd.behaviorTriggeredDataMatrix(items(j).tp, items(j).position, items(j).gltname, taxis, 'conditions', items(j).conditions, varargin{:});
 end
 \[mi, tcent, bit\_rate, tstart] \= BehaviorTriggeredData.miDiscreteVsTime(taxis, dm, tbinEdges, varargin{:});
 
 end
 
 function \[dkl12, tcent, bit\_rate, tstart] \= klDivergenceVsTime (btd, item1, item2, taxis, tbinEdges, varargin)
 %function \[mi, tcent] \= miVsTime (btd, items, taxis, tbinEdges, varargin)
 %finds the kl divergence dkl(item1\|\|item2\) information between signals defined by
 %item1 and item2 
 %see static function klDivergenceBetweenDM
 %
 
 if (\~exist('item1', 'var'))
 items.tp \= '';
 items.position \= '';
 items.gltname \= '';
 items.conditions.name \= '';
 items.conditions.validop \= '';
 dkl12 \= items;
 return;
 end
 if \~isfield(item1, 'conditions')
 item1\.conditions \= \[];
 end
 if \~isfield(item2, 'conditions')
 item2\.conditions \= \[];
 end
 items \= \[item1, item2];
 for j \= 1:length(items)
 %(btd, tp, position, gltname, displacementAxis, varargin)
 dm{j} \= btd.behaviorTriggeredDataMatrix(items(j).tp, items(j).position, taxis, 'conditions', items(j).conditions, varargin{:});
 end
 % function \[dkl12, tcent] \= klDivergenceBetweenDM (taxis, dm1, dm2, tbinEdges, varargin)
 \[dkl12, tcent, bit\_rate, tstart] \= BehaviorTriggeredData.klDivergenceBetweenDM(taxis, dm1, dm2, tbinEdges, varargin{:});
 
 end
 
 function \[fom\_true, fom\_shifted, u, s, vals, ue, se] \= figureOfMerit (btd, tp, position, gltname, displacementAxis, varargin)
 %\[fom\_true, fom\_shifted, u, s, vals, ue, se] \= figureOfMerit (btd, tp, position, gltname, displacementAxis, varargin)
 %arguments same as for behaviorTriggeredAverage
 %additional arguments
 %shiftPad \- added to minimum shift to exclude slightly larger
 %region around 0 shift
 %deltaT \- amount to shift at one time \- default duration of
 %displacementAxis
 
 shiftPad \= 0;
 deltaT \= \[];
 varargin \= assignApplicable(varargin);
 
 \[\~,\~,bn] \= btd.behaviorTriggeredDataMatrix(tp, position, gltname, displacementAxis, varargin{:});
 nturns \= zeros(\[1 length(btd)]);
 for j \= 1:length(btd)
 nturns(j) \= nnz(bn \=\= j);
 end
 \[ue,se] \= btd.gatherGlt(gltname).theoreticalSumSqStats(max(displacementAxis)\-min(displacementAxis), length(displacementAxis), nturns);

 trange \= 0;
 for j \= 1:length(btd)
 centers \= btd(j).getBTDMCenters(tp, position, gltname, varargin{:});
 trange \= max(trange, max(centers)\-min(centers));
 end
 if (isempty(deltaT))
 deltaT \= max(displacementAxis) \- min(displacementAxis);
 end
 nshifts \= floor((trange\-2\*shiftPad)/deltaT)\-1;
 
 vals \= zeros(\[1 nshifts]);
 for j \= 1:nshifts
 vals(j) \= sum(btd.behaviorTriggeredAverage(tp, position, gltname, displacementAxis, 'shift', j\*deltaT\+shiftPad, varargin{:}).^2\);
 end
 u \= mean(vals);
 s \= std(vals);

 fom\_true \= (sum(btd.behaviorTriggeredAverage(tp, position, gltname, displacementAxis, varargin{:}).^2\) \- ue)/se;
 fom\_shifted \= (vals \- ue)/se;
 
 end
 
 function \[rate, ttime, rtime] \= simulateTurnTrain (btd, xname, ratefun, taxis, nlarvae, nreps)
 % function \[rate, ttime, rtime] \= simulateTurnTrain (btd, xname, ratefun, taxis, nlarvae)
 % rate \= ratefun({xdata}, t) \-\- {xdata} is a cell of values at
 % times specified in taxis; i.e. xdata{j} \= xname{j}(taxis)
 % ttime is time of turns (given nlarvae and poisson statistics)
 % rtime is time of runs (currently just taxis repeated nlarvae
 % times)
 % simulation of turns is repeated nreps times
 if (length(btd) \> 1\)
 for j \= 1:length(btd)
 \[ttime{j}, rtime{j}] \= simulateTurnTrain (btd(j), xname, ratefun, taxis, nlarvae, nreps); %\#ok
 end
 return;
 end
 if (\~iscell(xname))
 xname \= {xname};
 end
 %gather xdata
 for j \= 1:length(xname)
 ind \= btd.findField(xname{j});
 if (ind \<\= 0 \&\& j \=\= 1\)
 warning (\[xname{j} ': field not found']);
 rtime \= \[];
 ttime \= \[];
 return;
 end
 xf \= btd.glt(ind);
 if (\~strcmpi(xf.xField, 'eti'))
 warning (\['eti is not xField for ' xf.fieldname ' results possibly incorrect']);
 end
 existsAndDefault('taxis', xf.xData);
 xdata{j} \= xf.derivationMethod(taxis, xf.xData, xf.yData); %\#ok
 end
 
 rate \= ratefun(xdata, taxis);
 if (nargout \< 2\)
 return;
 end
 existsAndDefault('nlarvae', 1\);
 existsAndDefault('nreps', 1\);
 
 dt \= diff(taxis); dt \= \[dt(1\) dt];
 meanturns \= nlarvae\*rate.\*dt;
% plot (taxis, meanturns); pause;
 for j \= 1:nreps
 nturns \= poissrnd(meanturns);
 nt \= nturns(nturns \> 0\);
 tt \= taxis(nturns \> 0\);
 ttime{j} \= \[]; %\#ok
 for k \= 1:max(nt)
 ttime{j} \= \[ttime{j} tt(nt \>\= k)];
 end
 ttime{j} \= sort(ttime{j}(:)); %\#ok
 
 end
 if (nreps \=\= 1\)
 ttime \= ttime{1};
 end
 rtime \= repmat(taxis, \[nlarvae 1]); rtime \= rtime(:);
 
 
 end
 
 problemDescription \= simulateVarSwitch (btd, opstruct, oldpd, timeField, trange, staticParams, temporalParams, nlarvae); 
 end
end



\-\-\-

\#\#\# File: analyzeVarianceSwitchingExperiment.m (ID: @BehaviorTriggeredData.7\)

function btdstruct \= analyzeVarianceSwitchingExperiment(btdstruct, opstruct)
%btdstruct \= analyzeVarianceSwitchingExperiment(btdstruct, opstruct)
%

if (nargin \< 1\)
 opstruct.stim(1\).gqname \= 'led1ValDiff';
 opstruct.stim(1\).iswn \= true;
 opstruct.stim(1\).ramptype \= 'square';
 opstruct.stim(1\).switch \= true;
 opstruct.stim(1\).period \= \[];
 opstruct.stim(2\).gqname \= 'led2ValDiff';
 opstruct.stim(2\).iswn \= true;
 opstruct.stim(2\).ramptype \= 'square';
 opstruct.stim(2\).switch \= false;
 opstruct.stim(2\).period \= \[];
 opstruct.timeRange \= \[\-Inf Inf];
 opstruct.redogq \= true;
 opstruct.kernelTime \= 7;
 opstruct.kernelDt \= 0\.1;
 opstruct.numTimeBins \= 120; %time bin size \= period/numTimeBins
 opstruct.redogq \= false;
 opstruct.numLxBins \= 20;
 opstruct.adaptationTime \= 10; %first T seconds to exclude from high/low cycles in analysis
 opstruct.Q\_alpha \= 0\.2;
 opstruct.pdegree \= 1;
 btdstruct \= opstruct;
 return;
end

if (nargin \< 2 \|\| \~isfield(btdstruct, 'btd'))
 error ('first argument must be a btdstruct and second argument contains options');
end
if (\~isfield(opstruct, 'pdegree'))
 opstruct.pdegree \= 1;
end

if (\~isfield(btdstruct, 'var') \|\| opstruct.redogq)
 btdstruct \= BehaviorTriggeredData.prepVarianceSwitchingAnalysis(btdstruct, opstruct);
else
 fn \= {'stim', 'numLxBins', 'adaptationTime', 'Q\_alpha', 'numTimeBins', 'timeRange'};
 for j \= 1:length(fn)
 btdstruct.varops.(fn{j}) \= opstruct.(fn{j});
 end
end
for j \= 1:length(opstruct.stim)
 inds(j) \= find(strcmpi(opstruct.stim(j).gqname, {btdstruct.var.gqname}));
end

btdstruct.var \= btdstruct.var(inds);
vi \= \[opstruct.stim.iswn];


if (any(vi))
 btdstruct \= measureRatesVsVar (btdstruct);

 %fit stretch factor vs. time
 pd \= BehaviorTriggeredData.createProblemStructForRateFunFitting (btdstruct.var(vi), 'eti', opstruct.pdegree, opstruct.timeRange);
 pd.Q\_alpha \= opstruct.Q\_alpha \* eye(nnz(vi));
 pd.maxreps \= 2;
 btdstruct.alphavseti \= fitRateFunWithTemporalScalingND(pd);

 %turn time estimate into time in cycle estimate
 \[btdstruct.alphavseti.alpha\_ton, btdstruct.alphavseti.valpha\_ton, btdstruct.alphavseti.tx\_ton] \= ...
 etiThetaToCycleTheta(btdstruct.alphavseti.alpha, btdstruct.alphavseti.valpha, btdstruct.alphavseti.tx, pd.tshift, pd.period);
 \[btdstruct.alphavseti.alpha\_s\_ton, btdstruct.alphavseti.valpha\_s\_ton] \= ...
 etiThetaToCycleTheta(btdstruct.alphavseti.alpha\_s, btdstruct.alphavseti.valpha\_s, btdstruct.alphavseti.tx, pd.tshift, pd.period);
 
 %directly calculate stretch factor vs cycle time
 
 pd \= BehaviorTriggeredData.createProblemStructForRateFunFitting (btdstruct.var(vi), 'ton', 1, opstruct.timeRange);
 
 if all(size(pd.alpha\_0\) \=\= size(btdstruct.alphavseti.alpha\_ton))
 pd.alpha\_0 \= btdstruct.alphavseti.alpha\_ton;
 end
 pd.params\_0 \= btdstruct.alphavseti.staticParams;
 pd.tparams\_0 \= btdstruct.alphavseti.temporalParams;
 
 pd.Q\_alpha \= opstruct.Q\_alpha \* eye(nnz(vi)) \* pd.period / diff(pd.timeRange);
 \[btdstruct.alphavston, scaledValues] \= fitRateFunWithTemporalScalingND(pd);
 btdstruct \= adaptedRatesVsVar (btdstruct, scaledValues, pd.period);
 
end
 
function btdstruct \= adaptedRatesVsVar (btdstruct, scaledValues, period)
opstruct \= btdstruct.varops;
tton \= scaledValues.turnT;
teti \= scaledValues.turnEti;
rton \= scaledValues.runT;
reti \= scaledValues.runEti;

tval \= scaledValues.tval;
rval \= scaledValues.rval;
deltaT \= scaledValues.deltaT;

tvalid \= teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
thigh \= tton \> opstruct.adaptationTime \& tton \< period/2 \& tvalid;
tlow \= tton \> period/2 \+ opstruct.adaptationTime \& tton \< period \& tvalid;
tup \= tton \> 0 \& tton \< opstruct.adaptationTime \& tvalid;
tdown \= tton \> period/2 \& tton \< period/2 \+ opstruct.adaptationTime \& tvalid;


rvalid \= reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
rhigh \= rton \> opstruct.adaptationTime \& rton \< period/2 \& rvalid;
rlow \= rton \> period/2 \+ opstruct.adaptationTime \& rton \< period \& rvalid;
rup \= rton \> 0 \& rton \< opstruct.adaptationTime \& rvalid;
rdown \= rton \> period/2 \& rton \< period/2 \+ opstruct.adaptationTime \& rvalid;

 

for j \= 1:size(rval, 2\)
 lx \= linspace(\-3\*std(rval(rvalid,j)), 3\*std(rval(rvalid,j)), opstruct.numLxBins);
 btdstruct.scaledRFHigh(j) \= turnRates(tval(thigh, j), rval(rhigh, j), deltaT, lx);
 btdstruct.scaledRFLow(j) \= turnRates(tval(tlow, j), rval(rlow, j), deltaT, lx);
 btdstruct.scaledRFUp(j) \= turnRates(tval(tup, j), rval(rup, j), deltaT, lx);
 btdstruct.scaledRFDown(j) \= turnRates(tval(tdown, j), rval(rdown, j), deltaT, lx);
end



function rf \= turnRates (xt, xr, deltaT, lx)

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

existsAndDefault('lx', linspace(\-3\*std(xr), 3\*std(xr), 20\));

nt \= histcounts(xt, binEdgesFromCenters(lx));
nr \= histcounts(xr, binEdgesFromCenters(lx));

rf.lx \= lx;
rf.rate \= 1/deltaT \* nt ./ nr;
rf.rate\_eb \= 1/deltaT \* sqrt(nt) ./ nr;

nlogp \= @(p) \-sum(polyval(p, xt)) \+ deltaT\*sum(exp(polyval(p,xr)));
p0 \= \[mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
rf.rateFitLin \= fminunc(nlogp, p0, op);
p0 \= \[0 rf.rateFitLin];
rf.rateFitQuad \= fminunc(nlogp, p0, op);


 

function btdstruct \= measureRatesVsVar (btdstruct)

opstruct \= btdstruct.varops;
vi \= find(\[opstruct.stim.iswn]);
if (isempty(vi))
 return;
end

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

for j \= vi
 deltaT \= median(diff(btdstruct.var(j).fullensemble.eti));
 
 ti \= btdstruct.var(j).turn.ton \> opstruct.adaptationTime \& btdstruct.var(j).turn.ton \< btdstruct.var(j).turn.toff \& ...
 btdstruct.var(j).turn.eti \>\= min(opstruct.timeRange) \& btdstruct.var(j).turn.eti \< max(opstruct.timeRange);
 ri \= btdstruct.var(j).noturn.ton \> opstruct.adaptationTime \& btdstruct.var(j).noturn.ton \< btdstruct.var(j).noturn.toff \& ...
 btdstruct.var(j).noturn.eti \>\= min(opstruct.timeRange) \& btdstruct.var(j).noturn.eti \< max(opstruct.timeRange);
 
 xt \= btdstruct.var(j).turn.x\_conv(ti);
 xr \= btdstruct.var(j).noturn.x\_conv(ri);
 
 
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 
 btdstruct.rfHighVar(j) \= turnRates (xt, xr, deltaT, lx);
 
 
 ti \= btdstruct.var(j).turn.toff \> opstruct.adaptationTime \& btdstruct.var(j).turn.toff \< btdstruct.var(j).turn.ton \& ...
 btdstruct.var(j).turn.eti \>\= min(opstruct.timeRange) \& btdstruct.var(j).turn.eti \< max(opstruct.timeRange);
 ri \= btdstruct.var(j).noturn.toff \> opstruct.adaptationTime \& btdstruct.var(j).noturn.toff \< btdstruct.var(j).noturn.ton \& ...
 btdstruct.var(j).noturn.eti \>\= min(opstruct.timeRange) \& btdstruct.var(j).noturn.eti \< max(opstruct.timeRange);
 
 xt \= btdstruct.var(j).turn.x\_conv(ti);
 xr \= btdstruct.var(j).noturn.x\_conv(ri);
 
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 
 
 btdstruct.rfLowVar(j) \= turnRates (xt, xr, deltaT, lx);
 
end
 



\-\-\-

\#\#\# File: simulateVarSwitch.m (ID: @BehaviorTriggeredData.8\)

function problemDescription \= simulateVarSwitch (btd, opstruct, oldpd, timeField, trange, staticParams, nlarvae)
% problemDescription \= simulateVarSwitch (btd, opstruct, timeField, polynomialDegree, trange, staticParams, temporalParams, nlarvae)
%

if (nargin \< 1\)
 opstruct.stim(1\).gqname \= 'led1ValDiff';
 opstruct.stim(1\).iswn \= true;
 opstruct.stim(1\).ramptype \= 'square';
 opstruct.stim(1\).switch \= true;
 opstruct.stim(1\).period \= \[];
 opstruct.taxis \= 60:.05:1200;
 opstruct.alphaLow \= 0\.7;
 opstruct.alphaHigh \= 1\.3;
 problemDescription \= opstruct;
 disp ('ramp types are square, triangle, sine, and constant');
 return;
end
fn \= {'ratefun', 'gradlogratefun', 'hesslogratefun', 'params\_0', 'temporalratemod'};
for j \= 1:length(fn)
 pd.(fn{j}) \= oldpd.(fn{j});
end
existsAndDefault('trange', oldpd.timeRange);

for j \= find(\~\[opstruct.stim.iswn] \& \[opstruct.stim.switch])
 disp (\['stim ' \- num2str(j) ' is not switching or noisy \- so I am ignoring it']);
end

varswitch \= \[opstruct.stim.iswn] \& \[opstruct.stim.switch];
switchstim \= 0;
switch (nnz(varswitch))
 case 0
 if (any(\[opstruct.stim.switch]))
 switchstim \= find(\[opstruct.stim.switch], 1, 'first');
 gq\_switch \= opstruct.stim(switchstim).gqname;
 end
 case 1
 switchstim \= find(varswitch);
 gq\_switch \= \[opstruct.stim(switchstim).gqname '\_var'];
 otherwise
 warning ('I don''t know how to handle multiple variances switching simultaneously');
 return;
end
if (strcmpi(opstruct.stim(switchstim).ramptype, 'square'))
 gqlow \= \[gq\_switch, '\_low'];
else
 gqlow \= \[sq\_switch, '\_rising'];
end

ndim \= nnz(\[opstruct.stim.iswn]);

if(switchstim\=\=0\)
 xnames \= cellfun(@(s) \[s 'TurnLin'], {opstruct.stim(\[opstruct.stim.iswn]).gqname}, 'UniformOutput', false);
else
 xnames \= cellfun(@(s) \[s 'TurnLin'], {opstruct.stim(\[opstruct.stim.switch]).gqname}, 'UniformOutput', false);
end

xnames \= \[xnames gqlow];

dt \= min(0\.05, median(diff(opstruct.taxis)));

pd.rateTx \= min(opstruct.taxis):dt:max(opstruct.taxis);

if(isfield(oldpd, 'alpha\_eti'))
 
 tx\_eti \= oldpd.tx\_eti;
 alpha\_eti \= oldpd.alpha\_eti;
 alpha\_eti \= interp1(tx\_eti, alpha\_eti, pd.rateTx);
 % ratefun \= @(xdata, tdata) pd.temporalratemod(temporalParams, tdata) .\* pd.ratefun(staticParams, alpha\_eti.\*xdata{1});
 ratefun \= @(xdata, tdata) pd.ratefun(staticParams, alpha\_eti.\*xdata{1});
else
 
 alphafun \= @(xd) opstruct.alphaHigh\*double(logical(xd)) \+ opstruct.alphaLow\*double(\~logical(xd));
 % ratefun \= @(xdata, tdata) pd.temporalratemod(temporalParams, tdata) .\* pd.ratefun(staticParams, alphafun(xdata{end}).\*xdata{1});
 ratefun \= @(xdata, tdata) pd.ratefun(staticParams, alphafun(xdata{end}).\*xdata{1});
end

for j \= 1:length(btd)
 \[sim(j).rate, sim(j).turnEti, sim(j).runEti] \= simulateTurnTrain (btd(j), xnames, ratefun, pd.rateTx , nlarvae, 1\);
 for k \= 1:(length(xnames) \- 1\)
 ind \= btd(j).findField(xnames{k});
 xv \= btd(j).glt(ind).derivationMethod(pd.rateTx, btd(j).glt(ind).xData, btd(j).glt(ind).yData);
 sim(j).turnX(:,k) \= interp1(pd.rateTx, xv, sim(j).turnEti);
 sim(j).runX(:,k) \= interp1(pd.rateTx, xv, sim(j).runEti);
 end
 if (strcmpi(timeField, 'eti'))
 sim(j).turnT \= sim(j).turnEti;
 sim(j).runT \= sim(j).runEti;
 else
 ind \= btd(j).findField(\[gq\_switch '\_' timeField]);
 tf \= btd(j).glt(ind).derivationMethod(pd.rateTx, btd(j).glt(ind).xData, btd(j).glt(ind).yData);
 sim(j).turnT \= interp1(pd.rateTx, tf, sim(j).turnEti);
 sim(j).runT \= interp1(pd.rateTx, tf, sim(j).runEti);
 end
 sim(j).turnExpnum \= j \* ones(size(sim(j).turnEti));
 sim(j).runExpnum \= j \* ones(size(sim(j).runEti));
end
pd.sim \= sim;

pd.turnT \= vertcat(sim.turnT);
pd.turnEti \= vertcat(sim.turnEti);
pd.turnX \= vertcat(sim.turnX);
pd.turnExpnum \= vertcat(sim.turnExpnum);

pd.runT \= vertcat(sim.runT);
pd.runEti \= vertcat(sim.runEti);
pd.runX \= vertcat(sim.runX);
pd.runExpnum \= vertcat(sim.runExpnum);

existsAndDefault('deltaT', median(diff(opstruct.taxis)));
pd.deltaT \= deltaT;

if (switchstim \> 0\) 
 period \= opstruct.stim(switchstim).period;
else
 period \= 0;
end
if (strcmpi(timeField, 'ton') \|\| strcmpi(timeField, 'toff'))
 pd.tx \= 0:pd.deltaT:period; 
 pd.pad \= true;
 if (\~exist('trange', 'var') \|\| isempty('trange'))
 minTime \= min(run(1\).eti(run(1\).ton \>\= 0 \& run(1\).toff \>\= 0\));
 trange \= minTime:period:max(run(1\).eti \+ pd.deltaT); trange \= trange(\[1 end]);
 end
 trange(1\) \= max(trange(1\),min(pd.runEti));
 trange(2\) \= min(trange(2\),max(pd.runEti));
else
 existsAndDefault('trange', \[min(opstruct.taxis) max(opstruct.taxis)]);
 trange(1\) \= max(trange(1\),min(pd.runEti));
 trange(2\) \= min(trange(2\),max(pd.runEti));
 pd.tx \= (trange(1\):pd.deltaT:trange(end))';
 pd.pad \= false;
end
existsAndDefault ('exprange', \[min(pd.runExpnum) max(pd.runExpnum)]);
pd.exprange \= exprange;

pd.timeRange \= trange;
pd.etx \= linspace(min(trange), max(trange), 100\);

ti \= pd.turnEti \>\= min(trange) \& pd.turnEti \< max(trange) \& pd.turnExpnum \>\= min(exprange) \& pd.turnExpnum \<\= max(exprange);
pd.turnT \= pd.turnT(ti);
pd.turnEti \= pd.turnEti(ti);
pd.turnX \= pd.turnX(ti,:);
pd.turnExpnum \= pd.turnExpnum(ti);

ri \= pd.runEti \>\= min(trange) \& pd.runEti \< max(trange) \& pd.runExpnum \>\= min(exprange) \& pd.runExpnum \<\= max(exprange);
pd.runT \= pd.runT(ri);
pd.runEti \= pd.runEti(ri);
pd.runX \= pd.runX(ri,:);
pd.runExpnum \= pd.runExpnum(ri);

pd.params\_0(end) \= log(length(pd.turnT)/(length(pd.runT)\*pd.deltaT));

pd.Q\_alpha \= 0\.2\*eye(ndim);
pd.Q\_s \= pd.Q\_alpha;

pd.tparams\_0 \= \[0 1000];
pd.alpha\_0 \= ones(length(pd.tx), ndim);
pd.sigma\_0 \= 10\*ones(length(pd.tx), ndim);
pd.v0 \= 1;
pd.w\_0 \= pd.Q\_alpha\*1000\*eye(ndim);
pd.maxreps \= 3;

pd.separateExperiments \= false;
pd.period \= period;
pd.tshift \= 0; %tshift is incorrect for now \-\- fix later
pd.temporalratemod \= \[];
problemDescription \= pd;

end

function hess \= twobytwohess (x, xdata)
hess \= zeros(size(xdata,1\), 2, 2\);
hess(:,1,1\) \= 2\*x(1\);
hess(:,1,2\) \= x(2\);
hess(:,2,1\) \= x(2\);
hess(:,2,2\) \= x(3\);
end


\-\-\-

\#\#\# File: loadBTDDirectory.m (ID: @BehaviorTriggeredData.9\)

function btdstruct \= loadBTDDirectory (basedir, varargin)
%function btdstruct \= loadBTDDirectory (basedir, varargin)


if (iscell(basedir))
 if (length(basedir) \=\= 1\)
 btdstruct \= BehaviorTriggeredData.loadBTDDirectory (basedir{1}, varargin);
 return;
 end
 for j \= 1:length(basedir)
 bs(j) \= BehaviorTriggeredData.loadBTDDirectory (basedir{j}, varargin{:});
 end
 btdstruct.srcdir \= {bs.srcdir};
 btdstruct.btd \= \[bs.btd];
 return;
end

fileList \= {};
varargin \= assignApplicable(varargin);

if (isempty(fileList))
 d \= dir(fullfile(basedir, 'btd\_\*.mat'));
 f \= {d(\~\[d.isdir]).name};
else
 f \= fileList;
 if \~iscell(f)
 f \= {f};
 end
end
for j \= 1:length(f)
 s \= load(fullfile(basedir, f{j}), 'btd');
 btd(j) \= s.btd; %\#ok
 valid(j) \= \~isempty(btd(j).glt); %\#ok
end
if (isempty(f))
 error (\['bad directory ' basedir]);
end
if (\~all(valid))
 inds \= find(\~valid);
 for j \= 1:length(inds)
 disp (\[f{inds(j)} ' had problems loading']);
 end
end


btd \= btd(valid);
btdstruct.srcdir \= basedir;
btdstruct.btd \= btd;





\-\-\-

\#\#\# File: summaryFigure.m (ID: @BehaviorTriggeredData.10\)

function ah \= summaryFigure (wnstruct, varargin)


fignum \= 1;
axeslabels \= true;
equizoom \= false;
scaleFactor \= 1; %change to peak intensity/255
shortSigmaTime \= 0;
longSigmaTime \= .5;
figtitle \= '';
varargin \= assignApplicable(varargin);
if (isempty(wnstruct.btd))
 ah \= \[];
 return;
end
\[adim, po] \= blank8x10Figure(fignum, 'nrows', 5, 'topmargin', 1/11, 'bottommargin', 0\.5/11\);

redcolor \= 'r';
bluecolor \= 'b';
magentacolor \= 'm';
cyancolor \= 'c';
blackcolor \= 'k';
tta\_tr \= \[\-10 5];
hsa\_tr \= \[\-5 5];
tsta\_tr \= \[\-20 5];
vktr \= \[0 20];

acchscolor \= \[0 183 178]/255;
rejhscolor \= \[200 0 50]/255;
lgturncolor \= \[255 163 0]/255;
smturncolor \= \[155 0 255]/255;


textaxespos \= \[adim.w5/2 adim.h0\+0\.2\*(1\-adim.h0\) 1\-adim.w5 (1\-adim.h0\)\*0\.8];
textaxes \= axes('Position', textaxespos, 'Box', 'Off', 'XLim', \[0 1], 'YLim', \[0 1], 'XTick', \[], 'YTick', \[]);
axis(textaxes, 'off');
if (isempty(figtitle))
 if (isfield(wnstruct, 'fname'))
 figtitle \= fileparts(wnstruct.fname{1});
 else
 figtitle \= fileparts(wnstruct.btd(1\).fname);
 end
end
figtitle(figtitle \=\= '\_') \= '\-';
if (isfield(wnstruct, 'es'))
 es \= wnstruct.es;
else
 es \= \[wnstruct.btd.es];
end
numan \= round(sum(\[es.numAnimals]));
numturn \= sum(\[es.numturns]);
numexp \= length(es);
antime \= sum(\[es.animalTime])/3600;
msg \= \[num2str(numexp), ' experiments; ' num2str(numan) ' larvae; ' num2str(numturn) ' turns; ' num2str(antime, 2\), ' hours of data'];

t1 \= text(0,0, msg, 'FontName', po.font, 'FontSize', po.bigfontsize\-2, 'HorizontalAlignment', 'left', 'VerticalAlignment', 'bottom', 'Parent', textaxes);
p \= get(t1, 'Extent');
t2 \= text(0,p(4\), figtitle, 'FontName', po.font, 'FontSize', po.bigfontsize, 'FontWeight', 'bold', 'HorizontalAlignment', 'left', 'VerticalAlignment', 'bottom', 'Parent', textaxes, 'Interpreter', 'None');



pos \= \[adim.lx3, adim.h0 \- adim.h, adim.w3, adim.h];
an \= 1;
ah(an).name \= \['tta'];
ah(an).pos \= pos;
ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});
yd \= scaleFactor\*wnstruct.turn\_start;
ydl \= lowpass1D(yd, longSigmaTime/median(diff(wnstruct.taxis)));
if (shortSigmaTime \> 0\)
 yd \= lowpass1D(yd, shortSigmaTime/median(diff(wnstruct.taxis)));
end

yd \= scaleFactor\*wnstruct.turn\_start;

sf \= sum(wnstruct.turn\_start(wnstruct.taxis \< 0 \& wnstruct.taxis \> \- wnstruct.kernelTime).^2\)/ sum(wnstruct.convkernels.^2\) \* length(wnstruct.convkernels) / nnz(wnstruct.taxis \< 0 \& wnstruct.taxis \> \- wnstruct.kernelTime);
sf \= scaleFactor\*sqrt(sf);

try
 yd\_f10 \= lowpass1D(scaleFactor\*wnstruct.firstten.turn\_start, longSigmaTime/median(diff(wnstruct.taxis)));
 yd\_s10 \= lowpass1D(scaleFactor\*wnstruct.secondten.turn\_start, longSigmaTime/median(diff(wnstruct.taxis)));
 ah(an).handles \= plot (wnstruct.taxis, yd, 'k\-', wnstruct.taxis,ydl, 'r\-', wnstruct.taxis,yd\_f10, 'g\-\-',wnstruct.taxis,yd\_s10, 'b\-\-',0:(\-wnstruct.kernelDt):(\-wnstruct.kernelTime), wnstruct.convkernels\*sf, 'm\-',po.plotOptions{:});
 % legend ('all', 'lp all', 'lp 0\-10', 'lp 10\-20');
catch me
 ah(an).handles \= plot (wnstruct.taxis, yd, 'k\-', wnstruct.taxis,ydl, 'r\-',0:(\-wnstruct.kernelDt):(\-wnstruct.kernelTime), wnstruct.convkernels\*sf, 'm\-', po.plotOptions{:});
end
xlim(tta\_tr);
xlabel ('time rel. to turn start (s)'); ylabel('');
hold on; plot(\[min(xlim) max(xlim)], \[0 0], 'k:', \[0 0], \[min(ylim) max(ylim)], 'k:');

%title ('turn triggered average');

an \= an\+1;
pos(1\) \= adim.cx3;
ah(an).name \= \['tsa'];
ah(an).pos \= pos;
ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});
ah(an).handles \= plot (wnstruct.taxis, scaleFactor\*lowpass1D(wnstruct.bigturn\_start\_onehs, longSigmaTime/median(diff(wnstruct.taxis))), 'k\-',wnstruct.taxis, scaleFactor\*lowpass1D(wnstruct.smallturn\_start\_onehs, longSigmaTime/median(diff(wnstruct.taxis))),'k\-', po.plotOptions{:});
set(ah(an).handles(1\), 'Color', lgturncolor);
set(ah(an).handles(2\), 'Color', smturncolor);
yl \= get(gca, 'YLim');
if (abs(yl(1\)) \> abs(yl(2\)))
 loc \= 'SouthWest';
else
 loc \= 'NorthWest';
end
set(legend('big', 'small', 'Location', loc), 'FontName', po.font, 'FontSize', po.fontsize);
xlim(tta\_tr);
xlabel ('time rel. to turn start (s)'); 
%title ('turn triggered average');

an \= an\+1;
pos(1\) \= adim.rx3;
ah(an).name \= 'hsa';
ah(an).pos \= pos;
ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});
if (shortSigmaTime \> 0\)
 yd1 \= lowpass1D(scaleFactor\*wnstruct.first\_acchs\_start, shortSigmaTime/median(diff(wnstruct.taxis)));
 yd2 \= lowpass1D(scaleFactor\*wnstruct.first\_rejhs\_start, shortSigmaTime/median(diff(wnstruct.taxis)));
else
 yd1 \= scaleFactor\*wnstruct.first\_acchs\_start;
 yd2 \= scaleFactor\*wnstruct.first\_rejhs\_start;
end
ah(an).handles \= plot (wnstruct.taxis, yd1, 'k\-',wnstruct.taxis, yd2,'k\-', po.plotOptions{:});
set(ah(an).handles(1\), 'Color', acchscolor);
set(ah(an).handles(2\), 'Color', rejhscolor);
hold on; plot(\[min(xlim) max(xlim)], \[0 0], 'k:', \[0 0], \[min(ylim) max(ylim)], 'k:');
xlabel('time (s) rel to h.s. start');
xlim(hsa\_tr);

an \= an\+1;
pos(1\) \= adim.lx3; pos(2\) \= pos(2\) \- adim.dh;
ah(an).name \= 'ens\_stat';
ah(an).pos \= pos;
ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});

% cv \= wnstruct.btd.behaviorTriggeredDataMatrix('all', '', wnstruct.linname, 0\);
% cvt \= wnstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', wnstruct.linname, 0\);
% hx \= linspace(\-3,3,30\);
% h1 \= histc(cv, binEdgesFromCenters(hx));
% h1 \= h1(1:end\-1\)/sum(h1\)/median(diff(hx));
% h2 \= histc(cvt, binEdgesFromCenters(hx));
% h2 \= h2(1:end\-1\)/sum(h2\)/median(diff(hx));
% 
% m1 \= mean(cv);
% s1 \= std(cv);
% 
% cvt \= (cvt\-m1\)/s1;
% dkl \= 0\.5\*(var(cvt) \- log(var(cvt)) \+ mean(cvt).^2 \- 1\);
hx \= wnstruct.hist\_x;
h1 \= wnstruct.hist\_all\_val;
h2 \= wnstruct.hist\_turn\_val;
h1 \= h1/sum(h1\)/median(diff(hx));
h2 \= h2/sum(h2\)/median(diff(hx));

dkl \= wnstruct.dkl\_est\_gauss;
ah(an).handles \= plot (hx, h1, hx, h2, po.plotOptions{:});
xlim(\[\-3 3]);
set(ah(an).axes, 'YTick', \[0 .25 .5]);
text(\-2\.9, .49, {'DKL \= ', num2str(dkl,3\)}, 'Parent', ah(an).axes, 'HorizontalAlignment', 'left', 'VerticalAlignment', 'top', 'fontName', po.font, 'fontSize', po.fontsize);
%0\.8\*max(get(ah(an).axes, 'YLim'))
an \= an\+1;
pos(1\) \= adim.cx3;
ah(an).name \= \['trvsconv'];
ah(an).pos \= pos;
ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});
ah(an).handles \= shadedErrorPlot (wnstruct.lx, 60\*wnstruct.tr\_vs\_conv, 60\*wnstruct.tr\_vs\_conv\_eb, 60\*wnstruct.tr\_vs\_conv\_eb);
hold on;
if (\~isfield(wnstruct, 'rate\_rog'))
 wnstruct.rate\_rog \= wnstruct.ratefun{1}(wnstruct.lx);
end
ah(an).handles \= \[ah(an).handles plot(wnstruct.lx, 60\*wnstruct.rate\_rog, 'r\-', po.plotOptions{:})];
% set(ah(an).axes, 'YColor', tacolor{m});
ylabel(ah(an).axes, 'turn rate (min\-1\)');
xlabel(ah(an).axes, 'conv. value');
 
 
acchsdelta \= wnstruct.meanChangeAfterAcceptedHeadsweep \- wnstruct.meanChangeAfterHeadsweep;
rejhsdelta \= wnstruct.meanChangeAfterRejectedHeadsweep \- wnstruct.meanChangeAfterHeadsweep;
 
acchsdelta\_eb \= sqrt(wnstruct.meanChangeAfterAcceptedHeadsweep\_eb.^2 \+ wnstruct.meanChangeAfterHeadsweep\_eb.^2\);
rejhsdelta\_eb \= sqrt(wnstruct.meanChangeAfterRejectedHeadsweep\_eb.^2 \+ wnstruct.meanChangeAfterHeadsweep\_eb.^2\);

bigturndelta \= wnstruct.meanChangeBeforeBigTurn \- wnstruct.meanChangeBeforeTurn;
smallturndelta \= wnstruct.meanChangeBeforeSmallTurn \- wnstruct.meanChangeBeforeTurn;

bigturndelta\_eb \= sqrt(wnstruct.meanChangeBeforeBigTurn\_eb.^2\+wnstruct.meanChangeBeforeTurn\_eb.^2\);
smallturndelta\_eb \= sqrt(wnstruct.meanChangeBeforeSmallTurn\_eb.^2\+wnstruct.meanChangeBeforeTurn\_eb.^2\);

%handles \= barweb(barvalues, errors, width, groupnames, bw\_title, bw\_xlabel, bw\_ylabel, bw\_colormap, gridstatus, bw\_legend, error\_sides, legend\_type)
 
an \= an\+1;
pos \= ah(an\-1\).pos; pos(1\) \= adim.rx3;
ah(an).pos \= pos;
ah(an).name \= 'changes for turn and hs';
ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});
bardat \= scaleFactor\*\[acchsdelta rejhsdelta ;smallturndelta bigturndelta];
ebdat \= scaleFactor\*\[acchsdelta\_eb rejhsdelta\_eb ;smallturndelta\_eb bigturndelta\_eb];
hh \= barweb\_marc(bardat, ebdat, \[] , {'HS', 'Turn Size'});
set(hh.bars(:,1\), 'FaceColor', redcolor, 'edgecolor', redcolor);
set(hh.bars(:,2\), 'FaceColor', 'w', 'edgecolor', redcolor);


if (isfield(wnstruct, 'ShannonInfo')) 
 an \= an\+1;
 pos(1\) \= adim.lx3; pos(2\) \= pos(2\) \- adim.dh; pos(3\) \= adim.w3;
 ah(an).name \= 'hs bit rate';
 ah(an).pos \= pos;
 ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});
 plot (ah(an).axes, wnstruct.ShannonInfo.allhs.tcent, wnstruct.ShannonInfo.allhs.bit\_rate, 'k'); 
 ah(an).axes(2\) \= axes('Position',get(ah(an).axes,'Position'),...
 'XAxisLocation','top',...
 'YAxisLocation','right',...
 'Color','none',...
 'XColor','b','YColor','b');
 plot (ah(an).axes(2\), wnstruct.ShannonInfo.allhs.tstart\_cum, wnstruct.ShannonInfo.allhs.cumbit); 
 set(ah(an).axes(2\), po.axesopts{:}, 'Color', 'none','XAxisLocation','top','YAxisLocation','right', 'XColor','b','YColor','b', 'XTickLabel', {}); 
 set(ah(an).axes, 'XLim', \[\-5 5]);
 xlabel(ah(an).axes(1\), 't(s) rel to hs');
 ylabel(ah(an).axes(1\), 'bits/s');
 %ylabel(ah(an).axes(2\), 'bits');

 an \= an\+1;
 pos(1\) \= adim.cx3\*.95 \+ adim.lx3\*0\.05; 
 ah(an).name \= 'turn bit rate';
 ah(an).pos \= pos;
 ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});
 plot (ah(an).axes, wnstruct.ShannonInfo.turnsize.tcent, wnstruct.ShannonInfo.turnsize.bit\_rate, 'k'); 
 ah(an).axes(2\) \= axes('Position',get(ah(an).axes,'Position'),...
 'XAxisLocation','top',...
 'YAxisLocation','right',...
 'Color','none',...
 'XColor','b','YColor','b');
 plot (ah(an).axes(2\), wnstruct.ShannonInfo.turnsize.tstart\_cum, wnstruct.ShannonInfo.turnsize.cumbit); 
 set(ah(an).axes(2\), po.axesopts{:}, 'Color', 'none','XAxisLocation','top','YAxisLocation','right', 'XColor','b','YColor','b', 'XTickLabel', {}); 
 set(ah(an).axes, 'XLim', \[\-30 15]);
 xlabel(ah(an).axes(1\), 't(s) rel to turn');
 %ylabel(ah(an).axes(1\), 'bits/s');
 ylabel(ah(an).axes(2\), 'bits');
 
 
 an \= an\+1;
 pos \= ah(an\-1\).pos; pos(1\) \= adim.rx3;
 ah(an).pos \= pos;
 ah(an).name \= 'changes for turn and hs';
 ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});
 ind1a \= find(wnstruct.ShannonInfo.allhs.tend\_cum \< 0, 1, 'last');
 ind1b \= find(wnstruct.ShannonInfo.allhs.tstart\_cum \>\= 0, 1, 'first');
 ind2a \= find(wnstruct.ShannonInfo.turnsize.tend\_cum \< 0, 1, 'last');
 ind2b \= find(wnstruct.ShannonInfo.turnsize.tstart\_cum \>\= 0, 1, 'first');
 
 %ind1 \= find(2\*wnstruct.ShannonInfo.allhs.tcent\-wnstruct.ShannonInfo.allhs.tstart \>\= 0, 1, 'first');
 %ind2 \= find(2\*wnstruct.ShannonInfo.turnsize.tcent\-wnstruct.ShannonInfo.turnsize.tstart \>\= 0, 1, 'first');
 bardat \= \[wnstruct.ShannonInfo.allhs.totalbits wnstruct.ShannonInfo.allhs.cumbit(ind1a) wnstruct.ShannonInfo.allhs.totalbits\-wnstruct.ShannonInfo.allhs.cumbit(ind1b);...
 wnstruct.ShannonInfo.turnsize.totalbits wnstruct.ShannonInfo.turnsize.cumbit(ind2a) wnstruct.ShannonInfo.turnsize.totalbits\-wnstruct.ShannonInfo.turnsize.cumbit(ind2b)];
 hh \= bar(bardat);
 set(hh(1\), 'FaceColor', redcolor, 'edgecolor', redcolor);
 set(hh(2\), 'FaceColor', 'w', 'edgecolor', redcolor);
 set(hh(3\), 'FaceColor', 'w', 'edgecolor', 'k');
 set(ah(an).axes, 'XTickLabel', {'HS', 'Turn Size'})
 % axis tight
 yl \= get(ah(an).axes, 'YLim');
 ylim(ah(an).axes, \[0 yl(2\)\*1\.1]);
else
 disp ('rerun analyzeBTDDirectory\_onesource to get information calculations');
end
 
an \= an\+1;
pos(1\) \= adim.lx4; pos(2\) \= pos(2\) \- adim.dh; pos(3\) \= adim.w4;
ah(an).name \= 'speed wiener';
ah(an).pos \= pos;
ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});

ah(an).handles \= plot (\-wnstruct.taxis, wnstruct.wiener.speed.k1\);
xlim(\[0 \-min(wnstruct.taxis)]);
set(ah(an).axes, 'XDir', 'reverse');
xlabel('tau (s)'); title ('k1 \- speed');

an \= an\+1;
pos(1\) \= adim.clx4; 
ah(an).name \= 'body bend wiener';
ah(an).pos \= pos;
ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});

ah(an).handles \= plot (\-wnstruct.taxis, wnstruct.wiener.absspineTheta.k1\);
xlim(\[0 \-min(wnstruct.taxis)]);
set(ah(an).axes, 'XDir', 'reverse');
xlabel('tau (s)'); title ('k1 \- body bend mag');

an \= an\+1;
pos(1\) \= adim.crx4; 
ah(an).name \= 'delta body bend wiener';
ah(an).pos \= pos;
ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});

ah(an).handles \= plot (\-wnstruct.taxis, wnstruct.wiener.dabsspineTheta.k1\);
xlim(\[0 \-min(wnstruct.taxis)]);
set(ah(an).axes, 'XDir', 'reverse');
xlabel('tau (s)'); title ('k1 \- delta body bend mag');

an \= an\+1;
pos(1\) \= adim.rx4; 
ah(an).name \= 'path dtheta wiener';
ah(an).pos \= pos;
ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});

ah(an).handles \= plot (\-wnstruct.taxis, wnstruct.wiener.absdeltatheta.k1\);
xlim(\[0 \-min(wnstruct.taxis)]);
set(ah(an).axes, 'XDir', 'reverse');
xlabel('tau (s)'); title ('k1 \- path dtheta');

if (isfield(wnstruct, 'fname'))
 names \= wnstruct.fname;
else
 names \= {wnstruct.btd.fname};
end
for j \= 1:length(names)
 \[\~,names{j}] \= fileparts(names{j});
 names{j} \= names{j}(end\-13:end);
end
 pos(1\) \= adim.lx4; pos(2\) \= pos(2\) \- adim.dh\*1\.05; pos(3\) \= adim.w4;
 xp \= \[adim.lx4 adim.clx4 adim.crx4 adim.rx4];
for j \= 1:4
 an \= an\+1;
 pos(1\) \= xp(j);
 ah(an).name \= 'tta by exp';
 ah(an).pos \= pos;
 ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});
 inds \= find(mod((1:length(wnstruct.exp)) \- j,4\) \=\= 0\);
 if (isempty(inds))
 continue;
 end
 ah(an).handles \= plot (wnstruct.taxis, lowpass1D(\[wnstruct.turn\_start; \[wnstruct.exp(inds).turn\_start]'], longSigmaTime/median(diff(wnstruct.taxis))));
 set(ah(an).handles(1\), 'color', 'k', 'linestyle', ':');
 
 title (names(inds), 'interpreter', 'none');
 axis tight;
 xlim(tta\_tr);
end
yl \= get(\[ah((an\-3\):an).axes], 'YLim');
set(\[ah((an\-3\):an).axes], 'YLim', \[min(\[yl{:}]) max(\[yl{:}])]);


% an \= an\+1;
% pos(1\) \= adim.rx4; 
% ah(an).name \= 'path curv wiener';
% ah(an).pos \= pos;
% ah(an).axes \= axes('position', ah(an).pos, po.axesopts{:});
% 
% ah(an).handles \= plot (\-wnstruct.taxis, wnstruct.wiener.abscurv.k1\);
% xlim(\[0 \-min(wnstruct.taxis)]);
% set(ah(an).axes, 'XDir', 'reverse');
% xlabel('tau (s)'); title ('k1 \- path curv');
% 

\-\-\-

\#\#\# File: prepVarianceSwitchingAnalysis\_Wolk.m (ID: @BehaviorTriggeredData.11\)

function btdstruct \= prepVarianceSwitchingAnalysis\_Wolk(btdstruct, opstruct)
%btdstruct \= prepVarianceSwitchingAnalysis(btdstruct, opstruct)
%

if (nargin \< 1\)
 opstruct.stim(1\).gqname \= 'led1ValDiff';
 opstruct.stim(1\).iswn \= true;
 opstruct.stim(1\).ramptype \= 'square';
 opstruct.stim(1\).switch \= true;
 opstruct.stim(1\).period \= \[];
 opstruct.stim(2\).gqname \= 'led2ValDiff';
 opstruct.stim(2\).iswn \= true;
 opstruct.stim(2\).ramptype \= 'square';
 opstruct.stim(2\).switch \= false;
 opstruct.stim(2\).period \= \[];
 opstruct.timeRange \= \[\-Inf Inf];
 opstruct.redogq \= true;
 opstruct.kernelTime \= 7;
 opstruct.kernelDt \= 0\.1;
 btdstruct \= opstruct;
 disp ('ramp types are square, triangle, sine, and constant');
 return;
end

if (nargin \< 2 \|\| \~isfield(btdstruct, 'btd'))
 warning ('first argument must be a btdstruct and second argument contains options');
 return;
end

for j \= find(\[opstruct.stim.iswn])
 
 if (opstruct.stim(j).switch \=\= 1\)
 if(strcmpi(opstruct.stim(j).gqname, 'led2m1ValDiff')) 
 if(strcmpi(opstruct.stim(1\).gqname, 'led1ValDiff'))
 stims{1} \= 'led1Val';
 stimdiffs{1} \= 'led1ValDiff';
 else
 stims{1} \= 'ledVal';
 stimdiffs{1} \= 'ledValDiff';
 end
 if(strcmpi(opstruct.stim(2\).gqname, 'led2ValDiff'))
 stims{2} \= 'led2Val';
 stimdiffs{2} \= 'led2ValDiff';
 else
 stims{2} \= 'ledVal';
 stimdiffs{2} \= 'ledValDiff';
 end
 OdorPlusLight \= @(yd) 1/sqrt(2\) \* (yd{1} \- yd{2});
 btdstruct.btd \= btdstruct.btd.addOperationFields({stims{2}, stims{1}}, 'led2m1Val', OdorPlusLight);
 btdstruct.btd \= btdstruct.btd.addOperationFields({stimdiffs{2}, stimdiffs{1}}, opstruct.stim(j).gqname, OdorPlusLight);
 end
 if (any(btdstruct.btd.findField(\[opstruct.stim(j).gqname '\_var\_ton']) \<\= 0\))
 btdstruct.btd \= btdstruct.btd.addVarianceGQs(opstruct.stim(j).gqname, opstruct.stim(j).ramptype, 'fixedPeriod', opstruct.stim(j).period);
 end
 end
 
end

for j \= 1:length(opstruct.stim)
 % if (opstruct.stim(j).iswn \&\& \~strcmpi(opstruct.stim(j).gqname, 'led2m1ValDiff') \&\& (opstruct.redogq \|\| any(btdstruct.btd.findField(\[opstruct.stim(j).gqname 'TurnLin']) \<\= 0\)))
 if ( \~strcmpi(opstruct.stim(j).gqname, 'led2m1ValDiff') \&\& (opstruct.redogq \|\| any(btdstruct.btd.findField(\[opstruct.stim(j).gqname 'TurnLin']) \<\= 0\)))
 btdstruct \= addScaledVarianceTurnLin (btdstruct, opstruct, j);
 end
end


for j \= find(\~\[opstruct.stim.iswn] \& \[opstruct.stim.switch])
 %if (opstruct.redogq \|\| any(btdstruct.btd.findField(\[opstruct.stim(j).gqname '\_ton']) \<\= 0\))
 btdstruct.btd \= btdstruct.btd.addTonToffGQs(opstruct.stim(j).gqname, opstruct.stim(j).ramptype, 'fixedPeriod', opstruct.stim(j).period);
 %end
end

for j \= find(\~\[opstruct.stim.iswn] \& \[opstruct.stim.switch])
 disp (\['stim ' \- num2str(j) ' is not switching or noisy \- so I am ignoring it']);
end

varswitch \= \[opstruct.stim.iswn] \& \[opstruct.stim.switch];
switchstim \= 0;
switch (nnz(varswitch))
 case 0
 if (any(\[opstruct.stim.switch]))
 switchstim \= find(\[opstruct.stim.switch], 1, 'first');
 gq\_switch \= opstruct.stim(switchstim).gqname;
 end
 case 1
% gq\_switch \= opstruct.stim(varswitch).gqname;
 switchstim \= find(varswitch);
% if (any(btdstruct.btd.findField(\[gq\_switch '\_ratePredROG\_var\_low']) \<\= 0\) \|\| any(btdstruct.btd.findField(\[gq\_switch '\_ratePredROG\_var\_low\_last'])\<\=0\) )
% btdstruct \= ratefunGQVariance(btdstruct, opstruct);
% end
 gq\_switch \= \[opstruct.stim(switchstim).gqname '\_var'];
 otherwise
 warning ('I don''t know how to handle multiple variances switching simultaneously');
 return;
end

opstruct.switchstim \= switchstim;
btdstruct.varops \= opstruct;

btdstruct \= gatherVarianceFields(btdstruct, opstruct);

end

function \[btdstruct, var] \= gatherVarianceFields (btdstruct, opstruct)

btd \= btdstruct.btd;

switchstim \= btdstruct.varops.switchstim;

aa \= \[btd.all]';
alleti \= \[aa.eti]';
tt \= \[btd.turn]';
turneti \= \[tt.start\_eti]';
isrun \= \[aa.isrun]';

acchs \= \[btd.acchs]';
rejhs \= \[btd.rejhs]';
acchseti \= \[acchs.start\_eti]';
rejhseti \= \[rejhs.start\_eti]';

accnhs \= \[acchs.hsnum]';
rejnhs \= \[rejhs.hsnum]';
firstacchs \= accnhs \=\= 1;
firstrejhs \= rejnhs \=\= 1;

if (switchstim \> 0\)
 if (btdstruct.varops.stim(switchstim).iswn)
 gqswitch \= \[btdstruct.varops.stim(switchstim).gqname '\_var'];
 else
 gqswitch \= btdstruct.varops.stim(switchstim).gqname;
 end
 
 
 if(strcmpi(btdstruct.varops.stim(switchstim).ramptype, 'square'))
 gq\_varh \= strcat(gqswitch, '\_high');
% gq\_varl \= strcat(gqswitch, '\_low');
 else
 gq\_varh \= strcat(gqswitch, '\_rising');
% gq\_varl \= strcat(gqswitch, '\_falling');
 end
 
 ii \= btd(1\).findField(gq\_varh);
 xd \= btd(1\).glt(ii).xData;
 yd \= double(btd(1\).glt(ii).yData);
 \[freq, phase] \= fitWave(xd, yd, 'square');
 period \= 2\*pi/freq;
 tshift \= phase/freq;
 
 gq\_ton \= \[gqswitch,'\_ton'];
 gq\_toff \= \[gqswitch,'\_toff'];
 
 firsths.name \= 'hsnum';
 firsths.validop \= @(x) x \=\= 1;

 all\_ton \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_ton, 0\);
 all\_toff \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_toff, 0\);
 turn\_ton \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_ton, 0\);
 turn\_toff \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_toff, 0\);
 acchs\_ton \= btd.behaviorTriggeredDataMatrix('acchs', 'start', gq\_ton, 0\);
 rejhs\_ton \= btd.behaviorTriggeredDataMatrix('rejhs', 'start', gq\_ton, 0\);
 acchs\_toff \= btd.behaviorTriggeredDataMatrix('acchs', 'start', gq\_toff, 0\);
 rejhs\_toff \= btd.behaviorTriggeredDataMatrix('rejhs', 'start', gq\_toff, 0\);
 
else
 all\_ton \= \[];
 all\_toff \= \[];
 turn\_ton \= \[];
 turn\_toff \= \[];
end

if (switchstim\>0 \&\& isempty(btdstruct.varops.stim(switchstim).period))
 btdstruct.varops.stim(switchstim).period \= max(max(all\_ton), max(all\_toff));
 period \= btdstruct.varops.stim(switchstim).period;
end
 

mintime \= min(alleti(all\_ton \> 0 \& all\_toff \> 0\));
if(\~isempty(mintime))
 btdstruct.varops.timeRange(1\) \= min(btdstruct.varops.timeRange(1\), mintime);
end
 
turnvalid \= turneti \>\= min(btdstruct.varops.timeRange) \& turneti \< max(btdstruct.varops.timeRange);
allvalid \= alleti \>\= min(btdstruct.varops.timeRange) \& alleti \< max(btdstruct.varops.timeRange);
acchsvalid \= acchseti \>\= min(btdstruct.varops.timeRange) \& acchseti \< max(btdstruct.varops.timeRange);
rejhsvalid \= rejhseti \>\= min(btdstruct.varops.timeRange) \& rejhseti \< max(btdstruct.varops.timeRange);


for whichStim \= 1:length(btdstruct.varops.stim)
 
 if strcmp(btdstruct.varops.stim(whichStim).gqname, 'led1ValDiff')
 gqname\_levels \= \['led1Val'];
 kname\_levels \= \[gqname\_levels 'TurnLin'];
 elseif strcmp(btdstruct.varops.stim(whichStim).gqname, 'led2ValDiff')
 gqname\_levels \= \['led2Val'];
 kname\_levels \= \[gqname\_levels 'TurnLin'];
 end
 
 
 if(strcmpi(btdstruct.varops.stim(whichStim).gqname, 'led2m1ValDiff'))
 continue
 end
 
 gq \= btdstruct.varops.stim(whichStim).gqname;
 gq\_conv \= strcat(gq, 'TurnLin');
 gq\_conv\_LK \= strcat(gq, 'TurnLin\_var\_low\_vals');
 gq\_conv\_HK \= strcat(gq, 'TurnLin\_var\_high\_vals');
 if(any(btdstruct.btd.findField(gq\_conv) \<\= 0\)) %for the case where gq is led1Val or led2Val
 \[turndata,\~,texpnum] \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq, 0\);
 \[alldata,\~,aexpnum] \= btd.behaviorTriggeredDataMatrix('all', 'start', gq, 0\);
 else
 \[turndata,\~,texpnum] \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_conv, 0\);
 \[alldata,\~,aexpnum] \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_conv, 0\);
 \[turndataLK,\~,texpnumLK] \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_conv\_LK, 0\);
 \[alldataLK,\~,aexpnumLK] \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_conv\_LK , 0\);
 \[turndataHK,\~,texpnumHK] \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_conv\_HK, 0\);
 \[alldataHK,\~,aexpnumHK] \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_conv\_HK, 0\);
 
 end
 if strcmp(btdstruct.varops.stim(whichStim).gqname, 'led1ValDiff') \|\| strcmp(btdstruct.varops.stim(whichStim).gqname, 'led2ValDiff')
 \[turndata\_lvl,\~,texpnum\_lvl] \= btd.behaviorTriggeredDataMatrix('turn', 'start', kname\_levels, 0\);
 \[alldata\_lvl,\~,aexpnum\_lvl] \= btd.behaviorTriggeredDataMatrix('all', 'start', kname\_levels, 0\);
 end
 
 if(isfield(opstruct, 'convkernel\_ber\_120'))
 \[turndata\_ber120,\~,texpnum\_ber120] \= btd.behaviorTriggeredDataMatrix('turn', 'start', 'led2ValDiffTurnLin\_ber120', 0\);
 \[alldata\_ber120,\~,aexpnum\_ber120] \= btd.behaviorTriggeredDataMatrix('all', 'start', 'led2ValDiffTurnLin\_ber120', 0\);
 
 var(whichStim).fullensemble.x\_conv\_ber120 \= alldata\_ber120(allvalid);
 var(whichStim).fullensemble.eti\_ber120 \= alleti (allvalid);
 var(whichStim).fullensemble.expnum\_ber120 \= aexpnum\_ber120 (allvalid); 
 
 var(whichStim).noturn.x\_conv\_ber120 \= alldata\_ber120(isrun \& allvalid);
 var(whichStim).noturn.eti\_ber120 \= alleti (isrun \& allvalid);
 var(whichStim).noturn.expnum\_ber120 \= aexpnum\_ber120 (isrun \& allvalid);
 
 var(whichStim).turn.x\_conv\_ber120 \= turndata\_ber120(turnvalid);
 var(whichStim).turn.eti\_ber120 \= turneti (turnvalid);
 var(whichStim).turn.expnum\_ber120 \= texpnum\_ber120 (turnvalid);
 end
 var(whichStim).gqname \= btdstruct.varops.stim(whichStim).gqname;
 
 var(whichStim).fullensemble.x\_conv \= alldata(allvalid);
 var(whichStim).fullensemble.x\_conv\_LK \= alldataLK(allvalid);
 var(whichStim).fullensemble.x\_conv\_HK \= alldataHK(allvalid);
 var(whichStim).fullensemble.eti \= alleti (allvalid);
 var(whichStim).fullensemble.expnum \= aexpnum (allvalid); 
 
 var(whichStim).noturn.x\_conv \= alldata(isrun \& allvalid);
 var(whichStim).noturn.x\_conv\_LK \= alldataLK(isrun \& allvalid);
 var(whichStim).noturn.x\_conv\_HK \= alldataHK(isrun \& allvalid);
 var(whichStim).noturn.eti \= alleti (isrun \& allvalid);
 var(whichStim).noturn.expnum \= aexpnum (isrun \& allvalid);
 
 var(whichStim).turn.x\_conv \= turndata(turnvalid);
 var(whichStim).turn.x\_conv\_LK \= turndataLK(turnvalid);
 var(whichStim).turn.x\_conv\_HK \= turndataHK(turnvalid);
 var(whichStim).turn.eti \= turneti (turnvalid);
 var(whichStim).turn.expnum \= texpnum (turnvalid);

 if strcmp(btdstruct.varops.stim(whichStim).gqname, 'led1ValDiff') \|\| strcmp(btdstruct.varops.stim(whichStim).gqname, 'led2ValDiff')
 var(whichStim).fullensemble.x\_conv\_lvl \= alldata\_lvl(allvalid);
 var(whichStim).fullensemble.eti\_lvl \= alleti (allvalid);
 var(whichStim).fullensemble.expnum\_lvl \= aexpnum\_lvl(allvalid); 
 
 var(whichStim).noturn.x\_conv\_lvl \= alldata\_lvl(isrun \& allvalid);
 var(whichStim).noturn.eti\_lvl \= alleti (isrun \& allvalid);
 var(whichStim).noturn.expnum\_lvl \= aexpnum\_lvl (isrun \& allvalid);
 
 var(whichStim).turn.x\_conv\_lvl \= turndata\_lvl(turnvalid);
 var(whichStim).turn.eti\_lvl \= turneti (turnvalid);
 var(whichStim).turn.expnum\_lvl \= texpnum\_lvl (turnvalid);
 end

 var(whichStim).acchs.eti \= acchseti(acchsvalid \& firstacchs);
 var(whichStim).rejhs.eti \= rejhseti(rejhsvalid \& firstrejhs);
 
 if(switchstim \> 0\)
 var(whichStim).fullensemble.ton \= all\_ton (allvalid);
 var(whichStim).fullensemble.toff \= all\_toff (allvalid);
 var(whichStim).noturn.ton \= all\_ton (isrun \& allvalid);
 var(whichStim).noturn.toff \= all\_toff (isrun \& allvalid);
 var(whichStim).turn.ton \= turn\_ton (turnvalid);
 var(whichStim).turn.toff \= turn\_toff (turnvalid);
 
 var(whichStim).acchs.ton \= acchs\_ton(acchsvalid \& firstacchs);
 var(whichStim).acchs.toff \= acchs\_toff(acchsvalid \& firstacchs);
 var(whichStim).rejhs.ton \= rejhs\_ton(rejhsvalid \& firstrejhs);
 var(whichStim).rejhs.toff \= rejhs\_toff(rejhsvalid \& firstrejhs);
 
 var(whichStim).period \= period;
 var(whichStim).tshift \= tshift;
 end
 
 btdstruct.var \= var;
end

if(switchstim\>0\)
 if(strcmpi(btdstruct.varops.stim(switchstim).gqname, 'led2m1ValDiff'))
 kname\_uv \= {'linU', 'linV'};
 
 stimnames \= {opstruct.stim(1\).gqname, opstruct.stim(2\).gqname};
 kname1 \= \[stimnames{1} 'TurnLin'];
 kname2 \= \[stimnames{2} 'TurnLin'];

 if(isfield(opstruct, 'thetaUV') \&\& \~isfield(opstruct.thetaUV, 'low') )
 
 theta\_all \= opstruct.thetaUV \* ones(size(all\_ton));
 theta\_turn \= opstruct.thetaUV \* ones(size(turn\_ton));
 
 elseif(isfield(btdstruct, 'theta\_all'))
 theta\_all \= btdstruct.theta\_all;
 elseif(isfield(opstruct, 'thetaUV') \&\& isfield(opstruct.thetaUV, 'low') )
 
 if(strcmpi(opstruct.stim(switchstim).ramptype, 'square'))
 theta\_all \= zeros(size(all\_ton));
 theta\_all(all\_ton(period/2\-opstruct.adaptationTime) \& all\_ton\<(period/2\+opstruct.adaptationTime)) \= opstruct.thetaUV.high;
 theta\_all(all\_toff\>(period/2\-opstruct.adaptationTime) \& all\_toff\<(period/2\+opstruct.adaptationTime)) \= opstruct.thetaUV.low;
 if(isfield(opstruct.thetaUV, 'up'))
 theta\_all(all\_ton\>opstruct.adaptationTime) \= opstruct.thetaUV.up;
 theta\_all(all\_toff\>opstruct.adaptationTime) \= opstruct.thetaUV.down;
 end
 theta\_all(theta\_all\=\=0\) \= pi/4;
 
 theta\_turn \= zeros(size(turn\_ton));
 theta\_turn(turn\_ton\>(period/2\-opstruct.adaptationTime) \& turn\_ton\<(period/2\+opstruct.adaptationTime)) \= opstruct.thetaUV.high;
 theta\_turn(turn\_toff\>(period/2\-opstruct.adaptationTime) \& turn\_toff\<(period/2\+opstruct.adaptationTime)) \= opstruct.thetaUV.low;
 if(isfield(opstruct.thetaUV, 'up'))
 theta\_turn(turn\_ton\>opstruct.adaptationTime) \= opstruct.thetaUV.up;
 theta\_turn(turn\_toff\>opstruct.adaptationTime) \= opstruct.thetaUV.down;
 end
 theta\_turn(theta\_turn\=\=0\) \= pi/4;
 end
 
 end
 
 alldata \= btd.behaviorTriggeredDataMatrix('all', 'start', {kname1, kname2}, 0\);
 turndata \= btd.behaviorTriggeredDataMatrix('turn', 'start', {kname1, kname2}, 0\);
 ad(:,1\) \= cos(theta\_all).\*alldata(:,1\) \+ sin(theta\_all).\*alldata(:,2\);
 td(:,1\) \= cos(theta\_turn).\*turndata(:,1\) \+ sin(theta\_turn).\*turndata(:,2\);
 ad(:,2\) \= cos(theta\_all).\*alldata(:,2\) \- sin(theta\_all).\*alldata(:,1\);
 td(:,2\) \= cos(theta\_turn).\*turndata(:,2\) \- sin(theta\_turn).\*turndata(:,1\);
 
 for whichStim\=1:2
 
% \[td,\~,texpnum] \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', kname\_uv{whichStim}, 0\);
% \[ad,\~,aexpnum] \= btdstruct.btd.behaviorTriggeredDataMatrix('all', 'start', kname\_uv{whichStim}, 0\);
 btdstruct.var\_uv(whichStim).gqname \= kname\_uv{whichStim};

 btdstruct.var\_uv(whichStim).fullensemble.theta \= theta\_all(allvalid);
 btdstruct.var\_uv(whichStim).fullensemble.x\_conv \= ad(allvalid, whichStim);
 btdstruct.var\_uv(whichStim).fullensemble.eti \= alleti (allvalid);
 btdstruct.var\_uv(whichStim).fullensemble.ton \= all\_ton (allvalid);
 btdstruct.var\_uv(whichStim).fullensemble.toff \= all\_toff (allvalid);
 btdstruct.var\_uv(whichStim).fullensemble.expnum \= aexpnum (allvalid);
 
 btdstruct.var\_uv(whichStim).noturn.theta \= theta\_all(isrun \& allvalid);
 btdstruct.var\_uv(whichStim).noturn.x\_conv \= ad(isrun \& allvalid, whichStim);
 btdstruct.var\_uv(whichStim).noturn.eti \= alleti (isrun \& allvalid);
 btdstruct.var\_uv(whichStim).noturn.ton \= all\_ton (isrun \& allvalid);
 btdstruct.var\_uv(whichStim).noturn.toff \= all\_toff (isrun \& allvalid);
 btdstruct.var\_uv(whichStim).noturn.expnum \= aexpnum (isrun \& allvalid);
 
 btdstruct.var\_uv(whichStim).turn.theta \= theta\_turn(turnvalid);
 btdstruct.var\_uv(whichStim).turn.x\_conv \= td(turnvalid, whichStim);
 btdstruct.var\_uv(whichStim).turn.eti \= turneti (turnvalid);
 btdstruct.var\_uv(whichStim).turn.ton \= turn\_ton (turnvalid);
 btdstruct.var\_uv(whichStim).turn.toff \= turn\_toff (turnvalid);
 btdstruct.var\_uv(whichStim).turn.expnum \= texpnum (turnvalid);
 btdstruct.var\_uv(whichStim).period \= period;
 btdstruct.var\_uv(whichStim).tshift \= tshift;
 
 end
 end
end

% for whichStim \= find(\[btdstruct.varops.stim.iswn])




end

function btdstruct \= addScaledVarianceTurnLin (btdstruct,opstruct,j)

switchstim \= find(\[opstruct.stim.switch], 1, 'first');
if(\~isempty(switchstim))
 switchname \= opstruct.stim(switchstim).gqname;
end
btd \= btdstruct.btd;
gqname \= opstruct.stim(j).gqname;
if(opstruct.stim(j).isstep)
 gqname \= \[gqname '\_nostep'];
end
kname \= \[gqname 'TurnLin'];
kname\_low \= \[gqname 'TurnLin\_var\_low\_vals'];
kname\_high \= \[gqname 'TurnLin\_var\_high\_vals'];

if strcmp(opstruct.stim(j).gqname, 'led1ValDiff')
 gqname\_levels \= \['led1Val'];
 kname\_levels \= \[gqname\_levels 'TurnLin'];
elseif strcmp(opstruct.stim(j).gqname, 'led2ValDiff')
 gqname\_levels \= \['led2Val'];
 kname\_levels \= \[gqname\_levels 'TurnLin'];
end



kernelTime \= opstruct.kernelTime;
kernelDt \= opstruct.kernelDt;
btdstruct.kernelTime \= kernelTime;
btdstruct.kernelDt \= kernelDt;

taxis \= \-(0:kernelDt:kernelTime);

% if( (nnz(\[opstruct.stim.iswn]) \=\= 1 \&\& opstruct.stim(j).switch \=\= 1 \&\& strcmpi(opstruct.stim(j).ramptype, 'square')) \|\| nnz(\[opstruct.stim.switch])\=\=0 \|\| (nnz(\[opstruct.stim.iswn]) \=\= 2 \&\& \~isfield(opstruct, 'convkernels')) )
if( (nnz(\[opstruct.stim.iswn]) \=\= 1 \&\& opstruct.stim(j).switch \=\= 1 \&\& strcmpi(opstruct.stim(j).ramptype, 'square')) \|\| (nnz(\[opstruct.stim.iswn]) \=\= 2 \&\& \~isfield(opstruct, 'convkernels')) )

 if(\~isempty(switchstim))
 stimTon \= btd.behaviorTriggeredDataMatrix ('all', '', \[switchname '\_var\_ton'],0\);
 stimToff \= btd.behaviorTriggeredDataMatrix ('all', '', \[switchname '\_var\_toff'],0\);
 turnTon \= btd.behaviorTriggeredDataMatrix ('turn', 'start', \[switchname '\_var\_ton'],0\);
 turnToff \= btd.behaviorTriggeredDataMatrix ('turn', 'start', \[switchname '\_var\_toff'],0\);
 
 islow \= turnToff \< turnTon \& turnToff \> 0;
 ishigh \= turnToff \> turnTon \& turnToff \> 0;
 islow\_all \= stimToff \< stimTon \& stimToff \> 0;
 ishigh\_all \= stimToff \> stimTon \& stimToff \> 0;
 end
 %using only one kernel
 
 btdstruct.linname{j} \= kname;
 \[convkernel, btd] \= btdstruct.btd.createBTAKernel('turn', 'start', gqname, kernelTime, kernelDt, 'newFieldName',kname, 'abbott', true);
 stimInput \= btd.behaviorTriggeredDataMatrix ('all', '', kname, 0\);
 turnInput \= btd.behaviorTriggeredDataMatrix('turn', 'start', gqname, taxis);
 
 if(opstruct.stim(j).switch)
 inds\_low \= islow\_all \& stimToff \> kernelTime; %guarantee only in low variance portion
 inds\_high \= ishigh\_all \& stimTon\>kernelTime;
 sl \= std(stimInput(inds\_low));
 sh \= std(stimInput(inds\_high));
 s \= sl;
 btdstruct.kernelScaling(j) \= s;
 else
 s \= std(stimInput) / opstruct.stim(j).var;
% s \= std(stimInput);
 end
 
 convkernel \= convkernel / s;
 
 
 % using light levels instead of derivatives
 if strcmp(opstruct.stim(j).gqname, 'led1ValDiff') \|\| strcmp(opstruct.stim(j).gqname, 'led2ValDiff')
 \[convkernel\_l, btd] \= btdstruct.btd.createBTAKernel('turn', 'start', gqname\_levels, kernelTime, kernelDt, 'newFieldName',kname\_levels,'abbott',true);
 %convkernel\_l \= btdstruct.btd.behaviorTriggeredAverage('turn','start', gqname\_levels , taxis);
 %ker\_mean\_shift \= mean(btdstruct.btd.behaviorTriggeredAverage('turn','start', gqname\_levels , 10:0\.1:15\));
 %ck \= convkernel\_l \- ker\_mean\_shift;
 %ck \= csaps(1:length(ck), ck, kernelDt, 1:length(ck));
 %convkernel\_l \= ck./sqrt(sum(ck.^2\));
 %btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname\_levels, kname\_levels, convkernel\_l, kernelDt, 'scaleToSqr', true);
 stimInput\_l \= btd.behaviorTriggeredDataMatrix ('all', '', kname\_levels, 0\);
 turnInput\_l \= btd.behaviorTriggeredDataMatrix('turn', 'start', gqname\_levels, taxis);
 
 if(opstruct.stim(j).switch)
 inds\_low \= islow\_all \& stimToff \> kernelTime; %guarantee only in low variance portion
 inds\_high \= ishigh\_all \& stimTon\>kernelTime;
 sl\_l \= std(stimInput\_l(inds\_low));
 sh\_l \= std(stimInput\_l(inds\_high));
 s\_l \= sl\_l;
 btdstruct.kernelScaling\_l(j) \= s\_l;
 else
 s\_l \= std(stimInput\_l) / opstruct.stim(j).var;
 end
 
 convkernel\_l \= convkernel\_l / s\_l;
 end
 
 % using high and low kernels
 
 aa \= \[btd.all];
 alleti \= \[aa.eti];
 tt \= \[btd.turn]';
 turneti \= \[tt.start\_eti]';
 
 % mintime \= min(alleti(stimTon \> 0 \& stimToff \> 0\));
 mintime \= min(opstruct.timeRange);
 turnvalid \= turneti \>\= mintime;
 allvalid \= alleti \>\= mintime;
 
 ishigh \= ishigh(turnvalid);
 islow \= islow(turnvalid);
 
 dm\_all \= turnInput(turnvalid, :);
 
 dm\_high \= dm\_all(ishigh, :);
 dm2 \= dm\_high; dm2(\~isfinite(dm2\)) \= 0;
 bta\_high \= sum(dm2\)./sum(isfinite(dm\_high));
 
 dm\_low \= dm\_all(islow, :);
 dm2 \= dm\_low; dm2(\~isfinite(dm2\)) \= 0;
 bta\_low \= sum(dm2\)./sum(isfinite(dm\_low));
 bta\_low \= bta\_low \* max(abs(bta\_high))/max(abs(bta\_low));
 
 abbottfun \= @(x,t) (x(3\)\*exp(\-x(2\)\*t)/(x(1\)\-x(2\)) \- x(5\)\*exp(\-x(4\)\*t)/(x(1\)\-x(4\)) \+ (x(3\)\*(x(4\)\-x(1\)) \- x(5\)\*(x(2\)\-x(1\)))\*exp(\-x(1\)\*t)/((x(1\)\-x(2\))\*(x(1\)\-x(4\)))) .\* (t \<\= 0\);
 
 \[\~,I] \= max(abs(bta\_low));
 mv \= bta\_low(I);
 x0 \= \[\-1\.5 \-1 mv \-0\.5 mv\*1\.5];
 op \= optimset('lsqcurvefit');
 op.MaxFunEvals \= 1E4;
 op.MaxIter \= 1e4;
 x \= lsqcurvefit(abbottfun, x0, taxis, bta\_low,\[],\[],op);
 convkernel\_low \= abbottfun(x,taxis);
 
 
 \[\~,I] \= max(abs(bta\_high));
 mv \= bta\_high(I);
 x0 \= \[\-1\.5 \-1 mv \-0\.5 mv\*1\.5];
 op \= optimset('lsqcurvefit');
 op.MaxFunEvals \= 1E5;
 op.MaxIter \= 1e4;
 x \= lsqcurvefit(abbottfun, x0, taxis, bta\_high,\[],\[],op);
 convkernel\_high \= abbottfun(x,taxis);
 
 convkernel\_low \= convkernel\_low \* max(abs(convkernel))/max(abs(convkernel\_low));
 convkernel\_high \= convkernel\_high \* max(abs(convkernel))/max(abs(convkernel\_high));
 
 btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, kname\_low, convkernel\_low, kernelDt, 'scaleToSqr', true);
 btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, kname\_high, convkernel\_high, kernelDt, 'scaleToSqr', true);
 
 btdstruct.convkernels\_low{j} \= convkernel\_low;
 btdstruct.convkernels\_high{j} \= convkernel\_high;
 
else

 convkernel \= opstruct.convkernels{j};

 
end

% include 'old' kernel (from berlin 120 brownian stim experiments) 
if(isfield(opstruct, 'convkernel\_ber\_120'))
 btdstruct.convkernel\_ber\_120{1} \= opstruct.convkernel\_ber\_120; 
 btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, 'led2ValDiffTurnLin\_ber120', btdstruct.convkernel\_ber\_120{1}, kernelDt, 'scaleToSqr', true); 
end

btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, kname, convkernel, kernelDt, 'scaleToSqr', true);

if strcmp(opstruct.stim(j).gqname, 'led1ValDiff') \|\| strcmp(opstruct.stim(j).gqname, 'led2ValDiff')
 btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname\_levels, kname\_levels, convkernel\_l, kernelDt);
 btdstruct.convkernels\_l{j} \= convkernel\_l;
end

btdstruct.convkernels{j} \= convkernel;


xgf03 \= normpdf(\-20:1:20,0,0\.3\);
xgf03 \= xgf03/sum(xgf03\); 
btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, 'led2ValDiff\_gf03', xgf03, kernelDt, 'symmetric', true);

xgf06 \= normpdf(\-20:1:20,0,0\.6\);
xgf06 \= xgf06/sum(xgf06\); 
btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, 'led2ValDiff\_gf06', xgf06, kernelDt,'symmetric', true);

xgf1 \= normpdf(\-20:1:20,0,1\);
xgf1 \= xgf1/sum(xgf1\); 
btdstruct.btd \= btdstruct.btd.addConvolvedFields(gqname, 'led2ValDiff\_gf1', xgf1, kernelDt, 'symmetric', true);



end




\-\-\-

\#\#\# File: prepVarianceSwitchingAnalysis.m (ID: @BehaviorTriggeredData.12\)

function btdstruct \= prepVarianceSwitchingAnalysis(btdstruct, opstruct)
%btdstruct \= prepVarianceSwitchingAnalysis(btdstruct, opstruct)
%

if (nargin \< 1\)
 opstruct.stim(1\).gqname \= 'led1ValDiff';
 opstruct.stim(1\).iswn \= true;
 opstruct.stim(1\).ramptype \= 'square';
 opstruct.stim(1\).switch \= true;
 opstruct.stim(1\).period \= \[];
 opstruct.stim(2\).gqname \= 'led2ValDiff';
 opstruct.stim(2\).iswn \= true;
 opstruct.stim(2\).ramptype \= 'square';
 opstruct.stim(2\).switch \= false;
 opstruct.stim(2\).period \= \[];
 opstruct.timeRange \= \[\-Inf Inf];
 opstruct.redogq \= true;
 opstruct.kernelTime \= 7;
 opstruct.kernelDt \= 0\.1;
 btdstruct \= opstruct;
 disp ('ramp types are square, triangle, sine, and constant');
 return;
end

if (nargin \< 2 \|\| \~isfield(btdstruct, 'btd'))
 warning ('first argument must be a btdstruct and second argument contains options');
 return;
end


for j \= find(\[opstruct.stim.iswn])
 if (opstruct.stim(j).switch \=\= 1\)
 btdstruct.btd \= btdstruct.btd.addVarianceGQs(opstruct.stim(j).gqname, opstruct.stim(j).ramptype, 'fixedPeriod', opstruct.stim(j).period);
 end
 % if (opstruct.redogq \|\| any(btdstruct.btd.findField(\[opstruct.stim(j).gqname '\_var\_ton']) \<\= 0\))
 %end
 
end

for j \= find(\~\[opstruct.stim.iswn] \& \[opstruct.stim.switch])
 %if (opstruct.redogq \|\| any(btdstruct.btd.findField(\[opstruct.stim(j).gqname '\_ton']) \<\= 0\))
 btdstruct.btd \= btdstruct.btd.addTonToffGQs(opstruct.stim(j).gqname, opstruct.stim(j).ramptype, 'fixedPeriod', opstruct.stim(j).period);
 %end
end

for j \= find(\~\[opstruct.stim.iswn] \& \[opstruct.stim.switch])
 disp (\['stim ' \- num2str(j) ' is not switching or noisy \- so I am ignoring it']);
end

varswitch \= \[opstruct.stim.iswn] \& \[opstruct.stim.switch];
switchstim \= 0;
switch (nnz(varswitch))
 case 0
 if (any(\[opstruct.stim.switch]))
 switchstim \= find(\[opstruct.stim.switch], 1, 'first');
 gq\_switch \= opstruct.stim(switchstim).gqname;
 end
 case 1
% gq\_switch \= opstruct.stim(varswitch).gqname;
 switchstim \= find(varswitch);
% if (any(btdstruct.btd.findField(\[gq\_switch '\_ratePredROG\_var\_low']) \<\= 0\) \|\| any(btdstruct.btd.findField(\[gq\_switch '\_ratePredROG\_var\_low\_last'])\<\=0\) )
% btdstruct \= ratefunGQVariance(btdstruct, opstruct);
% end
 gq\_switch \= \[opstruct.stim(switchstim).gqname '\_var'];
 otherwise
 warning ('I don''t know how to handle multiple variances switching simultaneously');
 return;
end
for j \= 1:length(opstruct.stim)
 btdstruct \= addScaledVarianceTurnLin (btdstruct, opstruct, j, gq\_switch);
end

opstruct.switchstim \= switchstim;
btdstruct.varops \= opstruct;

btdstruct \= gatherVarianceFields(btdstruct);

end

function btdstruct \= addScaledVarianceTurnLin (btdstruct,opstruct,j, gq\_switch)

gqname \= opstruct.stim(j).gqname;
kernelTime \= opstruct.kernelTime;
kernelDt \= opstruct.kernelDt;

kname \= \[gqname 'TurnLin'];
btdstruct.linname{j} \= kname;
btdstruct.kernelTime \= kernelTime;
btdstruct.kernelDt \= kernelDt;


\[convkernel, btd] \= btdstruct.btd.createBTAKernel('turn', 'start', gqname, kernelTime, kernelDt, 'newFieldName',kname, 'abbott', true);
stimInput \= btd.behaviorTriggeredDataMatrix ('all', '', kname, 0\);

existsAndDefault (gq\_switch, \[]);
if (isempty(gq\_switch) \&\& opstruct.stim(j).switch)
 if (opstruct.stim(j).iswn)
 gq\_switch \= \[opstruct.stim(j) '\_var'];
 else
 gq\_switch \= opstruct.stim(j);
 end
end
if (\~isempty(gq\_switch))
 stimTon \= btd.behaviorTriggeredDataMatrix ('all', '', \[gq\_switch '\_ton'],0\);
 stimToff \= btd.behaviorTriggeredDataMatrix ('all', '', \[gq\_switch '\_toff'],0\);
 
 islow \= stimToff \< stimTon \& stimToff \> 0;
 inds \= islow \& stimToff \> kernelTime; %guarantee only in low variance portion
 slow \= std(stimInput(inds));
 ishigh \= stimTon \< stimToff \& stimTon \> 0;
 inds \= ishigh \& stimTon \> kernelTime; %guarantee only in high variance portion
 shigh \= std(stimInput(inds));
 s \= min(slow, shigh);
 
else
 s \= std(stimInput); %choose the lower variance epoch
end

convkernel \= convkernel / s;
btdstruct.btd \= btd.addConvolvedFields(gqname, kname, convkernel, kernelDt, 'scaleToSqr', true);
btdstruct.convkernels{j} \= convkernel;

end

function btdstruct \= gatherVarianceFields (btdstruct)

btd \= btdstruct.btd;

switchstim \= btdstruct.varops.switchstim;

aa \= \[btd.all]';
alleti \= \[aa.eti]';
tt \= \[btd.turn]';
turneti \= \[tt.start\_eti]';
isrun \= \[aa.isrun]';


if (switchstim \> 0\)
 if (btdstruct.varops.stim(switchstim).iswn)
 gqswitch \= \[btdstruct.varops.stim(switchstim).gqname '\_var'];
 else
 gqswitch \= btdstruct.varops.stim(switchstim).gqname;
 end
 
 
 if(strcmpi(btdstruct.varops.stim(switchstim).ramptype, 'square'))
 gq\_varh \= strcat(gqswitch, '\_high');
% gq\_varl \= strcat(gqswitch, '\_low');
 else
 gq\_varh \= strcat(gqswitch, '\_rising');
% gq\_varl \= strcat(gqswitch, '\_falling');
 end
 
 ii \= btd(1\).findField(gq\_varh);
 xd \= btd(1\).glt(ii).xData;
 yd \= double(btd(1\).glt(ii).yData);
 \[freq, phase] \= fitWave(xd, yd, 'square');
 period \= 2\*pi/freq;
 tshift \= phase/freq;
 
 gq\_ton \= \[gqswitch,'\_ton'];
 gq\_toff \= \[gqswitch,'\_toff'];
 
 all\_ton \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_ton, 0\);
 all\_toff \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_toff, 0\);
 turn\_ton \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_ton, 0\);
 turn\_toff \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_toff, 0\);
else
 all\_ton \= \[];
 all\_toff \= \[];
 turn\_ton \= \[];
 turn\_toff \= \[];
end
%
% if (isempty(btdstruct.varops.stim(switchstim).period))
% btdstruct.varops.stim(switchstim).period \= max(max(all\_ton), max(all\_toff));
% end
% period \= btdstruct.varops.stim(switchstim).period;
mintime \= min(alleti(all\_ton \> 0 \& all\_toff \> 0\));
btdstruct.varops.timeRange(1\) \= max(btdstruct.varops.timeRange(1\), mintime);
turnvalid \= turneti \>\= min(btdstruct.varops.timeRange) \& turneti \< max(btdstruct.varops.timeRange);
allvalid \= alleti \>\= min(btdstruct.varops.timeRange) \& alleti \< max(btdstruct.varops.timeRange);

for whichStim \= find(\[btdstruct.varops.stim.iswn])
 
 
 gq \= btdstruct.varops.stim(whichStim).gqname;
 gq\_conv \= strcat(gq, 'TurnLin');
 \[turndata,\~,texpnum] \= btd.behaviorTriggeredDataMatrix('turn', 'start', gq\_conv, 0\);
 \[alldata,\~,aexpnum] \= btd.behaviorTriggeredDataMatrix('all', 'start', gq\_conv, 0\);
 btdstruct.var(whichStim).gqname \= btdstruct.varops.stim(whichStim).gqname;
 btdstruct.var(whichStim).fullensemble.x\_conv \= alldata(allvalid);
 btdstruct.var(whichStim).fullensemble.eti \= alleti (allvalid);
 btdstruct.var(whichStim).fullensemble.ton \= all\_ton (allvalid);
 btdstruct.var(whichStim).fullensemble.toff \= all\_toff (allvalid);
 btdstruct.var(whichStim).fullensemble.expnum \= aexpnum (allvalid);
 
 btdstruct.var(whichStim).noturn.x\_conv \= alldata(isrun \& allvalid);
 btdstruct.var(whichStim).noturn.eti \= alleti (isrun \& allvalid);
 btdstruct.var(whichStim).noturn.ton \= all\_ton (isrun \& allvalid);
 btdstruct.var(whichStim).noturn.toff \= all\_toff (isrun \& allvalid);
 btdstruct.var(whichStim).noturn.expnum \= aexpnum (isrun \& allvalid);
 
 btdstruct.var(whichStim).turn.x\_conv \= turndata(turnvalid);
 btdstruct.var(whichStim).turn.eti \= turneti (turnvalid);
 btdstruct.var(whichStim).turn.ton \= turn\_ton (turnvalid);
 btdstruct.var(whichStim).turn.toff \= turn\_toff (turnvalid);
 btdstruct.var(whichStim).turn.expnum \= texpnum (turnvalid);
 btdstruct.var(whichStim).period \= period;
 btdstruct.var(whichStim).tshift \= tshift;
end



end





\-\-\-

\#\#\# File: analyzeBTDDirectory\_onesource.m (ID: @BehaviorTriggeredData.13\)

function btdstruct \= analyzeBTDDirectory\_onesource (btdstruct, gqname, varargin)
%function btdstruct \= analyzeBTDDirectory\_onesource (btdstruct, gqname, varargin)


taxis \= \-30:0\.1:10;
kernelTime \= 7; %s
kernelDt \= 0\.1;
turnSizeRange \= \[\-15 \-3];
headSweepAcceptRange \= \[0 1\.25];
compensatorName \= '';
valName \= 'led1Val';
%deltaTPower \= 1; %derivatives
varargin \= assignApplicable(varargin);



if (\~isstruct(btdstruct))
 if (ischar(btdstruct) \|\| (iscell(btdstruct) \&\& all(cellfun(@ischar, btdstruct))))
 btdstruct \= BehaviorTriggeredData.loadBTDDirectory(btdstruct);
 else
 error ('first argument must be btdstruct or basedir');
 end
end
btd \= btdstruct.btd;
if (isempty(btd))
 return;
end

if (\~existsAndDefault('gqname', 'led1ValDiff')) 
 if (isfield(btdstruct, 'gqname'))
 gqname \= btdstruct.gqname;
 end
end
%existsAndDefault('compensatorName', '');

btdstruct.kernelTime \= kernelTime;
btdstruct.kernelDt \= kernelDt;
btdstruct.taxis \= taxis;
btdstruct.turnSizeRange \= turnSizeRange;
btdstruct.headSweepAcceptRange \= headSweepAcceptRange;
btdstruct.gqname \= gqname;
hs \= \[btd.hs];
hsd \= \[hs.end\_eti] \- \[hs.start\_eti];
hsa \= logical(\[hs.accepted]);
btdstruct.hsdur.mean \= mean(hsd);
btdstruct.hsdur.median \= median(hsd);
btdstruct.hsdur.sigma \= std(hsd);

btdstruct.hsdur.mean\_acc \= mean(hsd(hsa));
btdstruct.hsdur.median\_acc \= median(hsd(hsa));
btdstruct.hsdur.sigma\_acc \= std(hsd(hsa));

btdstruct.hsdur.mean\_rej \= mean(hsd(\~hsa));
btdstruct.hsdur.median\_rej \= median(hsd(\~hsa));
btdstruct.hsdur.sigma\_rej \= std(hsd(\~hsa));


for j \= 1:length(btd)
 btd(j).all.absdeltatheta \= abs(btd(j).all.deltatheta);
 tn \= btd(j).all.tnum;
 btd(j).all.absdeltatheta \= abs(btd(j).all.deltatheta);
 btd(j).all.dabsdeltatheta \= zeros(size(btd(j).all.absdeltatheta));
 for k \= 1:max(tn)
 btd(j).all.dabsdeltatheta(tn \=\= k) \= \[0 diff(btd(j).all.absdeltatheta(tn \=\= k))];
 end
 btd(j).all.absspineTheta \= abs(btd(j).all.spineTheta);
 btd(j).all.dabsspineTheta \= zeros(size(btd(j).all.absspineTheta));
 for k \= 1:max(tn)
 btd(j).all.dabsspineTheta(tn \=\= k) \= \[0 diff(btd(j).all.absspineTheta(tn \=\= k))];
 end
 btd(j).all.abscurv \= abs(btd(j).all.curv);
 pct \= percentile(btd(j).all.abscurv, 0\.95\);
 btd(j).all.abscurv \= min(btd(j).all.abscurv, pct);
end

fields \= {'speed', 'absdeltatheta','dabsdeltatheta', 'abscurv', 'absspineTheta','dabsspineTheta'};
for j \= 1:length(fields)
 \[k0,k1] \= btd.wienerKernels(gqname, fields{j}, \-taxis);
 btdstruct.wiener.(fields{j}).k0 \= k0;
 btdstruct.wiener.(fields{j}).k1 \= k1;
end


fields \= {'turn', 'pause', 'acchs', 'rejhs'};% 'acchs', 'rejhs','acchs', 'rejhs'};
pos \= {'start', 'start', 'start', 'start'};% 'atmax', 'atmax', 'end', 'end'};

for j \= 1:length(fields)
 \[bta, \~, eb] \= btd.behaviorTriggeredAverage(fields{j}, pos{j}, gqname, taxis);
 btdstruct.(\[fields{j} '\_' pos{j}]) \= bta;
 btdstruct.(\[fields{j} '\_' pos{j} '\_eb']) \= eb;
 if (\~isempty(compensatorName))
 btdstruct.(\[fields{j} '\_' pos{j} '\_compensator']) \= btd.behaviorTriggeredAverageCompensator(fields{j}, pos{j}, gqname, compensatorName, taxis);
 end
 try
 \[bta, \~, eb] \= btd.behaviorTriggeredAverage(fields{j}, pos{j}, valName, taxis);
 btdstruct.val.(\[fields{j} '\_' pos{j}]) \= bta;
 btdstruct.val.(\[fields{j} '\_' pos{j} '\_eb']) \= eb;
 catch me %\#ok
 end
 
end

fields \= {'turn'};% 'acchs', 'rejhs','acchs', 'rejhs'};
pos \= {'start'};% 'atmax', 'atmax', 'end', 'end'};

for k \= 1:length(btd)
 
 for j \= 1:length(fields)
 btdstruct.exp(k).(\[fields{j} '\_' pos{j}]) \= btd(k).behaviorTriggeredAverage(fields{j}, pos{j}, gqname, taxis)';
 end
end


kname \= \[gqname 'TurnLin'];
btdstruct.linname \= kname;

inrun.name \= 'isrun';
inrun.validop \= @(x) logical(x);

\[btdstruct.convkernels, btd] \= btd.createBTAKernel('turn', 'start', gqname, kernelTime, kernelDt, 'newFieldName',kname, 'abbott', true);
s \= std(btd.behaviorTriggeredDataMatrix ('all', 'start', kname, 0\));
% btdstruct.convkernels \= btdstruct.convkernels / s;
btd \= btd.addConvolvedFields(gqname, kname, btdstruct.convkernels, kernelDt, 'scaleToSqr', true);

\[btdstruct.tr\_vs\_conv, btdstruct.tr\_vs\_conv\_eb, btdstruct.lx] \= rateVsField(btd, 'turn', 'start', kname);
for k \= 1:length(btd)
 \[tr\_vs\_conv, tr\_vs\_conv\_eb, lx] \= rateVsField(btd(k), 'turn', 'start', kname);
 btdstruct.exp(k).tr\_vs\_conv \= tr\_vs\_conv';
 btdstruct.exp(k).tr\_vs\_conv\_eb \= tr\_vs\_conv\_eb';
 btdstruct.exp(k).lx \= lx';
end



firstten.name \= 'start\_eti';
firstten.validop \= @(x) x \< 600;
secondten \= firstten;
secondten.validop \= @(x) (x \>\= 600 \& x \< 1200\);

fields \= {'turn', 'acchs', 'rejhs'};% 'acchs', 'rejhs','acchs', 'rejhs'};
pos \= {'start', 'start', 'start'};% 'atmax', 'atmax', 'end', 'end'};

for j \= 1:length(fields)
 \[bta, \~, eb] \= btd.behaviorTriggeredAverage(fields{j}, pos{j}, gqname, taxis, 'conditions', firstten);
 btdstruct.firstten.(\[fields{j} '\_' pos{j}]) \= bta;
 btdstruct.firstten.(\[fields{j} '\_' pos{j} '\_eb']) \= eb;
 \[bta, \~, eb] \= btd.behaviorTriggeredAverage(fields{j}, pos{j}, gqname, taxis, 'conditions', secondten);
 btdstruct.secondten.(\[fields{j} '\_' pos{j}]) \= bta;
 btdstruct.secondten.(\[fields{j} '\_' pos{j} '\_eb']) \= eb;
 
end


fieldlist \= {kname};
ratenames \= {\[gqname '\_ratePredROG']};
turndata \= btd.behaviorTriggeredDataMatrix('turn', 'start', fieldlist, 0\);
alldata \= btd.behaviorTriggeredDataMatrix('all', 'start', fieldlist, 0, 'conditions', inrun);

tt \= \[btd.turn];
turneti \= \[tt.start\_eti];
aa \= \[btd.all];
alleti \= \[aa.eti]; alleti \= alleti(logical(\[aa.isrun]));

dt \= median(diff(btd(1\).all.eti)); %assuming all movies were captured at same frame rate!


xx \= binEdgesFromCenters(btdstruct.lx);
for j \= 1:length(fieldlist)
 yy \= turndata(turneti \< 600, j);
 aa \= alldata(alleti \< 600, j);
 h1 \= histc(yy,xx);
 h2 \= histc(aa,xx);
 rr \= 1/dt\*h1(1:(end\-1\))./h2(1:(end\-1\));
 reb \= 1/dt\*sqrt(h1(1:(end\-1\)))./h2(1:(end\-1\));
 btdstruct.firstten.tr\_vs\_conv(j,:) \= rr';
 btdstruct.firstten.tr\_vs\_conv\_eb(j,:) \= reb';
 
end
for j \= 1:length(fieldlist)
 yy \= turndata(turneti \>\= 600 \& turneti \< 1200, j);
 aa \= alldata(alleti \>\= 600 \& alleti \< 1200, j);
 h1 \= histc(yy,xx);
 h2 \= histc(aa,xx);
 rr \= 1/dt\*h1(1:(end\-1\))./h2(1:(end\-1\));
 reb \= 1/dt\*sqrt(h1(1:(end\-1\)))./h2(1:(end\-1\));
 btdstruct.secondten.tr\_vs\_conv(j,:) \= rr';
 btdstruct.secondten.tr\_vs\_conv\_eb(j,:) \= reb';
end


btdstruct.firstten.nr \= nnz(turneti \< 600\);
btdstruct.firstten.na \= nnz(alleti\<600\);
btdstruct.firstten.mu \= mean(turndata(turneti \< 600,:));
btdstruct.firstten.mu\_a \= mean(alldata(alleti \< 600,:));
btdstruct.firstten.s \= std(turndata(turneti \< 600,:));
btdstruct.firstten.s\_a \= std(alldata(alleti \< 600,:));

btdstruct.secondten.nr \= nnz(turneti \>\= 600 \& turneti \< 1200\);
btdstruct.secondten.na \= nnz(alleti \>\= 600 \& alleti \< 1200\);
btdstruct.secondten.mu \= mean(turndata(turneti \>\= 600 \& turneti \< 1200,:));
btdstruct.secondten.mu\_a \= mean(alldata(alleti \>\= 600 \& alleti \< 1200,:));
btdstruct.secondten.s \= std(turndata(turneti \>\= 600 \& turneti \< 1200,:));
btdstruct.secondten.s\_a \= std(alldata(alleti \>\= 600 \& alleti \< 1200,:));


nr \= size(turndata, 1\);
na \= size(alldata,1\);
mu \= mean(turndata);
mu\_a \= mean(alldata);
s \= std(turndata);
s\_a \= std(alldata);

for j \= 1:size(turndata, 2\)
 
 ratefun \= @(ydata) nr/(na\*dt)\*normpdf(ydata,mu(j),s(j))./normpdf(ydata, 1\.0\*mu\_a(j), s\_a(j));
 btdstruct.ratefun{j} \= ratefun;
 btd \= btd.addOperationFields(fieldlist{j}, ratenames{j}, ratefun);
 
 %{
 ratefun0 \= @(x, xdata) x(1\) \* normpdf(xdata, x(2\), x(3\)) ./ normpdf(xdata, 0, x(4\)); 
 initguess0 \= \[nr/(na\*dt) mu(j) s(j) s\_a(j)];
 fitfun0 \= @(x) \-sum(log(max(ratefun0(x,turndata(:,j)),1E\-100\))) \+ sum(max(0,ratefun0(x,alldata(:,j))));
 
 op \= optimset('fmincon');
 op.Algorithm \= 'active\-set';
 %op.LargeScale \= 'off';
 problem.objective \= fitfun0;
 problem.solver \= 'fmincon';
 problem.x0 \= initguess0;
 problem.lb \= \[0 \-Inf 0 0];
 problem.ub \= \[Inf Inf Inf Inf];
 problem.options \= op;
 fitParams0 \= fmincon(problem);
 
 ratefun \= @(ydata) ratefun0(fitParams0, ydata);
 btd \= btd.addOperationFields(fieldlist{j}, \[ratenames{j} '\_fit'], ratefun);
 %}

 
 
 ratefun \= @(ydata) btdstruct.firstten.nr/(btdstruct.firstten.na\*dt)\*normpdf(ydata,btdstruct.firstten.mu(j),btdstruct.firstten.s(j))...
 ./normpdf(ydata, 1\.0\*btdstruct.firstten.mu\_a(j), btdstruct.firstten.s\_a(j));
 btdstruct.firstten.ratefun{j} \= ratefun;
 btd \= btd.addOperationFields(fieldlist{j}, \[ratenames{j} '\_firstten'], ratefun);
 
 ratefun \= @(ydata) btdstruct.secondten.nr/(btdstruct.secondten.na\*dt)\*normpdf(ydata,btdstruct.secondten.mu(j),btdstruct.secondten.s(j))...
 ./normpdf(ydata, 1\.0\*btdstruct.secondten.mu\_a(j), btdstruct.secondten.s\_a(j));
 btdstruct.secondten.ratefun{j} \= ratefun;
 btd \= btd.addOperationFields(fieldlist{j}, \[ratenames{j} '\_secondten'], ratefun);
end

btdstruct.rate\_rog \= btdstruct.ratefun{1}(btdstruct.lx);
btdstruct.firstten.rate\_rog \= btdstruct.firstten.ratefun{1}(btdstruct.lx);
btdstruct.secondten.rate\_rog \= btdstruct.secondten.ratefun{1}(btdstruct.lx);


ratenames\_firstten \= cellfun(@(s) \[s '\_firstten'], ratenames, 'UniformOutput', false);
ratenames\_secondten \= cellfun(@(s) \[s '\_secondten'], ratenames, 'UniformOutput', false);
btdstruct.predratefields \= \[ratenames ratenames\_firstten ratenames\_secondten];
turn\_predrate \= btd.behaviorTriggeredDataMatrix('turn', 'start', btdstruct.predratefields, 0\);
all\_predrate \= btd.behaviorTriggeredDataMatrix('all', 'start', btdstruct.predratefields, 0, 'conditions', inrun);

btdstruct.trx \= linspace(min(btdstruct.ratefun{1}(btdstruct.lx)), max(btdstruct.ratefun{1}(btdstruct.lx)), length(btdstruct.lx));

trxx \= binEdgesFromCenters(btdstruct.trx);
btdstruct.trpred\_rsq \= \[];
for j \= 1:length(btdstruct.predratefields)
 yy \= turn\_predrate(:, j);
 aa \= all\_predrate(:, j);
 h1 \= histc(yy,trxx);
 h2 \= histc(aa,trxx);
 rr \= 1/dt\*h1(1:(end\-1\))./h2(1:(end\-1\));
 reb \= 1/dt\*sqrt(h1(1:(end\-1\)))./h2(1:(end\-1\));
 btdstruct.tr\_vs\_pred(j,:) \= rr';
 btdstruct.tr\_vs\_pred\_eb(j,:) \= reb'; 
 btdstruct.nturns\_vs\_pred(j,:) \= h1(1:(end\-1\))';
 mtr \= sum(btdstruct.nturns\_vs\_pred(j,:).\*btdstruct.tr\_vs\_pred(j,:))./sum(btdstruct.nturns\_vs\_pred(j,:));
 sstot \= sum(btdstruct.nturns\_vs\_pred(j,:).\*(btdstruct.tr\_vs\_pred(j,:)\-mtr).^2\)./sum(btdstruct.nturns\_vs\_pred(j,:));
 ssres \= sum(btdstruct.nturns\_vs\_pred(j,:).\*(btdstruct.tr\_vs\_pred(j,:)\-btdstruct.trx).^2\)./sum(btdstruct.nturns\_vs\_pred(j,:));
 btdstruct.trpred\_rsq(j) \= 1 \- ssres./sstot;
 
end
btdstruct.firstten.trpred\_rsq \= \[];
for j \= 1:length(btdstruct.predratefields)
 yy \= turn\_predrate(turneti \< 600, j);
 aa \= all\_predrate(alleti \< 600, j);
 h1 \= histc(yy,trxx);
 h2 \= histc(aa,trxx);
 rr \= 1/dt\*h1(1:(end\-1\))./h2(1:(end\-1\));
 reb \= 1/dt\*sqrt(h1(1:(end\-1\)))./h2(1:(end\-1\));
 btdstruct.firstten.tr\_vs\_pred(j,:) \= rr';
 btdstruct.firstten.tr\_vs\_pred\_eb(j,:) \= reb';
 btdstruct.firstten.nturns\_vs\_pred(j,:) \= h1(1:(end\-1\))';
 mtr \= sum(btdstruct.firstten.nturns\_vs\_pred(j,:).\*btdstruct.firstten.tr\_vs\_pred(j,:))./sum(btdstruct.firstten.nturns\_vs\_pred(j,:));
 sstot \= sum(btdstruct.firstten.nturns\_vs\_pred(j,:).\*(btdstruct.firstten.tr\_vs\_pred(j,:)\-mtr).^2\)./sum(btdstruct.firstten.nturns\_vs\_pred(j,:));
 ssres \= sum(btdstruct.firstten.nturns\_vs\_pred(j,:).\*(btdstruct.firstten.tr\_vs\_pred(j,:)\-btdstruct.trx).^2\)./sum(btdstruct.firstten.nturns\_vs\_pred(j,:));
 btdstruct.firstten.trpred\_rsq(j) \= 1 \- ssres./sstot;
 
end
btdstruct.secondten.trpred\_rsq \= \[];
for j \= 1:length(btdstruct.predratefields)
 yy \= turn\_predrate(turneti \>\= 600 \& turneti \< 1200, j);
 aa \= all\_predrate(alleti \>\= 600 \& alleti \< 1200, j);
 h1 \= histc(yy,trxx);
 h2 \= histc(aa,trxx);
 rr \= 1/dt\*h1(1:(end\-1\))./h2(1:(end\-1\));
 reb \= 1/dt\*sqrt(h1(1:(end\-1\)))./h2(1:(end\-1\));
 btdstruct.secondten.tr\_vs\_pred(j,:) \= rr';
 btdstruct.secondten.tr\_vs\_pred\_eb(j,:) \= reb';
 btdstruct.secondten.nturns\_vs\_pred(j,:) \= h1(1:(end\-1\))';
 mtr \= sum(btdstruct.secondten.nturns\_vs\_pred(j,:).\*btdstruct.secondten.tr\_vs\_pred(j,:))./sum(btdstruct.secondten.nturns\_vs\_pred(j,:));
 sstot \= sum(btdstruct.secondten.nturns\_vs\_pred(j,:).\*(btdstruct.secondten.tr\_vs\_pred(j,:)\-mtr).^2\)./sum(btdstruct.secondten.nturns\_vs\_pred(j,:));
 ssres \= sum(btdstruct.secondten.nturns\_vs\_pred(j,:).\*(btdstruct.secondten.tr\_vs\_pred(j,:)\-btdstruct.trx).^2\)./sum(btdstruct.secondten.nturns\_vs\_pred(j,:));
 btdstruct.secondten.trpred\_rsq(j) \= 1 \- ssres./sstot;
 
end




cv \= btd.behaviorTriggeredDataMatrix('all', 'start', btdstruct.linname, 0, 'conditions', inrun);
cvt \= btd.behaviorTriggeredDataMatrix('turn', 'start', btdstruct.linname, 0\);
cvt\_first \= btd.behaviorTriggeredDataMatrix('turn', 'start', btdstruct.linname, 0, 'conditions', firstten);
cvt\_second \= btd.behaviorTriggeredDataMatrix('turn', 'start', btdstruct.linname, 0, 'conditions', secondten);

btdstruct.hist\_x \= linspace(percentile(cv,0\.01\), percentile(cv,.99\), 20\);

btdstruct.turn\_linval \= cvt;
btdstruct.firstten.turn\_linval \= cvt\_first;
btdstruct.secondten.turn\_linval \= cvt\_second;
hx \= btdstruct.hist\_x;
h1 \= histc(cv, binEdgesFromCenters(hx));
btdstruct.hist\_all\_val \= h1(1:end\-1\);
h2 \= histc(cvt, binEdgesFromCenters(hx));
btdstruct.hist\_turn\_val \= h2(1:end\-1\);

btdstruct.rate \= 60\*btdstruct.hist\_turn\_val./btdstruct.hist\_all\_val/dt;

btdstruct.linval\_mean\_all \= mean(cv);
btdstruct.linval\_mean\_turn \= mean(cvt);
btdstruct.linval\_var\_all \= var(cv);
btdstruct.linval\_var\_turn \= var(cvt);



m1 \= mean(cv);
s1 \= std(cv);

cvt \= (cvt\-m1\)/s1;
btdstruct.dkl\_est\_gauss \= 0\.5\*(var(cvt) \- log(var(cvt)) \+ mean(cvt).^2 \- 1\);
%btdstruct.dkl\_est\_gauss \= 0\.5\*(var(cvt)/var(cv) \- log(var(cvt)/var(cv)) \+ mean(cvt.^2\)/var(cv)\-1\);


p \= polyfit(btdstruct.lx, dt\*btdstruct.tr\_vs\_conv,4\);
btdstruct.turnratepoly \= fitRateFun(btd, 'turn', 'start', kname, @polyval, p);

btd \= btd.addOperationFields (kname, \[gqname '\_ratePredPoly'], @(x) 1/dt\*polyval(btdstruct.turnratepoly, x));
firsths.name \= 'hsnum';
firsths.validop \= @(x) x \=\= 1;

fields \= {'acchs', 'rejhs'};%, 'acchs', 'rejhs','acchs', 'rejhs'};
pos \= {'start', 'start'};%, 'atmax', 'atmax', 'end', 'end'};

for j \= 1:length(fields)
 \[bta, \~] \= btd.behaviorTriggeredAverage(fields{j}, pos{j}, gqname, taxis, 'conditions', firsths);
 btdstruct.(\['first\_' fields{j} '\_' pos{j}]) \= bta;
end


fields \= {'acchs', 'rejhs'};%, 'acchs', 'rejhs','acchs', 'rejhs'};
pos \= {'start', 'start'};%, 'atmax', 'atmax', 'end', 'end'};

for j \= 1:length(fields)
 \[bta, \~] \= btd.behaviorTriggeredAverage(fields{j}, pos{j}, gqname, taxis, 'conditions', \[firstten firsths]);
 btdstruct.firstten.(\['first\_' fields{j} '\_' pos{j}]) \= bta;
 \[bta, \~] \= btd.behaviorTriggeredAverage(fields{j}, pos{j}, gqname, taxis, 'conditions', \[secondten firsths]);
 btdstruct.secondten.(\['first\_' fields{j} '\_' pos{j}]) \= bta;
end

t \= \[btd.turn]; 
btdstruct.meanSquaredTurn \= mean(\[t.dtheta].^2\);
ms \= btdstruct.meanSquaredTurn;
bigturn.name \= 'dtheta';
bigturn.validop \= @(x) x.^2 \> ms;
smallturn.name \= 'dtheta';
smallturn.validop \= @(x) x.^2 \< ms;
onehs.name \= 'numhs';
onehs.validop \= @(x) x \=\= 1;
multihs \= onehs;
multihs.validop \= @(x) x \> 1;
if (\~isempty(compensatorName))
 btdstruct.bigturn\_start\_all\_compensator \= btd.behaviorTriggeredAverageCompensator('turn', 'start', gqname, compensatorName, taxis, 'conditions', bigturn);
 btdstruct.smallturn\_start\_all\_compensator \= btd.behaviorTriggeredAverageCompensator('turn', 'start', gqname, compensatorName, taxis, 'conditions', smallturn);
 btdstruct.smallturn\_start\_onehs\_compensator \= btd.behaviorTriggeredAverageCompensator('turn', 'start', gqname, compensatorName,taxis, 'conditions', \[smallturn onehs]);
 btdstruct.bigturn\_start\_onehs\_compensator \= btd.behaviorTriggeredAverageCompensator('turn', 'start', gqname, compensatorName, taxis, 'conditions', \[bigturn onehs]);
end

btdstruct.bigturn\_start\_onehs \= btd.behaviorTriggeredAverage('turn', 'start', gqname, taxis, 'conditions', \[bigturn onehs]);
btdstruct.smallturn\_start\_onehs \= btd.behaviorTriggeredAverage('turn', 'start', gqname, taxis, 'conditions', \[smallturn onehs]);
btdstruct.bigturn\_start\_multis \= btd.behaviorTriggeredAverage('turn', 'start', gqname, taxis, 'conditions', \[bigturn multihs]);
btdstruct.smallturn\_start\_multihs \= btd.behaviorTriggeredAverage('turn', 'start', gqname, taxis, 'conditions', \[smallturn multihs]);

btdstruct.bigturn\_start\_all \= btd.behaviorTriggeredAverage('turn', 'start', gqname, taxis, 'conditions', bigturn);
btdstruct.smallturn\_start\_all \= btd.behaviorTriggeredAverage('turn', 'start', gqname, taxis, 'conditions', smallturn);


btdstruct.weightedTurnStart\_multihs \= btd.behaviorTriggeredWeightedAverage('turn', 'start', 'dtheta',gqname, taxis, 'weightedOp', @abs, 'conditions', multihs);
btdstruct.weightedTurnStart\_onehs \= btd.behaviorTriggeredWeightedAverage('turn', 'start', 'dtheta', gqname, taxis, 'weightedOp', @abs, 'conditions', onehs);
btdstruct.weightedTurnStart\_all \= btd.behaviorTriggeredWeightedAverage('turn', 'start', 'dtheta', gqname, taxis, 'weightedOp', @abs);

try
 btdstruct.val.bigturn\_start\_onehs \= btd.behaviorTriggeredAverage('turn', 'start', valName, taxis, 'conditions', \[bigturn onehs]);
 btdstruct.val.smallturn\_start\_onehs \= btd.behaviorTriggeredAverage('turn', 'start', valName, taxis, 'conditions', \[smallturn onehs]);
 btdstruct.val.bigturn\_start\_multis \= btd.behaviorTriggeredAverage('turn', 'start', valName, taxis, 'conditions', \[bigturn multihs]);
 btdstruct.val.smallturn\_start\_multihs \= btd.behaviorTriggeredAverage('turn', 'start', valName, taxis, 'conditions', \[smallturn multihs]);

 btdstruct.val.bigturn\_start\_all \= btd.behaviorTriggeredAverage('turn', 'start', valName, taxis, 'conditions', bigturn);
 btdstruct.val.smallturn\_start\_all \= btd.behaviorTriggeredAverage('turn', 'start', valName, taxis, 'conditions', smallturn);
 
 btdstruct.val.weightedTurnStart\_multihs \= btd.behaviorTriggeredWeightedAverage('turn', 'start', 'dtheta',valName, taxis, 'weightedOp', @abs, 'conditions', multihs);
 btdstruct.val.weightedTurnStart\_onehs \= btd.behaviorTriggeredWeightedAverage('turn', 'start', 'dtheta', valName, taxis, 'weightedOp', @abs, 'conditions', onehs);
 btdstruct.val.weightedTurnStart\_all \= btd.behaviorTriggeredWeightedAverage('turn', 'start', 'dtheta', valName, taxis, 'weightedOp', @abs);

catch me %\#ok
end
num\_tspts \= 200;

dm \= btd.behaviorTriggeredDataMatrix('turn', 'start', gqname, linspace(turnSizeRange(1\), turnSizeRange(2\), num\_tspts));
dm2 \= dm; dm2(\~isfinite(dm2\)) \= 0;
turnmc \= mean(dm2, 2\);

t \= \[btd.turn]; 
isbigturn \= (\[t.dtheta].^2 \> btdstruct.meanSquaredTurn);
issmallturn \= \~isbigturn;
hasonehs \= \[t.numhs] \=\= 1;

btdstruct.meanChangeBeforeTurn \= mean(turnmc, 1\);
btdstruct.meanChangeBeforeTurn\_eb \= std(turnmc, 1\)./sqrt(length(turnmc));

btdstruct.meanChangeBeforeTurn\_onehs \= sum(turnmc(hasonehs,:), 1\)./nnz(hasonehs);
btdstruct.meanChangeBeforeTurn\_onehs\_eb \= std(turnmc(hasonehs,:), 1\)./sqrt(nnz(hasonehs));

btdstruct.meanChangeBeforeBigTurn \= sum(turnmc(isbigturn,:), 1\)./nnz(isbigturn);
btdstruct.meanChangeBeforeBigTurn\_eb \= std(turnmc(isbigturn,:), 1\)./sqrt(nnz(isbigturn));

btdstruct.meanChangeBeforeSmallTurn \= sum(turnmc(issmallturn,:), 1\)./nnz(issmallturn);
btdstruct.meanChangeBeforeSmallTurn\_eb \= std(turnmc(issmallturn,:), 1\)./sqrt(nnz(issmallturn));

btdstruct.meanChangeBeforeBigTurn\_onehs \= sum(turnmc(isbigturn \& hasonehs,:), 1\)./nnz(isbigturn \& hasonehs);
btdstruct.meanChangeBeforeBigTurn\_onehs\_eb \= std(turnmc(isbigturn \& hasonehs,:), 1\)./sqrt(nnz(isbigturn \& hasonehs));

btdstruct.meanChangeBeforeSmallTurn\_onehs \= sum(turnmc(issmallturn \& hasonehs,:), 1\)./nnz(issmallturn \& hasonehs);
btdstruct.meanChangeBeforeSmallTurn\_onehs\_eb \= std(turnmc(issmallturn \& hasonehs,:), 1\)./sqrt(nnz(issmallturn \& hasonehs));

hs \= \[btd.hs];
acc \= logical(\[hs.accepted]);
rej \= \~acc;
isfirsths \= \[hs.hsnum] \=\= 1;

% firstacc \= acc(isfirsths);
% firstrej \= rej(isfirsths);

num\_hspts \= 50;
dm \= btd.behaviorTriggeredDataMatrix('hs', 'start', gqname, linspace(headSweepAcceptRange(1\), headSweepAcceptRange(2\), num\_hspts));
dm2 \= dm; dm2(\~isfinite(dm2\)) \= 0;
hsmc \= mean(dm2, 2\); %rate per second
% firsthsmc \= hsmc(isfirsths);

btdstruct.meanChangeAfterHeadsweep \= mean(hsmc,1\);
btdstruct.meanChangeAfterHeadsweep\_eb \= std(hsmc, 1\)./sqrt(length(hsmc));
btdstruct.meanChangeAfterFirstHeadsweep \= sum(hsmc(isfirsths,:), 1\)./nnz(isfirsths);
btdstruct.meanChangeAfterFirstHeadsweep\_eb \= std(hsmc(isfirsths,:), 1\)./sqrt(nnz(isfirsths));

btdstruct.meanChangeAfterAcceptedHeadsweep \= sum(hsmc(acc,:), 1\)./nnz(acc);
btdstruct.meanChangeAfterAcceptedHeadsweep\_eb \= std(hsmc(acc,:), 1\)./sqrt(nnz(acc));

btdstruct.meanChangeAfterRejectedHeadsweep \= sum(hsmc(rej,:), 1\)./nnz(rej);
btdstruct.meanChangeAfterRejectedHeadsweep\_eb \= std(hsmc(rej,:), 1\)./sqrt(nnz(rej));

btdstruct.meanChangeAfterFirstAcceptedHeadsweep \= sum(hsmc(acc \& isfirsths,:), 1\)./nnz(acc \& isfirsths);
btdstruct.meanChangeAfterFirstAcceptedHeadsweep\_eb \= std(hsmc(acc \& isfirsths,:), 1\)./sqrt(nnz(acc \& isfirsths));

btdstruct.meanChangeAfterFirstRejectedHeadsweep \= sum(hsmc(rej \& isfirsths,:), 1\)./nnz(rej \& isfirsths);
btdstruct.meanChangeAfterFirstRejectedHeadsweep\_eb \= std(hsmc(rej \& isfirsths,:), 1\)./sqrt(nnz(rej \& isfirsths));



firsths.name \= 'hsnum';
firsths.validop \= @(x) x \=\= 1;
otherhs \= firsths;
otherhs.validop \= @(x) x \> 1;

btdstruct.weightedFirstHeadsweep \= btd.behaviorTriggeredWeightedAverage('hs', 'start', 'accepted', gqname, taxis, 'conditions', firsths);

btdstruct.btd \= btd;
aa \= \[btd.all]; hsdt \= median(diff(\[aa.eti]));
hstaxis \= \-10:hsdt:10;
hsbw \= 0\.5;
cumnsamp \= 3;

if (\~exist('IShannon\_HShannon\_initialization'))
 return;
end

\[it.firsths.mi, it.firsths.tcent, it.firsths.bit\_rate, it.firsths.tstart] \= miFieldSignalVsTime (btd, 'hs', 'accepted', 'start', gqname, hstaxis, hsbw, 'conditions', firsths);
\[\~, \~, it.firsths.bit\_rate\_fast, it.firsths.tstart\_cum] \= miFieldSignalVsTime (btd, 'hs', 'accepted', 'start', gqname, hstaxis, \[hstaxis(1:end\-cumnsamp); hstaxis((1\+cumnsamp):end)], 'conditions', firsths);
it.firsths.tend\_cum \= hstaxis((1\+cumnsamp):end);
\[it.otherhs.mi, it.otherhs.tcent, it.otherhs.bit\_rate, it.otherhs.tstart] \= miFieldSignalVsTime (btd, 'hs', 'accepted', 'start', gqname, hstaxis, hsbw, 'conditions', otherhs);
\[\~, \~, it.otherhs.bit\_rate\_fast, it.otherhs.tstart\_cum] \= miFieldSignalVsTime (btd, 'hs', 'accepted', 'start', gqname, hstaxis, \[hstaxis(1:end\-cumnsamp); hstaxis((1\+cumnsamp):end)], 'conditions', otherhs);
it.otherhs.tend\_cum \= hstaxis((1\+cumnsamp):end);
\[it.allhs.mi, it.allhs.tcent, it.allhs.bit\_rate, it.allhs.tstart] \= miFieldSignalVsTime (btd, 'hs', 'accepted', 'start', gqname, hstaxis, hsbw);
\[\~, \~, it.allhs.bit\_rate\_fast, it.allhs.tstart\_cum] \= miFieldSignalVsTime (btd, 'hs', 'accepted', 'start', gqname, hstaxis, \[hstaxis(1:end\-cumnsamp); hstaxis((1\+cumnsamp):end)]);
it.allhs.tend\_cum \= hstaxis((1\+cumnsamp):end);
it.firsths.bw \= hsbw;
it.allhs.bw \= hsbw;
it.otherhs.bw \= hsbw;


tstaxis \= \-60:0\.25:60;
tsbw \= 5;
cumnsamp \= 2;
\[it.turnsize.mi, it.turnsize.tcent, it.turnsize.bit\_rate, it.turnsize.tstart] \= miFieldSignalVsTime (btd, 'turn', 'dtheta', 'start', gqname, tstaxis, tsbw, 'operation', @(x) abs(x));
\[\~, \~, it.turnsize.bit\_rate\_fast, it.turnsize.tstart\_cum] \= miFieldSignalVsTime (btd, 'turn', 'dtheta', 'start', gqname, tstaxis, \[tstaxis(1:end\-cumnsamp); tstaxis((1\+cumnsamp):end)], 'operation', @(x) abs(x));
it.turnsize.tend\_cum \= tstaxis((1\+cumnsamp):end);
it.turnsize.bw \= tsbw;
fn \= {'firsths', 'otherhs', 'allhs','turnsize'};
for j \= 1:length(fn)
 dt \= diff(it.(fn{j}).tstart\_cum); dt \= dt(\[1:end end]);
 it.(fn{j}).cumbit \= cumsum((it.(fn{j}).bit\_rate\_fast \- msNoOutliers(it.(fn{j}).bit\_rate\_fast,2\.5\)).\*dt);
 
 it.(fn{j}).totalbits \= it.(fn{j}).cumbit(end);
 \[it.(fn{j}).peakrate, I] \= max((it.(fn{j}).bit\_rate \- msNoOutliers(it.(fn{j}).bit\_rate,2\.5\)));
 it.(fn{j}).peaktime\_start \= it.(fn{j}).tstart(I);
 it.(fn{j}).peaktime\_cent \= it.(fn{j}).tcent(I);
 it.(fn{j}).peaktime\_end \= 2\*it.(fn{j}).tcent(I) \- it.(fn{j}).tstart(I);
 it.(fn{j}).mi \= it.(fn{j}).mi/log(2\); %provide mutual information in bits
end
it.unit \= 'bits';
btdstruct.ShannonInfo \= it;
 

\-\-\-

\#\#\# Folder: @ExperimentSet (ID: @ExperimentSet)

\-\-\-

\#\#\# File: make2DHistogram.m (ID: @ExperimentSet.1\)

function h2 \= make2DHistogram(eset, fieldname1, fieldaxis1, fieldname2, fieldaxis2, varargin)
%function h2 \= make2DHistogram(eset, fieldname1, fieldaxis1, fieldname2, fieldaxis2, varargin)
%
%generates a histogram of all values in expt.track.getDerivedQuantity(fieldname,varargin{:})
%if no arguments are specified, generates a plot of that histogram
%optional args 'subfield', subfieldname
% calls eset.gatherFromSubfield(subfieldname, fieldname1,varargin{:});
subfield \= \[];
varargin \= assignApplicable(varargin);
if (isempty(subfield))
 h \= makeIm (eset.gatherField(fieldname1, varargin{:}), eset.gatherField(fieldname2, varargin{:}), fieldaxis1, fieldaxis2\);
else
 h \= makeIm (eset.gatherFromSubField(subfield, fieldname1, varargin{:}), eset.gatherFromSubField(subfield,fieldname2, varargin{:}), fieldaxis1, fieldaxis2\);
end
if (nargout \=\= 0\)
 pcolor (fieldaxis1, fieldaxis2, h); shading flat; colorbar vert
 
 xlabel(fieldname1\); ylabel(fieldname2\); embiggen();
else
 h2 \= h;
end

\-\-\-

\#\#\# File: averageFromSubField.m (ID: @ExperimentSet.2\)

function \[qv, datamatrix] \= averageFromSubField(eset, subfield, fieldname, centerpos, offsetinds, varargin)
%function \[qv, datamatrix] \= averageFromSubField(eset, subfield, fieldname, centerpos, offsetinds, varargin)
%TODO: comments

\[qv, datamatrix] \= averageFromSubField(eset.expt, subfield, fieldname, centerpos, offsetinds, varargin{:});

 
\-\-\-

\#\#\# File: meanField2vsField1\.m (ID: @ExperimentSet.3\)

function \[x,meany,standarderror,standarddeviation] \= meanField2vsField1 (eset, field1name, field2name, field1axis, varargin)
% the mean value of points in field2 corresponding to values of field1
% function \[x,meany,standarderror,standarddeviation] \= meanField2vsField1
% (eset, field1name, field2name, field1axis, varargin)
%
% gathers two fields (with varargin arguments for both) and calls meanyvsx on them
% if no return arguments are requested, plots the result
% note that field1axis is bin edges \[edge1,edge2\) and x is the mean value
% of field1 in that bin
%
% outputs:
% X: the x\-axis, the mean value of field1 for all points in each bin
% MEANY: the mean value of field2 for all points in each bin
% STANDARDERROR: the standard deviation of field2 in each bin / 
% sqrt of number of points in each bin
% STANDARDDEVIATION: the standard deviation of field2 in each bin
% inputs:
% ESET: a member of the ExperimentSet class
% FIELD1NAME: the name of the independent field (must be 1D)
% FIELD2NAME: the name of the dependent field (may be ND)
% FIELD1AXIS: bin edges \[edge1,edge2\); thus length(x) \=
% length(field1axis) \- 1; and x(j) is the mean value of all points
% with field1 \>\= field1axis(j) and field1 \< field1axis(j\+1\)
% VARARGIN:
% any option that can be passed to ExperimentSet/gatherField
% 'inds', inds will take value only from inds in this
% fashion (same for ydata/field2name):
% xdata \= eset.gatherField(field1name, varargin{:});
% xdata \= xdata(inds)
% 'field1dim' \- if field1 is ND instead of 1D, choose this dimension
% \- e.g. if field1name is 'loc', pass 'field1dim',1 for x
% position
% 'polar', true/false \-\- adjusts xdata for polar histogram
% 'autocorr\_tau' \- autocorrelation time constant (in seconds)
% \_t0 \~\= exp(\-t/tau)
% 'timerange' \-\- only consider within this time period
inds \= \[];
field1dim \= \[];
polar \= false;
autocorr\_tau \= \-1;
timerange \= \[];

varargin \= assignApplicable(varargin);
if (autocorr\_tau \< 0\)
 if (eset.autocorr\_tau \<\= 0\)
 disp ('calculating and setting autocorrelation time constant');
 eset.setAutocorrTau;
 end
 autocorr\_tau \= eset.autocorr\_tau;
end
xdata \= eset.gatherField(field1name, varargin{:});
if \~isempty(field1dim)
 xdata \= xdata(field1dim,:);
end
if (polar)
 fxc \= (field1axis(1:end\-1\) \+ field1axis(2:end))/2;
 xdata \= adjustForPolarHistogram(xdata, fxc);
end
 

ydata \= eset.gatherField(field2name, varargin{:});
if (\~isempty(timerange))
 eti \= eset.gatherField('eti', varargin{:});
 timinds \= eti \>\= min(timerange) \& eti \<\= max(timerange);
 if (\~isempty(inds))
 if (max(inds) \> 1\)
 inds2 \= false(size(timinds));
 inds2(inds) \= true;
 inds \= inds2;
 end
 inds \= inds \& timinds;
 else
 inds \= timinds;
 end
end
if (\~isempty(inds))
 xdata \= xdata(inds); %xdata must be 1\-D
 ydata \= ydata(:,inds);
end
\[x,meany,standarderror,standarddeviation] \= meanyvsx(xdata, ydata, field1axis);
dti \= eset.expt(1\).track(1\).dr.interpTime;
k \= sqrt((1 \+ exp(\-dti/autocorr\_tau))/(1 \- exp(\-dti/autocorr\_tau)));
standarderror \= k\*standarderror;
if (nargout \=\= 0\)
 errorbar (x,meany,standarderror); title (eset.defaultTitle);
 xlabel(field1name);
 ylabel(\['$\<$' field2name '$\>$']);
 embiggen();
end
\-\-\-

\#\#\# File: processJavaDirectoryToMatfiles.m (ID: @ExperimentSet.4\)

function \[eset, success] \= processJavaDirectoryToMatfiles (basedir,varargin)
%function eset \= loadTrimStitchAndSave(basedir, esetname, ecl, camcalinfo, varargin)
%loads, stitches, trims, cleans, etc. then saves to mat files in a
%'matfiles' subdirectory 
%varargin: parameter \= defaultvalue
% to change, pass 'parameter', value after basedir, esetname
% checkerLocation \= '';
% checkerboardfname \= 'checkerboard.png';
% checkeroptions \= {'xinds', 310:2170, 'yinds', 220:1640, 'flipy', true, 'flipx', false, 'flatten', true};
% minptsToLoad \= 50;
% frameDiff \= 4;
% maxDist \= 0\.1;
% buffer \= \[\-0\.1 0\.2 0\.1 0\.1];
% trimrect \= \[];
% fieldsToDerive \= {};
%
% explanation of parameters (more detail found inside
% processDirectoryToMatfiles\_Janelia.m)
%
% checkboardfname \- specifies the name of the picture of the 1cm checkerboard that we
% will use to calibrate the camera; place the
% checkerboard inside basedir
% checkeroptions \- options to pass to the checkerboard calibration routine
% 
% minPtsToLoad \- the minimum length a track must be before we will even
% load it from disk
%
% frameDiff \- stitch together tracks if first ended frameDiff or fewer frames before second started
% maxDist \- stitch together tracks if first ended within maxDist (in cm) of
% second's start
% buffer \- distance from leftmost, rightmost, bottommost, topmost point to trim 
% (to eliminate border region)
% trimrect \- you can specify an actual trim rectangle here
% if both buffer \& trimrect are specified, trimrect is used \& buffer is
% ignored; if buffer \= \[] and trimrect \= \[], trimming is disabled
% fieldsToDerive \- extra data fields to derive before saving to save time
% later
% ccInSupDataDir \- true/\[false] \-\- if true, cameracalibration info is
% stored in supplemental datadir
%
% individualMatFiles \- whether to process the experiment mat files
% pseudo\-individually using the same name as the .jav files 
%
% requireMaggot \= \[true]/false \-\- if true, exits without loading if
% experiment does not contain maggot tracks
%




% this section sets the parameters that will be used throughout the script
% you can change any of these parameters by passing 
%'parameter\_name', parameter value after basedir, esetname in the
% arguments to the function

%this specifies the name of the picture of the 1cm checkerboard that we
%will use to calibrate the camera \-\- using the checkerboard lets us analyze
%the data \- maggot lengths, run speeds, run lengths, etc. in real units
%(cm) that we can compare between experiments and labs
%
%place the checkerboard inside basedir 
%optionally you can provide a different location for the checkerboard

checkerboardfname \= '1cm\_checkerboard.png';

checkerLocation \= '';


%these are options to pass to the checkerboard calibration routine. xinds,
%yinds specify the region of the image that contains the checkerboard (if
%we are zoomed out enough to see the beyond the edge of the checkerboard)
%'flipy' is true (for cold\_arrows) because when we put 0,0 in the lower
%left corner, the image is upside down
%'flipx' is false (for cold\_arrows) because when we put 0,0 in the lower
%left corner, warm is to \+x
%'flatten', true evens out the illumination over the checkerboard, and is
%generally worth doing
checkeroptions \= {'flipy', true, 'flipx', false, 'flatten', true};


% minPtsToLoad is the minimum length a track must be before we will even
% load it from disk
minptsToLoad \= 50;

% loadParallel is whether to use parallel processes to load mat files. set
% to false if you are running on a computer with "limited" (say \< 8 GB)
% memory
loadParallel \= false;

%these are options to use when stitching together tracks \-\- we do this in
%case the track extraction software dropped a frame or two in the middle of
%an otherwise good track. . . note that if the track is in
%collision with another track in the experiment, we don't stitch 

frameDiff \= 7; % stitch together tracks if first ended 4 or fewer frames before second started
maxDist \= 0\.1; % stitch together tracks if first ended within 1 mm of second's start

buffer \= \[0\.1 0\.1 0\.1 0\.1]; % \[left, right, top, bottom]
 
trimrect \= \[]; % \[left bottom right top] you can specify an actual trim rectangle here, which will mean buffer is ignored
 % note that the window should be specified in cm, not pixels

trimrectpixels \= \[]; % \[left bottom right top] trim rectangle set in pixels; this is based on full image pixels (ROI is ignored); if both trimrect and trimrectpixels are specified, trimrect wins


 
setRulesByPeri \= true; % instead of using default derivation rules, set smoothing, derivative times, and minimum run times by detected peristalsis frequency
 
%we derive all the fields necessary to segment the tracks and generate navigation figures before saving
%if there are other fields you want derived and saved, place them here
fieldsToDerive \= {};

individualMatFiles \= true;

fixedInterpTime \= \[]; %if fixedInterpTime is a number, then all experiments will have same fixed interpolation time (not determined from frame rate)

camcalinfo \= \[]; %allows you to directly pass in camcalinfo
requireMaggot \= true;
%TODO: fix all non\-essential displays to respond to verbosity trigger
verbose \= false;

varargin \= assignApplicable(varargin);


if verbose 
 disp('\~\~\~\~\~\~\~\~\~ processJavaDirectoryToMatfiles \~\~\~\~\~\~\~\~\~');
end
%we clean the experiment set twice \-\- once before stitching and once after
%stitching; the cleaner (eclnukespots) before stitching just looks for spots that are
%clearly not maggot tracks \-\- head tail is largely invalid; does not move
%more than 2 mm
%
%after stitching we are more selective, insisting on a minimum number of
%points, a fairly high number of valid head tail determinations, a minimum
%distance travelled, and a requirement that the larva not continuously
%circle in one direction

eclnukespots \= ESetCleaner();
eclnukespots.minHTValid \= 0\.6;
eclnukespots.minDist \= 0\.2; 
eclnukespots.askFirst \= false;


ecl \= ESetCleaner();
ecl.minDist \= 1; % track must be more than 1 cm long
mintime \= 30; % tracks must be at least 60 seconds \-\- we will convert this into a minimum number of points later
ecl.minHTValid \= 0\.9; % discard any track where we couldn't determine a head tail properly at least 90% of the time
ecl.rpmCut \= 2; % get rid of any track that circles in one direction with a frequency of at least 2 rev/min
ecl.minRevCut \= 3; % provided that track does at least 3 complete circles


ccInSupDataDir \= false;



varargin \= assignApplicableAndFixTypes(varargin);
success \= false;
ts1 \= tic();




% this section will look through the directory for .jav files and verify
% that we have the appropriate .mdat files as well
d \= \[dir(fullfile(basedir, '\*.jav'))];
d \= d(\~cellfun(@(n) strcmpi(n,'divergedTrackExp.jav'),{d.name}));

if (isempty(d))
 disp (\['no .jav files in ' basedir]);
 eset \= \[];
 return;
end




matfileexists \= false(size(d));
for j \= 1:length(d)
 fname{j} \= fullfile(basedir, d(j).name); %\#ok\<\*AGROW\>
 \[ps,nm] \= fileparts(fname{j});
 mdatname{j} \= fullfile(ps,\[nm '.mdat']);
 if (\~exist(mdatname{j}, 'file'))
 disp ('cannot find metadata file');
 disp (\['jav file name \= ' fname{j}]);
 disp (\['metadata file name \= ' mdatname{j}]);
 error ('must have metadata file to proceed');
 return %\#ok
 end
 matfileexists(j) \= exist(fullfile(ps, 'matfiles', \[nm '.mat']), 'file');
 ptTp \= Experiment.getJavaPtType(fname{j});
 ismaggot(j) \= isa(ptTp, 'MaggotTrackPoint') \|\| isa(ptTp, 'LarvaTrackPoint');
end
ismaggot \= logical(ismaggot);
if (requireMaggot)
 if \~all(ismaggot)
 for j \= find(\~ismaggot)
 warning ('eset:pd2m', '%s', \[fname{j} ' does not contain maggot track points \& is being ignored']);
 end
 end
 fname \= fname(ismaggot);
 mdatname \= mdatname(ismaggot);
 matfileexists \= matfileexists(ismaggot);
 
 
end


if (individualMatFiles)
 pfname \= fname(matfileexists);
 fname \= fname(\~matfileexists);
 if (isempty(fname))
 eset \= \[];
 if (verbose)
 disp (\['already processed all jav files in ' basedir]);
 end
 return;
 end
 for j \= 1:length(pfname)
 if (verbose)
 disp (\['already processed: ' pfname{j}]);
 end
 end
 for j \= 1:length(fname)
 if (verbose)
 disp (\['need to process: ' fname{j}]);
 end
 end
end

disp('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');
disp(\['Processing jav\-\>mat (' num2str(length(fname)) ' files) in dir: ' basedir]);
disp('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');

%%%%%%%%%%%%%%% CAMCAL STUFF
% this section carries out the camera calibration if needed and saves it
% to disk
disp('\*\*\*\*\* Carrying out copying camera calibration and/or copying calibration data');
if (ccInSupDataDir)
 for j \= 1:length(fname) %\#ok
 \[p,f] \= fileparts(fname{j});
 if (\~exist(fullfile(p, \[f ' sup data dir'], 'camcalinfo.mat'), 'file'))
 warning ('es:pd2m', \['you told me to look in ' f ' sup data dir for camcalinfo, but I couldn''t find it']);
 return;
 end
 temp \= load(fullfile(p, \[f ' sup data dir'], 'camcalinfo.mat'), 'camcalinfo');
 if (j \=\= 1\)
 camcalinfo \= temp.camcalinfo;
 else
 camcalinfo(j) \= temp.camcalinfo;
 end
 end
else
 if (\~isempty(camcalinfo) \|\| \~exist(fullfile(basedir, 'camcalinfo.mat'), 'file'))
 if (isempty(camcalinfo))
 try
 if (\~isempty(checkerLocation))
 im \= imread(fullfile(checkerLocation, checkerboardfname));
 else
 im \= imread(fullfile(basedir, checkerboardfname));
 end
 catch me
 disp ('could not read in checkerboard from: ');
 disp (fullfile(basedir, checkerboardfname));
 disp ('error was: ')
 disp (me.getReport());
 disp ('');
 warning ('cannot proceed without camera calibration \-\- aborting');
 eset \= \[];
 return;
 end
 if (verbose)
 disp ('calibrating checkerboard');
 end 
 camcalinfo \= CameraCalibration(im, checkeroptions{:});
 if (isempty(camcalinfo))
 error ('camera calibration failed \- check options');
 end
 end
 % make sure that the checkerboard that displays here is correct \-\- I am
 % not putting a checkoff in the script because you want to run it automatically, but this is a potential place for errors
 
 
 save(fullfile(basedir, 'camcalinfo.mat'), 'camcalinfo');
 else
 load(fullfile(basedir, 'camcalinfo.mat'), 'camcalinfo');
 end 
 close all
end 


% now we will load each mdat file and see if there is an ROI offset we need
% to take into account for the camera calibration

for j \= 1:length(mdatname)
 ind \= min(j, length(camcalinfo));
 if (isa(camcalinfo(ind), 'SimpleScalingCameraCalibration') \|\| isa(camcalinfo(ind), 'ScalingAndRotationCameraCalibration'))
 cc(j) \= camcalinfo(ind);
 continue;
 end
 
 rx \= camcalinfo(ind).realx;
 ry \= camcalinfo(ind).realy;
 cx \= camcalinfo(ind).camx;
 cy \= camcalinfo(ind).camy;
 data \= importdata(mdatname{j});
 xcol \= find(strcmpi(data.colheaders, 'ROIX'));
 if (\~isempty(xcol))
 roix \= median(data.data(isfinite(data.data(:,xcol)),xcol)); % we should be able just to take the first value, but this should be more robust
 else
 roix \= 0;
 end
 ycol \= find(strcmpi(data.colheaders, 'ROIY'));
 if (\~isempty(ycol))
 roiy \= median(data.data(isfinite(data.data(:,ycol)),ycol)); % we should be able just to take the first value, but this should be more robust
 else
 roiy \= 0;
 end
 cc(j) \= CameraCalibration(rx, ry, cx\-roix, cy\-roiy);
 
end



try
 if (isempty(trimrect) \&\& \~isempty (trimrectpixels))
 \[\~,trimrect,\~] \= camcalinfo.realRectFromCamRect(trimrectpixels);
 end
catch me
 disp(me.getReport);
 return;
end


%%%%%%%CAMCALDONE

disp('\*\*\*\*\* Done carrying out copying camera calibration and/or copying calibration data');

% This section calls the processing functions
args \= \[varargin, {'frameDiff', frameDiff, 'maxDist', maxDist, 'setRulesByPeri', setRulesByPeri, 'fieldsToDerive', fieldsToDerive}];

if (individualMatFiles)
 if (loadParallel \&\& length(fname) \> 1\)
 ts1 \= tic;
 if (matlabpool('size') \=\= 0\)
 if (verbose)
 disp ('opening parallel processes'); 
 end
 matlabpool;
 toc(ts1\);
 closepool \= true;
 else
 closepool \= false;
 end
 
 %%NOTE: when matlabpool is switched to parpool, uncomment lines below 
 
 %AddJavaPathToParPool(poolName) %% UMCOMMENT THIS
 
 parfor n\=1:length(fname)
 
 %AddJavaPath(getAttachedFilesFolder) %% UMCOMMENT THIS
 
 if (verbose)
 disp(\['Loading file \#' num2str(n) ' : ' fname{n}]);
 end 
 try
 %2/7/2015 \-\- changed camcalinfo to cc(n): camcalinfo is
 %nonvectorized and does not include ROI offsets.
 ss(n) \= processSingleJavaExperimentToMatfile (fname{n}, ecl, eclnukespots, cc(n), minptsToLoad, fixedInterpTime, trimrect, buffer, mintime, basedir, args{:});
 disp(\['finished loading file \#' num2str(n) ' : t \= ' num2str(toc(ts1\))]);
 catch e
 disp(\['Error in processSingleJavaExperimentToMatfile for: ' fname{n}]);
 end
 
 end
 
 if (closepool)
 disp('closing parallel processes'); ts2 \= tic;
 matlabpool close;
 toc(ts2\);
 end
 disp(\['total time to load ' num2str(length(fname)) ' files \= ' num2str(toc(ts1\))]);
 success \= success \&\& all(ss);
 else
 for j \= 1:length(fname)
 try
 %2/7/2015 \-\- changed camcalinfo to cc(n): camcalinfo is
 %nonvectorized and does not include ROI offsets.
 success \= success \& processSingleJavaExperimentToMatfile (fname{j}, ecl, eclnukespots, cc(j), minptsToLoad, fixedInterpTime, trimrect, buffer, mintime, basedir, args{:});
 catch me
 disp(\['Error in processSingleJavaExperimentToMatfile for: ' fname{j}]);
 disp(me.getReport());
 end
 end
 end
 eset \= \[];
 
 
 return;

else
 % this command actually loads the experiments from disk \-\- so short!
 eset \= ExperimentSet.fromJavaFiles(fname{:}, 'minpts', minptsToLoad, 'camcalinfo', cc, 'parallel', loadParallel, 'fixedInterpTime', fixedInterpTime);
 if (isempty(eset))
 return;
 end

 disp('\*\*\*\*\* Post\-mat processing');

 % this is NEW NEW NEW \-\- we will try to determine appropriate smoothing
 % and interpolation times, as well as minimum run times based on
 % peristalsis detected in high frequency movies

 if (setRulesByPeri \&\& median(eset.gatherSubField('dr', 'interpTime')) \<\= 0\.1251\) % \>\= 8 Hz
 \[mf, f, ps] \= eset.setDerivationRulesByPeristalsisFrequency();
 disp (\['calculated peristalis frequency is: ' num2str(mf), ' Hz.']);
 figure();
 plot (f, ps); title(\['calculated peristalis frequency is: ' num2str(mf), ' Hz.']);
 xlabel ('freq'); ylabel ('power');
 end

 % we are going to put the rest of the file in try/catch blocks \-\- that way
 % if there's a failure, you don't have to reload the tracks from disk to
 % see what the problem is because the function will still return a value

 % get rid of obviously bad tracks (dust, crap) before stitching
 try
 disp ('cleaning bad spots');
 eclnukespots.clean(eset);
 catch me
 disp(me.getReport);
 return;
 end

 %stitch tracks together
 try 
 disp ('stitching tracks');
 eset.executeExperimentFunction('stitchTracks', frameDiff, maxDist, 'interactive', false);
 catch me
 disp(me.getReport);
 return;
 end

 %trim the region near the edge of the experiment

 try
 if (isempty(trimrect))
 if (\~isempty(buffer))
 il \= eset.gatherField('iloc');
 ll \= min(il,\[],2\);
 ur \= max(il,\[],2\);
 trimrect \= \[ll(1\) ll(2\) ur(1\) ur(2\)] \+ buffer.\*\[1 1 \-1 \-1];
 end
 end
 catch me
 disp(me.getReport);
 return;
 end
 try
 if (\~isempty(trimrect))
 disp ('trimming tracks');
 eset.executeExperimentFunction('trimTracks', \[], trimrect);
 else
 disp ('skipping trimming');
 end
 catch me
 disp(me.getReport);
 return;
 end

 %clean out marginal tracks that will not contribute to analysis
 ecl.minPts \= ceil(mintime / eset.expt(1\).dr.interpTime);
 ecl.askFirst \= false; 
 ecl.showFigsInReport \= false;
 \[\~,rpt] \= ecl.getReport(eset);
 try
 fid \= fopen (fullfile (basedir, 'cleaning report.txt'), 'wt');
 for j \= 1:length(rpt)
 fprintf(fid, '%s\\n', rpt{j});
 end
 catch me
 disp ('trouble writing cleaning report to disk, continuing anyway');
 disp (me.getReport);
 end

 disp ('cleaning eset');
 try
 ecl.clean(eset);
 valid \= true(size(eset.expt));
 for j \= 1:length(eset.expt)
 if (isempty(eset.expt(j).track))
 disp (\[eset.expt(j).fname ' \- after cleaning no valid tracks']);
 valid(j) \= false;
 end
 end
 eset.expt \= eset.expt(valid);
 catch me
 disp(me.getReport);
 return;
 end


 %calculate derived quantities used in segmentation; set segmentation speeds

 disp('calculating dq');
 try
 eset.evaluateTrackExpression('track.so.autoset\_curv\_cut\= true;'); %NEW set radius of curvature cutoff to be 1/5 of body length
 eset.executeTrackFunction('setSegmentSpeeds');
 dvfields \= {'spineTheta', 'vel\_dp', 'spineLength', 'sspineTheta', 'lrdtheta'};
 for j \= 1:length(dvfields)
 disp (\['calculating ' dvfields{j}]);
 eset.gatherField(dvfields{j});
 end


 for j \= 1:length(fieldsToDerive) 
 disp (\['calculating ' fieldsToDerive{j}]);
 eset.gatherField(fieldsToDerive{j});
 end
 catch me
 disp(me.getReport);
 return;
 end
 disp('done with loading, stitching and cleaning');
 toc(ts1\)
 disp('\*\*\*\*\* Done with post\-mat processing');

 %finally, save the eset to disk as matfiles, so it can be loaded quickly later
 disp('\*\*\*\*\* Saving mat files');
 try
 if (\~exist(fullfile(basedir, 'matfiles'), 'dir'))
 mkdir (fullfile(basedir, 'matfiles'));
 end
 eset.executeExperimentFunction('toMatFile', 'extradir', 'matfiles');
 %{
 if (individualMatFiles)
 eset.executeExperimentFunction('toMatFile', 'extradir', 'matfiles');
 else 
 eset.toMatFiles(fullfile(basedir, 'matfiles',esetname));
 end
 %}
 disp('saved file');
 toc(ts1\)
 catch me
 disp(me.getReport);
 return;
 end

 disp('\*\*\*\*\* Done saving mat files');

 success \= true;

 % needed to close all windows and run smoothly in the cluster
 close all;
 if verbose 
 disp('\~\~\~\~\~\~\~\~\~ processJavaDirectoryToMatfiles: DONE \~\~\~\~\~\~\~\~\~');
 end
end


disp('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');
disp(\['Done processing jav\-\>mat in dir: ' basedir]);
disp('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');

function success \= processSingleJavaExperimentToMatfile (fname, ecl, eclnukespots, camcalinfo, minptsToLoad, fixedInterpTime, trimrect, buffer, mintime, basedir, varargin)


frameDiff \= 7; % stitch together tracks if first ended 4 or fewer frames before second started
maxDist \= 0\.1; 
setRulesByPeri \= true; % instead of using default derivation rules, set smoothing, derivative times, and minimum run times by detected peristalsis frequency
 
%we derive all the fields necessary to segment the tracks and generate navigation figures before saving
%if there are other fields you want derived and saved, place them here
fieldsToDerive \= {};
redomatfile \= false;
tracksInSubDir \= false;
varargin \= assignApplicable(varargin);

success \= false;
ts1 \= tic();

% this section carries out the camera calibration if needed and saves it
% to disk

\[ps,nm] \= fileparts(fname);
mdatname \= fullfile(ps,\[nm '.mdat']);
if (\~exist(mdatname, 'file'))
 disp ('cannot find metadata file');
 disp (\['jav file name \= ' fname]);
 disp (\['metadata file name \= ' mdatname]);
 error ('must have metadata file to proceed');
 return %\#ok
end
matfileexists \= exist(fullfile(ps, 'matfiles', \[nm '.mat']), 'file');

% THIS IS ALREADY DONE IN MAIN FUNCTION \-\- SKIP
% now we will load each mdat file and see if there is an ROI offset we need
% to take into account for the camera calibration
% 
% rx \= camcalinfo.realx;
% ry \= camcalinfo.realy;
% 
% cx \= camcalinfo.camx;
% cy \= camcalinfo.camy;
% data \= importdata(mdatname);
% xcol \= find(strcmpi(data.colheaders, 'ROIX'));
% if (\~isempty(xcol))
% roix \= median(data.data(isfinite(data.data(:,xcol)),xcol)); % we should be able just to take the first value, but this should be more robust
% else
% roix \= 0;
% end
% ycol \= find(strcmpi(data.colheaders, 'ROIY'));
% if (\~isempty(ycol))
% roiy \= median(data.data(isfinite(data.data(:,ycol)),ycol)); % we should be able just to take the first value, but this should be more robust
% else
% roiy \= 0;
% end
% 
% cc \= CameraCalibration(rx, ry, cx\-roix, cy\-roiy);

if (\~redomatfile \&\& matfileexists)
 success \= true;
 return;
end




% this command actually loads the experiments from disk \-\- so short!
eset \= ExperimentSet.fromJavaFiles(fname, 'minpts', minptsToLoad, 'camcalinfo', camcalinfo, 'parallel', false, 'fixedInterpTime', fixedInterpTime);
if (isempty(eset))
 return;
end

disp('\*\*\*\*\* Post\-mat processing');

% this is NEW NEW NEW \-\- we will try to determine appropriate smoothing
% and interpolation times, as well as minimum run times based on
% peristalsis detected in high frequency movies
try
 disp ('setting derivation rules by peristalsis frequency');
 if (setRulesByPeri \&\& median(eset.gatherSubField('dr', 'interpTime')) \<\= 0\.1251\) % \>\= 8 Hz
 \[mf, f, ps] \= eset.setDerivationRulesByPeristalsisFrequency();
 % disp (\['calculated peristalis frequency is: ' num2str(mf), ' Hz.']);
 % figure();
 % plot (f, ps); title(\['calculated peristalis frequency is: ' num2str(mf), ' Hz.']);
 %xlabel ('freq'); ylabel ('power');
 end
catch me
 disp (me.getReport());
 return;
end


% we are going to put the rest of the file in try/catch blocks \-\- that way
% if there's a failure, you don't have to reload the tracks from disk to
% see what the problem is because the function will still return a value

% get rid of obviously bad tracks (dust, crap) before stitching
try
 disp ('cleaning bad spots');
 eclnukespots.clean(eset);
catch me
 disp(me.getReport);
 return;
end

%stitch tracks together
try 
 disp ('stitching tracks');
 eset.executeExperimentFunction('stitchTracks', frameDiff, maxDist, 'interactive', false);
catch me
 disp(me.getReport);
 return;
end
 
%trim the region near the edge of the experiment
try
 if (isempty(trimrect))
 if (\~isempty(buffer))
 il \= eset.gatherField('iloc');
 ll \= min(il,\[],2\);
 ur \= max(il,\[],2\);
 trimrect \= \[ll(1\) ll(2\) ur(1\) ur(2\)] \+ buffer.\*\[1 1 \-1 \-1];
 end
 end
catch me
 disp(me.getReport);
 return;
end

try
 if (\~isempty(trimrect))
 disp ('trimming tracks');
 eset.executeExperimentFunction('trimTracks', \[], trimrect);
 else
 disp ('skipping trimming');
 end
catch me
 disp(me.getReport);
 return;
end

%clean out marginal tracks that will not contribute to analysis
try
 ecl.minPts \= ceil(mintime / eset.expt(1\).dr.interpTime);
 ecl.askFirst \= false; 
 ecl.showFigsInReport \= false;
 \[\~,rpt] \= ecl.getReport(eset);
catch me
 disp (me.getReport())
 return;
end

\[basedir,nm] \= fileparts(fname);

try
 fid \= fopen (fullfile (basedir, \[nm ' cleaning report.txt']), 'wt');
 for j \= 1:length(rpt)
 fprintf(fid, '%s\\n', rpt{j});
 end
catch me
 disp ('trouble writing cleaning report to disk, continuing anyway');
 disp (me.getReport);
end

disp ('cleaning eset');
try
 ecl.clean(eset);
 valid \= true(size(eset.expt));
 for j \= 1:length(eset.expt)
 if (isempty(eset.expt(j).track))
 disp (\[eset.expt(j).fname ' \- after cleaning no valid tracks']);
 valid(j) \= false;
 end
 end
 eset.expt \= eset.expt(valid);
catch me
 disp(me.getReport);
 return;
end

if (isempty(eset.expt))
 return;
end

%calculate derived quantities used in segmentation; set segmentation speeds

try
 eset.evaluateTrackExpression('track.so.autoset\_curv\_cut\= true;'); %NEW set radius of curvature cutoff to be 1/5 of body length
 eset.executeTrackFunction('setSegmentSpeeds');
 dvfields \= {'spineTheta', 'vel\_dp', 'spineLength', 'sspineTheta', 'lrdtheta'};
 for j \= 1:length(dvfields)
 disp (\['calculating ' dvfields{j}]);
 eset.gatherField(dvfields{j});
 end
 
 
 for j \= 1:length(fieldsToDerive) 
 disp (\['calculating ' fieldsToDerive{j}]);
 eset.gatherField(fieldsToDerive{j});
 end
catch me
 disp(me.getReport);
 return;
end
disp('done with loading, stitching and cleaning');
toc(ts1\)


disp('\*\*\*\*\* Done with post\-mat processing');

disp('\*\*\*\*\* Saving mat files');

%finally, save the eset to disk as matfiles, so it can be loaded quickly later
try
 if (\~exist(fullfile(basedir, 'matfiles'), 'dir'))
 mkdir (fullfile(basedir, 'matfiles'));
 end
 eset.executeExperimentFunction('toMatFile', 'extradir', 'matfiles', 'tracksInSubDir', tracksInSubDir);
 disp('saved file');
 imdir \= fullfile(basedir, 'diagnostics');
 if (\~exist(imdir, 'dir'))
 mkdir(imdir);
 end
 for j \= 1:length(eset.expt)
 im \= eset.expt(j).diagnosticImage();
 if (\~isempty(im))
 \[\~,fn] \= fileparts(eset.expt(j).fname);
 imwrite(im/255, fullfile(imdir, \[fn ' diagnostic foreground.bmp']), 'bmp');
 end
 end
 
 toc(ts1\)
catch me
 disp(me.getReport);
 return;
end

disp('\*\*\*\*\* Done saving mat files');
success \= true;






\-\-\-

\#\#\# File: ExperimentSet.m (ID: @ExperimentSet.5\)

classdef ExperimentSet \< handle
 %a class for manipulating groups of experiments
 %
 
 properties
 expt; % array of experiments
 defaultTitle \= 'untitled'; % the default title prepended to auto generated graphs
 autocorr\_tau \= 0;
 end
 
 methods
 qvec \= gatherField(eset, fieldname, varargin)
 qvec \= gatherSubField (eset, field, subfield, varargin)
 qvec \= gatherFromSubField(eset, subfield, fieldname, varargin)
 varargout \= executeTrackFunction(eset, func, varargin);
 result \= evaluateTrackExpression(eset, expression);
 varargout \= executeExperimentFunction(eset, func, varargin);
 \[h, eb] \= makeHistogram(eset, fieldname, fieldaxis, varargin);
 \[h, eb] \= makeSubFieldHistogram(eset, field, subfield, fieldaxis, varargin);
 \[h, eb] \= makeReorientationHistogram(eset, fieldname, fieldaxis, varargin);
 \[h, eb] \= makeHeadSwingAcceptanceHistogram(eset, fieldname, fieldaxis, varargin);
 \[x,meany,standarderror,standarddeviation] \= meanField2vsField1 (eset, field1name, field2name, field1axis, varargin);
 \[x,meany,standarderror,standarddeviation] \= meanField2vsField1\_slidingwindow (eset, field1name, field2name, field1center, field1binsize, windowType, varargin);
 \[x,meany,standarderror,standarddeviation] \= meanSubField2vsSubField1 (eset, field1name, subfield1name, field2name, subfield2name, field1axis, varargin);
 \[xc, np, tx, nt] \= crosscorrelate (eset, fieldname1, fieldname2, varargin);
 \[ac, np, tx, nt] \= autocorrelate (eset, fieldname, varargin);
 tau \= getAutocorrTau(eset, varargin);
 setAutocorrTau(eset, varargin);
 \[h,eb] \= makeReorientationHistogram\_slidingWindow(eset, fieldname, fieldcenters, fieldwidth, windowType, varargin)
 \[qv, datamatrix] \= averageFromSubField(eset, subfield, fieldname, centerpos, offsetinds, varargin); 
 \[meanPeriFreq, freqs, psd] \= setDerivationRulesByPeristalsisFrequency (eset, varargin)
 
 varargout \= indToTrack(eset, ind);
 toMatFiles(eset, fstub);
 addTimingByFrameDifference(eset, deltaT);
 
 %note that these methods will produce different results than
 %calling same methods on each experiment individually, because the
 %adjustment will be made globally for all experiments, instead of
 %individually for each experiment
 %UP TO YOU TO DECIDE MORE APPROPRIATE METHOD
 addTemperatureAdjustedSpeed (eset, varargin); %calculates mean speed vs. temp, then creates adjusted speed to take out linear contribution
 addAdjustedField(eset, field1, adjfield,varargin) %calculates mean adjfield vs. field1, then creates adjusted field to take out linear contribution
 end
 methods(Static)
 eset \= fromFiles(varargin);
 eset \= fromMWTFiles(inputdir, camcalinfo, varargin);
 eset \= fromMatFiles(fstub, fileinds,segment);
 eset \= loadTrimStitchAndSave(basedir, esetname, ecl, camcalinfo, varargin);
 \[eset, success] \= processDirectoryToMatfiles (basedir, varargin); %similar to load trim stitch and save
 eset \= fromJavaFiles(varargin);
 \[eset, success] \= processJavaDirectoryToMatfiles (basedir,varargin);
 end
 
end


\-\-\-

\#\#\# File: makeReorientationHistogramVsDistance.m (ID: @ExperimentSet.6\)

function h \= makeReorientationHistogramVsDistance(eset, fieldname, fieldaxis, varargin)
% generates a plot of mean reorientation rate (in 1/minutes) vs. fieldname
% function h \= makeReorientationHistogram(eset, fieldname, fieldaxis, varargin)
% 
% generates a plot of mean reorientation rate (in 1/minutes) vs. fieldname
% if no return arguments are given, plots this 
% as with almost all eset functions, assumes (explicitly here, implicitly
% other places) that interpTime is the same for all experiments
%
% outputs:
% H: (optional), the reorientation rate vs. bin center;
% if no output arguments, plots this
% inputs:
% ESET: a member of the ExperimentSet class
% FIELDNAME: the name of the field over which to make the reo rate plot 
% FIELDAXIS: bin centers for the histogram
% VARARGIN: optional arguments:
% 'r2d','true' causes plot fieldaxis to be displayed in degrees
% rather than radians
% 'polar',true \- adjust data so that the 0 degree bin is the same size as the
% next bin; the last bin may be screwed by this, so be careful
% in other words, passing polar,true fieldaxis \= deg2rad(0:30:330\) is good
% passing polar,true fieldaxis \= deg2rad(0:30:360\) will nuke your
% last bin
% 'validname', fieldname
% 'validoperation', op
% reorientation rate is calculated for the subset of the experiment points
% that satisfy op(gatherField(fieldname)) \=\= true
% 'incllastrun', true/\[false]
% whether to include the last run of a track when calculating
% statistics
% 'makePlot', true/\[false]
% if true, make the plot even if a value is returned
% (maggot tracks only)
% 'minHS',n only include reorientations with at least n headsweeps
% 'maxHS',n only include reorientations with at most n headsweeps
% (worm tracks only)
% 'turnsequence' \- only include reorientations with this sequence of
% turns
minHS \= 0;
maxHS \= 10000;
validname \= \[];
validoperation \= @(x) logical(x);
r2d \= false;
polar \= false;
incllastrun \= false;
makePlot \= false;
turnsequence \= \[];
varargin \= assignApplicable(varargin);
if (isstr(validoperation))
 validoperation \= str2func(validoperation);
end
if (isa(eset.expt(1\).track(1\), 'MaggotTrack'))
 hsexpression \= \['\[track.reorientation.numHS] \>\= ' num2str(minHS) ' \& \[track.reorientation.numHS] \<\= ' num2str(maxHS)];
 qv \= eset.gatherFromSubField('reorientation', fieldname, 'position', 'start', 'indsExpression', hsexpression);
else
 hsexpression \= \[];
 qv \= eset.gatherFromSubField('reorientation', fieldname, 'position', 'start');
end
if \~isempty(turnsequence)
 r \= eset.gatherField('reorientation');
 goodreo \= r.turnsequenceEquals(turnsequence);
else
 goodreo \= true(\[1 length(qv)]);
end

if (\~isempty(validname))
 if (\~isempty(hsexpression))
 valid \= validoperation(eset.gatherFromSubField('reorientation', validname, 'position', 'start', 'indsExpression', hsexpression));
 else
 valid \= validoperation(eset.gatherFromSubField('reorientation', validname, 'position', 'start'));
 end
else
 valid \= true(\[1 length(qv)]);
end
qv \= qv(:,valid\&goodreo);
if (polar)
 c1 \= fieldaxis(1\);
 dt \= fieldaxis(2\) \- c1;
 edge \= c1 \- dt/2;
 qv \= mod(qv\-edge,2\*pi)\+edge;
end
h1 \= hist(qv, fieldaxis);

if (incllastrun)
 indsExpression \= 'true(size(track.run))';
else
 indsExpression \= '1:length(track.run) \~\= length(track.run)';
end
qv \= eset.gatherFromSubField('run', fieldname, 'indsExpression', indsExpression);
if (\~isempty(validname))
 valid \= validoperation(eset.gatherFromSubField('run', validname, 'indsExpression', indsExpression));
 qv \= qv(:,valid);
end
if (polar)
 c1 \= fieldaxis(1\);
 dt \= fieldaxis(2\) \- c1;
 edge \= c1 \- dt/2;
 qv \= mod(qv\-edge,2\*pi)\+edge;
end

h2 \= hist(qv, fieldaxis);

if (nargout \> 0\)
 h \= h1\./h2 /eset.expt(1\).dr.interpTime \* 60;
end
if (nargout \=\= 0 \|\| makePlot)
 htemp \= h1\./h2/eset.expt(1\).dr.interpTime \* 60;
 if (r2d)
 fieldaxis \= rad2deg(fieldaxis);
 end
 plot (fieldaxis, htemp);
 xlabel (fieldname);
 ylabel ('reorientation rate (min^{\-1})');
 title (\[eset.defaultTitle ': reorientation rate vs. instantaneous ' fieldname]);
end

\-\-\-

\#\#\# File: addTemperatureAdjustedSpeed.m (ID: @ExperimentSet.7\)

function addTemperatureAdjustedSpeed (eset, varargin)
% function addTemperatureAdjustedSpeed (expt, varargin)
%
% calculates mean speed vs. temp, then creates adjusted speed to take out linear contribution
% see addAdjustedField for implementation details
% EXPT \< expt

fn \= {eset.expt(1\).globalQuantity.fieldname};
ind \= strcmpi('temperature', fn);
if(any(ind))
 fn \= fn{find(ind, 1, 'first')};
 eset.addAdjustedField(fn, 'speed');
 return;
end
ind \= strcmpi('temp', fn);
if(any(ind))
 fn \= fn{find(ind, 1, 'first')};
 eset.addAdjustedField(fn, 'speed');
 return;
end 
\-\-\-

\#\#\# File: gatherField.m (ID: @ExperimentSet.8\)

function qvec \= gatherField(eset, fieldname, varargin)
% gathers fieldname from all tracks in all experiments
% function qvec \= gatherField(eset, fieldname, varargin)
%
% what you would get from qvec \= \[eset.expt.gatherField(fieldname,
% varargin)] 
% if that were a valid matlab function call
% inputs: 
% ESET: a member of the ExperimentSet class
% FIELDNAME: either a property of the Track/MaggotTrack/etc. in ESET.expt or
% a fieldname that can be passed to Track/getDerivedQuantity
% VARARGIN: if fieldname is passed to getDerivedQuantity, VARARGIN{:}
% is also passed, so any valid arguments to getDerivedQuantity can be
% appended here
% e.g. add 'runs', 'reorientations', 'headswings','runend' to get field just in
% runs/reos/hs
% 'validname', fieldname
% 'validoperation', op \-\- @(x) logical(x)
% gathers from the subset of points that stasify
% that satisfy op(gatherField(fieldname,varargin{:})) \=\= true
% 'inds' \-\- a list of indices to select

inds \= \[];
varargin \= assignApplicable(varargin);
qvec \= \[];
if (strcmpi(fieldname, 'expNum'))
 for j \= 1:length(eset.expt)
 qv{j} \= j\*ones(size(eset.expt(j).gatherField('eti', varargin{:}))); 
 end 
 qvec \= \[qv{:}];
else
 for j \= 1:length(eset.expt)
 qvec \= \[qvec eset.expt(j).gatherField(fieldname, varargin{:})];
 end
end
if (\~isempty(inds))
 qvec \= qvec(:,inds);
end
\-\-\-

\#\#\# File: makeReorientationHistogram.m (ID: @ExperimentSet.9\)

function \[h,eb] \= makeReorientationHistogram(eset, fieldname, fieldaxis, varargin)
% generates a plot of mean reorientation rate (in 1/minutes) vs. fieldname
% function \[h,eb] \= makeReorientationHistogram(eset, fieldname, fieldaxis, varargin)
% 
% generates a plot of mean reorientation rate (in 1/minutes) vs. fieldname
% if no return arguments are given, plots this 
% as with almost all eset functions, assumes (explicitly here, implicitly
% other places) that interpTime is the same for all experiments
%
% outputs:
% H: (optional), the reorientation rate vs. bin center;
% if no output arguments, plots this
% inputs:
% ESET: a member of the ExperimentSet class
% FIELDNAME: the name of the field over which to make the reo rate plot 
% FIELDAXIS: bin centers for the histogram
% VARARGIN: optional arguments:
% 'r2d','true' causes plot fieldaxis to be displayed in degrees
% rather than radians
% 'polar',true \- adjust data so that the 0 degree bin is the same size as the
% next bin; the last bin may be screwed by this, so be careful
% in other words, passing polar,true fieldaxis \= deg2rad(0:30:330\) is good
% passing polar,true fieldaxis \= deg2rad(0:30:360\) will nuke your
% last bin
% 'validname', fieldname
% 'validoperation', op
% reorientation rate is calculated for the subset of the experiment points
% that satisfy op(gatherField(fieldname)) \=\= true
% 'incllastrun', true/\[false]
% whether to include the last run of a track when calculating
% statistics
% 'makePlot', true/\[false]
% if true, make the plot even if a value is returned
% (maggot tracks only)
% 'minHS',n only include reorientations with at least n headsweeps
% 'maxHS',n only include reorientations with at most n headsweeps
% (worm tracks only)
% 'turnsequence' \- only include reorientations with this sequence of
% turns
% 'vsDistance' \- find reorientation rate in inverse length instead of
% inverse time
% 'timerange' \- only include this time range for analysis 
% 'useprevdir' \[true] \-\- if field is 'theta', use reorientation.prevDir,
% instead of reorientation.getDerivedQuantity('theta', 'start')
% 'datarow', if field is multi\-dimensional (e.g. 'vel'), which row to use
ts1 \= tic;
minHS \= 0;
maxHS \= 10000;
validname \= \[];
validoperation \= @(x) logical(setNonFiniteToZero(x));
r2d \= false;
polar \= false;
incllastrun \= true; %default changed 8/7/2014 by mhg
makePlot \= false;
turnsequence \= \[];
vsDistance \= false;
timerange \= \[];
useprevdir \= true;
datarow \= 1;
varargin \= assignApplicable(varargin);

useprevdir \= useprevdir \&\& strcmpi(fieldname, 'theta');

if (isstr(validoperation))
 validoperation \= str2func(validoperation);
end
if (isa(eset.expt(1\).track(1\), 'MaggotTrack'))
 hsexpression \= \['\[track.reorientation.numHS] \>\= ' num2str(minHS) ' \& \[track.reorientation.numHS] \<\= ' num2str(maxHS)];
 if (\~useprevdir)
 qv \= eset.gatherFromSubField('reorientation', fieldname, 'position', 'start', 'indsExpression', hsexpression);
 else
 nhs \= eset.gatherSubField('reorientation', 'numHS');
 qv \= eset.gatherSubField('reorientation', 'prevDir');
 qv \= qv(:, nhs \>\= minHS \& nhs \<\= maxHS);
 end
else
 hsexpression \= \[];
 if (\~useprevdir)
 qv \= eset.gatherFromSubField('reorientation', fieldname, 'position', 'start');
 else
 qv \= eset.gatherSubField('reorientation', 'prevDir');
 end
end

if \~isempty(turnsequence)
 %r \= eset.gatherField('reorientation');
 %goodreo \= r.turnsequenceEquals(turnsequence);
 goodreo \= eset.evaluateTrackExpression(\['track.reorientation.turnsequenceEquals(' num2str(turnsequence) ')']);
 while(iscell(goodreo))
 goodreo \= \[goodreo{:}];
 end
else
 goodreo \= true(\[1 length(qv)]);
end

if \~isempty(timerange)
 if (\~isempty(hsexpression))
 reti \= eset.gatherFromSubField('reorientation', 'eti', 'position', 'start', 'indsExpression', hsexpression);
 else
 reti \= eset.gatherFromSubField('reorientation', 'eti', 'position', 'start');
 end
 validtim \= reti \>\= min(timerange) \& reti \<\= max(timerange);
else
 validtim \= true(\[1 length(qv)]);
end

valid \= true(\[1 length(qv)]);

if (\~isempty(validname))
 if (\~iscell(validname))
 validname \= {validname};
 end
 if (\~iscell(validoperation))
 validoperation \= {validoperation};
 end
 for k \= 1:length(validname)
 opnum \= min(k, length(validoperation));
 if (\~isempty(hsexpression))
 valid \= valid \& validoperation{opnum}(eset.gatherFromSubField('reorientation', validname{k}, 'position', 'start', 'indsExpression', hsexpression));
 else
 valid \= valid \& validoperation{opnum}(eset.gatherFromSubField('reorientation', validname{k}, 'position', 'start'));
 end
 end
end

qv \= qv(:,valid\&goodreo\&validtim);
if (polar)
 c1 \= fieldaxis(1\);
 dt \= fieldaxis(2\) \- c1;
 edge \= c1 \- dt/2;
 qv \= mod(qv\-edge,2\*pi)\+edge;
end
h1 \= histc(qv(datarow,:), binEdgesFromCenters(fieldaxis));
h1 \= h1(1:end\-1\);
if (incllastrun)
 indsExpression \= 'true(size(track.run))';
else
 indsExpression \= '1:length(track.run) \~\= length(track.run)';
end
qv \= eset.gatherFromSubField('run', fieldname, 'indsExpression', indsExpression);
sp \= eset.gatherFromSubField('run', 'speed', 'indsExpression', indsExpression);

valid \= true(\[1 length(qv)]);
if (\~isempty(validname))
 for k \= 1:length(validname)
 opnum \= min(k, length(validoperation));
 valid \= valid \& validoperation{opnum}(eset.gatherFromSubField('run', validname{k}, 'indsExpression', indsExpression));
 end
end

if (\~isempty(timerange))
 reti \= eset.gatherFromSubField('run', 'eti', 'indsExpression', indsExpression);
 validtim \= reti \>\= min(timerange) \& reti \<\= max(timerange);
else
 validtim \= true(\[1 length(qv)]);
end


qv \= qv(:,valid\&validtim);
sp \= sp(:,valid\&validtim);

if (polar)
 c1 \= fieldaxis(1\);
 dt \= fieldaxis(2\) \- c1;
 edge \= c1 \- dt/2;
 qv \= mod(qv\-edge,2\*pi)\+edge;
end
%toc
if (\~vsDistance)
 h2 \= histc(qv(datarow,:), binEdgesFromCenters(fieldaxis)) \* eset.expt(1\).dr.interpTime / 60;
 h2 \= h2(1:end\-1\);
else
 \[\~,\~,\~,\~,h2] \= meanyvsx (qv(datarow,:), sp, binEdgesFromCenters(fieldaxis));
 h2 \= h2\*eset.expt(1\).dr.interpTime;
end
%toc

eb \= sqrt(h1\)./h2;
if (nargout \> 0\)
 h \= h1\./h2;
end
if (nargout \=\= 0 \|\| makePlot)
 htemp \= h1\./h2;
 if (r2d)
 fieldaxis \= rad2deg(fieldaxis);
 end
 errorbar (fieldaxis, htemp, eb);
 xlabel (fieldname);
 if (vsDistance)
 ylabel ('reorientation rate (dist^{\-1})');
 else
 ylabel ('reorientation rate (min$^{\-1}$)');
 end
 title (\[eset.defaultTitle ': reorientation rate vs. instantaneous ' fieldname]);
end
%disp (\['last line of makeReorientationHistogram \- ', num2str(toc(ts1\))]);
%{
toc
bob \= whos();
nm \= {bob.name};
nm \= setdiff(nm, {'h'});
clear(nm{:}, 'bob', 'nm');
toc
%}
\-\-\-

\#\#\# File: crosscorrelate.m (ID: @ExperimentSet.10\)

function \[xc, np, tx, nt] \= crosscorrelate (eset, fieldname1, fieldname2, varargin)
%cross correlates track fields
%function \[xc, np, tx, nt] \= crosscorrelate (eset, fieldname1, fieldname2, varargin)
%
%cross correlates track fields (see Track.crosscorrelate)
%
%outputs:
%XC is the unnormalized cross correlation (normalized is xc./np)
%TX is the time axis for the cross correlation
%NP is the number of points contributing to a certain bin
%NT is the number of tracks contributing to a certain bin
%
%xc(T) \= ; \-N denotes the average
%XC is the return 1x(2N\-1\) vector XC(j) \= xc(j\-N);
%
%inputs:
%EXPT: a member of the Experiment class
%FIELDNAME1, FIELDNAME2: the names of the fields to cross\-correlate
%VARARGIN: any parameter/value pair passed to Track/crosscorrelate, see
%below
%
%we define the cross\-correlation to be
%XC(T) \= ; \-N denotes the average
%xc is the return 1x(2N\-1\) vector xc(j) \= XC(j\-N);
%
%
%arguments to pass in:
%'row', row number(s)
%if row \= m, just finds the correlation of track.dq.(fieldnames)(m,:)\\
%'inRuns', true/false
%if inRuns is true, we take the autocorrelation over the whole track, but
%first interpolate the fields over only the run indices
%this is useful if the fields are ill\-defined between runs (e.g. velocity
%direction)
%'withinRuns', true/false
%if withinRuns is true, we find the correlation only within each run
%'isangle', true/false
% if isangle is true, then we compute the correlation as cos (theta1 \-
% theta2\) instead of as theta1\*theta2
%'timerange', \[mintime maxtime] \-\- only consider data from this time range


maxTime \= zeros(\[1 length(eset.expt)]);
dt \= zeros(\[1 length(eset.expt)]);
for j \= 1:length(eset.expt)
 \[xc, np, tx, nt] \= eset.expt(j).crosscorrelate (fieldname1, fieldname2, varargin{:});
 crosscorr{j} \= xc; %\#ok\<\*AGROW\>
 numpts{j} \= np;
 timeaxis{j} \= tx;
 numtracks{j} \= nt;
 maxTime(j) \= max(tx(np \> 0\));
 dt(j) \= diff(tx(1:2\));
end
tx \= 0:min(dt):maxTime;
tx \= \[\-tx(end:\-1:2\) tx]; %this way, tx always includes 0
%tx \= \-maxTime:(min(dt)):maxTime;
xc \= zeros(size(tx));
np \= xc;
nt \= xc;

for j \= 1:length(eset.expt)
 xc \= xc \+ interp1(timeaxis{j}, crosscorr{j}, tx, 'linear', 0\);
 np \= np \+ interp1(timeaxis{j}, numpts{j}, tx, 'linear', 0\);
 nt \= nt \+ interp1(timeaxis{j}, numtracks{j}, tx, 'linear', 0\);
end
\-\-\-

\#\#\# File: addAdjustedField.m (ID: @ExperimentSet.11\)

function addAdjustedField(eset, field1, adjfield,varargin) 
%function addAdjustedField(eset, field1, adjfield,varargin)
%
% eset \< Experiment
% FIELD1 \< 1\-dimensional field (e.g. temperature)
% ADJFIELD \< 1\-dimensional field (e.g. speed)
%
% calculates mean adjfield vs. field1, then creates adjusted field to take out linear contribution
% say field1 \= T; adjfield \= s. 
% approximate  \=  ~~\+ a(T\-T0\), where  ~~is mean over all
% temperatures
% s\_adj \= s\*F(T): F(T) \= 1/(1\+a/~~\*(T\-T0\));
%


% if field1 is not 1 dimensional, use
% 'fieldrow', d to take the dth dimension of field1
%fieldrow \= \[];
%varargin \= assignApplicable(varargin);

x \= eset.gatherField(field1\);
% if (\~isempty(fieldrow))
% x \= x(fieldrow, :);
% end
y \= eset.gatherField(adjfield);

inds \= isfinite(x) \& isfinite(y);
x \= x(inds); y \= y(inds);
x \= \[x;x]; x(2,:) \= 1;
A \= y\*pinv(x);
my \= mean(y);

xaxis \= linspace(min(x(1,:)),max(x(1,:)), 1000\);
adj\_vs\_x \= my./(A(1\)\*xaxis \+ A(2\));

gq \= GlobalQuantity;
gq.xField \= {field1, adjfield};
gq.fieldname \= \[field1 '\_adjusted\_' adjfield];
% if (\~isempty(fieldrow))
% gq.fieldname \= \[field1 num2str(fieldrow) '\_adjusted\_' adjfield];
% else
% gq.fieldname \= \[field1 '\_adjusted\_' adjfield];
% end
gq.xData \= xaxis;
gq.yData \= adj\_vs\_x;
gq.derivationMethod \= @GlobalQuantity.oneDinterpolationAndMultiplication;
for j \= 1:length(eset.expt)
 eset.expt(j).addGlobalQuantity(gq);
end
\-\-\-

\#\#\# File: addTimingByFrameDifference.m (ID: @ExperimentSet.12\)

function addTimingByFrameDifference(eset, deltaT)
%function addTimingByFrameDifference(eset, deltaT)
%
%iterates through experiments and assigns timing to any that do not already
%have elapsedTime defined

for j \= 1:length(eset.expt)
 if (isempty(eset.expt(j).elapsedTime)) 
 try
 \[\~,nm] \= fileparts(eset.expt(j).fname);
 warning('ESET:NOTIME', \[nm ': no timing information \-\- adding guessed info']);
 catch
 end
 eset.expt(j).setTimingByFrameDifference(deltaT, false);
 end
end
\-\-\-

\#\#\# File: make2DReorientationHistogram.m (ID: @ExperimentSet.13\)

function h2 \= make2DReorientationHistogram(eset, fieldname1, fieldaxis1, fieldname2, fieldaxis2, varargin)
%function h2 \= make2DReorientationHistogram(eset, fieldname1, fieldaxis1, fieldname2, fieldaxis2, varargin)
%
%generates a plot of mean reorientation rate (in 1/minutes) vs. fieldname
%if no return arguments are given, plots this 
%passing 'r2d','true' causes plot fieldaxis to be displayed in degrees
%rather than radians
%
%as will almost all eset functions, assumes (explicitly here, implicitly
%other places) that interpTime is the same for all experiments
%
%optional params:
%'validname', fieldname
%'validoperation', op
%reorientation rate is calculated for the subset of the experiment points
%that satisfy op(gatherField(fieldname)) \=\= true
%
%'minHS',n only include reorientations with at least n headsweeps
%'maxHS',n only include reorientations with at most n headsweeps

minHS \= 0;
maxHS \= 10000;
validname \= \[];
validoperation \= @(x) logical(x);
r2d \= false;
incllastrun \= false;
varargin \= assignApplicable(varargin);
if (isstr(validoperation))
 validoperation \= str2func(validoperation);
end

hsexpression \= \['\[track.reorientation.numHS] \>\= ' num2str(minHS) ' \& \[track.reorientation.numHS] \<\= ' num2str(maxHS)];

qv1 \= eset.gatherFromSubField('reorientation', fieldname1, 'position', 'start', 'indsExpression', hsexpression);
qv2 \= eset.gatherFromSubField('reorientation', fieldname2, 'position', 'start', 'indsExpression', hsexpression);

if (\~isempty(validname))
 valid \= validoperation(eset.gatherFromSubField('reorientation', validname, 'position', 'start', 'indsExpression', hsexpression));
 qv \= qv1(:,valid);
 qv \= qv2(:,valid);
end

h \= makeIm(qv1, qv2, fieldaxis1, fieldaxis2\);

if (incllastrun)
 indsExpression \= 'true(size(track.run))';
else
 indsExpression \= '1:length(track.run) \~\= length(track.run)';
end
qv1 \= eset.gatherFromSubField('run', fieldname1, 'indsExpression', indsExpression);
qv2 \= eset.gatherFromSubField('run', fieldname2, 'indsExpression', indsExpression);

if (\~isempty(validname))
 valid \= validoperation(eset.gatherFromSubField('run', validname, 'indsExpression', indsExpression));
 qv1 \= qv1(:,valid);
 qv2 \= qv2(:,valid);
end

hrun \= makeIm(qv1, qv2, fieldaxis1, fieldaxis2\);


if (nargout \> 0\)
 h2 \= h./hrun /eset.expt(1\).dr.interpTime \* 60;
else
 htemp \= h./hrun/eset.expt(1\).dr.interpTime \* 60;
 pcolor (fieldaxis1, fieldaxis2, htemp); shading flat
 colorbar vert
 xlabel (fieldname1\);
 ylabel (fieldname2\);
 title (\[eset.defaultTitle ': reorientation rate vs. instantaneous ' fieldname1 '\&' fieldname2]);
end

\-\-\-

\#\#\# File: executeTrackFunction.m (ID: @ExperimentSet.14\)

function result \= executeTrackFunction(eset, func, varargin)
%function result \= executeTrackFunction(eset, func, varargin)
%
%result{j} \= eset.expt(j).executeTrackFunction(func, varargin)
%
if (length(eset) \> 1\)
 if (nargout \> 0 \&\& objNargout (eset(1\).expt(1\).track(1\), func) \~\= 0\)
 for j \= 1:length(eset)
 \[result{1:nargout}] \= eset(j).executeTrackFunction(func, varargin{:});
 allresult{j} \= result;
 end
 for k \= 1:nargout
 clear temp;
 for j \= 1:length(allresult)
 temp(j) \= allresult{j}{k};
 end
 varargout{k} \= temp;
 end
 else
 for j \= 1:length(eset.expt)
 eset(j).executeTrackFunction(func, varargin{:});
 end
 end
 return;
end

if (nargout \> 0 \&\& objNargout (eset.expt(1\).track(1\), func) \~\= 0\)
 for j \= 1:length(eset.expt)
 \[result{1:nargout}] \= eset.expt(j).executeTrackFunction(func, varargin{:});
 allresult{j} \= result;
 end
 for k \= 1:nargout
 clear temp;
 for j \= 1:length(allresult)
 temp(j) \= allresult{j}{k};
 end
 varargout{k} \= temp;
 end
else
 if (true \|\| matlabpool('size') \=\= 0\)
 for j \= 1:length(eset.expt)
 eset.expt(j).executeTrackFunction(func, varargin{:});
 end
 else
 parfor j \= 1:length(eset.expt)
 eset.expt(j).executeTrackFunction(func, varargin{:});
 end
 end
end
\-\-\-

\#\#\# File: gatherSubField.m (ID: @ExperimentSet.15\)

function qvec \= gatherSubField (eset, field, subfield, varargin)
%function qvec \= gatherSubField (eset, field, subfield, varargin)
%
%what you would get from \[eset.expt.gatherSubField(field,subfield,varargin{:})] if 
%that were valid syntax
%
%outputs:
%QVEC: a kxN array where k is the dimension of field.subfield and N is the
% number of points
%
%inputs:
%ESET: a member of the ExperimentSet class
%FIELD: a property of ESET.expt.track
% if field is 'firsths', gathers the first headsweep from every
% reorientation only
%SUBFIELD: a property of ESET.expt.track.FIELD
% i.e. if FIELD is 'run', subfield might be 'startTheta', in which case
% the starting angle of every run is returned
%optional inputs:
%'expandToInds', true/false
%if you pass 'expandToInds',true the subfield is expanded so that
%the return vector is the same length as gatherFromSubField would return
%field must have a subfield inds
%
%for example say a field has a subfield "fieldnumber" \= 1 for first field, 2
%for second and so on
%and field(1\).inds \= \[1 2 3], field(2\).inds \= \[1 2 3 4 5], field(3\).inds \=
%\[187]
%
%then gatherSubField(field, fieldnumber, 'expandToInds', true) would yield
%\[1 1 1 2 2 2 2 2 3]

qvec \= \[];
for j \= 1:length(eset.expt)
 qvec \= \[qvec eset.expt(j).gatherSubField(field, subfield, varargin{:})];
end

\-\-\-

\#\#\# File: makeReorientationHistogram\_slidingWindow.m (ID: @ExperimentSet.16\)

function \[h,eb] \= makeReorientationHistogram\_slidingWindow(eset, fieldname, fieldcenters, fieldwidth, windowType, varargin)
%function \[h,eb] \= makeReorientationHistogram\_slidingWindow(eset,
%fieldname, fieldcenters, fieldwidth, windowType, varargin)
% generates a plot of mean reorientation rate (in 1/minutes) vs. fieldname
% function h \= makeReorientationHistogram(eset, fieldname, fieldaxis, varargin)
% 
% generates a plot of mean reorientation rate (in 1/minutes) vs. fieldname
% if no return arguments are given, plots this 
% as with almost all eset functions, assumes (explicitly here, implicitly
% other places) that interpTime is the same for all experiments
%
% outputs:
% H: (optional), the reorientation rate vs. bin center;
% if no output arguments, plots this
% inputs:
% ESET: a member of the ExperimentSet class
% FIELDNAME: the name of the field over which to make the reo rate plot 
% FIELDAXIS: bin centers for the histogram
% VARARGIN: optional arguments:
% 'r2d','true' causes plot fieldaxis to be displayed in degrees
% rather than radians
% 'polar',true \- adjust data so that the 0 degree bin is the same size as the
% next bin; the last bin may be screwed by this, so be careful
% in other words, passing polar,true fieldaxis \= deg2rad(0:30:330\) is good
% passing polar,true fieldaxis \= deg2rad(0:30:360\) will nuke your
% last bin
% 'validname', fieldname
% 'validoperation', op
% reorientation rate is calculated for the subset of the experiment points
% that satisfy op(gatherField(fieldname)) \=\= true
% 'incllastrun', true/\[false]
% whether to include the last run of a track when calculating
% statistics
% 'makePlot', true/\[false]
% if true, make the plot even if a value is returned
% (maggot tracks only)
% 'minHS',n only include reorientations with at least n headsweeps
% 'maxHS',n only include reorientations with at most n headsweeps
% (worm tracks only)
% 'turnsequence' \- only include reorientations with this sequence of
% turns
% 'vsDistance' \- find reorientation rate in inverse length instead of
% inverse time
% 'timerange' \- only include this time range for analysis 
% 'useprevdir' \[true] \-\- if field is 'theta', use reorientation.prevDir,
% instead of reorientation.getDerivedQuantity('theta', 'start')
% ts1 \= tic;
minHS \= 0;
maxHS \= 10000;
validname \= \[];
validoperation \= @(x) logical(setNonFiniteToZero(x));
r2d \= false;
polar \= false;
incllastrun \= false;
makePlot \= false;
turnsequence \= \[];
vsDistance \= false;
timerange \= \[];
useprevdir \= true;
varargin \= assignApplicable(varargin); %\#ok

useprevdir \= useprevdir \&\& strcmpi(fieldname, 'theta');

switch(lower(windowType))
 case 'gaussian'
 weightFun \= @(xd,xc) exp(\-4\*log(2\)\*(xd\-xc).^2\./fieldwidth^2\);
 case 'halfgaussian'
 weightFun \= @(xd,xc) exp(\-4\*log(2\)\*(xd\-xc).^2\./fieldwidth^2\).\*(sign(xd\-xc) \=\= sign(fieldwidth));
 case 'step'
 weightFun \= @(xd,xc) heavisideStep(fieldwidth/2 \- abs(xd\-xc));
 otherwise
 disp('windowType must be gaussian or step');
 return;
 
end

if (ischar(validoperation))
 validoperation \= str2func(validoperation);
end
if (isa(eset.expt(1\).track(1\), 'MaggotTrack'))
 hsexpression \= \['\[track.reorientation.numHS] \>\= ' num2str(minHS) ' \& \[track.reorientation.numHS] \<\= ' num2str(maxHS)];
 if (\~useprevdir)
 qv \= eset.gatherFromSubField('reorientation', fieldname, 'position', 'start', 'indsExpression', hsexpression);
 else
 nhs \= eset.gatherSubField('reorientation', 'numHS');
 qv \= eset.gatherSubField('reorientation', 'prevDir');
 qv \= qv(:, nhs \>\= minHS \& nhs \<\= maxHS);
 end
else
 hsexpression \= \[];
 if (\~useprevdir)
 qv \= eset.gatherFromSubField('reorientation', fieldname, 'position', 'start');
 else
 qv \= eset.gatherSubField('reorientation', 'prevDir');
 end
end

if \~isempty(turnsequence)
 %r \= eset.gatherField('reorientation');
 %goodreo \= r.turnsequenceEquals(turnsequence);
 goodreo \= eset.evaluateTrackExpression(\['track.reorientation.turnsequenceEquals(' num2str(turnsequence) ')']);
 while(iscell(goodreo))
 goodreo \= \[goodreo{:}];
 end
else
 goodreo \= true(\[1 length(qv)]);
end

if \~isempty(timerange)
 if (\~isempty(hsexpression))
 reti \= eset.gatherFromSubField('reorientation', 'eti', 'position', 'start', 'indsExpression', hsexpression);
 else
 reti \= eset.gatherFromSubField('reorientation', 'eti', 'position', 'start');
 end
 validtim \= reti \>\= min(timerange) \& reti \<\= max(timerange);
else
 validtim \= true(\[1 length(qv)]);
end

valid \= true(\[1 length(qv)]);

if (\~isempty(validname))
 if (\~iscell(validname))
 validname \= {validname};
 end
 if (\~iscell(validoperation))
 validoperation \= {validoperation};
 end
 for k \= 1:length(validname)
 opnum \= min(k, length(validoperation));
 if (\~isempty(hsexpression))
 valid \= valid \& validoperation{opnum}(eset.gatherFromSubField('reorientation', validname{k}, 'position', 'start', 'indsExpression', hsexpression));
 else
 valid \= valid \& validoperation{opnum}(eset.gatherFromSubField('reorientation', validname{k}, 'position', 'start'));
 end
 end
end

qv \= qv(:,valid\&goodreo\&validtim);
h1 \= zeros(size(fieldcenters));
for j \= 1:length(fieldcenters)
 if (polar)
 qv \= mod(qv \- fieldcenters(j) \+ pi, 2\*pi) \- pi \+ fieldcenters(j);
 end
 
 w \= weightFun(qv,fieldcenters(j));
 
 h1(j) \= sum(w);
end

% if (polar)
% c1 \= fieldaxis(1\);
% dt \= fieldaxis(2\) \- c1;
% edge \= c1 \- dt/2;
% qv \= mod(qv\-edge,2\*pi)\+edge;
% end
% h1 \= histc(qv, binEdgesFromCenters(fieldaxis));
% h1 \= h1(1:end\-1\);
if (incllastrun)
 indsExpression \= 'true(size(track.run))';
else
 indsExpression \= '1:length(track.run) \~\= length(track.run)';
end
qv \= eset.gatherFromSubField('run', fieldname, 'indsExpression', indsExpression);
sp \= eset.gatherFromSubField('run', 'speed', 'indsExpression', indsExpression);

valid \= true(\[1 length(qv)]);
if (\~isempty(validname))
 for k \= 1:length(validname)
 opnum \= min(k, length(validoperation));
 valid \= valid \& validoperation{opnum}(eset.gatherFromSubField('run', validname{k}, 'indsExpression', indsExpression));
 end
end

if (\~isempty(timerange))
 reti \= eset.gatherFromSubField('run', 'eti', 'indsExpression', indsExpression);
 validtim \= reti \>\= min(timerange) \& reti \<\= max(timerange);
else
 validtim \= true(\[1 length(qv)]);
end


qv \= qv(:,valid\&validtim);
sp \= sp(:,valid\&validtim);

h2 \= zeros(size(fieldcenters));
for j \= 1:length(fieldcenters)
 if (polar)
 qv \= mod(qv \- fieldcenters(j) \+ pi, 2\*pi) \- pi \+ fieldcenters(j);
 end
 
 w \= weightFun(qv,fieldcenters(j));
 if (\~vsDistance)
 h2(j) \= sum(w)\* eset.expt(1\).dr.interpTime / 60;
 else
 h2(j) \= sum(w.\*sp)\* eset.expt(1\).dr.interpTime;
 end
end
% %toc
% if (\~vsDistance)
% h2 \= histc(qv, binEdgesFromCenters(fieldaxis)) \* eset.expt(1\).dr.interpTime / 60;
% h2 \= h2(1:end\-1\);
% else
% \[\~,\~,\~,\~,h2] \= meanyvsx (qv, sp, binEdgesFromCenters(fieldaxis));
% h2 \= h2\*eset.expt(1\).dr.interpTime;
% end
% %toc

eb \= sqrt(h1\)./h2;
if (nargout \> 0\)
 h \= h1\./h2;
end
if (nargout \=\= 0 \|\| makePlot)
 htemp \= h1\./h2;
 if (r2d)
 fieldaxis \= rad2deg(fieldaxis);
 end
 errorbar (fieldaxis, htemp, eb);
 xlabel (fieldname);
 if (vsDistance)
 ylabel ('reorientation rate (dist^{\-1})');
 else
 ylabel ('reorientation rate (min$^{\-1}$)');
 end
 title (\[eset.defaultTitle ': reorientation rate vs. instantaneous ' fieldname]);
end
%disp (\['last line of makeReorientationHistogram \- ', num2str(toc(ts1\))]);
%{
toc
bob \= whos();
nm \= {bob.name};
nm \= setdiff(nm, {'h'});
clear(nm{:}, 'bob', 'nm');
toc
%}
\-\-\-

\#\#\# File: indToTrack.m (ID: @ExperimentSet.17\)

function varargout \= indToTrack(eset, ind)
% converts a position in list of all tracks into a track or expt, track indices
% function varargout \= indToTrack(eset, ind)
%
% \[exptind,tracknum] \= eset.indToTrack(ind)
% trackptr \= eset.indToTrack(ind)
%
% say t \= \[eset.expt.track];
% then trackptr \= t(ind) \= eset.expt(exptind).track(ind)
%
% outputs:
% if 1 output: 
% TRACKPTR \= indicated track (handle)
% if 2 outputs:
% EXPTIND, TRACKNUM: track is found at ESET.expt(EXPTIND).TRACKNUM
%
% inputs:
% ESET: a member of the ExperimentSet class
% IND: the index of the track in \[eset.expt.track]

if (nargout \=\= 1\)
 t \= \[eset.expt.track];
 varargout{1} \= t(ind);
 return
end

eind \= zeros(size(\[eset.expt.track]));
tind \= eind;
k \= 0;
for j \= 1:length(eset.expt)
 tinds \= 1:length(eset.expt(j).track);
 eind(k \+ tinds) \= j;
 tind(k \+ tinds) \= tinds;
 k \= k \+ length(eset.expt(j).track);
end

varargout{1} \= eind(ind);
varargout{2} \= tind(ind);

\-\-\-

\#\#\# File: getAutocorrTau.m (ID: @ExperimentSet.18\)

function tau \= getAutocorrTau (eset, varargin)
%function setAutocorrTau (eset, varargin)

%sets the autocorrelation time constant
%uses the autocorrelation of the field (default vnorm)
%and sets tau to be the first time s.t. ac(tau) \<\= 1/e
%
%optional arguments:
%'fieldname', fieldname (default 'vnorm') \-\- but note default call with no
% additional arguments is different
%calls to ExperimentSet.autocorrelate, including
%'row', row number(s)
%if row \= m, just finds the correlation of track.dq.(fieldnames)(m,:)\\
%'inRuns', true/false
%if inRuns is true, we take the autocorrelation over the whole track, but
%first interpolate the fields over only the run indices
%this is useful if the fields are ill\-defined between runs (e.g. velocity
%direction)
%'withinRuns', true/false
%if withinRuns is true, we find the correlation only within each run
%'isangle', true/false
% if isangle is true, then we compute the correlation as cos (theta1 \-
% theta2\) instead of as theta1\*theta2
%
%default autocorrelation is 'fieldname', theta, 'isangle', true, 'inRuns',
%true
%and is performed if no optional args are passed in

if isempty(varargin)
 \[ac, np, tx] \= eset.autocorrelate('theta', 'isangle', true, 'inRuns', \~isempty(\[eset.expt(1\).track.run]));
else
 fieldname \= 'vnorm';
 varargin \= assignApplicable(varargin);
 \[ac, np, tx] \= eset.autocorrelate(fieldname, varargin{:});
end

ac \= ac./np;
ac \= ac / ac(1\);

I \= find(ac \< exp(\-1\), 1, 'first');

tau \= tx(I);

 

\-\-\-

\#\#\# File: expt.globalLookupTable (ID: @ExperimentSet.19\)


\-\-\-

\#\#\# File: meanSubField2vsSubField1\.m (ID: @ExperimentSet.20\)

function \[x,meany,standarderror,standarddeviation] \= meanSubField2vsSubField1 (eset, field1name, subfield1name, field2name, subfield2name, field1axis, varargin)
%function \[x,meany,standarderror,standarddeviation] \= meanSubField2vsSubField1 (eset, field1name, subfield1name, field2name, subfield2name, field1axis, varargin)
%
%gathers two sub fields (with varargin arguments for both) and calls meanyvsx on them
%if no return arguments are requested, plots the result
%note that field1axis is bin edges \[edge1,edge2\) and x is the mean value
%of subfield1 in that bin
%
%passing 'inds', inds will take value only from inds in this
%fashion (same for ydata/field2name):
%xdata \= eset.gatherSubField(field1name, subfield1name, varargin{:});
%xdata \= xdata(inds)

inds \= \[];
varargin \= assignApplicable(varargin);


xdata \= eset.gatherSubField(field1name, subfield1name, varargin{:});
ydata \= eset.gatherSubField(field2name, subfield2name, varargin{:});

if (\~isempty(inds))
 xdata \= xdata(inds); %xdata must be 1\-D
 ydata \= ydata(:,inds);
end
\[x,meany,standarderror,standarddeviation] \= meanyvsx(xdata, ydata, field1axis);

if (nargout \=\= 0\)
 errorbar (x,meany,standarderror); title (eset.defaultTitle);
 xlabel(subfield1name);
 ylabel(\['\<' subfield2name '\>']);
 embiggen();
end
\-\-\-

\#\#\# File: setAutocorrTau.m (ID: @ExperimentSet.21\)

function setAutocorrTau (eset, varargin)
%function setAutocorrTau (eset, varargin)
%
%sets the autocorrelation time constant
%uses the autocorrelation of the field (default vnorm)
%and sets tau to be the first time s.t. ac(tau) \<\= 1/e
%
%optional arguments:
%'fieldname', fieldname (default 'theta') \-\- but note default call with no
% additional arguments is different
%calls to ExperimentSet.autocorrelate, including
%'row', row number(s)
%if row \= m, just finds the correlation of track.dq.(fieldnames)(m,:)\\
%'inRuns', true/false
%if inRuns is true, we take the autocorrelation over the whole track, but
%first interpolate the fields over only the run indices
%this is useful if the fields are ill\-defined between runs (e.g. velocity
%direction)
%'withinRuns', true/false
%if withinRuns is true, we find the correlation only within each run
%'isangle', true/false
% if isangle is true, then we compute the correlation as cos (theta1 \-
% theta2\) instead of as theta1\*theta2
%
%default autocorrelation is 'fieldname', theta, 'isangle', true, 'inRuns',
%true
%and is performed if no optional args are passed in

eset.autocorr\_tau \= eset.getAutocorrTau(varargin{:});

 

\-\-\-

\#\#\# File: toMatFiles.m (ID: @ExperimentSet.22\)

function toMatFiles(eset, fstub)
% saves every experiment in eset to a separate mat flile
% function toMatFiles(eset, fstub)
%
% saves every experiment in eset to a separate mat flile
% variable name is experiment\_j in file fstub\_experiment\_j.mat
%
% outputs: none (to disk)
% inputs: 
% ESET: a member of the ExperimentSet class
% FSTUB: the file stub to which \_experiment\_1\.mat, etc. will be appended

for j \= 1:length(eset.expt)
 eval(\['experiment\_' num2str(j) ' \= eset.expt(j);']);
 save (\[fstub '\_experiment\_' num2str(j)], \['experiment\_' num2str(j)]);
end

\-\-\-

\#\#\# File: fromMatFiles.m (ID: @ExperimentSet.23\)

function eset \= fromMatFiles(fstub, fileinds, segment)
% reloads experiment set from mat files
% function eset \= fromMatFiles(fstub, fileinds)
%
% loads every experiment in eset from a separate mat flile
% variable name is experiment\_j in file fstub\_experiment\_j.mat
%
% outputs: an experiment set
% inputs:
% FSTUB: everything preceding \_experiment\_j.mat in the file name
% : or the path to a directory containting files
% FILEINDS: which (j) experiments to load
% pass fileinds empty or 'all' to load all with correct form
% SEGMENT: whether to segment tracks after loading (segmentation is not
% saved currently) \- default false
% example:
% fstub \= 'D:\\Marc Processed\\maggots\\ethyl acetate 4 pct 20 2000\\odor4pct'
% eset \= ExperimentSet.fromMatFiles(fstub);
existsAndDefault('segment', false);

if (\~existsAndDefault ('fstub', \[]))
 \[filename,pathname] \= uigetfile('\*experiment\*.mat', 'select mat file(s) to load','MultiSelect', 'on');
 if (\~iscell(filename))
 filename \= {filename};
 end
 
 %{
 fileinds \= zeros(size(filename));
 temp \= regexp(filename{1}, '\_experiment\_(\\d\+).mat', 'split');
 fstub \= fullfile(pathname, temp{1});
 for j \= 1:length(filename)
 temp \= regexp(filename{j}, '\_experiment\_(\\d\+).mat', 'tokens');
 fileinds(j) \= str2double(temp{1});
 end
 %}
 for j \= 1:length(filename)
 filenames{j} \= fullfile(pathname, filename{j});
 end
 fileinds \= \[];
 % fileinds \= 1:length(filenames);
else if iscell(fstub)
 filenames \= fstub;
 fileinds \= \[];
else if isdir(fstub)
 d \= dir(fullfile(fstub, '\*experiment\*.mat'));
 if (isempty(d))
 d \= dir(fullfile(fstub, '\*.mat'));
 if (isempty(d))
 disp (\['no files with appropriate name structure found in ' fstub]);
 eset \= \[];
 return;
 end
 end
 for j \= 1:length(d)
 filenames{j} \= fullfile(fstub, d(j).name);
 end
 fileinds \= \[];
 %fileinds \= 1:length(filenames);
else if (\~exist('fileinds', 'var') \|\| isempty(fileinds) \|\| strcmpi(fileinds, 'all'))
 d \= dir(\[fstub '\_experiment\_\*.mat']);
 fileinds \= zeros(size(d));
 for j \= 1:length(d)
 ind \= strfind(d(j).name, '\_');
 if (\~isempty(ind))
 ind \= ind\+1;
 ind2 \= strfind(d(j).name, '.mat');
 if (\~isempty(ind2\))
 inds \= ind(end):(ind2(end)\-1\);
 %d(j).name(inds)
 fileinds(j) \= str2double(d(j).name(inds));
 end
 end
 end
 fileinds \= fileinds(fileinds \~\= 0\);
end;end;end;end;

if (\~exist('filenames', 'var'))
 for j \= 1:length(fileinds)
 filenames{j} \= \[fstub '\_experiment\_' num2str(fileinds(j)) '.mat'];
 end
end


ts1 \= tic;

eset \= ExperimentSet();
foundany \= false;
for k \= 1:length(filenames) 
 try
 result \= load (filenames{k});
 fldnm \= fieldnames(result);
 nfound \= 0;
 for j \= 1:length(fldnm)
 if (isa(result.(fldnm{j}), 'Experiment')); 
 if (\~foundany)
 eset.expt \= result.(fldnm{j});
 foundany \= true;
 else
 eset.expt \= \[eset.expt result.(fldnm{j})];
 end
 nfound \= nfound \+ 1;
 end
 end
 toc(ts1\);
 if (nfound \~\= 1\)
 disp (\['warning: loaded ' num2str(nfound) ' experiments from ' filenames{k}]);
 end
 catch me
 disp (\['problem loading experiment from matfile: ' filenames{k}]);
 disp (me.getReport());
 end
end

 

if (segment)
 disp('segmenting');
 try
 eset.executeTrackFunction('segmentTrack');
 catch me
 disp(me.getReport());
 disp ('segmentation failed');
 end
end
disp (\['finished \- ' num2str(toc(ts1\))]);
% 
% 
% if (matlabpool('size') \~\= 0\)
% %fileinds
% parfor k \= 1:length(fileinds) 
% disp(\['start ' num2str(k) ' \- ' num2str(toc(ts1\))])
% j \= fileinds(k);
% result \= load (\[fstub '\_experiment\_' num2str(j) '.mat'], \['experiment\_' num2str(j)]);
% fldnm \= fieldnames(result);
% expt(k) \= result.(fldnm{1});
% disp(\['end ' num2str(k) ' \- ' num2str(toc(ts1\))]);
% end
% 
% eset \= ExperimentSet();
% eset.expt \= expt;
% disp(\['loaded all \- ' num2str(toc(ts1\))]);
% else
% for k \= 1:length(fileinds) 
% j \= fileinds(k);
% load (\[fstub '\_experiment\_' num2str(j) '.mat'], \['experiment\_' num2str(j)]);
% toc(ts1\);
% end
% 
% eset \= ExperimentSet();
% %we have to initialize eset.expt to be an array of experiment or we
% %have problems later
% j \= fileinds(1\);
% eval(\['eset.expt \= experiment\_' num2str(j) ';']);
% 
% for k \= 1:length(fileinds) 
% j \= fileinds(k);
% eval(\['eset.expt(' num2str(k) ') \= experiment\_' num2str(j) ';']);
% 
% end
% end

\-\-\-

\#\#\# File: executeExperimentFunction.m (ID: @ExperimentSet.24\)

function varargout \= executeExperimentFunction(eset, func, varargin)
% executes a given method from the Experiment class on each expt
% function result \= executeExperimentFunction(eset, func, varargin)
%
% func is the string name of a function in experiment class
% result{j} \= eset.expt(j).(func)(varargin{:}) 
%
% outputs:
% VARARGOUT: up to the number of arguments returned by func
% in pseudo\-code, \[varargout{1}, varargout{2}, etc.] \=
% \[eset.expt.func(varargin)]
% inputs: 
% ESET: a member of the ExperimentSet class
% FUNC: a string that is the name of a method in the Experiment class
% VARARGIN: passed to FUNC

if (nargout \> 0 \&\& objNargout(eset.expt(1\), func) \~\= 0\)
 
 for j \= 1:length(eset.expt) 
 
 \[result{1:nargout}] \= eset.expt(j).(func)(varargin{:});
 allresult{j} \= result;
 end
 
 for k \= 1:nargout
 clear temp;
 for j \= 1:length(allresult)
 temp{j} \= allresult{j}{k};
 end
 varargout{k} \= temp;
 end
else
 if (true \|\| matlabpool('size') \=\= 0\)
 for j \= 1:length(eset.expt)
 eset.expt(j).(func)(varargin{:});
 end
 else
 parfor j \= 1:length(eset.expt)
 eset.expt(j).(func)(varargin{:});
 end
 end
end


\-\-\-

\#\#\# File: fromFiles.m (ID: @ExperimentSet.25\)

function eset \= fromFiles (varargin)
% loads a set of experiments from .bin files
% function eset \= ExperimentSet.fromFiles (varargin)
% 
% Load a bunch of tracks.bin into the experiment. modified from ARC code
%
% output: an Experiment Set
% inputs: variable
% 'minpts', XX sets the minimum number of points in the tracks to load
% 'loadcontour', true/false (default true); whether to load Maggot ctrs
% with no (additional) arguments, user selects bin files to load
% if 1st argument is a directory, loads all .bin files from that
% directory; ignores all other args
% with \>1 argument, each argument is the file name to load
%'camcalinfo', CameraCalibration struct or \[] to ignore
%'parallel', \[false]/true \- whether to load in parallel using matlab
% parallel computing library
%'sortbydate', \[false]/true \- if expts should be sorted by file date; if
%false they are the default sort order, which I think is alphabetical

%Set params
minpts \= 100;
loadcontour \= true;
camcalinfo \= \[];
parallel \= false;
sortbydate \= false;
fixedInterpTime \= \[];
varargin \= assignApplicable(varargin);

%Build the eset
eset \= ExperimentSet();

%Get the file names
if (isempty(varargin))
 \[fn, basedir] \= uigetfile('\*.bin','Select the .bin files you would like to use', 'MultiSelect', 'on');
 if (\~iscellstr(fn))
 fn \= {fn};
 end
 for j \= 1:length(fn)
 fn{j} \= \[basedir fn{j}];
 end
else
 if (isdir(varargin{1}))
 basedir \= varargin{1};
 if (basedir(end) \~\= '\\')
 basedir \= \[basedir '\\'];
 end
 d \= dir(\[basedir '\*.bin']);
 if (sortbydate)
 \[\~,I] \= sort(\[d.datenum]);
 d \= d(I);
 end
 for j \= 1:length(d)
 fn{j} \= \[basedir d(j).name]; %\#ok\<\*AGROW\>
 end
 else
 fn \= varargin;
 end
end

%Ignore any files that have been marked as bad
valid \= true(size(fn));
for j \= 1:length(fn)
 \[bd,f] \= fileparts(fn{j});
 if exist (fullfile(bd, \[f '.bad']), 'file')
 warning ('EFF:BAD', \['file: ' f ' is marked as bad and will not be loaded. To load file, remove ' f '.bad from directory and rerun command']);
 valid(j) \= false;
 end
end
fn \= fn(valid);
valid \= true(size(fn));


expt \= repmat(Experiment(), size(valid));

if (parallel \&\& length(fn) \> 1\)
%Load the experiments in parallel
 ts1 \= tic;
 if (matlabpool('size') \=\= 0\)
 disp ('opening parallel processes'); 
 matlabpool;
 toc(ts1\);
 closepool \= true;
 else
 closepool \= false;
 end
 
 
 parfor n\=1:length(fn)
 try 
 disp(\['Loading file \#' num2str(n) ' : ' fn{n}]);
 ind \= strfind(fn{n}, '.');
 if (isempty(ind))
 disp(\['problem with ' fn{n}]);
 end
 %timfn\=\[fn{n}(1:ind(end)) 'tim'];
 if (length(camcalinfo) \>\= n)
 %Actually load the experiment!!
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 \[temp,valid(n)] \= Experiment.fromFile (fn{n}, \[], loadcontour, camcalinfo(n), minpts);
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 if (valid(n) \&\& \~isempty(temp))
 expt(n) \= temp;
 end
 else
 %Actually load the experiment!!
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 \[temp,valid(n)] \= Experiment.fromFile (fn{n}, \[], loadcontour, camcalinfo, minpts);
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 if (valid(n)\&\& \~isempty(temp))
 expt(n) \= temp;
 end
 end
 disp(\['finished loading file \#' num2str(n) ' : t \= ' num2str(toc(ts1\))]);
 catch me
 %valid(n)\=0;
 disp('\*\*\*\*\*\*\*\*\*\*');
 disp(me.getReport());
 disp(\[fn{n} 'failed to process!']);
 disp('\*\*\*\*\*\*\*\*\*\*');
 end
 end
 if (closepool)
 disp('closing parallel processes'); ts2 \= tic;
 matlabpool close;
 toc(ts2\);
 end
 disp(\['total time to load ' num2str(length(fn)) ' files \= ' num2str(toc(ts1\))]);
 
else
%Load the experiments in series:
 for n\=1:length(fn)
 disp(\['Loading file \#' num2str(n) ' : ' fn{n}]);
 ind \= strfind(fn{n}, '.');
 if (isempty(ind))
 disp(\['problem with ' fn{n}]);
 end
 %timfn\=\[fn{n}(1:ind(end)) 'tim'];
 if (length(camcalinfo) \>\= n)
 %Use separate camcalinfo's for each expt
 try
 \[ppp, fff] \= fileparts(fn{n});
 if (exist(fullfile(ppp, \[fff '.bad']), 'file'))
 disp (\[fn{n} ' is marked as a bad file \-\- ignoring.']);
 disp (\['fix problem and delete file: ' fff '.bad']);
 temp \= \[];
 valid(n) \= false;
 else
 %Actually load the experiment!!
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 temp \= Experiment.fromFile (fn{n}, \[], loadcontour, camcalinfo(n), minpts);
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 end
 if (\~isempty(temp))
 expt(n) \= temp;
 else
 valid(n) \= false;
 end
 catch me
 disp('\*\*\*\*\*\*\*\*\*\*');
 disp(\[fn{n} 'failed to process!']);
 disp('\*\*\*\*\*\*\*\*\*\*');
 disp (me.getReport());
 valid(n) \= false;
 \[ppp, fff] \= fileparts(fn{n});
 fidd \= fopen(fullfile(ppp, \[fff '.bad']),'wt');
 fprintf(fidd, me.getReport());
 fclose(fidd);
 end
 else
 %Use the same camcalinfo for all expt's
 try
 %Actually load the experiment!!
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 temp \= Experiment.fromFile (fn{n}, \[], loadcontour, camcalinfo, minpts);
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 if (\~isempty(temp))
 expt(n) \= temp;
 else
 valid(n) \= false;
 end
 catch me
 disp('\*\*\*\*\*\*\*\*\*\*');
 disp(\[fn{n} 'failed to process!']);
 disp('\*\*\*\*\*\*\*\*\*\*');
 disp (me.getReport());
 valid(n) \= false;
 end
 end
 end
end

if (\~exist ('expt', 'var') \|\| isempty(expt))
 disp ('no valid experiments loaded');
 eset \= repmat(eset, 0\);
 return;
end

%Only keep the valid experiments
eset.expt \= expt(valid);
try %restore try deleted by nbernat 05\-20 \-\- don't understand how this worked at all afterwards
 %Calculate derived quantities
 dr \= \[expt.dr];
 if ((\~isempty(fixedInterpTime) \&\& fixedInterpTime \> 0\) \|\| min(\[dr.interpTime]) \< 0\.98 \* max(\[dr.interpTime])) %\#ok
 if ((\~isempty(fixedInterpTime) \&\& fixedInterpTime \> 0\)) %\#ok
 mdr \= num2str(fixedInterpTime);
 else
 mdr \= num2str(min(\[dr.interpTime]));
 end
 eset.evaluateTrackExpression(\['track.dr.interpTime \= ' mdr ';']);
 mdr \= min(\[dr.interpTime]);
 for j \= 1:length(expt)
 expt(j).dr.interpTime \= mdr;
 end
 eset.executeTrackFunction('recalculateDerivedQuantities');
 eset.executeExperimentFunction('assignGlobalQuantities');
 end
catch me
 disp(me.getReport());
end
\-\-\-

\#\#\# File: setDerivationRulesByPeristalsisFrequency.m (ID: @ExperimentSet.26\)

function \[meanPeriFreq, freqs, psd] \= setDerivationRulesByPeristalsisFrequency (eset, varargin)
%function setDerivationRulesByPeristalsisFrequency (eset, varargin)

%homogeonize interpolation time
it \= eset.gatherSubField('dr', 'interpTime');
interpTime \= percentile(it, 0\.05\);
if (any (it \~\= interpTime))
 warning ('ESET:ITIME', \['eset has non homogeneous interpolation times; updating to all have same \- ' num2str(interpTime)]); 
 eset.evaluateTrackExpression(\['track.dr.interpTime \= ' num2str(interpTime, 10\) ';']);
 eset.executeTrackFunction('recalculateDerivedQuantities'); 
end
if (interpTime \>\= 0\.25\)
 warning ('ESET:ITIME','Interpolation Time is too slow for likely peristalsis frequencies');
end

im \= eset.gatherField('imid');
im \= im(:,all(isfinite(im)));
sigma \= min(1\.5, 0\.1/interpTime);
vm \= sqrt(sum(deriv(im,sigma).^2\))/interpTime;

%important: nuke large jumps between tracks!
vm(vm \> percentile(vm, 0\.98\)) \= percentile(vm, 0\.98\);

Hs \= spectrum.welch('Hamming', 20/interpTime);
hpsd \= Hs.psd(vm \- mean(vm), 'Fs', 1 / interpTime, 'NormalizedFrequency', false); ps \= hpsd.Data; f \= hpsd.frequencies;
freqs \= f;
psd \= ps;

cutoffFrequency \= 0\.4;
ps \= ps(f \> cutoffFrequency);
f \= f(f \> cutoffFrequency);
\[\~,I] \= max(ps);
periFreq \= f(I);
if (nargout \> 0\)
 meanPeriFreq \= periFreq;
end
%plot (f, ps, f(I), ps(I), 'r\*');

if (I \=\= 1 \|\| I \=\= length(ps))
 warning ('ESET:PERI','failed to detect a peristalsis peak, aborting');
 return;
end

smoothTime \= 0\.5/periFreq;
derivTime \= smoothTime/2;

for j \= 1:length(eset.expt)
 eset.expt(j).dr.interpTime \= interpTime;
 eset.expt(j).dr.smoothTime \= smoothTime;
 eset.expt(j).dr.derivTime \= derivTime;
end
eset.evaluateTrackExpression(\['track.dr.smoothTime \= ' num2str(smoothTime, 10\) ';']);
eset.evaluateTrackExpression(\['track.dr.derivTime \= ' num2str(derivTime, 10\) ';']);
eset.evaluateTrackExpression(\['track.so.minRunTime \= ' num2str(2\.5/periFreq, 10\) ';']);
eset.evaluateTrackExpression(\['track.so.smoothBodyTime \= ' num2str(0\.2/periFreq, 10\) ';']);
eset.executeTrackFunction('recalculateDerivedQuantities');
eset.executeExperimentFunction('assignGlobalQuantities');
\-\-\-

\#\#\# File: makeHistogram.m (ID: @ExperimentSet.27\)

function \[h,eb] \= makeHistogram(eset, fieldname, fieldaxis, varargin)
% generates a histogram of expt.track.getDerivedQuantity(fieldname,varargin{:})
% function \[h,eb] \= makeHistogram(eset, fieldname, fieldaxis, varargin)
%
% generates a histogram of all values in expt.track.getDerivedQuantity(fieldname,varargin{:})
% if no arguments are specified, generates a plot of that histogram
%
% 
% outputs:
% H: (optional), the histogram; if no output arguments, plots histogram
% inputs:
% ESET: a member of the ExperimentSet class
% FIELDNAME: the name of the field over which to make the histogram 
% FIELDAXIS: bin centers for the histogram
% VARARGIN: 
% anything to ExperimentSet.gatherField
% optional parameter/value pairs
% 'r2d',true \- when plotting, plot fieldaxis in degrees instead of radians
% 'polar',true \- adjust data so that the 0 degree bin is the same size as the
% next bin; the last bin may be screwed by this, so be careful
% in other words, passing polar, fieldaxis \= deg2rad(0:30:330\) is good
% passing polar,true deg2rad(0:30:360\) will nuke your last bin
% it's necessary to pass polar as an argument if you are using
% time chunks to calculate proper error bars and the data is
% polar; otherwise the averaging due to time chunks can cause
% problems if the chunk passes through the x\-axis
% 'autocorr\_tau' \- autocorrelation time constant (in seconds)
% \_t0 \~\= exp(\-t/tau)

r2d \= false;
polar \= false;
%timechunk \= \[];
autocorr\_tau \= \-1;
varargin \= assignApplicable(varargin);
data \= eset.gatherField(fieldname, varargin{:});
if (autocorr\_tau \< 0\)
 if (eset.autocorr\_tau \<\= 0\)
 disp ('calculating and setting autocorrelation time constant');
 eset.setAutocorrTau;
 end
 autocorr\_tau \= eset.autocorr\_tau;
end

if (polar)
 data \= unwrap(data);
end
%{
if (\~isempty(timechunk))
 t \= eset.gatherField('eti', varargin{:});
 tx \= min(t):timechunk:(max(t)\+timechunk); %\#ok
 binsize \= timechunk/eset.expt(1\).dr.interpTime;
 \[\~,my,\~,\~,sumy] \= meanyvsx(t,data,tx);
 nelems \= sumy./my;
 howmany \= nelems./binsize;
 data \= my(isfinite(howmany) \& howmany \> 0\);
 howmany \= howmany(isfinite(howmany) \& howmany \> 0\);
else
 howmany \= ones(size(data));
end
%}

if (polar)
 c1 \= fieldaxis(1\);
 dt \= fieldaxis(2\) \- c1;
 edge \= c1 \- dt/2;
 data \= mod(data\-edge,2\*pi)\+edge;
end
h1 \= hist(data(isfinite(data)), fieldaxis);
n \= sum(h1\);
dti \= eset.expt(1\).track(1\).dr.interpTime;
k \= sqrt((1 \+ exp(\-dti/autocorr\_tau))/(1 \- exp(\-dti/autocorr\_tau)));
eb \= k\*sqrt((h1/n).\*(1\-h1/n))\*sqrt(n); %sigma \= sqrt(Npq)
%{
low \= 2\*fieldaxis(1\)\-fieldaxis(2\);
high \= 2\*fieldaxis(end)\-fieldaxis(end\-1\);
fieldedges \= 1/2 \* (\[low fieldaxis] \+ \[fieldaxis high]);
\[\~,bin] \= histc(data,fieldedges);
h1 \= zeros(size(fieldaxis));

for j \= 1:length(fieldaxis)
 h1(j) \= sum(howmany(bin \=\= j));
end
%}
if (nargout \=\= 0\)
 if (r2d)
 bar (rad2deg(fieldaxis), h1\); hold on; title (eset.defaultTitle);
 errorbar (rad2deg(fieldaxis), h1, eb,'k.', 'LineWidth', 3\); hold off
 else
 bar (fieldaxis, h1\); hold on; title (eset.defaultTitle); 
 errorbar (fieldaxis, h1, eb,'k.', 'LineWidth', 3\); hold off
 end
 
 xlabel(fieldname); ylabel('counts'); embiggen();
else
 h \= h1;
 
end

\-\-\-

\#\#\# File: gatherFromSubField.m (ID: @ExperimentSet.28\)

function qvec \= gatherFromSubField(eset, subfield, fieldname, varargin)
%function qvec \= gatherField(eset, subfield, fieldname, varargin)
%
%what you would get from qvec \= \[eset.expt.gatherSubField(subfield, fieldname,
%varargin)] 
%if that were a valid matlab function call
%
%passing 'inds', inds returns only qvec(:,inds) (and inds does not
%propogate to later function calls)
% see Experiment.gatherFromSubField, 
% see Track.getSubFieldDQ and 
% TrackPart.getDerivedQuantity for optional params

inds \= \[];
varargin \= assignApplicable(varargin);
qvec \= \[];
if (strcmpi(fieldname, 'expNum'))
 for j \= 1:length(eset.expt)
 qv{j} \= j\*ones(size(eset.expt(j).gatherFromSubField(subfield,'trackNum', varargin{:}))); 
 end 
 qvec \= \[qv{:}];
else
 for j \= 1:length(eset.expt)
 qvec \= \[qvec eset.expt(j).gatherFromSubField(subfield, fieldname, varargin{:})];
 end
end
if (\~isempty(inds))
 qvec \= qvec(:,inds);
end

\-\-\-

\#\#\# File: meanField2vsField1\_slidingwindow.m (ID: @ExperimentSet.29\)

function \[x,meany,standarderror,standarddeviation] \= meanField2vsField1\_slidingwindow (eset, field1name, field2name, field1centers, field1binsize, windowType, varargin)
% the mean value of points in field2 corresponding to values of field1
% function \[x,meany,standarderror,standarddeviation] \= meanField2vsField1
% (eset, field1name, field2name, field1axis, varargin)
%
% gathers two fields (with varargin arguments for both) and calls meanyvsx on them
% if no return arguments are requested, plots the result
% note that field1axis is bin edges \[edge1,edge2\) and x is the mean value
% of field1 in that bin
%
% outputs:
% X: the x\-axis, the mean value of field1 for all points in each bin
% MEANY: the mean value of field2 for all points in each bin
% STANDARDERROR: the standard deviation of field2 in each bin / 
% sqrt of number of points in each bin
% STANDARDDEVIATION: the standard deviation of field2 in each bin
% inputs:
% ESET: a member of the ExperimentSet class
% FIELD1NAME: the name of the independent field (must be 1D)
% FIELD2NAME: the name of the dependent field (may be ND)
% FIELD1AXIS: bin edges \[edge1,edge2\); thus length(x) \=
% length(field1axis) \- 1; and x(j) is the mean value of all points
% with field1 \>\= field1axis(j) and field1 \< field1axis(j\+1\)
% VARARGIN:
% any option that can be passed to ExperimentSet/gatherField
% 'inds', inds will take value only from inds in this
% fashion (same for ydata/field2name):
% xdata \= eset.gatherField(field1name, varargin{:});
% xdata \= xdata(inds)
% 'field1dim' \- if field1 is ND instead of 1D, choose this dimension
% \- e.g. if field1name is 'loc', pass 'field1dim',1 for x
% position
% 'polar', true/false \-\- adjusts xdata for polar histogram
% 'autocorr\_tau' \- autocorrelation time constant (in seconds)
% \_t0 \~\= exp(\-t/tau)
% 'timerange' \-\- only consider within this time period
inds \= \[];
field1dim \= \[];
autocorr\_tau \= \-1;
timerange \= \[];
polar \= false;
varargin \= assignApplicable(varargin);
if (autocorr\_tau \< 0\)
 if (eset.autocorr\_tau \<\= 0\)
 disp ('calculating and setting autocorrelation time constant');
 eset.setAutocorrTau;
 end
 autocorr\_tau \= eset.autocorr\_tau;
end
xdata \= eset.gatherField(field1name, varargin{:});
if \~isempty(field1dim)
 xdata \= xdata(field1dim,:);
end

ydata \= eset.gatherField(field2name, varargin{:});
if (\~isempty(timerange))
 eti \= eset.gatherField('eti', varargin{:});
 timinds \= eti \>\= min(timerange) \& eti \<\= max(timerange);
 if (\~isempty(inds))
 if (max(inds) \> 1\)
 inds2 \= false(size(timinds));
 inds2(inds) \= true;
 inds \= inds2;
 end
 inds \= inds \& timinds;
 else
 inds \= timinds;
 end
end
if (\~isempty(inds))
 xdata \= xdata(inds); %xdata must be 1\-D
 ydata \= ydata(:,inds);
end
\[x,meany,standarderror,standarddeviation] \= meanyvsx\_slidingwindow(xdata, ydata, field1centers, field1binsize, windowType, polar);
dti \= eset.expt(1\).track(1\).dr.interpTime;
k \= sqrt((1 \+ exp(\-dti/autocorr\_tau))/(1 \- exp(\-dti/autocorr\_tau)));
standarderror \= k\*standarderror;
if (nargout \=\= 0\)
 shadedErrorPlot (x,meany,standarderror); title (eset.defaultTitle);
 xlabel(field1name);
 ylabel(\['$\<$' field2name '$\>$']);
 embiggen();
end
\-\-\-

\#\#\# File: evaluateTrackExpression.m (ID: @ExperimentSet.30\)

function result \= evaluateTrackExpression(eset, expression)
% evaluates a given expression at every track
% function result \= evaluateTrackExpression(eset, expression)
%
% concatinates the results of eset.expt(j).evaluateTrackExpression(eset,
% expression) (if any)
% attempts to convert the resulting cell array to a matrix 
%
% details from Experiment/evaluateTrackExpression
% evaluates the expression for each track in experiment
% expression should use 'track' as the name of the track
% and 'expt' as the name of the experiment
%
% examples:
% to get the number of runs in each track
% numruns \= expt.evaluateTrackExpression('length(track.run)');
%
% to set all the segmentation options to a default value
% expt.evaluateTrackExpression('track.so \= expt.so');
%
% result is returned as a matrix if possible, otherwise as a cell
%
% outputs:
% RESULT: optional; the result of the expression for each track
% asking for an output from an expression that doesn't produce one
% will result in errors
% inputs:
% ESET: a member of the ExperimentSet class
% EXPRESSION: the expression to evaluate

for j \= 1:length(eset.expt)
 if (nargout \> 0\)
 mycell{j} \= eset.expt(j).evaluateTrackExpression(expression);
 else
 eset.expt(j).evaluateTrackExpression(expression);
 end
end


if (nargout \> 0\)
 try 
 result \= cell2mat(mycell);
 catch me
 result \= mycell;
 end
end



\-\-\-

\#\#\# File: autocorrelate.m (ID: @ExperimentSet.31\)

function \[ac, np, tx, nt] \= autocorrelate (eset, fieldname, varargin)
%finds the autocorrelation of a field with itself
%function \[ac, np, tx, nt] \= autocorrelate (eset, fieldname, varargin)
%
%
%auto correlates track field (see Track.crosscorrelate)
%
%outputs:
%AC is the unnormalized auto\-correlation (normalized is ac./np)
%TX is the time axis for the cross correlation
%NP is the number of points contributing to a certain bin
%NT is the number of tracks contributing to a certain bin
%
%we define the auto\-correlation to be
%ac(T) \= ; 0 denotes the average
%AC is the return 1xN vector AC(j) \= AC(j\-1\);
%
%inputs:
%EXPT: a member of the Experiment class
%FIELDNAME: the name of the field to auto\-correlate
%VARARGIN: any parameter/value pair passed to Track/crosscorrelate, see
%below
%
%arguments to pass in:
%'row', row number(s)
%if row \= m, just finds the correlation of track.dq.(fieldnames)(m,:)\\
%'inRuns', true/false
%if inRuns is true, we take the autocorrelation over the whole track, but
%first interpolate the fields over only the run indices
%this is useful if the fields are ill\-defined between runs (e.g. velocity
%direction)
%'withinRuns', true/false
%if withinRuns is true, we find the correlation only within each run
%'isangle', true/false
% if isangle is true, then we compute the correlation as cos (theta1 \-
% theta2\) instead of as theta1\*theta2
%'timerange', \[mintime maxtime] \-\- only consider data from this time range

\[xc,np,tx,nt] \= eset.crosscorrelate(fieldname, fieldname, varargin{:});
%length(xc)
%N \= floor((length(xc) \+ 1\) / 2\); %changed by MHG 8/24 to add floor
N \= find(tx \>\= 0 , 1, 'first'); %changed by MHG 8/24 to find first time \> 0
ac \= xc(N:end);
np \= np(N:end);
tx \= tx(N:end);
nt \= nt(N:end);
\-\-\-

\#\#\# File: fromJavaFiles.m (ID: @ExperimentSet.32\)

function eset \= fromJavaFiles(varargin)
% loads a set of experiments from .jav files
% function eset \= ExperimentSet.fromFiles (varargin)
% 
% Load a bunch of tracks.jav into the experiment. modified from ARC code
%
% output: an Experiment Set
% inputs: variable
% 'minpts', XX sets the minimum number of points in the tracks to load
% 'loadcontour', true/false (default true); whether to load Maggot ctrs
% with no (additional) arguments, user selects jav files to load
% if 1st argument is a directory, loads all .jav files from that
% directory; ignores all other args
% with \>1 argument, each argument is the file name to load
%'camcalinfo', CameraCalibration struct or \[] to ignore
%'parallel', \[false]/true \- whether to load in parallel using matlab
% parallel computing library
%'sortbydate', \[false]/true \- if expts should be sorted by file date; if
%false they are the default sort order, which I think is alphabetical

%Set params
minpts \= 100;
loadcontour \= true;
camcalinfo \= \[];
parallel \= false;
sortbydate \= false;
fixedInterpTime \= \[];
verbose \= false;
varargin \= assignApplicable(varargin);

%Build the eset
eset \= ExperimentSet();

%Get the file names
if (isempty(varargin))
 \[fn, basedir] \= uigetfile('\*.jav','Select the .jav files you would like to use', 'MultiSelect', 'on');
 if (\~iscellstr(fn))
 fn \= {fn};
 end
 for j \= 1:length(fn)
 fn{j} \= \[basedir fn{j}];
 end
else
 if (isdir(varargin{1}))
 basedir \= varargin{1};
 if (basedir(end) \~\= '\\')
 basedir \= \[basedir '\\'];
 end
 d \= dir(\[basedir '\*.jav']);
 if (sortbydate)
 \[\~,I] \= sort(\[d.datenum]);
 d \= d(I);
 end
 for j \= 1:length(d)
 fn{j} \= \[basedir d(j).name]; %\#ok\<\*AGROW\>
 end
 else
 fn \= varargin;
 end
end

%Ignore any files that have been marked as bad
valid \= true(size(fn));
for j \= 1:length(fn)
 \[bd,f] \= fileparts(fn{j});
 if exist (fullfile(bd, \[f '.bad']), 'file')
 warning ('EFF:BAD', \['file: ' f ' is marked as bad and will not be loaded. To load file, remove ' f '.bad from directory and rerun command']);
 valid(j) \= false;
 end
end
fn \= fn(valid);
valid \= true(size(fn));


expt \= repmat(Experiment(), size(valid));

if (parallel \&\& length(fn) \> 1\)
%Load the experiments in parallel (or below for series)
 ts1 \= tic;
 if (matlabpool('size') \=\= 0\)
 disp ('opening parallel processes'); 
 matlabpool;
 toc(ts1\);
 closepool \= true;
 else
 closepool \= false;
 end
 
 
 parfor n\=1:length(fn)
 try 
 disp(\['\*\*\*\*\* Loading java data into matlab (jav file \#' num2str(n) '/' num2str(length(fn)) ') ' fn{n}]);
 AddJavaPath;
 ind \= strfind(fn{n}, '.');
 if (isempty(ind))
 disp(\['problem with ' fn{n}]);
 end
 %timfn\=\[fn{n}(1:ind(end)) 'tim'];
 if (length(camcalinfo) \>\= n)
 %Actually load the experiment!!
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 \[temp,valid(n)] \= Experiment.fromJava (\[], fn{n}, \[], loadcontour, camcalinfo(n), minpts);
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 if (valid(n) \&\& \~isempty(temp))
 expt(n) \= temp;
 end
 else
 %Actually load the experiment!!
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 \[temp,valid(n)] \= Experiment.fromJava (\[], fn{n}, \[], loadcontour, camcalinfo, minpts);
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 if (valid(n)\&\& \~isempty(temp))
 expt(n) \= temp;
 end
 end
 disp(\['\*\*\*\*\* Done loading java data into matlab (jav file \#' num2str(n) '/' num2str(length(fn)) ') ' fn{n}]);
% disp(\['finished loading file \#' num2str(n) ' : t \= ' num2str(toc(ts1\))]);
 catch e
 %valid(n)\=0;
 disp(\['\*\*\*\*\* ' fn{n} 'failed to process!']);
 end
 end
 if (closepool)
 disp('closing parallel processes'); ts2 \= tic;
 matlabpool close;
 toc(ts2\);
 end
 disp(\['total time to load ' num2str(length(fn)) ' files \= ' num2str(toc(ts1\))]);
 
else
%Load the experiments in series (or above for parallel)
 for n\=1:length(fn)
 disp(\['\*\*\*\*\* Loading java data into matlab (jav file \#' num2str(n) '/' num2str(length(fn)) ') ' fn{n}]);
 ind \= strfind(fn{n}, '.');
 if (isempty(ind))
 disp(\['problem with ' fn{n}]);
 end
 %timfn\=\[fn{n}(1:ind(end)) 'tim'];
 if (length(camcalinfo) \>\= n)
 %Use separate camcalinfo's for each expt
 try
 \[ppp, fff] \= fileparts(fn{n});
 if (exist(fullfile(ppp, \[fff '.bad']), 'file'))
 disp (\[fn{n} ' is marked as a bad file \-\- ignoring.']);
 disp (\['fix problem and delete file: ' fff '.bad']);
 temp \= \[];
 valid(n) \= false;
 else
 %Actually load the experiment!!
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 temp \= Experiment.fromJava (\[], fn{n}, \[], loadcontour, camcalinfo(n), minpts);
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 end
 if (\~isempty(temp))
 expt(n) \= temp;
 else
 valid(n) \= false;
 end
 
 catch me
 disp(\['\*\*\*\*\* ' fn{n} 'failed to process!']);
 disp (me.getReport());
 valid(n) \= false;
 \[ppp, fff] \= fileparts(fn{n});
 fidd \= fopen(fullfile(ppp, \[fff '.bad']),'wt');
 fprintf(fidd, me.getReport());
 fclose(fidd);
 end
 else
 %Use the same camcalinfo for all expt's
 try
 %Actually load the experiment!!
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 temp \= Experiment.fromJava (\[], fn{n}, \[], loadcontour, camcalinfo, minpts);
 %\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~
 if (\~isempty(temp))
 expt(n) \= temp;
 else
 valid(n) \= false;
 end
 catch me
 disp(\['\*\*\*\*\* ' fn{n} 'failed to process!']);
 disp (me.getReport());
 valid(n) \= false;
 end
 end
 disp(\['\*\*\*\*\* Done loading java data into matlab (jav file \#' num2str(n) '/' num2str(length(fn)) ') ' fn{n}]);
 end
end

if (\~exist ('expt', 'var') \|\| isempty(expt))
 disp ('no valid experiments loaded');
 eset \= repmat(eset, 0\);
 return;
end

%Only keep the valid experiments
eset.expt \= expt(valid);

%Calculate derived quantities
 dr \= \[expt.dr];
 if ((\~isempty(fixedInterpTime) \&\& fixedInterpTime \> 0\) \|\| min(\[dr.interpTime]) \< 0\.98 \* max(\[dr.interpTime])) %\#ok
 disp('\*\*\*\*\* Calculating dq');
 if ((\~isempty(fixedInterpTime) \&\& fixedInterpTime \> 0\)) %\#ok
 mdr \= num2str(fixedInterpTime);
 else
 mdr \= num2str(min(\[dr.interpTime]));
 end
 eset.evaluateTrackExpression(\['track.dr.interpTime \= ' mdr ';']);
 mdr \= min(\[dr.interpTime]);
 for j \= 1:length(expt)
 expt(j).dr.interpTime \= mdr;
 end
 eset.executeTrackFunction('recalculateDerivedQuantities');
 eset.executeExperimentFunction('assignGlobalQuantities');
 disp('\*\*\*\*\* Done calculating dq');
 end

end
\-\-\-

\#\#\# File: makeSubFieldHistogram.m (ID: @ExperimentSet.33\)

function h \= makeSubFieldHistogram(eset, field, subfield, fieldaxis, varargin)
% generates a histogram of all values in eset.expt.track.(field).(subfield)
% function h \= makeSubFieldHistogram(eset, field, subfield, fieldaxis, varargin)
%
% generates a histogram of all values in eset.expt.track.(field).(subfield)
% if no return arguments are specified, generates a plot of that histogram
%
% outputs:
% H: (optional), the histogram; if no output arguments, plots histogram
% inputs:
% ESET: a member of the ExperimentSet class
% FIELD, SUBFIELD: make the histogram over track.FIELD.SUBFIELD 
% FIELDAXIS: bin centers for the histogram
% VARARGIN: 
% optional parameter/value pairs
% 'r2d',true \- when plotting, plot fieldaxis in degrees instead of radians
% 'polar',true \- adjust data so that the 0 degree bin is the same size as the
% next bin; the last bin may be screwed by this, so be careful
% in other words, passing polar, fieldaxis \= deg2rad(0:30:330\) is good
% passing polar,true deg2rad(0:30:360\) will nuke your last bin
r2d \= false;
polar \= false;
varargin \= assignApplicable(varargin);

qv \= eset.gatherSubField(field, subfield);
if (polar)
 c1 \= fieldaxis(1\);
 dt \= fieldaxis(2\) \- c1;
 edge \= c1 \- dt/2;
 qv \= mod(qv\-edge,2\*pi)\+edge;
end
h1 \= hist(qv, fieldaxis);

if (nargout \=\= 0\)
 if (r2d)
 fieldaxis \= rad2deg(fieldaxis);
 end
 bar (fieldaxis, h1\); title (eset.defaultTitle);
 xlabel(\[field '.' subfield]); ylabel('counts'); embiggen();
else
 h \= h1;
end



\-\-\-

\#\#\# File: makeHeadSwingAcceptanceHistogram.m (ID: @ExperimentSet.34\)

function \[h,eb] \= makeHeadSwingAcceptanceHistogram(eset, fieldname, fieldaxis, varargin)
% make a histogram of acceptance ratio vs. fieldname
% h \= makeHeadSwingAcceptanceHistogram(eset, fieldname, fieldaxis, varargin)
%
% make a histogram of acceptance ratio vs. fieldname
% each headswing maps one value of fieldname (mean(fieldname(hs.inds))) to 
% a 0 (rejected) or 1 (accepted)
% we then form a graph of acceptance probability vs. fieldname within bins
% specified by fieldaxis
%
% to use value at start/end of headswing rather than mean value, pass
% 'atstart',true or 'atend', true as optional arguments;
%
% outputs:
% H: (optional), the histogram; if no output arguments, plots histogram
% inputs:
% ESET: a member of the ExperimentSet class
% FIELDNAME: the name of the field over which to make the acceptance
% histogram
% FIELDAXIS: determines the binning for the histogram
% VARARGIN: optional parameter/value pairs
% to use value at start/end of headswing rather than mean value, pass
% 'atstart',true or 'atend', true as optional arguments;

atstart \= false;
atend \= false;
varargin \= assignApplicable(varargin);


t \= \[eset.expt.track];
hs \= \[t.headSwing];
acc \= \[hs.accepted];
%size(acc)
if (atstart)
 mfv \= eset.gatherField(fieldname, 'hs', 'start');
else
 if (atend)
 mfv \= eset.gatherField(fieldname, 'hs', 'end');
 else
 mfv \= eset.gatherField(fieldname, 'hs','mean');
 end
end
%size(mfv)
n \= hist (mfv, fieldaxis);
h1 \= hist(mfv(logical(acc)), fieldaxis) ./ n;
eb \= h1\.\*(1\-h1\)./sqrt(n);

if (nargout \> 0\)
 h \= h1;
else
 errorbar (fieldaxis, h1, eb, varargin{:}); xlabel(fieldname); ylabel ('head swing acceptance');
 if atstart
 t \= 'headswing acceptance vs. value at start of headswing'; %\#ok
 else if atend
 t \= 'headwing acceptance vs. value at end of headswing'; %\#ok
 else
 t \= 'headswing acceptance vs. mean value during headswing';
 end
 end
 title (\[eset.defaultTitle ': ' t]);
end


\-\-\-

\#\#\# File: processDirectoryToMatfiles.m (ID: @ExperimentSet.35\)

function \[eset, success] \= processDirectoryToMatfiles (basedir,varargin)
%function eset \= loadTrimStitchAndSave(basedir, esetname, ecl, camcalinfo, varargin)
%loads, stitches, trims, cleans, etc. then saves to mat files in a
%'matfiles' subdirectory 
%varargin: parameter \= defaultvalue
% to change, pass 'parameter', value after basedir, esetname
% checkerLocation \= '';
% checkerboardfname \= 'checkerboard.png';
% checkeroptions \= {'xinds', 310:2170, 'yinds', 220:1640, 'flipy', true, 'flipx', false, 'flatten', true};
% minptsToLoad \= 50;
% frameDiff \= 4;
% maxDist \= 0\.1;
% buffer \= \[\-0\.1 0\.2 0\.1 0\.1];
% trimrect \= \[];
% fieldsToDerive \= {};
%
% explanation of parameters (more detail found inside
% processDirectoryToMatfiles\_Janelia.m)
%
% checkboardfname \- specifies the name of the picture of the 1cm checkerboard that we
% will use to calibrate the camera; place the
% checkerboard inside basedir
% checkeroptions \- options to pass to the checkerboard calibration routine
% 
% minPtsToLoad \- the minimum length a track must be before we will even
% load it from disk
%
% frameDiff \- stitch together tracks if first ended frameDiff or fewer frames before second started
% maxDist \- stitch together tracks if first ended within maxDist (in cm) of
% second's start
% buffer \- distance from leftmost, rightmost, bottommost, topmost point to trim 
% (to eliminate border region)
% trimrect \- you can specify an actual trim rectangle here
% if both buffer \& trimrect are specified, trimrect is used \& buffer is
% ignored; if buffer \= \[] and trimrect \= \[], trimming is disabled
% fieldsToDerive \- extra data fields to derive before saving to save time
% later
% ccInSupDataDir \- true/\[false] \-\- if true, cameracalibration info is
% stored in supplemental datadir
%
% individualMatFiles \- whether to process the experiment mat files
% pseudo\-individually using the same name as the .bin files 
%
% requireMaggot \= \[true]/false \-\- if true, exits without loading if
% experiment does not contain maggot tracks
%
%% this section sets the parameters that will be used throughout the script
% you can change any of these parameters by passing 
%'parameter\_name', parameter value after basedir, esetname in the
% arguments to the function

%this specifies the name of the picture of the 1cm checkerboard that we
%will use to calibrate the camera \-\- using the checkerboard lets us analyze
%the data \- maggot lengths, run speeds, run lengths, etc. in real units
%(cm) that we can compare between experiments and labs
%
%place the checkerboard inside basedir 
%optionally you can provide a different location for the checkerboard

checkerboardfname \= '1cm\_checkerboard.png';

checkerLocation \= '';


%these are options to pass to the checkerboard calibration routine. xinds,
%yinds specify the region of the image that contains the checkerboard (if
%we are zoomed out enough to see the beyond the edge of the checkerboard)
%'flipy' is true (for cold\_arrows) because when we put 0,0 in the lower
%left corner, the image is upside down
%'flipx' is false (for cold\_arrows) because when we put 0,0 in the lower
%left corner, warm is to \+x
%'flatten', true evens out the illumination over the checkerboard, and is
%generally worth doing
checkeroptions \= {'flipy', true, 'flipx', false, 'flatten', true};


% minPtsToLoad is the minimum length a track must be before we will even
% load it from disk
minptsToLoad \= 50;

% loadParallel is whether to use parallel processes to load mat files. set
% to false if you are running on a computer with "limited" (say \< 8 GB)
% memory
loadParallel \= true;

%these are options to use when stitching together tracks \-\- we do this in
%case the track extraction software dropped a frame or two in the middle of
%an otherwise good track. . . note that if the track is in
%collision with another track in the experiment, we don't stitch 

frameDiff \= 7; % stitch together tracks if first ended 4 or fewer frames before second started
maxDist \= 0\.1; % stitch together tracks if first ended within 1 mm of second's start

buffer \= \[0\.1 0\.1 0\.1 0\.1]; % \[left, right, top, bottom]
 
trimrect \= \[]; % \[left bottom right top] you can specify an actual trim rectangle here, which will mean buffer is ignored
 % note that the window should be specified in cm, not pixels

trimrectpixels \= \[]; % \[left bottom right top] trim rectangle set in pixels; this is based on full image pixels (ROI is ignored); if both trimrect and trimrectpixels are specified, trimrect wins


 
setRulesByPeri \= true; % instead of using default derivation rules, set smoothing, derivative times, and minimum run times by detected peristalsis frequency
 
%we derive all the fields necessary to segment the tracks and generate navigation figures before saving
%if there are other fields you want derived and saved, place them here
fieldsToDerive \= {};

individualMatFiles \= true;

fixedInterpTime \= \[]; %if fixedInterpTime is a number, then all experiments will have same fixed interpolation time (not determined from frame rate)

camcalinfo \= \[]; %allows you to directly pass in camcalinfo
requireMaggot \= true;
%TODO: fix all non\-essential displays to respond to verbosity trigger
verbose \= true;
tracksInSubDir \= false;
varargin \= assignApplicable(varargin);

%we clean the experiment set twice \-\- once before stitching and once after
%stitching; the cleaner (eclnukespots) before stitching just looks for spots that are
%clearly not maggot tracks \-\- head tail is largely invalid; does not move
%more than 2 mm
%
%after stitching we are more selective, insisting on a minimum number of
%points, a fairly high number of valid head tail determinations, a minimum
%distance travelled, and a requirement that the larva not continuously
%circle in one direction

eclnukespots \= ESetCleaner();
eclnukespots.minHTValid \= 0\.6;
eclnukespots.minDist \= 0\.2;
eclnukespots.askFirst \= false;


ecl \= ESetCleaner();
ecl.minDist \= 1; % track must be more than 1 cm long
mintime \= 30; % tracks must be at least 60 seconds \-\- we will convert this into a minimum number of points later
ecl.minHTValid \= 0\.9; % discard any track where we couldn't determine a head tail properly at least 90% of the time
ecl.rpmCut \= 2; % get rid of any track that circles in one direction with a frequency of at least 2 rev/min
ecl.minRevCut \= 3; % provided that track does at least 3 complete circles


ccInSupDataDir \= false;



varargin \= assignApplicableAndFixTypes(varargin);
success \= false;
ts1 \= tic();

%% this section will look through the directory for .bin files and verify
% that we have the appropriate .mdat files as well
d \= dir(fullfile(basedir, '\*.bin'));
if (isempty(d))
 disp (\['no .bin files in ' basedir]);
 eset \= \[];
 return;
end

matfileexists \= false(size(d));
for j \= 1:length(d)
 fname{j} \= fullfile(basedir, d(j).name); %\#ok\<\*AGROW\>
 \[ps,nm] \= fileparts(fname{j});
 mdatname{j} \= fullfile(ps,\[nm '.mdat']);
 if (\~exist(mdatname{j}, 'file'))
 disp ('cannot find metadata file');
 disp (\['bin file name \= ' fname{j}]);
 disp (\['metadata file name \= ' mdatname{j}]);
 error ('must have metadata file to proceed');
 return %\#ok
 end
 matfileexists(j) \= exist(fullfile(ps, 'matfiles', \[nm '.mat']), 'file');
 ismaggot(j) \= isa(Experiment.getPtType(fname{j}), 'MaggotTrackPoint');
end
ismaggot \= logical(ismaggot);
if (requireMaggot)
 if \~all(ismaggot)
 for j \= find(\~ismaggot)
 warning ('eset:pd2m', '%s', \[fname{j} ' does not contain maggot track points \& is being ignored']);
 end
 end
 fname \= fname(ismaggot);
 mdatname \= mdatname(ismaggot);
 matfileexists \= matfileexists(ismaggot);
 
 
end


if (individualMatFiles)
 pfname \= fname(matfileexists);
 fname \= fname(\~matfileexists);
 if (isempty(fname))
 eset \= \[];
 if (verbose)
 disp (\['already processed all bin files in ' basedir]);
 end
 return;
 end
 for j \= 1:length(pfname)
 if (verbose)
 disp (\['already processed: ' pfname{j}]);
 end
 end
 for j \= 1:length(fname)
 if (verbose)
 disp (\['need to process: ' fname{j}]);
 end
 end
end


%% this section carries out the camera calibration if needed and saves it
% to disk

if (ccInSupDataDir)
 
 for j \= 1:length(fname) %\#ok
 sdd \= Experiment.findSuppDataDir(fname{j});
 if (isempty(sdd))
 warning ('es:pd2m', 'you told me to look in sup data dir for camcalinfo, but I couldn''t find directory');
 return;
 end
 
 if (\~exist(fullfile(sdd, 'camcalinfo.mat'), 'file'))
 warning ('es:pd2m', \['you told me to look in ' f ' sup data dir for camcalinfo, but I couldn''t find it']);
 return;
 end
 temp \= load(fullfile(sdd, 'camcalinfo.mat'), 'camcalinfo');
 if (j \=\= 1\)
 camcalinfo \= temp.camcalinfo;
 else
 camcalinfo(j) \= temp.camcalinfo;
 end
 end
else
 if (\~isempty(camcalinfo) \|\| \~exist(fullfile(basedir, 'camcalinfo.mat'), 'file'))
 if (isempty(camcalinfo))
 try
 if (\~isempty(checkerLocation))
 im \= imread(fullfile(checkerLocation, checkerboardfname));
 else
 im \= imread(fullfile(basedir, checkerboardfname));
 end
 catch me
 disp ('could not read in checkerboard from: ');
 disp (fullfile(basedir, checkerboardfname));
 disp ('error was: ')
 disp (me.getReport());
 disp ('');
 warning ('cannot proceed without camera calibration \-\- aborting');
 eset \= \[];
 return;
 end
 if (verbose)
 disp ('calibrating checkerboard');
 end 
 camcalinfo \= CameraCalibration(im, checkeroptions{:});
 if (isempty(camcalinfo))
 error ('camera calibration failed \- check options');
 end
 end
 % make sure that the checkerboard that displays here is correct \-\- I am
 % not putting a checkoff in the script because you want to run it automatically, but this is a potential place for errors
 
 
 save(fullfile(basedir, 'camcalinfo.mat'), 'camcalinfo');
 else
 load(fullfile(basedir, 'camcalinfo.mat'), 'camcalinfo');
 end 
 close all
end 
% now we will load each mdat file and see if there is an ROI offset we need
% to take into account for the camera calibration


for j \= 1:length(mdatname)
 ind \= min(j, length(camcalinfo));
 if (isa(camcalinfo(ind), 'SimpleScalingCameraCalibration') \|\| isa(camcalinfo(ind), 'ScalingAndRotationCameraCalibration'))
 cc(j) \= camcalinfo(ind);
 continue;
 end
 
 rx \= camcalinfo(ind).realx;
 ry \= camcalinfo(ind).realy;
 cx \= camcalinfo(ind).camx;
 cy \= camcalinfo(ind).camy;
 data \= importdata(mdatname{j});
 xcol \= find(strcmpi(data.colheaders, 'ROIX'));
 if (\~isempty(xcol))
 roix \= median(data.data(isfinite(data.data(:,xcol)),xcol)); % we should be able just to take the first value, but this should be more robust
 else
 roix \= 0;
 end
 ycol \= find(strcmpi(data.colheaders, 'ROIY'));
 if (\~isempty(ycol))
 roiy \= median(data.data(isfinite(data.data(:,ycol)),ycol)); % we should be able just to take the first value, but this should be more robust
 else
 roiy \= 0;
 end
 cc(j) \= CameraCalibration(rx, ry, cx\-roix, cy\-roiy);
 
end



try
 if (isempty(trimrect) \&\& \~isempty (trimrectpixels))
 \[\~,trimrect,\~] \= camcalinfo.realRectFromCamRect(trimrectpixels);
 end
catch me
 disp(me.getReport);
 return;
end

args \= \[varargin, {'frameDiff', frameDiff, 'maxDist', maxDist, 'setRulesByPeri', setRulesByPeri, 'fieldsToDerive', fieldsToDerive, 'tracksInSubDir', tracksInSubDir}];

if (individualMatFiles)
 
 
 
 
 if (loadParallel \&\& length(fname) \> 1\)
 ts1 \= tic;
 if (matlabpool('size') \=\= 0\)
 if (verbose)
 disp ('opening parallel processes'); 
 end
 matlabpool;
 toc(ts1\);
 closepool \= true;
 else
 closepool \= false;
 end
 
 
 parfor n\=1:length(fname)
 if (verbose)
 disp(\['Loading file \#' num2str(n) ' : ' fname{n}]);
 end 
 try
 %2/7/2015 \-\- changed camcalinfo to cc(n): camcalinfo is
 %nonvectorized and does not include ROI offsets.
 ss(n) \= processSingleExperimentToMatfile (fname{n}, ecl, eclnukespots, cc(n), minptsToLoad, fixedInterpTime, trimrect, buffer, mintime, args{:});
 disp(\['finished loading file \#' num2str(n) ' : t \= ' num2str(toc(ts1\))]);
 catch e
 disp(\['Error in processSingleExperimentToMatfile for: ' fname{n}]);
 end
 
 end
 
 if (closepool)
 disp('closing parallel processes'); ts2 \= tic;
 matlabpool close;
 toc(ts2\);
 end
 disp(\['total time to load ' num2str(length(fname)) ' files \= ' num2str(toc(ts1\))]);
 success \= success \&\& all(ss);
 else
 for j \= 1:length(fname)
 try
 %2/7/2015 \-\- changed camcalinfo to cc(n): camcalinfo is
 %nonvectorized and does not include ROI offsets.
 success \= success \& processSingleExperimentToMatfile (fname{j}, ecl, eclnukespots, cc(j), minptsToLoad, fixedInterpTime, trimrect, buffer, mintime, args{:});
 catch me
 disp(\['Error in processSingleExperimentToMatfile for: ' fname{j}]);
 disp(me.getReport());
 end
 end
 end
 eset \= \[];
 return;
end


%% this command actually loads the experiments from disk \-\- so short!
eset \= ExperimentSet.fromFiles(fname{:}, 'minpts', minptsToLoad, 'camcalinfo', cc, 'parallel', loadParallel, 'fixedInterpTime', fixedInterpTime);
if (isempty(eset))
 return;
end


%% this is NEW NEW NEW \-\- we will try to determine appropriate smoothing
%% and interpolation times, as well as minimum run times based on
%% peristalsis detected in high frequency movies

if (setRulesByPeri \&\& median(eset.gatherSubField('dr', 'interpTime')) \<\= 0\.1251\) % \>\= 8 Hz
 \[mf, f, ps] \= eset.setDerivationRulesByPeristalsisFrequency();
 disp (\['calculated peristalis frequency is: ' num2str(mf), ' Hz.']);
 figure();
 plot (f, ps); title(\['calculated peristalis frequency is: ' num2str(mf), ' Hz.']);
 xlabel ('freq'); ylabel ('power');
end

%% we are going to put the rest of the file in try/catch blocks \-\- that way
% if there's a failure, you don't have to reload the tracks from disk to
% see what the problem is because the function will still return a value

% get rid of obviously bad tracks (dust, crap) before stitching
try
 disp ('cleaning bad spots');
 eclnukespots.clean(eset);
catch me
 disp(me.getReport);
 return;
end

%stitch tracks together
try 
 disp ('stitching tracks');
 eset.executeExperimentFunction('stitchTracks', frameDiff, maxDist, 'interactive', false);
catch me
 disp(me.getReport);
 return;
end
 
%trim the region near the edge of the experiment

try
 if (isempty(trimrect))
 if (\~isempty(buffer))
 il \= eset.gatherField('iloc');
 ll \= min(il,\[],2\);
 ur \= max(il,\[],2\);
 trimrect \= \[ll(1\) ll(2\) ur(1\) ur(2\)] \+ buffer.\*\[1 1 \-1 \-1];
 end
 end
catch me
 disp(me.getReport);
 return;
end
try
 if (\~isempty(trimrect))
 disp ('trimming tracks');
 eset.executeExperimentFunction('trimTracks', \[], trimrect);
 else
 disp ('skipping trimming');
 end
catch me
 disp(me.getReport);
 return;
end

%clean out marginal tracks that will not contribute to analysis
ecl.minPts \= ceil(mintime / eset.expt(1\).dr.interpTime);
ecl.askFirst \= false; 
ecl.showFigsInReport \= false;
\[\~,rpt] \= ecl.getReport(eset);
try
 fid \= fopen (fullfile (basedir, 'cleaning report.txt'), 'wt');
 for j \= 1:length(rpt)
 fprintf(fid, '%s\\n', rpt{j});
 end
catch me
 disp ('trouble writing cleaning report to disk, continuing anyway');
 disp (me.getReport);
end

disp ('cleaning eset');
try
 ecl.clean(eset);
 valid \= true(size(eset.expt));
 for j \= 1:length(eset.expt)
 if (isempty(eset.expt(j).track))
 disp (\[eset.expt(j).fname ' \- after cleaning no valid tracks']);
 valid(j) \= false;
 end
 end
 eset.expt \= eset.expt(valid);
catch me
 disp(me.getReport);
 return;
end


%calculate derived quantities used in segmentation; set segmentation speeds

try
 eset.evaluateTrackExpression('track.so.autoset\_curv\_cut\= true;'); %NEW set radius of curvature cutoff to be 1/5 of body length
 eset.executeTrackFunction('setSegmentSpeeds');
 dvfields \= {'spineTheta', 'vel\_dp', 'spineLength', 'sspineTheta', 'lrdtheta'};
 for j \= 1:length(dvfields)
 disp (\['calculating ' dvfields{j}]);
 eset.gatherField(dvfields{j});
 end
 
 
 for j \= 1:length(fieldsToDerive) 
 disp (\['calculating ' fieldsToDerive{j}]);
 eset.gatherField(fieldsToDerive{j});
 end
catch me
 disp(me.getReport);
 return;
end
disp('done with loading, stitching and cleaning');
toc(ts1\)

%finally, save the eset to disk as matfiles, so it can be loaded quickly later
try
 if (\~exist(fullfile(basedir, 'matfiles'), 'dir'))
 mkdir (fullfile(basedir, 'matfiles'));
 end
 eset.executeExperimentFunction('toMatFile', 'extradir', 'matfiles','tracksInSubDir',tracksInSubDir);
%{
 if (individualMatFiles)
 eset.executeExperimentFunction('toMatFile', 'extradir', 'matfiles');
 else 
 eset.toMatFiles(fullfile(basedir, 'matfiles',esetname));
 end
 %}
 disp('saved file');
 toc(ts1\)
catch me
 disp(me.getReport);
 return;
end


success \= true;

% needed to close all windows and run smoothly in the cluster
close all;

function success \= processSingleExperimentToMatfile (fname, ecl, eclnukespots, camcalinfo, minptsToLoad, fixedInterpTime, trimrect, buffer, mintime, varargin)


frameDiff \= 7; % stitch together tracks if first ended 4 or fewer frames before second started
maxDist \= 0\.1; 
setRulesByPeri \= true; % instead of using default derivation rules, set smoothing, derivative times, and minimum run times by detected peristalsis frequency
 
%we derive all the fields necessary to segment the tracks and generate navigation figures before saving
%if there are other fields you want derived and saved, place them here
fieldsToDerive \= {};
redomatfile \= false;
tracksInSubDir \= false;
varargin \= assignApplicable(varargin);

success \= false;
ts1 \= tic();

%% this section carries out the camera calibration if needed and saves it
% to disk

\[ps,nm] \= fileparts(fname);
mdatname \= fullfile(ps,\[nm '.mdat']);
if (\~exist(mdatname, 'file'))
 disp ('cannot find metadata file');
 disp (\['bin file name \= ' fname]);
 disp (\['metadata file name \= ' mdatname]);
 error ('must have metadata file to proceed');
 return %\#ok
end
matfileexists \= exist(fullfile(ps, 'matfiles', \[nm '.mat']), 'file');

% THIS IS ALREADY DONE IN MAIN FUNCTION \-\- SKIP
% now we will load each mdat file and see if there is an ROI offset we need
% to take into account for the camera calibration
% 
% rx \= camcalinfo.realx;
% ry \= camcalinfo.realy;
% 
% cx \= camcalinfo.camx;
% cy \= camcalinfo.camy;
% data \= importdata(mdatname);
% xcol \= find(strcmpi(data.colheaders, 'ROIX'));
% if (\~isempty(xcol))
% roix \= median(data.data(isfinite(data.data(:,xcol)),xcol)); % we should be able just to take the first value, but this should be more robust
% else
% roix \= 0;
% end
% ycol \= find(strcmpi(data.colheaders, 'ROIY'));
% if (\~isempty(ycol))
% roiy \= median(data.data(isfinite(data.data(:,ycol)),ycol)); % we should be able just to take the first value, but this should be more robust
% else
% roiy \= 0;
% end
% 
% cc \= CameraCalibration(rx, ry, cx\-roix, cy\-roiy);

if (\~redomatfile \&\& matfileexists)
 success \= true;
 return;
end




%% this command actually loads the experiments from disk \-\- so short!
eset \= ExperimentSet.fromFiles(fname, 'minpts', minptsToLoad, 'camcalinfo', camcalinfo, 'parallel', false, 'fixedInterpTime', fixedInterpTime);
if (isempty(eset))
 return;
end


%% this is NEW NEW NEW \-\- we will try to determine appropriate smoothing
%% and interpolation times, as well as minimum run times based on
%% peristalsis detected in high frequency movies
try
 if (setRulesByPeri \&\& median(eset.gatherSubField('dr', 'interpTime')) \<\= 0\.1251\) % \>\= 8 Hz
 \[mf, f, ps] \= eset.setDerivationRulesByPeristalsisFrequency();
 % disp (\['calculated peristalis frequency is: ' num2str(mf), ' Hz.']);
 % figure();
 % plot (f, ps); title(\['calculated peristalis frequency is: ' num2str(mf), ' Hz.']);
 %xlabel ('freq'); ylabel ('power');
 end
catch me
 disp (me.getReport());
 return;
end
%% we are going to put the rest of the file in try/catch blocks \-\- that way
% if there's a failure, you don't have to reload the tracks from disk to
% see what the problem is because the function will still return a value

% get rid of obviously bad tracks (dust, crap) before stitching
try
 disp ('cleaning bad spots');
 eclnukespots.clean(eset);
catch me
 disp(me.getReport);
 return;
end

%stitch tracks together
try 
 disp ('stitching tracks');
 eset.executeExperimentFunction('stitchTracks', frameDiff, maxDist, 'interactive', false);
catch me
 disp(me.getReport);
 return;
end
 
%trim the region near the edge of the experiment
try
 if (isempty(trimrect))
 if (\~isempty(buffer))
 il \= eset.gatherField('iloc');
 ll \= min(il,\[],2\);
 ur \= max(il,\[],2\);
 trimrect \= \[ll(1\) ll(2\) ur(1\) ur(2\)] \+ buffer.\*\[1 1 \-1 \-1];
 end
 end
catch me
 disp(me.getReport);
 return;
end

try
 if (\~isempty(trimrect))
 disp ('trimming tracks');
 eset.executeExperimentFunction('trimTracks', \[], trimrect);
 else
 disp ('skipping trimming');
 end
catch me
 disp(me.getReport);
 return;
end

%clean out marginal tracks that will not contribute to analysis
try
 ecl.minPts \= ceil(mintime / eset.expt(1\).dr.interpTime);
 ecl.askFirst \= false; 
 ecl.showFigsInReport \= false;
 \[\~,rpt] \= ecl.getReport(eset);
catch me
 disp (me.getReport())
 return;
end

\[basedir,nm] \= fileparts(fname);

try
 fid \= fopen (fullfile (basedir, \[nm ' cleaning report.txt']), 'wt');
 for j \= 1:length(rpt)
 fprintf(fid, '%s\\n', rpt{j});
 end
catch me
 disp ('trouble writing cleaning report to disk, continuing anyway');
 disp (me.getReport);
end

disp ('cleaning eset');
try
 ecl.clean(eset);
 valid \= true(size(eset.expt));
 for j \= 1:length(eset.expt)
 if (isempty(eset.expt(j).track))
 disp (\[eset.expt(j).fname ' \- after cleaning no valid tracks']);
 valid(j) \= false;
 end
 end
 eset.expt \= eset.expt(valid);
catch me
 disp(me.getReport);
 return;
end

if (isempty(eset.expt))
 return;
end

%calculate derived quantities used in segmentation; set segmentation speeds

try
 eset.evaluateTrackExpression('track.so.autoset\_curv\_cut\= true;'); %NEW set radius of curvature cutoff to be 1/5 of body length
 eset.executeTrackFunction('setSegmentSpeeds');
 dvfields \= {'spineTheta', 'vel\_dp', 'spineLength', 'sspineTheta', 'lrdtheta'};
 for j \= 1:length(dvfields)
 disp (\['calculating ' dvfields{j}]);
 eset.gatherField(dvfields{j});
 end
 
 
 for j \= 1:length(fieldsToDerive) 
 disp (\['calculating ' fieldsToDerive{j}]);
 eset.gatherField(fieldsToDerive{j});
 end
catch me
 disp(me.getReport);
 return;
end
disp('done with loading, stitching and cleaning');
toc(ts1\)

%finally, save the eset to disk as matfiles, so it can be loaded quickly later
try
 if (\~exist(fullfile(basedir, 'matfiles'), 'dir'))
 mkdir (fullfile(basedir, 'matfiles'));
 end
 eset.executeExperimentFunction('toMatFile', 'extradir', 'matfiles', 'tracksInSubDir', tracksInSubDir);
 disp('saved file');
 imdir \= fullfile(basedir, 'diagnostics');
 if (\~exist(imdir, 'dir'))
 mkdir(imdir);
 end
 for j \= 1:length(eset.expt)
 im \= eset.expt(j).diagnosticImage();
 if (\~isempty(im))
 \[\~,fn] \= fileparts(eset.expt(j).fname);
 imwrite(im/255, fullfile(imdir, \[fn ' diagnostic foreground.bmp']), 'bmp');
 end
 end
 
 toc(ts1\)
catch me
 disp(me.getReport);
 return;
end


success \= true;





\-\-\-

\#\#\# File: loadTrimStitchAndSave.m (ID: @ExperimentSet.36\)

function eset \= loadTrimStitchAndSave(basedir, esetname, ecl, camcalinfo, varargin)
%function eset \= loadTrimStitchAndSave(basedir, esetname, ecl, camcalinfo, varargin)
%loads, stitches, trims, cleans, etc. then saves to mat files in a
%'matfiles' subdirectory 
%varargin: minpts \- minimum length of a track in frames to load from disk
% frameDiff \- when stitching maximum number of missing frames between tracks
% maxDist \- when stitching maximum physical distance between
% tracks
% trimrect \- rectangle outside of which to remove points 
% buffer \- if trimrect is unspecified, distance from edge of analysis rectangle to trim
% prunebuffer \- if prunebuffer is specified, distance from edge of
% trimrectangle to prune tracks (remove all that start outside this edge) 
% NOTE: this distance is applied to the trimrectangle 
% default\_deltaT \- if loading timing fails, what is the default
% time interval between frames?
% checker\_calc \- if this was a checkerboard experiment, you can add checker data here
% timerange \- remove points outside this time window (usually this is left empty)
% fieldsToDerive \- additional fields to derive before saving
% (e.g. 'periAmp')
% setDRByPeristalsis \- whether to automatically set derivation
% rules by using automatically detected peristalsis frequency
% isMWT, true/\[false] \-\- if this is an MWT experiment



%Set params
minpts \= 50;
frameDiff \= 2; % stitch together tracks if first ended 2 or fewer frames before second started
if (isempty(camcalinfo))
 maxDist \= 10; % stitch together tracks if first ended within 10 pixels of second's start
else
 maxDist \= 0\.1; %one mm
end
prunebuffer \= \[];
buffer \= \[];
trimrect \= \[];
default\_deltaT \= 0\.2;

checker\_calc \= \[];
timerange \= \[];
fieldsToDerive \= {};
setDRByPeristalsis \= false;
isMWT \= false;
varargin \= assignApplicable(varargin);
eclexisted \= existsAndDefault('ecl', ESetCleaner());
existsAndDefault('camcalinfo', \[]);

eclnukespots \= ESetCleaner();
eclnukespots.minHTValid \= 0\.5;
if (\~isempty(camcalinfo)) 
 eclnukespots.minDist \= 0\.1;
 eclnukespots.minHTValid \= 0\.5;
 
end
eclnukespots.askFirst \= false;
ts1 \= tic;

%LOAD the experiments
if (isMWT)
 eset \= ExperimentSet.fromMWTFiles(basedir, camcalinfo, varargin{:});
else
 eset \= ExperimentSet.fromFiles(basedir, 'minpts', minpts, 'camcalinfo', camcalinfo, 'parallel', true, varargin{:});
end

%Optionally, generate derivation rules using properties of the track
if (setDRByPeristalsis)
 try
 eset.setDerivationRulesByPeristalsisFrequency;
 catch me
 disp(me.getReport());
 disp ('failed to set derivation rules; aborting now and returning so you still have eset');
 return;
 end 
end

%Add timing info (if it's not already there)
% note: in ExperimentSet.fromFiles, timing info is NOT there by default 
if (\~isMWT)
 eset.addTimingByFrameDifference(default\_deltaT);
end

%CLEAN the funky\-looking tracks out of the eset
eclnukespots.clean(eset);

%Set some ecl field values
if (\~eclexisted ) 
 if (\~isempty(camcalinfo))
 %real units, assume cm
 ecl.minDist \= 0\.1; %minimum distance 1 mm
 ecl.minSpeed \= 0\.01; %minimum average speed 100 microns/sec
 else
 ecl.minDist \= 10; %pixels
 ecl.minSpeed \= 0\.1; %pixels/second
 end
 ecl.minPts \= ceil(30 / eset.expt(1\).dr.interpTime);
end

%STITCH appropriate tracks together
eset.executeExperimentFunction('stitchTracks', frameDiff, maxDist, 'interactive', false);

%Set some more ecl field values
ecl.askFirst \= false; 
ecl.showFigsInReport \= false;
ecl.getReport(eset);

%CLEAN the weird\-looking tracks out of the experients again (after stitching tracks together)
ecl.clean(eset);

%Clear the experiments which have 0 tracks from the eset
valid \= true(size(eset.expt));
for j \= 1:length(eset.expt)
 if (isempty(eset.expt(j).track))
 disp (\[eset.expt(j).fname ' \- after cleaning no valid tracks']);
 valid(j) \= false;
 end
end
eset.expt \= eset.expt(valid);

%TRIM any points from the track which fall out of the valid time/location
%ranges
if (isempty(trimrect)) 
 il \= eset.gatherField('iloc');
 if (isempty(buffer))
 if(isempty(camcalinfo))
 buffer \= 25; %pixels
 else
 buffer \= 0\.15; %cm
 end
 end
 ll \= min(il,\[],2\) \+ buffer;
 ur \= max(il,\[],2\) \- buffer;
 trimrect \= \[ll(1\) ll(2\) ur(1\) ur(2\)];
end
disp ('trimming tracks');
eset.executeExperimentFunction('trimTracks', timerange, trimrect);
if (\~isempty(prunebuffer))
 prunerect \= trimrect \+ \[prunebuffer prunebuffer \-prunebuffer \-prunebuffer];
 disp ('pruning tracks');
 eset.executeExperimentFunction('trimTracks', \[], prunerect);
end

%CALCULATE derived quantities
disp('calculating derived quantities');
if (isa (eset.expt(1\).track(1\), 'MaggotTrack'))
 eset.executeTrackFunction('setSegmentSpeeds');
 eset.gatherField('sspineTheta');
 eset.gatherField('vel\_dp');
end
for j \= 1:length(fieldsToDerive) 
 try
 eset.gatherField(fieldsToDerive{j});
 catch me
 disp(me.getReport());
 end
end


disp('done with loading, stitching and cleaning');
toc(ts1\)

%Assign checker track data
if (\~isempty(checker\_calc))
 try
 disp ('assigning checker track data');
 checker\_calc.assignGlobals(eset.expt);
 catch me
 disp(me.getReport());
 end
 toc(ts1\);
end

%SAVE the eset as a matfile
ts1 \= tic;
if (\~exist(fullfile(basedir, 'matfiles'), 'dir'))
 mkdir (fullfile(basedir, 'matfiles'));
end
eset.toMatFiles(fullfile(basedir, 'matfiles',esetname));
disp('saved file');
toc(ts1\)


\-\-\-

\#\#\# File: fromMWTFiles.m (ID: @ExperimentSet.37\)

function eset \= fromMWTFiles(basedir, camcalinfo, varargin)
% loads a set of experiments from MWT files
% eset \= fromMWTFiles(basedir, camcalinfo, varargin);% 
%
% output: an Experiment Set
% inputs: basedir \- a directory containing subdirectories representing MWT
% experiments OR
% a directory containing zip files representing MWT experiments
%camcalinfo, CameraCalibration struct or \[] to ignore
%'parallel', \[false]/true \- whether to load in parallel using matlab
% parallel computing library
%'interpTime', (time in seconds) \- assign this value to derivation rules
% interpolation time, instead of autocomputing


existsAndDefault('camcalinfo', \[]);
parallel \= false;
interpTime \= \[];
varargin \= assignApplicable(varargin);
if (isempty(interpTime))
 warning('Interpolation time will be automatically determined. This may cause errors if multiple esets are later combined.');
end

eset \= ExperimentSet();
if (\~exist (basedir, 'file')) %checks for directories and files
 eset \= repmat(eset, 0\);
 disp (\[basedir ' does not match any files or directories']);
 return;
end

\[\~,\~,ext] \= fileparts(basedir);
if (strcmpi (ext, '.zip') \|\| (\~isempty(dir(fullfile(basedir, '\*.summary')))))
 disp ('called on mwt zip file / directory');
 fn \= {basedir};
else 
 d \= dir(basedir);
 d1 \= d(\[d.isdir]);
 if (\~isempty(d1\))
 tf \= cellfun(@(s) s(1\) \~\= '.', {d1\.name}) \& cellfun(@(s) \~isempty(dir(fullfile(basedir, s, '\*.summary'))), {d1\.name});
 d1 \= d1(tf);
 end
 d2 \= d(\~\[d.isdir]);
 if (\~isempty(d2\))
 
 tf \= false(size(d2\));
 for j \= 1:length(d2\)
 \[\~,\~,ext] \= fileparts(d2(j).name);
 tf(j) \= strcmpi(ext, 'zip');
 end
 d2 \= d2(tf);
 end
 d \= \[d1 d2];
 for j \= 1:length(d)
 fn{j} \= \[basedir d(j).name]; %\#ok\<\*AGROW\>
 end
end
if (parallel \&\& length(fn) \> 1\)
 ts1 \= tic;
 if (matlabpool('size') \=\= 0\)
 disp ('opening parallel processes'); 
 matlabpool;
 toc(ts1\);
 closepool \= true;
 else
 closepool \= false;
 end
 
 parfor n\=1:length(fn)
 disp(\['Loading file \#' num2str(n) ' : ' fn{n}]);
 expt(n) \= Experiment.fromMWTFile(fn{n}, camcalinfo);
 disp(\['finished loading file \#' num2str(n) ' : t \= ' num2str(toc(ts1\))]);
 end
 if (closepool)
 disp('closing parallel processes'); ts2 \= tic;
 matlabpool close;
 toc(ts2\);
 end
 disp(\['total time to load ' num2str(length(fn)) ' files \= ' num2str(toc(ts1\))]);
else
 ts1 \= tic;
 for n\=1:length(fn)
 disp(\['Loading file \#' num2str(n) ' : ' fn{n}]);
 expt(n) \= Experiment.fromMWTFile(fn{n}, camcalinfo);
 disp(\['finished loading file \#' num2str(n) ' : t \= ' num2str(toc(ts1\))]);
 end
end
eset.expt \= expt;
try
 if (isempty(interpTime))
 et \= \[expt.elapsedTime];
 interpTime \= percentile(diff(et), 0\.1\);
 end
 for j \= 1:length(expt)
 expt(j).dr.interpTime \= interpTime;
 end
 eset.expt.updateDerivationRules;
 %{
 mdr \= num2str(interpTime);
 eset.evaluateTrackExpression(\['track.dr.interpTime \= ' mdr ';']);
 
 %}
 eset.executeTrackFunction('recalculateDerivedQuantities');
 eset.executeExperimentFunction('assignGlobalQuantities');
catch me
 disp(me.getReport());
end
\-\-\-

\#\#\# Folder: @ScalingAndRotationCameraCalibration (ID: @ScalingAndRotationCameraCalibration)

\-\-\-

\#\#\# File: ScalingAndRotationCameraCalibration.m (ID: @ScalingAndRotationCameraCalibration.1\)

classdef ScalingAndRotationCameraCalibration \< CameraCalibration
 %SimpleScalingCameraCalibration \< handle
 %maps points from camera to real points
 %after extraction, larva position and posture are measured in pixels
 %this provides a map from each point in the image (pixel location) to 
 %physical space (usually measured in centimeters). 
 %
 %in this simplified class, you provide only a scaling factor pxpercm, which is
 %applied as cm \= px/pxpercm;
 %and a rotation theta. this rotation is the rotation of the real image
 %relative to the camera image. EG \-\- if theta is 90, an arrow that
 %points to the right in camera space will point up in real space
 properties
 pxpercm \= 1;
 theta \= 0;
 end
 
 methods %constructor
 function cc \= ScalingAndRotationCameraCalibration(varargin)
 %cc \= CameraCalibration(checkerim)
 %cc \= CameraCalibration (realx, realy, camx, camy);
 switch(length(varargin))
 case 0
 
 case 1
 cc.pxpercm \= varargin{1};
 
 case 2
 cc.pxpercm \= varargin{1};
 cc.theta \= deg2rad(varargin{2});
 end
 cc.P2R \= \[cos(cc.theta) \-sin(cc.theta); sin(cc.theta) cos(cc.theta)]/cc.pxpercm;
 cc.R2P \= inv(cc.P2R);
 end 
 end
 properties (SetAccess \= protected)
 P2R \= eye(2\);
 R2P \= eye(2\);
 end
 methods
 function \[realim,realxaxis,realyaxis] \= morphCamToReal(cc, camim, varargin)
 %NOT implemented yet
 disp ('not implemented yet');
 realim \= camim;
 realxaxis \= (1:size(camim,2\))/cc.pxpercm;
 realyaxis \= (1:size(camim,1\))/cc.pxpercm;
 end
 function camim \= morphRealToCam(cc, realim, varargin)
 %NOT implemented yet
 disp ('not implemented yet');
 camim \= realim;
 end
 
 function campts \= camPtsFromRealPts(cc, realpts) 
 campts \= double(cc.R2P\*realpts);
 end
 function realpts \= realPtsFromCamPts(cc, campts)
 realpts \= double(cc.P2R\*campts); 
 end
 function magfactor \= pixelsPerRealUnit (cc)
 magfactor \= cc.pxpercm;
 end
 function magfactor \= realUnitsPerPixel (cc)
 magfactor \= 1/cc.pxpercm;
 end
 
 end
end


\-\-\-

\#\#\# Folder: yamlMatlab (ID: yamlMatlab)

\-\-\-

\#\#\# File: Struct2Hashmap.m (ID: yamlMatlab.1\)

function ArrList \= Struct2Hashmap(S)
% This function converts matla struct to java object of type
% java.util.HashMap.
% Inputs:
% \- S : matlab struct
% Outputs:
% \- hmap: java.util.HashMap object

%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
%{
 Copyright (c) 2011
 This program is a result of a joined cooperation of Energocentrum
 PLUS, s.r.o. and Czech Technical University (CTU) in Prague.
 The program is maintained by Energocentrum PLUS, s.r.o. and
 licensed under the terms of MIT license. Full text of the license
 is included in the program release.
 
 Author(s):
 Jiri Cigler, Dept. of Control Engineering, CTU Prague
 Jan Siroky, Energocentrum PLUS s.r.o.
 
 Implementation and Revisions:

 Auth Date Description of change
 \-\-\-\- \-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 jc 01\-Mar\-11 First implementation
 jc 07\-Mar\-11 Support for date time and cell arrays nxm
 jc 08\-May\-11 Support for yaml write of cell of structs
%}
%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=


ArrList \= java.util.ArrayList;

for n\=1:numel(S)
 if iscell(S)
 ArrList.add(Struct2Hashmap(S{n}));
 else
 
 hmap \= java.util.LinkedHashMap;
 fnames \= setdiff(fieldnames(S), 'originalFieldName\_02138');
 for fn \= fnames'
 % fn iterates through the field names of S
 % fn is a 1x1 cell array
 
 val \= S(n).(fn{1}); %getfield(S(n),fn{1});
 if isstruct(val)
 val\=Struct2Hashmap(val);
 end
 
 vn \= java.util.ArrayList();
 if not(isscalar(val)) \&\& not(ischar(val)) \&\& not(isa(val,'java.util.LinkedHashMap') \|\| isa(val,'java.util.ArrayList'))
 if not(isscalar(val)) \&\& isnumeric(val) % numeric
 if size(val,1\)\=\=1 % one row
 arrayfun(@(x)vn.add(x),val);
 else
 for i\=1:size(val,1\)
 vnr \= java.util.ArrayList();
 arrayfun(@(x)vnr.add(x),val(i,:));
 vn.add(vnr);
 end
 end
 elseif iscell(val)
 if size(val,1\)\=\=1 % one row
 cellfun(@(x)vn.add(JavaObjType(x)),val);
 else
 for i\=1:size(val,1\)
 vnr \= java.util.ArrayList();
 cellfun(@(x)vnr.add(JavaObjType(x)),val(i,:));
 vn.add(vnr);
 end
 end
 
 else
 error('Unknown data type');
 end
 val \= vn;
 end
 if (isfield(S(n), 'originalFieldName\_02138') \&\& isfield(S(n).originalFieldName\_02138, fn{1}))
 hmap.put(S(n).originalFieldName\_02138\.(fn{1}),JavaObjType(val));
 else
 hmap.put(fn{1},JavaObjType(val));
 end
 end
 if numel(S)\>1
 ArrList.add(hmap);
 else
 ArrList\=hmap;
 end
 end
end
end


function outDataFormat\=JavaObjType(x)
if isa(x,'DateTime')
 outDataFormat\=java.util.Date(datestr(x));
elseif isstruct(x)
 outDataFormat\=Struct2Hashmap(x);
elseif ischar(x)
 outDataFormat \= EncodeUnicode(x);
else
 outDataFormat\=x;
end
end
\-\-\-

\#\#\# File: EncodeUnicode.m (ID: yamlMatlab.2\)

function str \= EncodeUnicode(orig\_utf)
% This function encodes unicode characters into default character set
% orig\_utf .. char

%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
%{
 Copyright (c) 2011
 This program is a result of a joined cooperation of Energocentrum
 PLUS, s.r.o. and Czech Technical University (CTU) in Prague.
 The program is maintained by Energocentrum PLUS, s.r.o. and
 licensed under the terms of MIT license. Full text of the license
 is included in the program release.
 
 Author(s):
 Jiri Cigler, Dept. of Control Engineering, CTU Prague 
 Jan Siroky, Energocentrum PLUS s.r.o.
 
 Implementation and Revisions:

 Auth Date Description of change
 \-\-\-\- \-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 jc 15\-Mar\-11 First implementation

%}
%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=

import java.lang.String
if (isempty(orig\_utf))
 str \= '';
 return;
end
string\=String(orig\_utf);

str \= char(String(string.getBytes('UTF\-8'),feature('DefaultCharacterSet')));

end % end of function
\-\-\-

\#\#\# File: README (ID: yamlMatlab.3\)

 YAMLMatlab 
 v0\.1 
 \=\=\=\=\=\=\=\=\=\=\=\=

About:
YAMLMatlab is a set of Matlab functions enabling reading in and writing out
documents in YAML format. The hierarchical structure of a YAML file is 
represented as a Matlab struct. 

Who:
This program was developed and is being maintained by Energocentrum
PLUS, s.r.o. and Czech Technical University (CTU) in Prague. One can 
redistribute the program under terms of MIT license. Full text of the
license is included in the program release.
 
Main author are:
 \- Jiri Cigler, Dept. of Control Engineering, CTU Prague
 \- Jan Siroky, Energocentrum PLUS s.r.o.



\- Release 0\.1 (2/03/2011\) :
 Features: 
 \- Reading in and writing out a yaml file. 
 \- Available data types are:
 \- Date (00:11:12\)
 \- Strings
 \- Int/Double
 \- Array of strings of size 1xN or Nx1
 \- Matrices of arbitrary size
 \- Introduced "description file" containing key\-word "import" standing for
 files which are to be processed together e.g.
 \-\-\-
 import: 
 \- test1\.yaml
 \- test2\.yaml
 ...
 stands for situation when the program reads two yaml files together
 into one struct

 
Installation:
 \- just add the codes and all subfolders to matlab path by
 \>\> addpath(genpath('path to codes'))
 
\-\-\-

\#\#\# File: MIT\-license.txt (ID: yamlMatlab.4\)

Copyright (c) 2011 CTU in Prague and Energocentrum PLUS s.r.o.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
\-\-\-

\#\#\# File: WriteYamlToString.m (ID: yamlMatlab.5\)

function str \= WriteYamlToString(matlab\_struct)
%function str \= WriteYamlToString(matlab\_struct)
% This function writers struct into Yaml string
% Example
% \>\> yaml\_file\_old \= 'EnaspolMain.yaml';
% \>\> yaml\_file\_new \= 'EnaspolMain.yaml';
% \>\> YamlStruct \= ReadYaml(yaml\_file\_old)
% \>\> WriteYaml(yaml\_file\_new,YamlStruct)

%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
%{
 Copyright (c) 2011
 This program is a result of a joined cooperation of Energocentrum
 PLUS, s.r.o. and Czech Technical University (CTU) in Prague.
 The program is maintained by Energocentrum PLUS, s.r.o. and
 licensed under the terms of MIT license. Full text of the license
 is included in the program release.
 
 Author(s):
 Jiri Cigler, Dept. of Control Engineering, CTU Prague 
 Jan Siroky, Energocentrum PLUS s.r.o.
 
 Implementation and Revisions:

 Auth Date Description of change
 \-\-\-\- \-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 jc 01\-Mar\-11 First implementation
 jc 02\-Mar\-11 .jar package initialization moved to external fun

%}
%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=

InitYaml();

import('org.yaml.snakeyaml.Yaml');

yaml \= Yaml();

Data \= Struct2Hashmap(matlab\_struct);

str \= char(yaml.dump(Data));

end % end of function










\-\-\-

\#\#\# File: InitYaml.m (ID: yamlMatlab.6\)

function InitYaml()
% This function initializes the YAMLReader and Writer


% %\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
%{
 Copyright (c) 2011
 This program is a result of a joined cooperation of Energocentrum
 PLUS, s.r.o. and Czech Technical University (CTU) in Prague.
 The program is maintained by Energocentrum PLUS, s.r.o. and
 licensed under the terms of MIT license. Full text of the license
 is included in the program release.
 
 Author(s):
 Jiri Cigler, Dept. of Control Engineering, CTU Prague
 Jan Siroky, Energocentrum PLUS s.r.o.
 
 Implementation and Revisions:

 Auth Date Description of change
 \-\-\-\- \-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 jc 02\-Mar\-11 First implementation
 jc 03\-Mar\-11 Fixed bug with initialization on windows machines
 jc 04\-Mar\-11 Added character encoding check (in order to set UTF\-8\)
 jc 07\-Jun\-11 Fixed bug when more jar archives were already in path
%}
%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=

archive\_name \= 'snakeyaml\-1\.8\.jar';
package\_path \= \['external\-packages' filesep 'snakeyaml'];
% add .jar to dynamic path

if not(any(cellfun(@(x)not(isempty(strfind(x,package\_path))),javaclasspath)))
 r \= matlabpath;
 tokens \= strtok(r,pathsep);
 found \= 0;
 \[p, remain] \= strtok(r,pathsep);
 while p
 if not(isempty(strfind(p, package\_path )))
 javaaddpath(\[ p filesep archive\_name ] );
 found \= 1;
 break;
 end
 \[p, remain] \= strtok(remain,pathsep);
 end
 if not(found)
 error('YAMLMatlab:init:failed','YAMLMatlab initialization failed')
 end
end


end
\-\-\-

\#\#\# File: ReadYaml.m (ID: yamlMatlab.7\)

function YamlStruct \= ReadYaml(yaml\_file)
% This function reads Yaml file into struct
% Example
% \>\> yaml\_file \= 'EnaspolMain.yaml';
% \>\> YamlStruct \= ReadYaml(yaml\_file)
%
% %\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
%{
 Copyright (c) 2011
 This program is a result of a joined cooperation of Energocentrum
 PLUS, s.r.o. and Czech Technical University (CTU) in Prague.
 The program is maintained by Energocentrum PLUS, s.r.o. and
 licensed under the terms of MIT license. Full text of the license
 is included in the program release.
 
 Author(s):
 Jiri Cigler, Dept. of Control Engineering, CTU Prague 
 Jan Siroky, Energocentrum PLUS s.r.o.
 
 Implementation and Revisions:

 Auth Date Description of change
 \-\-\-\- \-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 jc 01\-Mar\-11 First implementation
 jc 02\-Mar\-11 .jar package initialization moved to external fun
 jc 18\-Mar\-11 Warning added when imported file not found
 jc 07\-Jun\-11 Ability to merge structures
 jc 09\-Jun\-11 Merging of structures recursively
%}
%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=

InitYaml();

import('org.yaml.snakeyaml.Yaml');

yamlreader \= Yaml();

Data \= ReplaceImportByStruct(yaml\_file);

work\_folder\=fileparts(yaml\_file);
if isfield(Data,'import')
 yml \= '';
 for i\=1:numel(Data.import)
 fToImport\=\[work\_folder filesep Data.import{i}];
 
 try 
 s \= ReplaceImportByStruct(fToImport);
 Data \= mergeStructs(Data,s);
 catch
 warning('YAMLMatlab:FileNotFoundException','YAMLMatlab: File %s not found',fToImport);
 end 
 end
 %jymlobj \= yamlreader.load(yml);
 %YamlStruct \= Hash2Struct(jymlobj);
 YamlStruct \= rmfield(Data,'import');
else
 YamlStruct \=Data;
end
 function s \= ReplaceImportByStruct(fname)
 yml\_file \= fileread(fname);
 ymlobj \= yamlreader.load(yml\_file);

 s \= Hash2Struct(ymlobj);
 end % end of ReplaceImportByStruct

end % end of function


function res \= mergeStructs(x,y)

 
if isstruct(x) \&\& isstruct(y)
 res \= x;
 names \= fieldnames(y);
 for fnum \= 1:numel(names)
 if isfield(x,names{fnum})
 res.(names{fnum}) \= mergeStructs(x.(names{fnum}),y.(names{fnum}));
 else
 res.(names{fnum}) \= y.(names{fnum});
 end
 end
elseif isstruct(x) \&\& iscell(y)
 found \= 0;
 for i\=1:numel(y)
 if isequal(x,y{i})
 found \=1;
 break;
 end
 end
 if not(found)
 res \= \[x,y];
 else
 res \= y;
 end
elseif iscell(x) \&\& isstruct(y)
 found \= 0;
 for i\=1:numel(x)
 if isequal(x{i},y)
 found \=1;
 break;
 end
 end
 if not(found)
 res \= \[x,y];
 else
 res \= y;
 end
elseif iscell(x) \&\& iscell(y)
 
 for i\=1:min( numel(x), numel(y))
 res{i} \= mergeStructs(x{i},y{i});
 end
 
 if numel(x) \> i
 res(i\+1:numel(x)) \= x(i\+1:end);
 else
 res(i\+1:numel(y)) \= y(i\+1:end);
 end
else
 res \= y;
end
end

\-\-\-

\#\#\# File: WriteYaml.m (ID: yamlMatlab.8\)

function WriteYaml(yaml\_file,matlab\_struct)
% This function writers struct into Yaml file
% Example
% \>\> yaml\_file\_old \= 'EnaspolMain.yaml';
% \>\> yaml\_file\_new \= 'EnaspolMain.yaml';
% \>\> YamlStruct \= ReadYaml(yaml\_file\_old)
% \>\> WriteYaml(yaml\_file\_new,YamlStruct)

%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
%{
 Copyright (c) 2011
 This program is a result of a joined cooperation of Energocentrum
 PLUS, s.r.o. and Czech Technical University (CTU) in Prague.
 The program is maintained by Energocentrum PLUS, s.r.o. and
 licensed under the terms of MIT license. Full text of the license
 is included in the program release.
 
 Author(s):
 Jiri Cigler, Dept. of Control Engineering, CTU Prague 
 Jan Siroky, Energocentrum PLUS s.r.o.
 
 Implementation and Revisions:

 Auth Date Description of change
 \-\-\-\- \-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 jc 01\-Mar\-11 First implementation
 jc 02\-Mar\-11 .jar package initialization moved to external fun

%}
%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=

InitYaml();

import('org.yaml.snakeyaml.Yaml');

yaml \= Yaml();

Data \= Struct2Hashmap(matlab\_struct);

output \= yaml.dump(Data);
fid \= fopen(yaml\_file,'w');
fprintf(fid,'%s',char(output) );
fclose(fid);

end % end of function










\-\-\-

\#\#\# File: Hash2Struct.m (ID: yamlMatlab.9\)

function Data \= Hash2Struct(hashMap)
% This function converts object of type java.util.HashMap to matlab struct.
% Inputs:
% \- hashMap : java.util.HashMap object
% Outputs:
% \- Data : matlab struct
% This code is based on template provided by Jan Siroky on
% http://stackoverflow.com/questions/1638018/is\-there\-already\-a\-yaml\-library\-parser\-for\-matlab


% %\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
%{
 Copyright (c) 2011
 This program is a result of a joined cooperation of Energocentrum
 PLUS, s.r.o. and Czech Technical University (CTU) in Prague.
 The program is maintained by Energocentrum PLUS, s.r.o. and
 licensed under the terms of MIT license. Full text of the license
 is included in the program release.
 
 Author(s):
 Jiri Cigler, Dept. of Control Engineering, CTU Prague
 Jan Siroky, Energocentrum PLUS s.r.o.
 
 Implementation and Revisions:

 Auth Date Description of change
 \-\-\-\- \-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 jc 01\-Mar\-11 First implementation
 jc 03\-Mar\-11 Arrays of struct support
 jc 09\-Mar\-11 DateTime support extended
 jc 15\-Mar\-11 Support for different encodings
 jc 08\-May\-11 Support for yaml read of cell of structs
%}
%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=



if isa(hashMap,'java.util.ArrayList')
 iterator \= hashMap.iterator();
 index \= 0;
 while (iterator.hasNext())
 index \= index \+1;
 %Data(index)\= Hash2Struct(iterator.next());
 res \= Hash2Struct(iterator.next());
 if index\=\=1
 Data \= res;
 else
 if iscell(Data)
 Data{index} \= res;
 elseif isequal(fieldnames(res),fieldnames(Data))
 Data(index) \= res;
 else % convert array to cell
 Data \= num2cell(Data);
 Data{index}\= res;
 end 
 end 
 end
else
 Data \= \[];
 iterator \= hashMap.keySet().iterator();
 while (iterator.hasNext())
 field \= iterator.next();
 if \~isempty(field)
 d \= hashMap.get(java.lang.String(field));
 switch class(d)
 case {'java.util.LinkedHashMap'}
 Data.(fixFieldName(field)) \= Hash2Struct(d);
 case {'java.util.ArrayList'}
 switch class(d.get(0\))
 case {'char' ,'double','java.util.Date'}
 it \= d.iterator();
 val\={};
 while (it.hasNext())
 val(end\+1\)\={it.next()};
 if isa(val{end},'java.util.Date')
 val{end} \= DateTime(val{end});
 end
 if ischar(val{end})
 val{end} \= DecodeUnicode(val{end});
 end
 end
 if all(cellfun(@(x) isnumeric(x),val))
 val \= cell2mat(val);
 end
 case {'java.util.ArrayList'}
 itr \= d.iterator();
 val\={};
 r\=1;
 while (itr.hasNext())
 row\=itr.next();
 itc \= row.iterator();
 c\=1;
 while(itc.hasNext())
 val{r,c}\=itc.next();
 if isa(val{r,c},'java.util.Date')
 val{r,c} \= DateTime(val{r,c});
 end
 if ischar(val{r,c})
 val{r,c} \= DecodeUnicode(val{r,c});
 end
 c\=c\+1;
 end
 r\=r\+1;
 end
 if all(cellfun(@(x) isnumeric(x),val))
 val \= cell2mat(val);
 end
 case {'java.util.LinkedHashMap'}
 for hh\=0:(d.size\-1\)
 hm\=d.get(hh);
 h2sres \= Hash2Struct(hm);
 h2sres\_fn \= fieldnames(h2sres);
 
 if isfield(Data,fixFieldName(field))
 if iscell(Data.(fixFieldName(field)))
 Data.(fixFieldName(field)){hh\+1}\= h2sres;
 elseif isequal(h2sres\_fn,fieldnames(Data.(fixFieldName(field))))
 Data.(fixFieldName(field))(hh\+1\)\= h2sres;
 else % convert array to cell
 Data.(fixFieldName(field)) \= num2cell(Data.(fixFieldName(field)));
 Data.(fixFieldName(field)){hh\+1}\= h2sres;
 end
 else
 Data.(fixFieldName(field))\= h2sres;
 end
 end
 Data.originalFieldName\_02138\.(fixFieldName(field)) \= field; 
 continue;
 
 otherwise
 error('unknown java datatype');
 end
 
 
 Data.(fixFieldName(field)) \= val;
 otherwise
 if isa(d,'java.util.Date')
 d \= DateTime(d);
 end
 if ischar(d)
 d \= DecodeUnicode(d);
 end
 Data.(fixFieldName(field)) \= d;
 end
 Data.originalFieldName\_02138\.(fixFieldName(field)) \= field; 
 
 %Data.originalFieldName\_02138
 end
 end
end

function field \= fixFieldName(field)
%function field \= fixFieldName(field)
%replaces invalid field characters (whitespaces) with underscores

ind \= regexp(field, '\\s');
if (\~isempty(ind))
 field(ind) \= '\_';
end
\-\-\-

\#\#\# File: DecodeUnicode.m (ID: yamlMatlab.10\)

function str \= DecodeUnicode(orig\_utf)
% This function decodes/encodes unicode characters into default character set
% orig\_utf .. char 

%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
%{
 Copyright (c) 2011
 This program is a result of a joined cooperation of Energocentrum
 PLUS, s.r.o. and Czech Technical University (CTU) in Prague.
 The program is maintained by Energocentrum PLUS, s.r.o. and
 licensed under the terms of MIT license. Full text of the license
 is included in the program release.
 
 Author(s):
 Jiri Cigler, Dept. of Control Engineering, CTU Prague 
 Jan Siroky, Energocentrum PLUS s.r.o.
 
 Implementation and Revisions:

 Auth Date Description of change
 \-\-\-\- \-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 jc 15\-Mar\-11 First implementation

%}
%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=

import java.lang.String
if (isempty(orig\_utf))
 str \= '';
 return;
end
string\=String(orig\_utf);

str \= char(String(string.getBytes(feature('DefaultCharacterSet')),'UTF\-8'));
end % end of function
\-\-\-

\#\#\# Folder: yamlMatlab/YamlExamples (ID: yamlMatlab.YamlExamples)

\-\-\-

\#\#\# File: EnterpriseMain.yaml (ID: yamlMatlab.YamlExamples.1\)

\-\-\-
import: 
 \- test.yaml
 \- test2\.yaml
...

\-\-\-

\#\#\# File: .DS\_Store (ID: yamlMatlab.YamlExamples.2\)

Could not read file: 'utf\-8' codec can't decode byte 0x80 in position 3131: invalid start byte

\-\-\-

\#\#\# File: test.yaml (ID: yamlMatlab.YamlExamples.3\)

Enterprise:
 name : umfty dumf
 description : production of..
 location : \[ Olomouc , Brno, 12]
 matice : 
 zapis2: 2
Process:
 name: umfty\_dumf\_process
 Description\_umfty: Temperature of heating water 
 predictionHorizon: 142:00:00

\-\-\-

\#\#\# File: mergestruct.m (ID: yamlMatlab.YamlExamples.4\)

function sout \= mergestruct(varargin)
%MERGESTRUCT Merge structures with unique fields.

% Copyright 2009 The MathWorks, Inc.

% Start with collecting fieldnames, checking implicitly
% that inputs are structures.
fn \= \[];
for k \= 1:nargin
 try
 fn \= \[fn ; fieldnames(varargin{k})];
 catch MEstruct
 throw(MEstruct)
 end
end

% Make sure the field names are unique.
if length(fn) \~\= length(unique(fn))
 error('mergestruct:FieldsNotUnique',...
 'Field names must be unique');
end

% Now concatenate the data from each struct. Can't use
% structfun since input structs may not be scalar.
c \= \[];
for k \= 1:nargin
 try
 c \= \[c ; struct2cell(varargin{k})];
 catch MEdata
 throw(MEdata);
 end
end

% Construct the output.
sout \= cell2struct(c, fn, 1\);
end
\-\-\-

\#\#\# File: test2\.yaml (ID: yamlMatlab.YamlExamples.5\)

Process:
 name: umfty\_dumf
 Description: Temperature of heating water 
 controlSamplingPeriod: 1:00:00
 predictionHorizon: 144:00:00
Enterprise:
 matice:
 zapis1:e
sensors:
 \- class: Compass
 tiltSigma: 0\.2
 headingSigma: 0\.5
 Hz: 20
 translation: \[1,1,1]
 rotationaxis: \[1, 0, 0, 0]
 \- class: DepthSensor
 whiteSigma: 0\.1
 translation: \[0\.1, 0\.2, 0\.3]
 \- class: Compass
 tiltSigma: 0\.2
 headingSigma: 0\.5
 Hz: 20
 translation: \[1,1,1]
 rotationaxis: \[1, 0, 0, 0]

\-\-\-

\#\#\# File: catstruct.m (ID: yamlMatlab.YamlExamples.6\)

function A \= catstruct(varargin)
% CATSTRUCT \- concatenate structures
%
% X \= CATSTRUCT(S1,S2,S3,...) concates the structures S1, S2, ... into one
% structure X. 
%
% Example:
% A.name \= 'Me' ; 
% B.income \= 99999 ; 
% X \= catstruct(A,B) 
% % \-\> X.name \= 'Me' ;
% % X.income \= 99999 ;
%
% CATSTRUCT(S1,S2,'sorted') will sort the fieldnames alphabetically.
%
% If a fieldname occurs more than once in the argument list, only the last
% occurence is used, and the fields are alphabetically sorted.
%
% To sort the fieldnames of a structure A use:
% A \= CATSTRUCT(A,'sorted') ;
%
% To concatenate two similar array of structs use simple concatenation:
% A \= dir('\*.mat') ; B \= dir('\*.m') ; C \= \[A ; B] ;
%
% When there is nothing to concatenate, the result will be an empty
% struct (0x0 struct array with no fields). 
%
% See also CAT, STRUCT, FIELDNAMES, STRUCT2CELL

% for Matlab R13 and up
% version 2\.2 (oct 2008\)
% (c) Jos van der Geest
% email: jos@jasen.nl

% History
% Created: 2005
% Revisions
% 2\.0 (sep 2007\) removed bug when dealing with fields containing cell
% arrays (Thanks to Rene Willemink) 
% 2\.1 (sep 2008\) added warning and error identifiers
% 2\.2 (oct 2008\) fixed error when dealing with empty structs (Thanks to
% Lars Barring)

N \= nargin ;

error(nargchk(1,Inf,N)) ;

if \~isstruct(varargin{end}),
 if isequal(varargin{end},'sorted'),
 sorted \= 1 ;
 N \= N\-1 ;
 if N \< 1,
 A \= struct(\[]) ;
 return
 end
 else
 error('catstruct:InvalidArgument','Last argument should be a structure, or the string "sorted".') ;
 end
else
 sorted \= 0 ;
end

FN \= cell(N,1\) ;
VAL \= cell(N,1\) ;

for ii\=1:N,
 X \= varargin{ii} ;
 if \~isstruct(X),
 error('catstruct:InvalidArgument',\['Argument \#' num2str(ii) ' is not a structure.']) ;
 end
 if \~isempty(X),
 % empty structs are ignored
 FN{ii} \= fieldnames(X) ;
 VAL{ii} \= struct2cell(X) ; 
 end
end

FN \= cat(1,FN{:}) ;
VAL \= cat(1,VAL{:}) ;
\[UFN,ind] \= unique(FN) ;

if numel(UFN) \~\= numel(FN),
 warning('catstruct:DuplicatesFound','Duplicate fieldnames found. Last value is used and fields are sorted') ;
 sorted \= 1 ;
end

if sorted,
 VAL \= VAL(ind) ;
 FN \= FN(ind) ;
end

if \~isempty(FN),
 % This deals correctly with cell arrays
 A \= cell2struct(VAL, FN);
else
 A \= struct(\[]) ;
end
end
\-\-\-

\#\#\# Folder: yamlMatlab/external\-packages (ID: yamlMatlab.external\-packages)

\-\-\-

\#\#\# File: .DS\_Store (ID: yamlMatlab.external\-packages.1\)

Could not read file: 'utf\-8' codec can't decode byte 0xae in position 301: invalid start byte

\-\-\-

\#\#\# Folder: yamlMatlab/external\-packages/snakeyaml (ID: yamlMatlab.external\-packages.snakeyaml)

\-\-\-

\#\#\# File: LICENSE\-2\.0\.txt (ID: yamlMatlab.external\-packages.snakeyaml.1\)


 Apache License
 Version 2\.0, January 2004
 http://www.apache.org/licenses/

 TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

 1\. Definitions.

 "License" shall mean the terms and conditions for use, reproduction,
 and distribution as defined by Sections 1 through 9 of this document.

 "Licensor" shall mean the copyright owner or entity authorized by
 the copyright owner that is granting the License.

 "Legal Entity" shall mean the union of the acting entity and all
 other entities that control, are controlled by, or are under common
 control with that entity. For the purposes of this definition,
 "control" means (i) the power, direct or indirect, to cause the
 direction or management of such entity, whether by contract or
 otherwise, or (ii) ownership of fifty percent (50%) or more of the
 outstanding shares, or (iii) beneficial ownership of such entity.

 "You" (or "Your") shall mean an individual or Legal Entity
 exercising permissions granted by this License.

 "Source" form shall mean the preferred form for making modifications,
 including but not limited to software source code, documentation
 source, and configuration files.

 "Object" form shall mean any form resulting from mechanical
 transformation or translation of a Source form, including but
 not limited to compiled object code, generated documentation,
 and conversions to other media types.

 "Work" shall mean the work of authorship, whether in Source or
 Object form, made available under the License, as indicated by a
 copyright notice that is included in or attached to the work
 (an example is provided in the Appendix below).

 "Derivative Works" shall mean any work, whether in Source or Object
 form, that is based on (or derived from) the Work and for which the
 editorial revisions, annotations, elaborations, or other modifications
 represent, as a whole, an original work of authorship. For the purposes
 of this License, Derivative Works shall not include works that remain
 separable from, or merely link (or bind by name) to the interfaces of,
 the Work and Derivative Works thereof.

 "Contribution" shall mean any work of authorship, including
 the original version of the Work and any modifications or additions
 to that Work or Derivative Works thereof, that is intentionally
 submitted to Licensor for inclusion in the Work by the copyright owner
 or by an individual or Legal Entity authorized to submit on behalf of
 the copyright owner. For the purposes of this definition, "submitted"
 means any form of electronic, verbal, or written communication sent
 to the Licensor or its representatives, including but not limited to
 communication on electronic mailing lists, source code control systems,
 and issue tracking systems that are managed by, or on behalf of, the
 Licensor for the purpose of discussing and improving the Work, but
 excluding communication that is conspicuously marked or otherwise
 designated in writing by the copyright owner as "Not a Contribution."

 "Contributor" shall mean Licensor and any individual or Legal Entity
 on behalf of whom a Contribution has been received by Licensor and
 subsequently incorporated within the Work.

 2\. Grant of Copyright License. Subject to the terms and conditions of
 this License, each Contributor hereby grants to You a perpetual,
 worldwide, non\-exclusive, no\-charge, royalty\-free, irrevocable
 copyright license to reproduce, prepare Derivative Works of,
 publicly display, publicly perform, sublicense, and distribute the
 Work and such Derivative Works in Source or Object form.

 3\. Grant of Patent License. Subject to the terms and conditions of
 this License, each Contributor hereby grants to You a perpetual,
 worldwide, non\-exclusive, no\-charge, royalty\-free, irrevocable
 (except as stated in this section) patent license to make, have made,
 use, offer to sell, sell, import, and otherwise transfer the Work,
 where such license applies only to those patent claims licensable
 by such Contributor that are necessarily infringed by their
 Contribution(s) alone or by combination of their Contribution(s)
 with the Work to which such Contribution(s) was submitted. If You
 institute patent litigation against any entity (including a
 cross\-claim or counterclaim in a lawsuit) alleging that the Work
 or a Contribution incorporated within the Work constitutes direct
 or contributory patent infringement, then any patent licenses
 granted to You under this License for that Work shall terminate
 as of the date such litigation is filed.

 4\. Redistribution. You may reproduce and distribute copies of the
 Work or Derivative Works thereof in any medium, with or without
 modifications, and in Source or Object form, provided that You
 meet the following conditions:

 (a) You must give any other recipients of the Work or
 Derivative Works a copy of this License; and

 (b) You must cause any modified files to carry prominent notices
 stating that You changed the files; and

 (c) You must retain, in the Source form of any Derivative Works
 that You distribute, all copyright, patent, trademark, and
 attribution notices from the Source form of the Work,
 excluding those notices that do not pertain to any part of
 the Derivative Works; and

 (d) If the Work includes a "NOTICE" text file as part of its
 distribution, then any Derivative Works that You distribute must
 include a readable copy of the attribution notices contained
 within such NOTICE file, excluding those notices that do not
 pertain to any part of the Derivative Works, in at least one
 of the following places: within a NOTICE text file distributed
 as part of the Derivative Works; within the Source form or
 documentation, if provided along with the Derivative Works; or,
 within a display generated by the Derivative Works, if and
 wherever such third\-party notices normally appear. The contents
 of the NOTICE file are for informational purposes only and
 do not modify the License. You may add Your own attribution
 notices within Derivative Works that You distribute, alongside
 or as an addendum to the NOTICE text from the Work, provided
 that such additional attribution notices cannot be construed
 as modifying the License.

 You may add Your own copyright statement to Your modifications and
 may provide additional or different license terms and conditions
 for use, reproduction, or distribution of Your modifications, or
 for any such Derivative Works as a whole, provided Your use,
 reproduction, and distribution of the Work otherwise complies with
 the conditions stated in this License.

 5\. Submission of Contributions. Unless You explicitly state otherwise,
 any Contribution intentionally submitted for inclusion in the Work
 by You to the Licensor shall be under the terms and conditions of
 this License, without any additional terms or conditions.
 Notwithstanding the above, nothing herein shall supersede or modify
 the terms of any separate license agreement you may have executed
 with Licensor regarding such Contributions.

 6\. Trademarks. This License does not grant permission to use the trade
 names, trademarks, service marks, or product names of the Licensor,
 except as required for reasonable and customary use in describing the
 origin of the Work and reproducing the content of the NOTICE file.

 7\. Disclaimer of Warranty. Unless required by applicable law or
 agreed to in writing, Licensor provides the Work (and each
 Contributor provides its Contributions) on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 implied, including, without limitation, any warranties or conditions
 of TITLE, NON\-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 PARTICULAR PURPOSE. You are solely responsible for determining the
 appropriateness of using or redistributing the Work and assume any
 risks associated with Your exercise of permissions under this License.

 8\. Limitation of Liability. In no event and under no legal theory,
 whether in tort (including negligence), contract, or otherwise,
 unless required by applicable law (such as deliberate and grossly
 negligent acts) or agreed to in writing, shall any Contributor be
 liable to You for damages, including any direct, indirect, special,
 incidental, or consequential damages of any character arising as a
 result of this License or out of the use or inability to use the
 Work (including but not limited to damages for loss of goodwill,
 work stoppage, computer failure or malfunction, or any and all
 other commercial damages or losses), even if such Contributor
 has been advised of the possibility of such damages.

 9\. Accepting Warranty or Additional Liability. While redistributing
 the Work or Derivative Works thereof, You may choose to offer,
 and charge a fee for, acceptance of support, warranty, indemnity,
 or other liability obligations and/or rights consistent with this
 License. However, in accepting such obligations, You may act only
 on Your own behalf and on Your sole responsibility, not on behalf
 of any other Contributor, and only if You agree to indemnify,
 defend, and hold each Contributor harmless for any liability
 incurred by, or claims asserted against, such Contributor by reason
 of your accepting any such warranty or additional liability.

 END OF TERMS AND CONDITIONS

 APPENDIX: How to apply the Apache License to your work.

 To apply the Apache License to your work, attach the following
 boilerplate notice, with the fields enclosed by brackets "\[]"
 replaced with your own identifying information. (Don't include
 the brackets!) The text should be enclosed in the appropriate
 comment syntax for the file format. We also recommend that a
 file or class name and description of purpose be included on the
 same "printed page" as the copyright notice for easier
 identification within third\-party archives.

 Copyright \[yyyy] \[name of copyright owner]

 Licensed under the Apache License, Version 2\.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE\-2\.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

\-\-\-

\#\#\# File: snakeyaml\-1\.8\.jar (ID: yamlMatlab.external\-packages.snakeyaml.2\)

Could not read file: 'utf\-8' codec can't decode byte 0xf3 in position 89: invalid continuation byte

\-\-\-

\#\#\# Folder: yamlMatlab/classes (ID: yamlMatlab.classes)

\-\-\-

\#\#\# File: DateTime.m (ID: yamlMatlab.classes.1\)

classdef DateTime
 % This class enclapsulates date time value but behaves in a very
 % similar way as typical array of timestamps in datenum format
 %\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
 %{
 Copyright (c) 2011
 This program is a result of a joined cooperation of Energocentrum
 PLUS, s.r.o. and Czech Technical University (CTU) in Prague.
 The program is maintained by Energocentrum PLUS, s.r.o. and 
 licensed under the terms of MIT license. Full text of the license 
 is included in the program release. 
 
 Author(s): 
 Jiri Cigler, Dept. of Control Engineering, CTU Prague \& Automatic Control Laboratory, ETH Zurich 
 Jan Siroky, Energocentrum PLUS s.r.o. 
 
 Implementation and Revisions:

 Auth Date Description of change
 \-\-\-\- \-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 jc 01\-Mar\-11 First implementation
 %}
 %\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=

 properties
 serialDate
 end
 methods
 function this \= DateTime(varargin)
 if numel(varargin)\=\=1 \&\& isa(varargin{1},'java.util.Date')
 this.serialDate\=\-java.util.Date().getTimezoneOffset()/(60\*24\)\+datenum(char(varargin{1}.toGMTString));
 else
 this.serialDate\=datenum(varargin{:});
 end
 end
 function this \= plus(this,val)
 o \=@plus;
 this \= doFun(this,o,val);
 end
 function this \= minus(this,val)
 o \=@minus;
 this \= doFun(this,o,val);
 end
 function this \= times(this,val)
 o \=@times;
 this \= doFun(this,o,val);
 end
 
 function this \= mtimes(this,val)
 o \=@mtimes;
 this \= doFun(this,o,val);
 end
 
 function this \= mrdivide(this,val)
 o \=@mrdivide;
 this \= doFun(this,o,val);
 end
 
 function this \= rdivide(this,val)
 o \=@rdivide;
 this \= doFun(this,o,val);
 end
 
 
 
 function this \= horzcat(this,varargin)
 %this.serialDate \= \[this.serialDate, n.serialDate];
 for i\=1:numel(varargin)
 this.serialDate \= \[this.serialDate, varargin{i}.serialDate];
 end
 end
 
 function this \= vertcat(this,varargin)
 for i\=1:numel(varargin)
 this.serialDate \= \[this.serialDate; varargin{i}.serialDate];
 end
 end
 
 
 function this \= ctranspose(this)
 this.serialDate \= this.serialDate';
 end
 
 function this \= transpose(this)
 this.serialDate \= this.serialDate';
 end
 function disp(this)
 disp(\[this.serialDate])
 end
 function out \= double(this)
 out \= this.serialDate;
 end
 function out \= length(this)
 out \= length(this.serialDate);
 end
 
 function out \= size(this,varargin)
 out \= size(this.serialDate,varargin{:});
 end
 
 function out \= numel(this)
 out \= numel(this.serialDate);
 end
 function out \= isreal(this)
 out \= isreal(this.serialDate);
 end
 function out \= isnan(this)
 out \= isnan(this.serialDate);
 end
 function out \= isfinite(this)
 out \= isfinite(this.serialDate);
 end
 
 function out \= le(this,B)
 if isa(B,'DateTime')
 out \= le(this.serialDate,B.serialDate);
 else
 out \= le(this.serialDate,B);
 end
 end
 
 function out \= lt(this,B)
 fun\=@lt;
 if isa(B,'DateTime')
 out \= fun(this.serialDate,B.serialDate);
 else
 out \= fun(this.serialDate,B);
 end
 end
 function out \= gt(this,B)
 fun\=@gt;
 if isa(B,'DateTime')
 out \= fun(this.serialDate,B.serialDate);
 else
 out \= fun(this.serialDate,B);
 end
 end
 function out \= eq(this,B)
 fun\=@eq;
 if isa(B,'DateTime')
 out \= fun(this.serialDate,B.serialDate);
 else
 out \= fun(this.serialDate,B);
 end
 end
 function out \= diff(this)
 out \= diff(this.serialDate);
 end
 
 function out \= norm(this,varargin)
 out \= norm(this.serialDate,varargin{:});
 end
 
 function \[this k] \= sort(this,varargin)
 \[this.serialDate k] \= sort(this.serialDate,varargin{:});
 end
 
 function this \= subsref(this,S)
 if isa(S.subs{1},'DateTime')
 S.subs{1}\=double(S.subs{1});
 end
 
 this.serialDate \= subsref(this.serialDate,S);
 end
 
 function idx \= subsindex(this)
 idx \= double(this)\-1;
 end
 
 function endidx \= end(this,k,n) 
 if size(this.serialDate,1\)\=\=1 \|\| size(this.serialDate,2\)\=\=1
 endidx\=numel(this.serialDate);
 else
 endidx \= size(this.serialDate,k);
 end
 end
 
 function this \= subsasgn(this, S, B)
 if not(isa(B,'DateTime'))
 B\=DateTime(B);
 end
 
 this.serialDate \=subsasgn(this.serialDate, S, B);
 end
 
 function res \= bsxfun(fun,A,B)
 res \= fun(A,B);
 end
 
 function out \=superiorfloat (x,y,xi)
 if isa(x,'DateTime') \&\& isa(xi,'DateTime')
 out \= superiorfloat(x.serialDate,y,xi.serialDate);
 elseif isa(x,'DateTime') \&\& not(isa(xi,'DateTime'))
 out \= superiorfloat(x.serialDate,y,xi);
 elseif not(isa(x,'DateTime')) \&\& isa(xi,'DateTime')
 out \= superiorfloat(x,y,xi.serialDate);
 else
 out \= superiorfloat(x,y,xi);
 end
 end
 
 function this \= floor(this)
 this.serialDate \= floor(this.serialDate);
 end
 function this \= max(this,varargin)
 this.serialDate \= max(this.serialDate,varargin{:});
 end
 function this \= min(this,varargin)
 this.serialDate \= min(this.serialDate,varargin{:});
 end
 function out \= datestr(this)
 out \= datestr(this.serialDate);
 end
 end
 
 methods (Access \= private)
 function this \= doFun (this,o, val)
 if isa(val,'DateTime') \&\& isa(this,'DateTime')
 this.serialDate\=o(this.serialDate, val.serialDate);
 elseif isa(val,'DateTime') \&\& not(isa(this,'DateTime'))
 val.serialDate\=o(this, val.serialDate);
 this \= val;
 elseif not(isa(val,'DateTime')) \&\& (isa(this,'DateTime'))
 this.serialDate\=o(this.serialDate, val);
 else
 this.serialDate\=DateTime(o(this, val));
 end
 end
 
 
 end
 
end

\-\-\-

\#\#\# Folder: yamlMatlab/Tests (ID: yamlMatlab.Tests)

\-\-\-

\#\#\# File: scilabload.sce (ID: yamlMatlab.Tests.1\)

jimport java.io.InputStream;
jimport java.io.File;
res\=javaclasspath();
javaclasspath('/home/jirka/Software/yamlmatlab/trunk/external\-packages/snakeyaml/snakeyaml\-1\.8\.jar');

jimport('org.yaml.snakeyaml.Yaml')

yamlreader \= Yaml.new();
u \= mopen('/home/jirka/SVN/EnergoCentrum/MPC\_RT/Dejvice/Definition/OptimalControlProblem.yml','r');
yml \= mgetl(u);
mclose(u);
jymlobj \= yamlreader.load(yml);

f \= File.new("home/jirka/SVN/EnergoCentrum/MPC\_RT/Dejvice/Definition/OptimalControlProblem.yml");
 input \= FileInputStream.new(f);


\-\-\-

\#\#\# File: selftest\_report.html (ID: yamlMatlab.Tests.2\)

 ::SELFTEST REPORT::# Selftest report from:07\-Jun\-2011 20:16:18

 ## test\_ReadYaml

### test\_ReadYaml:

Passed  ### test\_ReadYaml\_DateTime:

Passed  ### test\_ReadYaml\_SimpleStructure:

Passed   ## test\_WriteYaml


\-\-\-

\#\#\# File: selftest\_yamlmatlab.m (ID: yamlMatlab.Tests.3\)

function selftest\_yamlmatlab(varargin)
% This function tests consistency of YAMLMatlab, by default, the results
% are stored in selftest\_report.html in current work folder.
% Example
% \>\> selftest\_yamlmatlab()
% \>\> selftest\_yamlmatlab(outFileName)
%
% %\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=
%{
 Copyright (c) 2011
 This program is a result of a joined cooperation of Energocentrum
 PLUS, s.r.o. and Czech Technical University (CTU) in Prague.
 The program is maintained by Energocentrum PLUS, s.r.o. and
 licensed under the terms of MIT license. Full text of the license
 is included in the program release.
 
 Author(s):
 Jiri Cigler, Dept. of Control Engineering, CTU Prague 
 Jan Siroky, Energocentrum PLUS s.r.o.
 
 Implementation and Revisions:

 Auth Date Description of change
 \-\-\-\- \-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
 jc 25\-May\-11 First implementation 
%}
%\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=

outFname \= 'selftest\_report.html';
if numel(varargin)
 outFname \= varargin{1};
end

outStr \= getHTMLHeader();

outStr \= strcat(outStr,'# Selftest report from:',datestr(now),'

');

tests \= dir(\[fileparts(which('selftest\_yamlmatlab')) filesep 'test\*.m']);

for test\=tests'
 \[\~,func]\=fileparts(test.name);
 fhandle \= str2func(func);
 stat \= fhandle();
 
 outStr \= strcat(outStr, ' ## ',func, '

', stat2html(stat,func),'');
 
end

outStr \= strcat(outStr,'');


fid \= fopen(outFname,'w');
fprintf(fid,outStr);
fclose(fid);
end

function html \= stat2html(stat,name)
if not(isstruct(stat))
 error('Input argument must be a struct');
end

html \= '';

fn \= fieldnames(stat);

if all(ismember({'ok','desc'},fn))
 if stat.ok
 flag \= 'Passed';
 else
 flag \= '**Failed**,';
 end
 html \= strcat(html,'### ',name,':

 ', flag, ' *', stat.desc,'* ' );
end

for test \=setdiff(fn',{'ok','desc'})
 html \= strcat(html, stat2html(stat.(test{1}),test{1}));
end
end


function str \= getHTMLHeader()
str \= \[ '' ... 
 ' ' ... 
 ''... 
 '::SELFTEST REPORT::'... 
 ''];
end
\-\-\-

\#\#\# File: test\_WriteYaml.m (ID: yamlMatlab.Tests.4\)

function stat \= test\_WriteYaml()

stat \= struct();
end
\-\-\-

\#\#\# File: test\_ReadYaml.m (ID: yamlMatlab.Tests.5\)

function stat \= test\_ReadYaml()
% this function tests reading in the yaml file

stat.ok \= 1;
stat.desc \= '';
try
 stat.test\_ReadYaml\_SimpleStructure \= test\_ReadYaml\_SimpleStructure(); 
 stat.test\_ReadYaml\_DateTime \= test\_ReadYaml\_DateTime(); 
catch 
 stat.ok \= 0;
 stat.desc \= 'Program crash';
end

end


function stat \= test\_ReadYaml\_SimpleStructure()

stat.ok \= 1;
stat.desc \= '';
try
 s \= ReadYaml('simple.yaml');
 
 ages \= \[s.age];
 
 if not(isequal(\[33 27], ages)) \|\| not(all(ismember({'John Smith', 'Mary Smith'}, {s.name}) ))
 stat.desc \= ' Wrong values loaded';
 stat.ok \= 0;
 end
 
catch 
 stat.desc \= 'Program crash';
 stat.ok \= 0;
end


end

function stat \= test\_ReadYaml\_DateTime()

stat.ok \= 1;
stat.desc \= '';
try
 s \= ReadYaml('time.yaml');
 
 if \~isa(s.Data.B1\_S\_SW{1},'DateTime')
 stat.desc \= ' Wrong data type of datetick';
 stat.ok \= 0;
 end
 if isa(s.Data.B1\_S\_SW{2},'DateTime')
 stat.desc \= ' Wrong data type of datetick';
 stat.ok \= 0;
 end
catch
 stat.desc \= 'Program crash';
 stat.ok \= 0;
end
end
\-\-\-

\#\#\# Folder: yamlMatlab/Tests/Data (ID: yamlMatlab.Tests.Data)

\-\-\-

\#\#\# File: simple.yaml (ID: yamlMatlab.Tests.Data.1\)

\- {name: John Smith, age: 33}
\- name: Mary Smith
 age: 27
\-\-\-

\#\#\# File: time.yaml (ID: yamlMatlab.Tests.Data.2\)

Data:
 B1\_S\_SW:
 \[!!timestamp '2011\-03\-29T18:09:20\.4543750\+02:00', 23\.80]
\-\-\-

\#\#\# Folder: Variance Adaptation Paper (ID: Variance Adaptation Paper)

\-\-\-

\#\#\# File: VarAdaptAll.m (ID: Variance Adaptation Paper.1\)

function btdstruct \= VarAdaptAll(btdstruct, var, opstruct, Q\_alpha, tau\_alpha, deltaT, ppf, bayes, simtype, rescale\_type, timeType)
%function btdstruct \= VarAdaptAll(btdstruct, var, opstruct, Q\_alpha, tau\_alpha, deltaT, ppf, bayes, simtype, rescale\_type, timeType)

% opstruct \-\- contains info about the experiment, they're all in: Z:\\Var.AdaptRuben\\Matfiles\\opstructs.mat

% var \-\- either \[], or btdstruct.var
% Q\_alpha \-\- variance of the prior for Point Process Filter
% tau\_alpha \-\- correlation time for the Bayesian estimator (variance of the Gaussian prior \= 2\*deltaT/tau\_alpha)
% deltaT \-\- time\-bin width for PPF and Bayesian estimates of gain\-rescaling factors
% ppf \-\- 0 or 1, runs PPF estimate of Alpha(t) or not
% bayes \-\- 0 or 1, runs Bayesian estimate of Alpha(t) or not
% simtype \-\- 'LowHigh' simulates the same number of experiments as are in btdstruct, with a rate function switching from low to high instantly
% simtype \-\- 'All' does the same, but uses the continuously changing rate function as calculated by Bayesian or PPF estimators
% simtype \-\- \[] doesn't simulate anything
% rescale\_type \-\- 'input' or 'output' ('output' might not work very well)
% timeType \-\- 'eti' calculates estimates vs. eti and then converts to cycle time
% timeType \-\- 'ton' calculates directly vs cycle time


logdat \= 1; % determines whether logP(data\|model) or P(data\|model) is used in Bayesian estimator \-\- shouldn't make a difference
nsim \= 1; % how many times the data is simulated ( n\=1 means the same number of experiments are simulated as were performed, with \#larvae\=mean(\#larvae) )



if (isempty(var))
 % use prepVarianceSwitchingAnalysis if kernels need recalculating (not light \& odor stimuli, e.g 20C08 or other neuron)
 btdstruct \= BehaviorTriggeredData.prepVarianceSwitchingAnalysis\_Gepner(btdstruct, opstruct);
 var \= btdstruct.var;
 if(isfield(btdstruct, 'var\_uv'))
 var\_uv \= btdstruct.var\_uv;
 end
end

if(isfield(btdstruct, 'var\_uv'))
 var\_uv \= btdstruct.var\_uv;
end

pdegree \= opstruct.pdegree;
if(size(var, 2\)\>\=2\)
 nstim \= 2;
else
 nstim \= 1;
end

if(\~isfield(btdstruct, 'varops'))
 fn \= {'stim', 'numLxBins', 'adaptationTime', 'Q\_alpha', 'numTimeBins', 'timeRange', 'kernelTime', 'kernelDt'};
 for j \= 1:length(fn)
 btdstruct.varops.(fn{j}) \= opstruct.(fn{j});
 end
end

whichStim \= find(\[btdstruct.varops.stim.switch]);

% TTA Kernels
if(\~isfield(btdstruct, 'Kernels'))
 btdstruct \= measureKernelsVsVar (btdstruct, var);
end

% Head Sweeps
% if(\~isfield(btdstruct, 'HSavgs') \&\& strcmpi(btdstruct.varops.stim(whichStim).ramptype, 'square'))
% existsAndDefault('HSdt',1\.5\);
% btdstruct \= measureHSstats (btdstruct, var, HSdt);
% end

% Rates vs. Stim.
if(\~isfield(btdstruct, 'Rates'))
 btdstruct \= measureRatesVsVar (btdstruct, var);
end
if(isfield(btdstruct, 'var\_uv') \&\& \~isfield(btdstruct, 'RatesU'))
 \[\~, btdstruct.RatesU] \= measureRatesVsVar (btdstruct, var\_uv);
end

% Rate vs Time
if(\~isfield(btdstruct, 'RateVTime'))
 rateDt \= 1;
 \[\~, btdstruct.RateVTime] \= measureRateVtime(var(1\), deltaT, rateDt);
end


% PPF \& Bayes Estimates of Gain\-Rescaling

if(bayes)
 Ddt\_alpha \= deltaT./tau\_alpha;
 if(strcmpi(timeType, 'eti'))
 if(isfinite(opstruct.timeRange(2\))) %jwolk 10/31 changed from btdstruct.varops to opstruct
 tx\_bayes \= opstruct.timeRange(1\):deltaT:opstruct.timeRange(2\); %jwolk 10/31
 else
 tx\_bayes \= opstruct.timeRange(1\):deltaT:max(btdstruct.var(1\).fullensemble.eti); %jwolk 10/31
 end
 else
 tx\_bayes \= 0:deltaT:btdstruct.var.period;
 end
end

if(ppf \&\& \~isfield(btdstruct, 'alphavseti'))
 disp('starting PPF estimate of Data (Odor, Light)')
 btdstruct \= runPPF(btdstruct, \[], var, opstruct, Q\_alpha, deltaT, timeType);
end

if( bayes \&\& \~isfield(btdstruct, 'var\_uv') \&\& \~isfield(btdstruct, 'BayesAlphavsEti\_OL'))
 tic
 if(nstim\=\=2 \&\& pdegree\=\=2\)
 disp('starting Bayesian estimate of Data (Odor, Light) \- added rates') % r(xo,xl) \= a\*u^2 \+ b\*u \+ c , with u\=cos(theta)\*xo\+sin(theta)\*xl
 btdstruct.BayesAlphavsEti\_OL.add \= BayesianModelEstimate(\[], btdstruct, var, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, 'add');
 disp('starting Bayesian estimate of Data (Odor, Light) \- multiplied rates')% r(xo,xl) \= r(xo)\*r(xl), where r(x)\=ax^2\+b\*x\+c
 btdstruct.BayesAlphavsEti\_OL.multiply \= BayesianModelEstimate(\[], btdstruct, var, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, 'mult');
 else
 disp('starting Bayesian estimate of Data (Odor, Light)')
 btdstruct.BayesAlphavsEti\_OL \= BayesianModelEstimate(\[], btdstruct, var, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, \[]);
 end
 toc
end

if(isfield(btdstruct, 'var\_uv') \&\& ppf \&\& \~isfield(btdstruct, 'alphavseti\_UV'))
 tic
 disp('starting PPF estimate of Rotated Data \- UV')
 \[\~, btdstruct.alphavseti\_UV] \= runPPF(btdstruct, \[], var\_uv, opstruct, Q\_alpha, deltaT, timeType);
 toc
end
if(isfield(btdstruct, 'var\_uv') \&\& ppf \&\& \~isfield(btdstruct, 'alphavseti\_U'))
 tic
 disp('starting PPF estimate of Rotated Data \- U')
 \[\~, btdstruct.alphavseti\_U] \= runPPF(btdstruct, \[], var\_uv(1\), opstruct, Q\_alpha, deltaT, timeType);
 toc
end


if( isfield(btdstruct, 'var\_uv') \&\& \~isempty(whichStim) \&\& bayes )
 
 if(\~isfield(btdstruct, 'BayesAlphavsEti\_UV'))
 disp('starting Bayesian estimate of Rotated Data \- UV')
 tic
 btdstruct.BayesAlphavsEti\_UV \= BayesianModelEstimate(\[], btdstruct, var\_uv, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, \[]);
 toc
 end
 if(\~isfield(btdstruct, 'BayesAlphavsEti\_U'))
 disp('starting Bayesian estimate of Rotated Data \- U')
 tic
 btdstruct.BayesAlphavsEti\_U \= BayesianModelEstimate(\[], btdstruct, var\_uv(1\), opstruct, timeType, deltaT, Ddt\_alpha(1\), tx\_bayes, logdat, \[], rescale\_type, \[]);
 toc
 end
% if(\~isfield(btdstruct, 'BayesAlphavsEti\_V'))
% disp('starting Bayesian estimate of Rotated Data \- V')
% tic
% btdstruct.BayesAlphavsEti\_V \= BayesianModelEstimate(\[], btdstruct, var\_uv(2\), opstruct, timeType, deltaT, Ddt\_alpha(2\), tx\_bayes, logdat, \[], rescale\_type);
% toc
% end
end

% Scaled Rates
if( any(\[opstruct.stim.switch]) )
 if( isfield(btdstruct, 'var\_uv') \&\& (bayes \|\| ppf) \&\& \~isfield(btdstruct, 'ScaledRatesU') )
 \[\~, btdstruct.ScaledRatesU] \= adaptedRatesVsVar (btdstruct, btdstruct.var\_uv(1\).period, rescale\_type);
 elseif( isfield(btdstruct, 'var') \&\& (bayes \|\| ppf) \&\& \~isfield(btdstruct, 'ScaledRates'))
 \[\~, btdstruct.ScaledRates] \= adaptedRatesVsVar (btdstruct, btdstruct.var(1\).period, rescale\_type);
 end
end

% DKL
if(\~isfield(btdstruct, 'DKL'))
 \[\~, btdstruct.DKL] \= measureDKLVsVar(btdstruct, var);
end
if(isfield(btdstruct, 'var\_uv') \&\& \~isfield(btdstruct, 'DKL\_UV'))
 \[\~, btdstruct.DKL\_UV] \= measureDKLVsVar(btdstruct, var\_uv);
end

% calculate fit params for alpha(sigma)\=1/(sigma^2\+sigma\_0^2\);
if(\~isempty(whichStim) \&\& nstim\=\=1\)
% if(strcmpi(btdstruct.varops.stim(whichStim).ramptype, 'triangle'))
 if(ppf \&\& \~isfield(btdstruct, 'gainrescaling\_PPF'))
 btdstruct.gainrescaling\_PPF \= fitVarianceRescaling(btdstruct, opstruct, 'PPF', opstruct.stim(whichStim).ramptype, whichStim);
 end
 if(bayes \&\& \~isfield(btdstruct, 'gainrescaling\_Bayes'))
 btdstruct.gainrescaling\_Bayes \= fitVarianceRescaling(btdstruct, opstruct, 'Bayes', opstruct.stim(whichStim).ramptype, whichStim);
 end
 
% end
end


% Simulated Data \& Estimates

if(\~isempty(whichStim))
 if(strcmpi(simtype, 'LowHigh') \|\| strcmpi(simtype, 'All'))
 
 if(\~isfield(btdstruct, 'SimData'))
 tic
 btdstruct.SimData \= SimulateData(btdstruct, var, opstruct, 'ton', nsim, simtype); %keep 'ton' to have both runTon and runT in the simulated data
 toc
 end
 
 if(isfield(btdstruct, \[simtype 'Sim']))
 eval(\['Sim \= btdstruct.' simtype 'Sim;']);
 
 if( ppf \&\& \~isfield(Sim, 'alphavseti'))
 disp('starting PPF estimate of simulated data')
 for i\=1:length(btdstruct.SimData)
 \[\~, Sim.alphavseti{i}] \= runPPF(btdstruct, btdstruct.SimData{i}, var, opstruct, Q\_alpha, deltaT, timeType);
 alpha\_ton(i,:) \= Sim.alphavseti{i}.alpha\_ton;
 valpha\_ton(i,:) \= Sim.alphavseti{i}.valpha\_ton;
 end
 Sim.tx\_ton\_ppf \= Sim.alphavseti{1}.tx\_ton;
 Sim.alpha\_ton\_ppf \= mean(alpha\_ton);
 Sim.valpha\_ton\_ppf \= mean(valpha\_ton)./nsim;
 end
 
 if( bayes \&\& \~isfield(Sim, 'BayesAlphavsEti'))
 disp('starting Bayesian estimate of simulated data')
 rP \= btdstruct.BayesAlphavsEti.RateParams;
 for i\=1:length(btdstruct.SimData)
 tic
 Sim.BayesAlphavsEti{i} \= BayesianModelEstimate(btdstruct.SimData{i}, btdstruct, var, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, \[]);
 alpha\_ton(i,:) \= Sim.BayesAlphavsEti{i}.alpha\_ton;
 valpha\_ton(i,:) \= Sim.BayesAlphavsEti{i}.valpha\_ton;
 toc
 end
 Sim.tx\_ton\_bayes \= Sim.BayesAlphavsEti{1}.tx\_ton;
 Sim.alpha\_ton\_bayes \= mean(alpha\_ton)/mean(mean(alpha\_ton));
 Sim.valpha\_ton\_bayes \= mean(valpha\_ton)./nsim;
 end
 eval(\['btdstruct.' simtype 'Sim \= Sim;']);
 else
 if(ppf \|\| bayes)
 if( ppf )
 disp('starting PPF estimate of simulated data')
 for i\=1:length(btdstruct.SimData)
 \[\~, Sim.alphavseti{i}] \= runPPF(btdstruct, btdstruct.SimData{i}, var, opstruct, Q\_alpha, deltaT, timeType);
 end

 end
 if(bayes)
 disp('starting Bayesian estimate of simulated data')
 for i\=1:length(btdstruct.SimData)
 tic
 Sim.BayesAlphavsEti{i} \= BayesianModelEstimate(btdstruct.SimData{i}, btdstruct, var, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, \[]);
 toc
 end

 end
 eval(\['btdstruct.' simtype 'Sim \= Sim;']);
 end
 end
 
 end
end

end




function \[btdstruct, DKL] \= measureDKLVsVar (btdstruct, var)
opstruct \= btdstruct.varops;
switchStim \= find(\[opstruct.stim.switch]);

if(switchStim\>0\)
 
 nstim \= size(var, 2\);

 for j \= 1:nstim
 
 deltaT \= median(diff(var(j).fullensemble.eti));
 adata \= var(j).noturn.x\_conv;
 tdata \= var(j).turn.x\_conv;
 tton \= var(j).turn.ton;
 ttoff \= var(j).turn.toff;
 teti \= var(j).turn.eti;
 rton \= var(j).noturn.ton;
 rtoff \= var(j).noturn.toff;
 reti \= var(j).noturn.eti;
 
 if(strcmpi(opstruct.stim(switchStim).ramptype, 'square'))
 
 tH \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> 0 \& tton \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> 0 \& ttoff \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 rH \= rton \> opstruct.adaptationTime \& rton \< rtoff \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rL \= rtoff \> opstruct.adaptationTime \& rtoff \< rton \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rU \= rton \> 0 \& rton \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rD \= rtoff \> 0 \& rtoff \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 else
 tH \= tton \> opstruct.adaptationTime \& tton \> (3\*max(tton)/8\) \& tton \< (5\*max(tton)/8\) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff \> opstruct.adaptationTime \& ttoff \> (3\*max(ttoff)/8\) \& ttoff \< (5\*max(ttoff)/8\) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 rH \= rton \> opstruct.adaptationTime \& rton \> (3\*max(rton)/8\) \& rton \< (5\*max(rton)/8\) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rL \= rtoff \> opstruct.adaptationTime \& rtoff \> (3\*max(rtoff)/8\) \& rtoff \< (5\*max(rtoff)/8\) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rU \= rton \> opstruct.adaptationTime \& rton \< rtoff \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rD \= rtoff \> opstruct.adaptationTime \& rtoff \< rton \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 end
 
 saH \= std(adata(rH)); saL \= std(adata(rL)); saU \= std(adata(rU)); saD \= std(adata(rD));
 stH \= std(tdata(tH)); stL \= std(tdata(tL)); stU \= std(tdata(tU)); stD \= std(tdata(tD));
 maH \= mean(adata(rH)); maL \= mean(adata(rL)); maU \= mean(adata(rU)); maD \= mean(adata(rD));
 mtH \= mean(tdata(tH)); mtL \= mean(tdata(tL)); mtU \= mean(tdata(tU)); mtD \= mean(tdata(tD));
 
 dkl1D(j).High \= 0\.5\*(stH^2/saH^2 \+ (maH\-mtH)^2/saH^2 \- 1 \+ log(saH^2/stH^2\));
 dkl1D(j).Low \= 0\.5\*(stL^2/saL^2 \+ (maL\-mtL)^2/saL^2 \- 1 \+ log(saL^2/stL^2\));
 dkl1D(j).Up \= 0\.5\*(stU^2/saU^2 \+ (maU\-mtU)^2/saU^2 \- 1 \+ log(saU^2/stU^2\));
 dkl1D(j).Down \= 0\.5\*(stD^2/saD^2 \+ (maD\-mtD)^2/saD^2 \- 1 \+ log(saD^2/stD^2\));
 
 
 end
 DKL.dkl1D \= dkl1D;
 
 if(nstim\=\=2\)
 for k\=1:2
 rdH(k,:) \= var(k).noturn.x\_conv(rH); rdL(k,:) \= var(k).noturn.x\_conv(rL);
 rdU(k,:) \= var(k).noturn.x\_conv(rU); rdD(k,:) \= var(k).noturn.x\_conv(rD);
 tdH(k,:) \= var(k).turn.x\_conv(tH); tdL(k,:) \= var(k).turn.x\_conv(tL);
 tdU(k,:) \= var(k).turn.x\_conv(tU); tdD(k,:) \= var(k).turn.x\_conv(tD);
 end

 covA \= cov(rdH');
 covT \= cov(tdH');
 muA \= mean(rdH');
 muT \= mean(tdH');
 a \= covA\\covT;
 b \= covA\\(muA\-muT)';
 dkl2D.High \= .5 \* ( trace(a) \+ (muA\-muT)\*b \- 2 \+ log(det(covA)/det(covT)) );
 
 covA \= cov(rdL');
 covT \= cov(tdL');
 muA \= mean(rdL');
 muT \= mean(tdL');
 a \= covA\\covT;
 b \= covA\\(muA\-muT)';
 dkl2D.Low \= .5 \* ( trace(a) \+ (muA\-muT)\*b \- 2 \+ log(det(covA)/det(covT)) );
 
 covA \= cov(rdU');
 covT \= cov(tdU');
 muA \= mean(rdU');
 muT \= mean(tdU');
 a \= covA\\covT;
 b \= covA\\(muA\-muT)';
 dkl2D.Up \= .5 \* ( trace(a) \+ (muA\-muT)\*b \- 2 \+ log(det(covA)/det(covT)) );
 
 covA \= cov(rdD');
 covT \= cov(tdD');
 muA \= mean(rdD');
 muT \= mean(tdD');
 a \= covA\\covT;
 b \= covA\\(muA\-muT)';
 dkl2D.Down \= .5 \* ( trace(a) \+ (muA\-muT)\*b \- 2 \+ log(det(covA)/det(covT)) );
 
 DKL.dkl2D \= dkl2D;
 end
 
else
 
 
 m4 \= @(x) mean(x)^4 \+ 6\*mean(x)^2\*std(x)^2 \+ 3\*std(x)^4;
 sev \= @(x) sqrt( (m4(x) \- (length(x)\-3\)\*std(x)^4/(length(x)\-1\)) / length(x) );
 for j \= 1:size(var, 2\)
 
 data \= var(j);
 
 
 
 adata \= data.noturn.x\_conv;
 tdata \= data.turn.x\_conv;
 sa \= std(adata);
 va \= std(adata)^2;
 st \= std(tdata);
 vt \= std(tdata)^2;
 sva \= sqrt(2\*va^2/(length(adata)\-1\));
 svt \= sqrt(2\*vt^2/(length(tdata)\-1\));
 
% sva \= sev(adata);
% svt \= sev(tdata);
 
 ma \= mean(adata);
 mt \= mean(tdata);
 sma \= sqrt(va/length(adata));
 smt \= sqrt(vt/length(tdata));
 
 DKL.mean(j) \= 0\.5\*(vt/va \+ (ma\-mt)^2/va \- 1 \+ log(va/vt));
 DKL.var(j) \= .5\*sva^2 \* ( (va\-vt\-(mt\-ma)^2\)/va^2 ) \+ .5\*svt^2 \* (1/va \- 1/vt) \+ sma^2 \* (ma\-mt)/va \+ smt^2 \* (mt\-ma)/va; 
 
 
 end
end
end

function SimulatedData \= SimulateData(btdstruct, var, opstruct, timeField, nreps, simtype)

if(isfield(btdstruct, 'BayesAlphavsEti'))
 alphastruct \= btdstruct.BayesAlphavsEti;
elseif(isfield(btdstruct, 'BayesAlphavsEti\_OL'))
 alphastruct \= btdstruct.BayesAlphavsEti\_OL;
else
 alphastruct \= btdstruct.alphavseti;
end

alphastruct.staticParams \= alphastruct.params;

if(isfield(btdstruct, 'SimData'))
 SimulatedData \= btdstruct.SimData;
 return
end

disp(\['simulating ' num2str(nreps) ' set of experiments']);

deltaT \= median(diff(var.fullensemble.eti));
pd \= BehaviorTriggeredData.createProblemStructForRateFunFitting (var, timeField, opstruct.pdegree, opstruct.timeRange, \[], deltaT);
pd.maxreps \= 2;


for j \= 1:length(btdstruct.btd), numan(j) \= btdstruct.btd(j).es.numAnimals; end
Nlarvae \= round(mean(numan));
% Nlarvae \= 40;

dt \= mean(diff(alphastruct.tx\_ton));
nt \= round(10/dt);

alpha\_ton \= alphastruct.alpha\_ton/mean(alphastruct.alpha\_ton);
alow \= mean(alpha\_ton(1\+nt:round(end/2\)));
ahigh \= mean(alpha\_ton(round(end/2\)\+nt:end));

if(strcmpi(simtype, 'LowHigh'))
 
 for j\=1:nreps
 SimulatedData{j} \= BehaviorTriggeredData.simulateVarSwitchFromPrevFit(btdstruct, alphastruct, pd, alow, ahigh, Nlarvae);
 end
 
elseif(strcmpi(simtype, 'All'))
 
 
 pd.tx\_eti \= alphastruct.tx;
 pd.alpha\_eti \= alphastruct.alpha;
 
 for k\=1:nreps
 SimulatedData{k} \= BehaviorTriggeredData.simulateVarSwitchFromPrevFit(btdstruct, alphastruct, pd, alow, ahigh, Nlarvae);
 end
 
end

end

function gainrescaling \= fitVarianceRescaling(btdstruct, opstruct, estimator, type, switchstim)

rescalingfun \= @(x,xdata) 1\./sqrt(xdata.^2 \+ x^2\) / mean(1\./sqrt(xdata.^2 \+ x^2\));
% rescalingfun \= @(x,xdata) x(1\)./sqrt(xdata.^2 \+ x(2\)^2\);

if(strcmpi(estimator, 'PPF'))
 if(length(btdstruct.varops.stim)\>2\)
 tx\_ton \= btdstruct.alphavseti\_U.tx\_ton;
 alpha\_s \= btdstruct.alphavseti\_U.alpha\_s\_ton;
 valpha\_s \= squeeze(btdstruct.alphavseti\_U.valpha\_s\_ton)';
 else
 tx\_ton \= btdstruct.alphavseti.tx\_ton;
 alpha\_s \= btdstruct.alphavseti.alpha\_s\_ton(switchstim, :);
 valpha\_s \= squeeze(btdstruct.alphavseti.valpha\_s\_ton(switchstim, switchstim, :))';
 end
else
 if(length(btdstruct.varops.stim)\>2\)
 tx\_ton \= btdstruct.BayesAlphavsEti\_U.tx\_ton;
 alpha\_s \= btdstruct.BayesAlphavsEti\_U.alpha\_ton;
 valpha\_s \= btdstruct.BayesAlphavsEti\_U.valpha\_ton;
 else
 tx\_ton \= btdstruct.BayesAlphavsEti\_OL.tx\_ton;
 alpha\_s \= btdstruct.BayesAlphavsEti\_OL.alpha\_ton(switchstim, :);
 valpha\_s \= btdstruct.BayesAlphavsEti\_OL.valpha\_ton(switchstim, :);
 end
end

if(isfield(btdstruct, 'var\_uv'))
 var \= btdstruct.var\_uv(1\);
elseif(isfield(btdstruct, 'var'))
 var \= btdstruct.var(1\);
else
 disp('no var field to calculate signal variance');
 return
end

trange \= opstruct.timeRange;
adaptTime \= opstruct.adaptationTime;
teti \= var.fullensemble.eti;
ton \= var.fullensemble.ton;
xo \= var.fullensemble.x\_conv;

valid \= teti\>trange(1\) \& tetiadaptTime \& ton(round(max(ton)/2\)\+adaptTime);

if(strcmpi(type, 'triangle'))
 \[\~,\~,\~,son\_all] \= meanyvsx(ton(valid), xo(valid), binEdgesFromCenters(tx\_ton));
 % son\_all \= son\_all';
 params.up \= lsqcurvefit(rescalingfun, \[1], son\_all(tx\_ton\<(max(tx\_ton)/2\)), alpha\_s(tx\_ton\<(max(tx\_ton)/2\)));
 params.down \= lsqcurvefit(rescalingfun, \[1], son\_all(tx\_ton\>(max(tx\_ton)/2\)), alpha\_s(tx\_ton\>(max(tx\_ton)/2\)));
 params.all \= lsqcurvefit(rescalingfun, \[1], son\_all, alpha\_s);
elseif(strcmpi(type, 'square'))
 
 high \= tx\_ton\>\=adaptTime \& tx\_ton(round(max(tx\_ton)/2\)\+adaptTime);
 all \= (tx\_ton\>adaptTime \& tx\_ton(round(max(tx\_ton)/2\)\+adaptTime);
 
% \[\~,\~,\~,son\_all] \= meanyvsx(ton(valid \& adapted), xo(valid \& adapted), binEdgesFromCenters(tx\_ton));
% params.high \= lsqcurvefit(rescalingfun, \[1 1], son\_all(high), alpha\_s(high));
% params.low \= lsqcurvefit(rescalingfun, \[1 1], son\_all(low), alpha\_s(low));
 
 \[\~,\~,\~,son\_all] \= meanyvsx(ton(valid \& adapted), xo(valid \& adapted), binEdgesFromCenters(tx\_ton));
 params.all \= lsqcurvefit(rescalingfun, \[1], son\_all(all), alpha\_s(all));
end
gainrescaling.estimator \= estimator;
gainrescaling.fitfun \= rescalingfun;
gainrescaling.son\_all \= son\_all;
gainrescaling.params \= params;
end


function \[btdstruct, alphavseti, alphavston, scaledValues] \= runPPF(btdstruct, pd, var, opstruct, Q\_alpha, deltaT, timeType)


nstim \= size(var, 2\);

if(isempty(pd))
 pd \= BehaviorTriggeredData.createProblemStructForRateFunFitting (var, 'eti', opstruct.pdegree, opstruct.timeRange, \[], deltaT);
 pd.Q\_alpha \= Q\_alpha \* eye(nstim);
 pd.maxreps \= 5;
end

pd.temporalratemod \= \[];


alphavseti \= fitRateFunWithTemporalScalingND(pd);

%turn time estimate into time in cycle estimate

\[alphavseti.alpha\_ton, alphavseti.valpha\_ton, alphavseti.tx\_ton] \= meanEstinCycle(alphavseti.alpha, alphavseti.valpha, alphavseti.tx, pd.tshift, pd.period, opstruct.timeRange, timeType);
\[alphavseti.alpha\_s\_ton, alphavseti.valpha\_s\_ton, alphavseti.tx\_ton] \= meanEstinCycle(alphavseti.alpha\_s, alphavseti.valpha\_s, alphavseti.tx, pd.tshift, pd.period, opstruct.timeRange, timeType);

alphavseti.Q\_alpha \= Q\_alpha;
btdstruct.alphavseti \= alphavseti;


if(strcmpi(timeType, 'ton'))
 %directly calculate stretch factor vs cycle time
 pd \= BehaviorTriggeredData.createProblemStructForRateFunFitting (var, 'ton', opstruct.pdegree, opstruct.timeRange, \[], deltaT);
 
 if all(size(pd.alpha\_0\) \=\= size(alphavseti.alpha\_ton))
 pd.alpha\_0 \= alphavseti.alpha\_ton;
 end
 pd.params\_0 \= alphavseti.staticParams;
 pd.tparams\_0 \= alphavseti.temporalParams;
 
 pd.Q\_alpha \= Q\_alpha \* eye(nstim) \* pd.period / diff(pd.timeRange);
 \[alphavston, scaledValues] \= fitRateFunWithTemporalScalingND(pd);
 
 btdstruct.scaledValues \= scaledValues;
 btdstruct.alphavston \= alphavston;
end


end

function \[btdstruct, ScaledRates] \= adaptedRatesVsVar (btdstruct, period, rescale\_type)
opstruct \= btdstruct.varops;
switchStim \= find(\[opstruct.stim.switch]);

if(isfield(btdstruct, 'BayesAlphavsEti\_U'))
 scaledValues \= btdstruct.BayesAlphavsEti\_U.scaledValues;
elseif(isfield(btdstruct, 'BayesAlphavsEti\_OL'))
 scaledValues \= btdstruct.BayesAlphavsEti\_OL.scaledValues;
elseif(isfield(btdstruct, 'BayesAlphavsEti'))
 scaledValues \= btdstruct.BayesAlphavsEti.scaledValues;
else
 scaledValues \= btdstruct.scaledValues;
end
tton \= scaledValues.turnTon;
teti \= scaledValues.turnEti;
rton \= scaledValues.runTon;
reti \= scaledValues.runEti;

tval \= scaledValues.tval;
rval \= scaledValues.rval;
deltaT \= scaledValues.deltaT;

tvalid \= teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
rvalid \= reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);

if(strcmpi(opstruct.stim(switchStim).ramptype, 'square'))
 thigh \= tton \> opstruct.adaptationTime \& tton \< period/2 \& tvalid;
 tlow \= tton \> period/2 \+ opstruct.adaptationTime \& tton \< period \& tvalid;
 tup \= tton \> 0 \& tton \< opstruct.adaptationTime \& tvalid;
 tdown \= tton \> period/2 \& tton \< period/2 \+ opstruct.adaptationTime \& tvalid;
 
 rhigh \= rton \> opstruct.adaptationTime \& rton \< period/2 \& rvalid;
 rlow \= rton \> period/2 \+ opstruct.adaptationTime \& rton \< period \& rvalid;
 rup \= rton \> 0 \& rton \< opstruct.adaptationTime \& rvalid;
 rdown \= rton \> period/2 \& rton \< period/2 \+ opstruct.adaptationTime \& rvalid;
else

 thigh \= tton \> opstruct.adaptationTime \& tton \< (period/2\) \& tvalid;
 tlow \= tton \> (period/2 \+ opstruct.adaptationTime) \& tton \< period \& tvalid;
 tup \= tton \< opstruct.adaptationTime \& tvalid;
 tdown \= tton \>(period/2\) \& tton\<(period/2 \+ opstruct.adaptationTime) \& tvalid;
 
 rhigh \= rton \> opstruct.adaptationTime \& rton \< (period/2\) \& rvalid;
 rlow \= rton \> (period/2 \+ opstruct.adaptationTime) \& rton \< period \& rvalid;
 rup \= rton \< opstruct.adaptationTime \& rvalid;
 rdown \= rton \>(period/2\) \& rton\<(period/2 \+ opstruct.adaptationTime) \& rvalid;
end

if(strcmpi(rescale\_type, 'input'))
 for j \= 1:size(rval, 2\)
 lx \= linspace(\-3\*std(rval(rvalid,j)), 3\*std(rval(rvalid,j)), opstruct.numLxBins);
 ScaledRates.scaledRFHigh(j) \= turnRates(tval(thigh, j), rval(rhigh, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFLow(j) \= turnRates(tval(tlow, j), rval(rlow, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFUp(j) \= turnRates(tval(tup, j), rval(rup, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFDown(j) \= turnRates(tval(tdown, j), rval(rdown, j), deltaT, \[], opstruct);
 end
 
elseif(strcmpi(rescale\_type, 'output'))
 
 alphaT \= scaledValues.alphaT;
 turnX \= scaledValues.turnX;
 runX \= scaledValues.runX;

 for j \= 1:size(rval, 2\)
 lx \= linspace(\-3\*std(runX(rvalid,j)), 3\*std(runX(rvalid,j)), opstruct.numLxBins);
 ScaledRates.scaledRFHigh(j) \= scaledturnRates(turnX(thigh, j), alphaT(thigh, j), runX(rhigh, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFLow(j) \= scaledturnRates(turnX(tlow, j), alphaT(tlow, j), runX(rlow, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFUp(j) \= scaledturnRates(turnX(tup,j), alphaT(tup,j), runX(rup, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFDown(j) \= scaledturnRates(turnX(tdown,j), alphaT(tdown,j), runX(rdown, j), deltaT, \[], opstruct);
 end
end

btdstruct.scaledRFUp \= ScaledRates.scaledRFUp;
btdstruct.scaledRFDown \= ScaledRates.scaledRFDown;
btdstruct.scaledRFLow \= ScaledRates.scaledRFLow;
btdstruct.scaledRFHigh \= ScaledRates.scaledRFHigh;
end

function rf \= turnRates2D(xt, xr, deltaT, tinds, rinds, nBins)

td(:,1\) \= xt(tinds, 1\);
td(:,2\) \= xt(tinds, 2\);
rd(:,1\) \= xr(rinds, 1\);
rd(:,2\) \= xr(rinds, 2\);
lx(:,1\) \= linspace(\-3\*std(rd(:,1\)), 3\*std(rd(:,1\)), nBins);
lx(:,2\) \= linspace(\-3\*std(rd(:,2\)), 3\*std(rd(:,2\)), nBins);
\[lxx, lxy] \= meshgrid(lx(:,1\), lx(:,2\));
lxdata \= \[lxx(:) lxy(:)];



h \= makeIm(rd(:,1\), rd(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
ht \= makeIm(td(:,1\), td(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
rhist \= reshape(h, size(lxx));
thist \= reshape(ht, size(lxx));

rf.lx \= lx;
rf.rate(:,1\) \= 1/deltaT \* sum(thist, 1\)./sum(rhist, 1\);
rf.rate\_eb(:,1\) \= 1/deltaT \* sqrt(sum(thist, 1\))./sum(rhist, 1\);
rf.rate(:,2\) \= 1/deltaT \* sum(thist, 2\)./sum(rhist, 2\);
rf.rate\_eb(:,2\) \= 1/deltaT \* sqrt(sum(thist, 2\))./sum(rhist, 2\);


end
 
function rf \= scaledturnRates (xt, alphaT, xr, deltaT, lx, opstruct)

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

if(isempty(lx))
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
end
existsAndDefault('lx', linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins));

\[nt, \~, tbins] \= histcounts(xt, binEdgesFromCenters(lx));
nr \= histcounts(xr, binEdgesFromCenters(lx));

for i\=1:length(lx), at(i) \= mean(alphaT(tbins\=\=i)); sat(i) \= std(alphaT(tbins\=\=i)); end

rf.lx \= lx;
rf.rate \= 1/deltaT \* at .\* nt./nr;
rf.rate\_eb \= 1/deltaT \* at .\* sqrt(nt) ./ nr;

nlogp \= @(p) \-sum(polyval(p, xt)) \+ deltaT\*sum(exp(polyval(p,xr)));
p0 \= \[mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
rf.rateFitLin \= fminunc(nlogp, p0, op);
p0 \= \[0 rf.rateFitLin];
rf.rateFitQuad \= fminunc(nlogp, p0, op);

end 

function rf \= turnRates (xt, xr, deltaT, lx, opstruct)

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

if(isempty(lx))
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
end
existsAndDefault('lx', linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins));

nt \= histcounts(xt, binEdgesFromCenters(lx));
nr \= histcounts(xr, binEdgesFromCenters(lx));

rf.lx \= lx;
rf.rate \= 1/deltaT \* nt ./ nr;
rf.rate\_eb \= 1/deltaT \* sqrt(nt) ./ nr;

nlogp \= @(p) \-sum(polyval(p, xt)) \+ deltaT\*sum(exp(polyval(p,xr)));
%p0 \= \[mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
p0 \= \[0\.1, \-2];
rf.rateFitLin \= fminunc(nlogp, p0, op);
p0 \= \[0 rf.rateFitLin];
rf.rateFitQuad \= fminunc(nlogp, p0, op);

end 

function \[btdstruct, HS\_stats] \= measureHSstats (btdstruct, var, dt)

opstruct \= btdstruct.varops;
switchStim \= find(\[opstruct.stim.switch]);

taxis \= \-(\-opstruct.kernelTime:0\.5:opstruct.kernelTime);

if(switchStim\>0\)
 
 for j \= 1:size(var, 2\)
 maxT \= 1\.25;
 period \= opstruct.stim(j).period;
 tBins \= 0:dt:round(period/2\-maxT);
 nt \= dt/abs(median(diff(taxis)));
 
 firsths.name \= 'hsnum';
 firsths.validop \= @(x) x \=\= 1;
 
 onehs.name \= 'numhs';
 onehs.validop \= @(x) x\=\=1;
 
 tvalid.name \= 'start\_eti';
 tvalid.validop \= @(x) x\>\= min(opstruct.timeRange) \& x\< max(opstruct.timeRange);
 
 lowvartime.name \= \[opstruct.stim(j).gqname '\_var\_toff'];
 
 
 acchs \= \[btdstruct.btd.acchs]';
 rejhs \= \[btdstruct.btd.rejhs]';
 acchseti \= \[acchs.start\_eti]';
 rejhseti \= \[rejhs.start\_eti]';
 
 accnhs \= \[acchs.hsnum]';
 rejnhs \= \[rejhs.hsnum]';
 firstacchs \= accnhs \=\= 1;
 firstrejhs \= rejnhs \=\= 1;
 

 delta\_t\_stim \= median(diff(btdstruct.btd(1\).all.eti));
 for i\=1:(length(tBins)\-1\)
 
 lowvartime.validop \= @(x) x \> tBins(i) \& x \< tBins(i\+1\);

 newtaxis \= 0:delta\_t\_stim:maxT;
 dm\_turn \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', opstruct.stim(j).gqname, newtaxis, 'conditions', \[onehs lowvartime tvalid]);
 dm\_acchs \= btdstruct.btd.behaviorTriggeredDataMatrix('acchs', 'start', opstruct.stim(j).gqname, newtaxis, 'conditions', \[firsths lowvartime tvalid] );
 dm\_rejhs \= btdstruct.btd.behaviorTriggeredDataMatrix('rejhs', 'start', opstruct.stim(j).gqname, newtaxis, 'conditions', \[firsths lowvartime tvalid]);
 
 meanDeltaAll \= sum(dm\_turn,2\)\*delta\_t\_stim/maxT;
 meanDeltaAll \= meanDeltaAll(isfinite(meanDeltaAll)); 
 HS\_stats.AllAvg(i) \= mean(meanDeltaAll);
 HS\_stats.AllAvg\_err(i) \= std(meanDeltaAll)/sqrt(length(meanDeltaAll));
 
 meanDeltaAcchs \= sum(dm\_acchs,2\)\*delta\_t\_stim/maxT;
 meanDeltaAcchs \= meanDeltaAcchs(isfinite(meanDeltaAcchs)); 
 HS\_stats.AccAvg(i) \= mean(meanDeltaAcchs);
 HS\_stats.AccAvg\_err(i) \= std(meanDeltaAcchs)/sqrt(length(meanDeltaAcchs)); %makes false assumption about independence of HS; ok if only 1 (or 2\) first headsweeps per 1\.5s of experiment
 
 meanDeltaRejhs \= sum(dm\_rejhs,2\)\*delta\_t\_stim/maxT;
 meanDeltaRejhs \= meanDeltaRejhs(isfinite(meanDeltaRejhs)); 
 HS\_stats.RejAvg(i) \= mean(meanDeltaRejhs);
 HS\_stats.RejAvg\_err(i) \= std(meanDeltaRejhs)/sqrt(length(meanDeltaRejhs));
 
 HS\_stats.numAcc(i) \= length(meanDeltaAcchs);
 HS\_stats.numRej(i) \= length(meanDeltaRejhs);
 
% nhs \= sum(isfinite(dm\_acchs),1\);
% dm\_acchs(\~isfinite(dm\_acchs)) \= 0;
% tta\_acchs \= sum(dm\_acchs, 1\)./nhs;
% ttv\_acchs \= sum( (dm\_acchs\-tta\_acchs).^2, 1\)./nhs;
% 
% dm\_rejhs(\~isfinite(dm\_rejhs)) \= 0;
% tta\_rejhs \= sum(dm\_rejhs, 1\)./sum(isfinite(dm\_rejhs), 1\);
% ttv\_rejhs \= sum( (dm\_rejhs\-tta\_rejhs).^2, 1 )./(sum(isfinite(dm\_rejhs), 1\)\-1\);
% 
% HS\_stats.tx \= taxis;
% HS\_stats.AccTTA{i} \= tta\_acchs;
% HS\_stats.RejTTA{i} \= tta\_rejhs;
% 
% HS\_stats.SDall(i) \= sqrt( sum(vt(taxis \> 0 \& taxis \< 1\.5\))/(nt^2\) );
% 
% 
% HS\_stats.AccAvg(i) \= sum(tta\_acchs(taxis \> 0 \& taxis \< 1\.5\))/nt;
% HS\_stats.AccAvg\_err(i) \= sqrt( sum(ttv\_acchs(taxis \> 0 \& taxis \< 1\.5\))/(nt^2\) );
% HS\_stats.RejAvg(i) \= sum(tta\_rejhs(taxis \> 0 \& taxis \< 1\.5\));
% HS\_stats.RejAvg\_err(i) \= sqrt( sum(ttv\_rejhs(taxis \> 0 \& taxis \< 1\.5\))/(nt^2\) );
% 
% HS\_stats.numAcc(i) \= size(dm\_acchs, 1\);
% HS\_stats.numRej(i) \= size(dm\_rejhs, 1\);
 
 end
 HS\_stats.tt \= tBins(1:end\-1\);
 btdstruct.HSavgs \= HS\_stats;
 
 
 end
end
end

function \[btdstruct, Kernels] \= measureKernelsVsVar (btdstruct, var)

opstruct \= btdstruct.varops;
switchStim \= find(\[opstruct.stim.switch]);

firsths.name \= 'hsnum';
firsths.validop \= @(x) x \=\= 1;

if(switchStim\>0\)
 
 for j \= 1:size(var, 2\)
 
 period \= var(j).period;
 
 tton \= var(j).turn.ton;
 ttoff \= var(j).turn.toff;
 teti \= var(j).turn.eti;
 
 accton \= var(j).acchs.ton;
 acctoff \= var(j).acchs.toff;
 rejton \= var(j).rejhs.ton;
 rejtoff \= var(j).rejhs.toff;
 acceti \= var(j).acchs.eti;
 rejeti \= var(j).rejhs.eti;
 
 tt \= \[btdstruct.btd.turn]';
 turneti \= \[tt.start\_eti]';
 acchs \= \[btdstruct.btd.acchs]';
 rejhs \= \[btdstruct.btd.rejhs]';
 acchseti \= \[acchs.start\_eti]';
 rejhseti \= \[rejhs.start\_eti]';
 
 accnhs \= \[acchs.hsnum]';
 rejnhs \= \[rejhs.hsnum]';
 firstacchs \= accnhs \=\= 1;
 firstrejhs \= rejnhs \=\= 1;

 turnvalid \= turneti \>\= min(btdstruct.varops.timeRange) \& turneti \< max(btdstruct.varops.timeRange);
 acchsvalid \= acchseti \>\= min(btdstruct.varops.timeRange) \& acchseti \< max(btdstruct.varops.timeRange);
 rejhsvalid \= rejhseti \>\= min(btdstruct.varops.timeRange) \& rejhseti \< max(btdstruct.varops.timeRange);

 
 
 taxis \= \-(\-opstruct.kernelTime:opstruct.kernelDt:opstruct.kernelTime);
 
% if strcmp(opstruct.stim(j).gqname, 'led1ValDiff')
% gqname\_levels \= \['led1Val'];
% elseif strcmp(opstruct.stim(j).gqname, 'led2ValDiff')
% gqname\_levels \= \['led2Val'];
% end
 
% dm\_val\_lvl \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', gqname\_levels, taxis);
% dm\_val\_lvl \= dm\_val\_lvl(turnvalid, :);
 
 dm\_val \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', opstruct.stim(j).gqname, taxis);
 dm\_val \= dm\_val(turnvalid, :);
 
 dm\_acchs \= btdstruct.btd.behaviorTriggeredDataMatrix('acchs', 'end', opstruct.stim(j).gqname, taxis);
 dm\_acchs \= dm\_acchs(acchsvalid \& firstacchs, :);
 
 dm\_rejhs \= btdstruct.btd.behaviorTriggeredDataMatrix('rejhs', 'end', opstruct.stim(j).gqname, taxis);
 dm\_rejhs \= dm\_rejhs(rejhsvalid \& firstrejhs, :);

 
 if(strcmpi(opstruct.stim(switchStim).ramptype, 'square'))
 
 tH \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> 0 \& tton \< (period/2\-opstruct.adaptationTime) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> 0 \& ttoff \< (period/2\-opstruct.adaptationTime) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 
 accH \= accton \> opstruct.adaptationTime \& accton \< acctoff \& acceti \>\= min(opstruct.timeRange) \& acceti \< max(opstruct.timeRange);
 accL \= acctoff \> opstruct.adaptationTime \& acctoff \< accton \& acceti \>\= min(opstruct.timeRange) \& acceti \< max(opstruct.timeRange);
 accU \= accton \> 0 \& accton \< (period/2\-opstruct.adaptationTime) \& acceti \>\= min(opstruct.timeRange) \& acceti \< max(opstruct.timeRange);
 accD \= acctoff \> 0 \& acctoff \< (period/2\-opstruct.adaptationTime) \& acceti \>\= min(opstruct.timeRange) \& acceti \< max(opstruct.timeRange);
 rejH \= rejton \> opstruct.adaptationTime \& rejton \< rejtoff \& rejeti \>\= min(opstruct.timeRange) \& rejeti \< max(opstruct.timeRange);
 rejL \= rejtoff \> opstruct.adaptationTime \& rejtoff \< rejton \& rejeti \>\= min(opstruct.timeRange) \& rejeti \< max(opstruct.timeRange);
 rejU \= rejton \> 0 \& rejton \< (period/2\-opstruct.adaptationTime) \& rejeti \>\= min(opstruct.timeRange) \& rejeti \< max(opstruct.timeRange);
 rejD \= rejtoff \> 0 \& rejtoff \< (period/2\-opstruct.adaptationTime) \& rejeti \>\= min(opstruct.timeRange) \& rejeti \< max(opstruct.timeRange);
 else
 tH \= tton \> opstruct.adaptationTime \& tton \> (3\*max(tton)/8\) \& tton \< (5\*max(tton)/8\) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff \> opstruct.adaptationTime \& ttoff \> (3\*max(ttoff)/8\) \& ttoff \< (5\*max(ttoff)/8\) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 end
 
% dm \= dm\_val\_lvl(tH, :);
% dm(\~isfinite(dm)) \= 0;
% Kernels.High\_lvl(j).taxis \= taxis;
% Kernels.High\_lvl(j).tta \= sum(dm)./sum(isfinite(dm\_val(tH,:)));
% Kernels.High\_lvl(j).nturns \= nnz(tH);
 
% dm \= dm\_val\_lvl(tL, :);
% dm(\~isfinite(dm)) \= 0;
% Kernels.Low\_lvl(j).taxis \= taxis;
% Kernels.Low\_lvl(j).tta \= sum(dm)./sum(isfinite(dm\_val(tL,:)));
% Kernels.Low\_lvl(j).nturns \= nnz(tL);
 
 dm \= dm\_val(tH, :);
 dm(\~isfinite(dm)) \= 0;
 Kernels.High(j).taxis \= taxis;
 Kernels.High(j).tta \= sum(dm)./sum(isfinite(dm\_val(tH,:)));
 Kernels.High(j).nturns \= nnz(tH);
 
 dm \= dm\_val(tL, :);
 dm(\~isfinite(dm)) \= 0;
 Kernels.Low(j).taxis \= taxis;
 Kernels.Low(j).tta \= sum(dm)./sum(isfinite(dm\_val(tL,:)));
 Kernels.Low(j).nturns \= nnz(tL);
 
 dm \= dm\_val(tU, :);
 dm(\~isfinite(dm)) \= 0;
 Kernels.Up(j).taxis \= taxis;
 Kernels.Up(j).tta \= sum(dm)./sum(isfinite(dm\_val(tU,:)));
 Kernels.Up(j).nturns \= nnz(tU);
 
 dm \= dm\_val(tD, :);
 dm(\~isfinite(dm)) \= 0;
 Kernels.Down(j).taxis \= taxis;
 Kernels.Down(j).tta \= sum(dm)./sum(isfinite(dm\_val(tD,:)));
 Kernels.Down(j).nturns \= nnz(tD);
 
 if(strcmpi(opstruct.stim(switchStim).ramptype, 'square'))
 dm\_acc \= dm\_acchs(accH, :);
 dm\_acc(\~isfinite(dm\_acc)) \= 0;
 dm\_rej \= dm\_rejhs(rejH, :);
 dm\_rej(\~isfinite(dm\_rej)) \= 0;
 Kernels.High(j).tta\_acchs \= sum(dm\_acc)./sum(isfinite(dm\_acchs(accH, :)));
 Kernels.High(j).tta\_rejhs \= sum(dm\_rej)./sum(isfinite(dm\_rejhs(rejH, :)));
 dm\_acc \= dm\_acchs(accL, :);
 dm\_acc(\~isfinite(dm\_acc)) \= 0;
 dm\_rej \= dm\_rejhs(rejL, :);
 dm\_rej(\~isfinite(dm\_rej)) \= 0;
 Kernels.Low(j).tta\_acchs \= sum(dm\_acc)./sum(isfinite(dm\_acchs(accL, :)));
 Kernels.Low(j).tta\_rejhs \= sum(dm\_rej)./sum(isfinite(dm\_rejhs(rejL, :)));
 dm\_acc \= dm\_acchs(accU, :);
 dm\_acc(\~isfinite(dm\_acc)) \= 0;
 dm\_rej \= dm\_rejhs(rejU, :);
 dm\_rej(\~isfinite(dm\_rej)) \= 0;
 Kernels.Up(j).tta\_acchs \= sum(dm\_acc)./sum(isfinite(dm\_acchs(accU, :)));
 Kernels.Up(j).tta\_rejhs \= sum(dm\_rej)./sum(isfinite(dm\_rejhs(rejU, :)));
 dm\_acc \= dm\_acchs(accD, :);
 dm\_acc(\~isfinite(dm\_acc)) \= 0;
 dm\_rej \= dm\_rejhs(rejD, :);
 dm\_rej(\~isfinite(dm\_rej)) \= 0;
 Kernels.Down(j).tta\_acchs \= sum(dm\_acc)./sum(isfinite(dm\_acchs(accD, :)));
 Kernels.Down(j).tta\_rejhs \= sum(dm\_rej)./sum(isfinite(dm\_rejhs(rejD, :)));
 end
 
 end

else
 
 for j \= 1:size(var, 2\)
 teti \= var(j).turn.eti;
 turnvalid \= teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 
 taxis \= \-(\-2:opstruct.kernelDt:opstruct.kernelTime);
 dm\_val \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', opstruct.stim(j).gqname, taxis);
 dm\_conv \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', \[opstruct.stim(j).gqname 'TurnLin'], 0\);
 dm\_val \= dm\_val(turnvalid, :);
 dm\_val(\~isfinite(dm\_val)) \= 0;
 dm\_conv \= dm\_conv(turnvalid);
 Kernels(j).taxis \= taxis;
 Kernels(j).tta \= sum(dm\_val)./sum(isfinite(dm\_conv));
 end
 
end


btdstruct.Kernels \= Kernels;


end

function \[btdstruct, Rates] \= measureRatesVsVar (btdstruct, var)
 

opstruct \= btdstruct.varops;
switchStim \= find(\[opstruct.stim.switch]);

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';


if(switchStim\>0\)
 
 for j \= 1:size(var, 2\)

 period \= var(j).period;
 
 deltaT \= median(diff(var(j).fullensemble.eti));
 tton \= var(j).turn.ton;
 ttoff \= var(j).turn.toff;
 teti \= var(j).turn.eti;
 rton \= var(j).noturn.ton;
 rtoff \= var(j).noturn.toff;
 reti \= var(j).noturn.eti;
 
 if(strcmpi(opstruct.stim(switchStim).ramptype, 'square'))
 
 tH \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> 0 \& tton \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> 0 \& ttoff \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange); 
 rH \= rton \> opstruct.adaptationTime \& rton \< rtoff \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rL \= rtoff \> opstruct.adaptationTime \& rtoff \< rton \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rU \= rton \> 0 \& rton \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rD \= rtoff \> 0 \& rtoff \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 else
 
 tH \= tton\>(period/2\-opstruct.adaptationTime) \& tton\<(period/2\+opstruct.adaptationTime) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff\>(period/2\-opstruct.adaptationTime) \& ttoff\<(period/2\+opstruct.adaptationTime) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 rH \= rton\>(period/2\-opstruct.adaptationTime) \& rton\<(period/2\+opstruct.adaptationTime) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rL \= rtoff\>(period/2\-opstruct.adaptationTime) \& rtoff\<(period/2\+opstruct.adaptationTime) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rU \= rton \> opstruct.adaptationTime \& rton \< rtoff \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rD \= rtoff \> opstruct.adaptationTime \& rtoff \< rton \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 %rH \= rton \> opstruct.adaptationTime \& rton \> (7\*max(rton)/16\) \& rton \< (9\*max(rton)/16\) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 %rL \= rtoff \> opstruct.adaptationTime \& rtoff \> (7\*max(rtoff)/16\) \& rtoff \< (9\*max(rtoff)/16\) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 end
 
 xt \= var(j).turn.x\_conv(tH);
 xr \= var(j).noturn.x\_conv(rH);
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins); 
 Rates.rfHighVar(j) \= turnRates (xt, xr, deltaT, lx, opstruct); 
 
% xt \= var(j).turn.x\_conv\_lvl(tH);
% xr \= var(j).noturn.x\_conv\_lvl(rH);
% lx \= linspace(mean(xr)\-3\*std(xr), mean(xr)\+3\*std(xr), opstruct.numLxBins); 
% Rates.rfHighVar\_lvl(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 xt \= var(j).turn.x\_conv(tL);
 xr \= var(j).noturn.x\_conv(rL); 
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 Rates.rfLowVar(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
% xt \= var(j).turn.x\_conv\_lvl(tL);
% xr \= var(j).noturn.x\_conv\_lvl(rL); 
% lx \= linspace(mean(xr)\-3\*std(xr), mean(xr)\+3\*std(xr), opstruct.numLxBins);
% Rates.rfLowVar\_lvl(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 if(opstruct.adaptationTime \> 0\)
 xt \= var(j).turn.x\_conv(tU);
 xr \= var(j).noturn.x\_conv(rU);
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 Rates.rfUp(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 xt \= var(j).turn.x\_conv(tD);
 xr \= var(j).noturn.x\_conv(rD);
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 Rates.rfDown(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 end
 end
 
 if(size(var, 2\) \=\= 2\) 
 xt2D(:,1\) \= var(1\).turn.x\_conv;
 xt2D(:,2\) \= var(2\).turn.x\_conv;
 xr2D(:,1\) \= var(1\).noturn.x\_conv;
 xr2D(:,2\) \= var(2\).noturn.x\_conv;
 Rates.Rates2D.rfHighVar \= turnRates2D (xt2D, xr2D, deltaT, tH, rH, opstruct.numLxBins);
 Rates.Rates2D.rfLowVar \= turnRates2D (xt2D, xr2D, deltaT, tL, rL, opstruct.numLxBins);
 if(opstruct.adaptationTime \> 0\)
 Rates.Rates2D.rfUp \= turnRates2D (xt2D, xr2D, deltaT, tU, rU, opstruct.numLxBins);
 Rates.Rates2D.rfDown \= turnRates2D (xt2D, xr2D, deltaT, tD, rD, opstruct.numLxBins);
 end
 end
 
 btdstruct.Rates \= Rates;
 
else
 
 for j \= 1:size(var, 2\)
 deltaT \= median(diff(var(j).fullensemble.eti));
 
 xt \= var(j).turn.x\_conv;
 expnt \= var(j).turn.expnum;
 xr \= var(j).noturn.x\_conv;
 expnr \= var(j).noturn.expnum;
 
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 
 Rates.rf(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 for k\=1:max(expnt)
 
 xt\_sep \= xt(expnt \=\= k);
 xr\_sep \= xr(expnr \=\= k);
 lx \= linspace(\-3\*std(xr\_sep), 3\*std(xr\_sep), opstruct.numLxBins);
 RatesSepExp{k}.rf(j) \= turnRates (xt\_sep, xr\_sep, deltaT, lx, opstruct);
 end
 
 end
 btdstruct.RatesSepExp \= RatesSepExp;
 btdstruct.Rates \= Rates;
 
end

end

function \[btdstruct, rateVtime] \= measureRateVtime(var, deltaT, dt)

if( isfield(var.turn, 'ton') )
 tton \= var.turn.ton;
 aton \= var.noturn.ton;
 tx\_ton \= 0:dt:var.period;
 rateVtime.rate\_ton \= 60\* histc(tton, tx\_ton)./histc(aton, tx\_ton) / deltaT;
 rateVtime.tx\_ton \= tx\_ton;
end

teti \= var.turn.eti;
aeti \= var.noturn.eti;
tx \= 0:dt:max(aeti);
rateVtime.rate \= 60\* histc(teti, tx)./histc(aeti, tx) / deltaT;

rateVtime.tx \= tx;
btdstruct.rateVtime \= rateVtime;

end
\-\-\-

\#\#\# File: VarAdaptAll\_Wolk.m (ID: Variance Adaptation Paper.2\)


function btdstruct \= VarAdaptAll\_Wolk(btdstruct, var, opstruct, Q\_alpha, tau\_alpha, deltaT, ppf, bayes, simtype, rescale\_type, timeType, varargin)
%function btdstruct \= VarAdaptAll(btdstruct, var, opstruct, Q\_alpha, tau\_alpha, deltaT, ppf, bayes, simtype, rescale\_type, timeType)

% opstruct \-\- contains info about the experiment 

% var \-\- either \[], or btdstruct.var
% Q\_alpha \-\- variance of the prior for Point Process Filter
% tau\_alpha \-\- correlation time for the Bayesian estimator (variance of the Gaussian prior \= 2\*deltaT/tau\_alpha)
% deltaT \-\- time\-bin width for PPF and Bayesian estimates of gain\-rescaling factors
% ppf \-\- 0 or 1, runs PPF estimate of Alpha(t) or not
% bayes \-\- 0 or 1, runs Bayesian estimate of Alpha(t) or not
% simtype \-\- 'LowHigh' simulates the same number of experiments as are in btdstruct, with a rate function switching from low to high instantly
% simtype \-\- 'All' does the same, but uses the continuously changing rate function as calculated by Bayesian or PPF estimators
% simtype \-\- \[] doesn't simulate anything
% rescale\_type \-\- 'input' or 'output' ('output' might not work very well)
% timeType \-\- 'eti' calculates estimates vs. eti and then converts to cycle time
% timeType \-\- 'ton' calculates directly vs cycle time
% to include TTA bootstrap estimates add 'bootstrap', 1

bootstrap \= false;
varargin \= assignApplicable(varargin);

logdat \= 1; % determines whether logP(data\|model) or P(data\|model) is used in Bayesian estimator \-\- shouldn't make a difference
nsim \= 1; % how many times the data is simulated ( n\=1 means the same number of experiments are simulated as were performed, with \#larvae\=mean(\#larvae) )



if (isempty(var))
 % use prepVarianceSwitchingAnalysis if kernels need recalculating (not light \& odor stimuli, e.g 20C08 or other neuron)
 btdstruct \= BehaviorTriggeredData.prepVarianceSwitchingAnalysis\_Wolk(btdstruct, opstruct);
 var \= btdstruct.var;
 if(isfield(btdstruct, 'var\_uv'))
 var\_uv \= btdstruct.var\_uv;
 end
end

if(isfield(btdstruct, 'var\_uv'))
 var\_uv \= btdstruct.var\_uv;
end

pdegree \= opstruct.pdegree;
if(size(var, 2\)\>\=2\)
 nstim \= 2;
else
 nstim \= 1;
end

if(\~isfield(btdstruct, 'varops'))
 fn \= {'stim', 'numLxBins', 'adaptationTime', 'Q\_alpha', 'numTimeBins', 'timeRange', 'kernelTime', 'kernelDt'};
 for j \= 1:length(fn)
 btdstruct.varops.(fn{j}) \= opstruct.(fn{j});
 end
end

whichStim \= find(\[btdstruct.varops.stim.switch]);

% TTA Kernels
if(\~isfield(btdstruct, 'Kernels'))
 btdstruct \= measureKernelsVsVar (btdstruct, var, bootstrap);
end

% Head Sweeps
% if(\~isfield(btdstruct, 'HSavgs') \&\& strcmpi(btdstruct.varops.stim(whichStim).ramptype, 'square'))
% existsAndDefault('HSdt',1\.5\);
% btdstruct \= measureHSstats (btdstruct, var, HSdt);
% end

% Rates vs. Stim.
if(\~isfield(btdstruct, 'Rates'))
 btdstruct \= measureRatesVsVar (btdstruct, var);
end
if(isfield(btdstruct, 'var\_uv') \&\& \~isfield(btdstruct, 'RatesU'))
 \[\~, btdstruct.RatesU] \= measureRatesVsVar (btdstruct, var\_uv);
end

% Rate vs Time
if(\~isfield(btdstruct, 'RateVTime'))
 rateDt \= 1;
 \[\~, btdstruct.RateVTime] \= measureRateVtime(var(1\), deltaT, rateDt);
end


% PPF \& Bayes Estimates of Gain\-Rescaling

if(bayes)
 Ddt\_alpha \= deltaT./tau\_alpha;
 if(strcmpi(timeType, 'eti'))
 if(isfinite(btdstruct.varops.timeRange(2\)))
 tx\_bayes \= btdstruct.varops.timeRange(1\):deltaT:btdstruct.varops.timeRange(2\);
 else
 tx\_bayes \= btdstruct.varops.timeRange(1\):deltaT:max(btdstruct.var(1\).fullensemble.eti);
 end
 else
 tx\_bayes \= 0:deltaT:btdstruct.var.period;
 end
end

if(ppf \&\& \~isfield(btdstruct, 'alphavseti'))
 disp('starting PPF estimate of Data (Odor, Light)')
 btdstruct \= runPPF(btdstruct, \[], var, opstruct, Q\_alpha, deltaT, timeType);
end

if( bayes \&\& \~isfield(btdstruct, 'var\_uv') \&\& \~isfield(btdstruct, 'BayesAlphavsEti\_OL'))
 tic
 if(nstim\=\=2 \&\& pdegree\=\=2\)
 disp('starting Bayesian estimate of Data (Odor, Light) \- added rates') % r(xo,xl) \= a\*u^2 \+ b\*u \+ c , with u\=cos(theta)\*xo\+sin(theta)\*xl
 btdstruct.BayesAlphavsEti\_OL.add \= BayesianModelEstimate(\[], btdstruct, var, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, 'add');
 disp('starting Bayesian estimate of Data (Odor, Light) \- multiplied rates')% r(xo,xl) \= r(xo)\*r(xl), where r(x)\=ax^2\+b\*x\+c
 btdstruct.BayesAlphavsEti\_OL.multiply \= BayesianModelEstimate(\[], btdstruct, var, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, 'mult');
 else
 disp('starting Bayesian estimate of Data (Odor, Light)')
 btdstruct.BayesAlphavsEti\_OL \= BayesianModelEstimate(\[], btdstruct, var, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, \[]);
 end
 toc
end

if(isfield(btdstruct, 'var\_uv') \&\& ppf \&\& \~isfield(btdstruct, 'alphavseti\_UV'))
 tic
 disp('starting PPF estimate of Rotated Data \- UV')
 \[\~, btdstruct.alphavseti\_UV] \= runPPF(btdstruct, \[], var\_uv, opstruct, Q\_alpha, deltaT, timeType);
 toc
end
if(isfield(btdstruct, 'var\_uv') \&\& ppf \&\& \~isfield(btdstruct, 'alphavseti\_U'))
 tic
 disp('starting PPF estimate of Rotated Data \- U')
 \[\~, btdstruct.alphavseti\_U] \= runPPF(btdstruct, \[], var\_uv(1\), opstruct, Q\_alpha, deltaT, timeType);
 toc
end


if( isfield(btdstruct, 'var\_uv') \&\& \~isempty(whichStim) \&\& bayes )
 
 if(\~isfield(btdstruct, 'BayesAlphavsEti\_UV'))
 disp('starting Bayesian estimate of Rotated Data \- UV')
 tic
 btdstruct.BayesAlphavsEti\_UV \= BayesianModelEstimate(\[], btdstruct, var\_uv, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, \[]);
 toc
 end
 if(\~isfield(btdstruct, 'BayesAlphavsEti\_U'))
 disp('starting Bayesian estimate of Rotated Data \- U')
 tic
 btdstruct.BayesAlphavsEti\_U \= BayesianModelEstimate(\[], btdstruct, var\_uv(1\), opstruct, timeType, deltaT, Ddt\_alpha(1\), tx\_bayes, logdat, \[], rescale\_type, \[]);
 toc
 end
% if(\~isfield(btdstruct, 'BayesAlphavsEti\_V'))
% disp('starting Bayesian estimate of Rotated Data \- V')
% tic
% btdstruct.BayesAlphavsEti\_V \= BayesianModelEstimate(\[], btdstruct, var\_uv(2\), opstruct, timeType, deltaT, Ddt\_alpha(2\), tx\_bayes, logdat, \[], rescale\_type);
% toc
% end
end

% Scaled Rates
if( any(\[opstruct.stim.switch]) )
 if( isfield(btdstruct, 'var\_uv') \&\& (bayes \|\| ppf) \&\& \~isfield(btdstruct, 'ScaledRatesU') )
 \[\~, btdstruct.ScaledRatesU] \= adaptedRatesVsVar (btdstruct, btdstruct.var\_uv(1\).period, rescale\_type);
 elseif( isfield(btdstruct, 'var') \&\& (bayes \|\| ppf) \&\& \~isfield(btdstruct, 'ScaledRates'))
 \[\~, btdstruct.ScaledRates] \= adaptedRatesVsVar (btdstruct, btdstruct.var(1\).period, rescale\_type);
 end
end

% DKL
if(\~isfield(btdstruct, 'DKL'))
 \[\~, btdstruct.DKL] \= measureDKLVsVar(btdstruct, var);
end
if(isfield(btdstruct, 'var\_uv') \&\& \~isfield(btdstruct, 'DKL\_UV'))
 \[\~, btdstruct.DKL\_UV] \= measureDKLVsVar(btdstruct, var\_uv);
end

% calculate fit params for alpha(sigma)\=1/(sigma^2\+sigma\_0^2\);
if(\~isempty(whichStim) \&\& nstim\=\=1\)
% if(strcmpi(btdstruct.varops.stim(whichStim).ramptype, 'triangle'))
 if(ppf \&\& \~isfield(btdstruct, 'gainrescaling\_PPF'))
 btdstruct.gainrescaling\_PPF \= fitVarianceRescaling(btdstruct, opstruct, 'PPF', opstruct.stim(whichStim).ramptype, whichStim);
 end
 if(bayes \&\& \~isfield(btdstruct, 'gainrescaling\_Bayes'))
 btdstruct.gainrescaling\_Bayes \= fitVarianceRescaling(btdstruct, opstruct, 'Bayes', opstruct.stim(whichStim).ramptype, whichStim);
 end
 
% end
end


% Simulated Data \& Estimates

if(\~isempty(whichStim))
 if(strcmpi(simtype, 'LowHigh') \|\| strcmpi(simtype, 'All'))
 
 if(\~isfield(btdstruct, 'SimData'))
 tic
 btdstruct.SimData \= SimulateData(btdstruct, var, opstruct, 'ton', nsim, simtype); %keep 'ton' to have both runTon and runT in the simulated data
 toc
 end
 
 if(isfield(btdstruct, \[simtype 'Sim']))
 eval(\['Sim \= btdstruct.' simtype 'Sim;']);
 
 if( ppf \&\& \~isfield(Sim, 'alphavseti'))
 disp('starting PPF estimate of simulated data')
 for i\=1:length(btdstruct.SimData)
 \[\~, Sim.alphavseti{i}] \= runPPF(btdstruct, btdstruct.SimData{i}, var, opstruct, Q\_alpha, deltaT, timeType);
 alpha\_ton(i,:) \= Sim.alphavseti{i}.alpha\_ton;
 valpha\_ton(i,:) \= Sim.alphavseti{i}.valpha\_ton;
 end
 Sim.tx\_ton\_ppf \= Sim.alphavseti{1}.tx\_ton;
 Sim.alpha\_ton\_ppf \= mean(alpha\_ton);
 Sim.valpha\_ton\_ppf \= mean(valpha\_ton)./nsim;
 end
 
 if( bayes \&\& \~isfield(Sim, 'BayesAlphavsEti'))
 disp('starting Bayesian estimate of simulated data')
 rP \= btdstruct.BayesAlphavsEti.RateParams;
 for i\=1:length(btdstruct.SimData)
 tic
 Sim.BayesAlphavsEti{i} \= BayesianModelEstimate(btdstruct.SimData{i}, btdstruct, var, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, \[]);
 alpha\_ton(i,:) \= Sim.BayesAlphavsEti{i}.alpha\_ton;
 valpha\_ton(i,:) \= Sim.BayesAlphavsEti{i}.valpha\_ton;
 toc
 end
 Sim.tx\_ton\_bayes \= Sim.BayesAlphavsEti{1}.tx\_ton;
 Sim.alpha\_ton\_bayes \= mean(alpha\_ton)/mean(mean(alpha\_ton));
 Sim.valpha\_ton\_bayes \= mean(valpha\_ton)./nsim;
 end
 eval(\['btdstruct.' simtype 'Sim \= Sim;']);
 else
 if(ppf \|\| bayes)
 if( ppf )
 disp('starting PPF estimate of simulated data')
 for i\=1:length(btdstruct.SimData)
 \[\~, Sim.alphavseti{i}] \= runPPF(btdstruct, btdstruct.SimData{i}, var, opstruct, Q\_alpha, deltaT, timeType);
 end

 end
 if(bayes)
 disp('starting Bayesian estimate of simulated data')
 for i\=1:length(btdstruct.SimData)
 tic
 Sim.BayesAlphavsEti{i} \= BayesianModelEstimate(btdstruct.SimData{i}, btdstruct, var, opstruct, timeType, deltaT, Ddt\_alpha, tx\_bayes, logdat, \[], rescale\_type, \[]);
 toc
 end

 end
 eval(\['btdstruct.' simtype 'Sim \= Sim;']);
 end
 end
 
 end
end

end




function \[btdstruct, DKL] \= measureDKLVsVar (btdstruct, var)
opstruct \= btdstruct.varops;
switchStim \= find(\[opstruct.stim.switch]);

if(switchStim\>0\)
 
 nstim \= size(var, 2\);

 for j \= 1:nstim
 
 deltaT \= median(diff(var(j).fullensemble.eti));
 adata \= var(j).noturn.x\_conv;
 tdata \= var(j).turn.x\_conv;
 tton \= var(j).turn.ton;
 ttoff \= var(j).turn.toff;
 teti \= var(j).turn.eti;
 rton \= var(j).noturn.ton;
 rtoff \= var(j).noturn.toff;
 reti \= var(j).noturn.eti;
 
 if(strcmpi(opstruct.stim(switchStim).ramptype, 'square'))
 
 tH \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> 0 \& tton \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> 0 \& ttoff \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 rH \= rton \> opstruct.adaptationTime \& rton \< rtoff \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rL \= rtoff \> opstruct.adaptationTime \& rtoff \< rton \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rU \= rton \> 0 \& rton \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rD \= rtoff \> 0 \& rtoff \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 else
 tH \= tton \> opstruct.adaptationTime \& tton \> (3\*max(tton)/8\) \& tton \< (5\*max(tton)/8\) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff \> opstruct.adaptationTime \& ttoff \> (3\*max(ttoff)/8\) \& ttoff \< (5\*max(ttoff)/8\) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 rH \= rton \> opstruct.adaptationTime \& rton \> (3\*max(rton)/8\) \& rton \< (5\*max(rton)/8\) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rL \= rtoff \> opstruct.adaptationTime \& rtoff \> (3\*max(rtoff)/8\) \& rtoff \< (5\*max(rtoff)/8\) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rU \= rton \> opstruct.adaptationTime \& rton \< rtoff \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rD \= rtoff \> opstruct.adaptationTime \& rtoff \< rton \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 end
 
 saH \= std(adata(rH)); saL \= std(adata(rL)); saU \= std(adata(rU)); saD \= std(adata(rD));
 stH \= std(tdata(tH)); stL \= std(tdata(tL)); stU \= std(tdata(tU)); stD \= std(tdata(tD));
 maH \= mean(adata(rH)); maL \= mean(adata(rL)); maU \= mean(adata(rU)); maD \= mean(adata(rD));
 mtH \= mean(tdata(tH)); mtL \= mean(tdata(tL)); mtU \= mean(tdata(tU)); mtD \= mean(tdata(tD));
 
 dkl1D(j).High \= 0\.5\*(stH^2/saH^2 \+ (maH\-mtH)^2/saH^2 \- 1 \+ log(saH^2/stH^2\));
 dkl1D(j).Low \= 0\.5\*(stL^2/saL^2 \+ (maL\-mtL)^2/saL^2 \- 1 \+ log(saL^2/stL^2\));
 dkl1D(j).Up \= 0\.5\*(stU^2/saU^2 \+ (maU\-mtU)^2/saU^2 \- 1 \+ log(saU^2/stU^2\));
 dkl1D(j).Down \= 0\.5\*(stD^2/saD^2 \+ (maD\-mtD)^2/saD^2 \- 1 \+ log(saD^2/stD^2\));
 
 
 end
 DKL.dkl1D \= dkl1D;
 
 if(nstim\=\=2\)
 for k\=1:2
 rdH(k,:) \= var(k).noturn.x\_conv(rH); rdL(k,:) \= var(k).noturn.x\_conv(rL);
 rdU(k,:) \= var(k).noturn.x\_conv(rU); rdD(k,:) \= var(k).noturn.x\_conv(rD);
 tdH(k,:) \= var(k).turn.x\_conv(tH); tdL(k,:) \= var(k).turn.x\_conv(tL);
 tdU(k,:) \= var(k).turn.x\_conv(tU); tdD(k,:) \= var(k).turn.x\_conv(tD);
 end

 covA \= cov(rdH');
 covT \= cov(tdH');
 muA \= mean(rdH');
 muT \= mean(tdH');
 a \= covA\\covT;
 b \= covA\\(muA\-muT)';
 dkl2D.High \= .5 \* ( trace(a) \+ (muA\-muT)\*b \- 2 \+ log(det(covA)/det(covT)) );
 
 covA \= cov(rdL');
 covT \= cov(tdL');
 muA \= mean(rdL');
 muT \= mean(tdL');
 a \= covA\\covT;
 b \= covA\\(muA\-muT)';
 dkl2D.Low \= .5 \* ( trace(a) \+ (muA\-muT)\*b \- 2 \+ log(det(covA)/det(covT)) );
 
 covA \= cov(rdU');
 covT \= cov(tdU');
 muA \= mean(rdU');
 muT \= mean(tdU');
 a \= covA\\covT;
 b \= covA\\(muA\-muT)';
 dkl2D.Up \= .5 \* ( trace(a) \+ (muA\-muT)\*b \- 2 \+ log(det(covA)/det(covT)) );
 
 covA \= cov(rdD');
 covT \= cov(tdD');
 muA \= mean(rdD');
 muT \= mean(tdD');
 a \= covA\\covT;
 b \= covA\\(muA\-muT)';
 dkl2D.Down \= .5 \* ( trace(a) \+ (muA\-muT)\*b \- 2 \+ log(det(covA)/det(covT)) );
 
 DKL.dkl2D \= dkl2D;
 end
 
else
 
 
 m4 \= @(x) mean(x)^4 \+ 6\*mean(x)^2\*std(x)^2 \+ 3\*std(x)^4;
 sev \= @(x) sqrt( (m4(x) \- (length(x)\-3\)\*std(x)^4/(length(x)\-1\)) / length(x) );
 for j \= 1:size(var, 2\)
 
 data \= var(j);
 
 
 
 adata \= data.noturn.x\_conv;
 tdata \= data.turn.x\_conv;
 sa \= std(adata);
 va \= std(adata)^2;
 st \= std(tdata);
 vt \= std(tdata)^2;
 sva \= sqrt(2\*va^2/(length(adata)\-1\));
 svt \= sqrt(2\*vt^2/(length(tdata)\-1\));
 
% sva \= sev(adata);
% svt \= sev(tdata);
 
 ma \= mean(adata);
 mt \= mean(tdata);
 sma \= sqrt(va/length(adata));
 smt \= sqrt(vt/length(tdata));
 
 DKL.mean(j) \= 0\.5\*(vt/va \+ (ma\-mt)^2/va \- 1 \+ log(va/vt));
 DKL.var(j) \= .5\*sva^2 \* ( (va\-vt\-(mt\-ma)^2\)/va^2 ) \+ .5\*svt^2 \* (1/va \- 1/vt) \+ sma^2 \* (ma\-mt)/va \+ smt^2 \* (mt\-ma)/va; 
 
 
 end
end
end

function SimulatedData \= SimulateData(btdstruct, var, opstruct, timeField, nreps, simtype)

if(isfield(btdstruct, 'BayesAlphavsEti'))
 alphastruct \= btdstruct.BayesAlphavsEti;
elseif(isfield(btdstruct, 'BayesAlphavsEti\_OL'))
 alphastruct \= btdstruct.BayesAlphavsEti\_OL;
else
 alphastruct \= btdstruct.alphavseti;
end

alphastruct.staticParams \= alphastruct.params;

if(isfield(btdstruct, 'SimData'))
 SimulatedData \= btdstruct.SimData;
 return
end

disp(\['simulating ' num2str(nreps) ' set of experiments']);

deltaT \= median(diff(var.fullensemble.eti));
pd \= BehaviorTriggeredData.createProblemStructForRateFunFitting (var, timeField, opstruct.pdegree, opstruct.timeRange, \[], deltaT);
pd.maxreps \= 2;


for j \= 1:length(btdstruct.btd), numan(j) \= btdstruct.btd(j).es.numAnimals; end
Nlarvae \= round(mean(numan));
% Nlarvae \= 40;

dt \= mean(diff(alphastruct.tx\_ton));
nt \= round(10/dt);

alpha\_ton \= alphastruct.alpha\_ton/mean(alphastruct.alpha\_ton);
alow \= mean(alpha\_ton(1\+nt:round(end/2\)));
ahigh \= mean(alpha\_ton(round(end/2\)\+nt:end));

if(strcmpi(simtype, 'LowHigh'))
 
 for j\=1:nreps
 SimulatedData{j} \= BehaviorTriggeredData.simulateVarSwitchFromPrevFit(btdstruct, alphastruct, pd, alow, ahigh, Nlarvae);
 end
 
elseif(strcmpi(simtype, 'All'))
 
 
 pd.tx\_eti \= alphastruct.tx;
 pd.alpha\_eti \= alphastruct.alpha;
 
 for k\=1:nreps
 SimulatedData{k} \= BehaviorTriggeredData.simulateVarSwitchFromPrevFit(btdstruct, alphastruct, pd, alow, ahigh, Nlarvae);
 end
 
end

end

function gainrescaling \= fitVarianceRescaling(btdstruct, opstruct, estimator, type, switchstim)

rescalingfun \= @(x,xdata) 1\./sqrt(xdata.^2 \+ x^2\) / mean(1\./sqrt(xdata.^2 \+ x^2\));
% rescalingfun \= @(x,xdata) x(1\)./sqrt(xdata.^2 \+ x(2\)^2\);

if(strcmpi(estimator, 'PPF'))
 if(length(btdstruct.varops.stim)\>2\)
 tx\_ton \= btdstruct.alphavseti\_U.tx\_ton;
 alpha\_s \= btdstruct.alphavseti\_U.alpha\_s\_ton;
 valpha\_s \= squeeze(btdstruct.alphavseti\_U.valpha\_s\_ton)';
 else
 tx\_ton \= btdstruct.alphavseti.tx\_ton;
 alpha\_s \= btdstruct.alphavseti.alpha\_s\_ton(switchstim, :);
 valpha\_s \= squeeze(btdstruct.alphavseti.valpha\_s\_ton(switchstim, switchstim, :))';
 end
else
 if(length(btdstruct.varops.stim)\>2\)
 tx\_ton \= btdstruct.BayesAlphavsEti\_U.tx\_ton;
 alpha\_s \= btdstruct.BayesAlphavsEti\_U.alpha\_ton;
 valpha\_s \= btdstruct.BayesAlphavsEti\_U.valpha\_ton;
 else
 tx\_ton \= btdstruct.BayesAlphavsEti\_OL.tx\_ton;
 alpha\_s \= btdstruct.BayesAlphavsEti\_OL.alpha\_ton(switchstim, :);
 valpha\_s \= btdstruct.BayesAlphavsEti\_OL.valpha\_ton(switchstim, :);
 end
end

if(isfield(btdstruct, 'var\_uv'))
 var \= btdstruct.var\_uv(1\);
elseif(isfield(btdstruct, 'var'))
 var \= btdstruct.var(1\);
else
 disp('no var field to calculate signal variance');
 return
end

trange \= opstruct.timeRange;
adaptTime \= opstruct.adaptationTime;
teti \= var.fullensemble.eti;
ton \= var.fullensemble.ton;
xo \= var.fullensemble.x\_conv;

valid \= teti\>trange(1\) \& tetiadaptTime \& ton(round(max(ton)/2\)\+adaptTime);

if(strcmpi(type, 'triangle'))
 \[\~,\~,\~,son\_all] \= meanyvsx(ton(valid), xo(valid), binEdgesFromCenters(tx\_ton));
 % son\_all \= son\_all';
 params.up \= lsqcurvefit(rescalingfun, \[1], son\_all(tx\_ton\<(max(tx\_ton)/2\)), alpha\_s(tx\_ton\<(max(tx\_ton)/2\)));
 params.down \= lsqcurvefit(rescalingfun, \[1], son\_all(tx\_ton\>(max(tx\_ton)/2\)), alpha\_s(tx\_ton\>(max(tx\_ton)/2\)));
 params.all \= lsqcurvefit(rescalingfun, \[1], son\_all, alpha\_s);
elseif(strcmpi(type, 'square'))
 
 high \= tx\_ton\>\=adaptTime \& tx\_ton(round(max(tx\_ton)/2\)\+adaptTime);
 all \= (tx\_ton\>adaptTime \& tx\_ton(round(max(tx\_ton)/2\)\+adaptTime);
 
% \[\~,\~,\~,son\_all] \= meanyvsx(ton(valid \& adapted), xo(valid \& adapted), binEdgesFromCenters(tx\_ton));
% params.high \= lsqcurvefit(rescalingfun, \[1 1], son\_all(high), alpha\_s(high));
% params.low \= lsqcurvefit(rescalingfun, \[1 1], son\_all(low), alpha\_s(low));
 
 \[\~,\~,\~,son\_all] \= meanyvsx(ton(valid \& adapted), xo(valid \& adapted), binEdgesFromCenters(tx\_ton));
 params.all \= lsqcurvefit(rescalingfun, \[1], son\_all(all), alpha\_s(all));
end
gainrescaling.estimator \= estimator;
gainrescaling.fitfun \= rescalingfun;
gainrescaling.son\_all \= son\_all;
gainrescaling.params \= params;
end


function \[btdstruct, alphavseti, alphavston, scaledValues] \= runPPF(btdstruct, pd, var, opstruct, Q\_alpha, deltaT, timeType)


nstim \= size(var, 2\);

if(isempty(pd))
 pd \= BehaviorTriggeredData.createProblemStructForRateFunFitting (var, 'eti', opstruct.pdegree, opstruct.timeRange, \[], deltaT);
 pd.Q\_alpha \= Q\_alpha \* eye(nstim);
 pd.maxreps \= 5;
end

pd.temporalratemod \= \[];


alphavseti \= fitRateFunWithTemporalScalingND(pd);

%turn time estimate into time in cycle estimate

\[alphavseti.alpha\_ton, alphavseti.valpha\_ton, alphavseti.tx\_ton] \= meanEstinCycle(alphavseti.alpha, alphavseti.valpha, alphavseti.tx, pd.tshift, pd.period, opstruct.timeRange, timeType);
\[alphavseti.alpha\_s\_ton, alphavseti.valpha\_s\_ton, alphavseti.tx\_ton] \= meanEstinCycle(alphavseti.alpha\_s, alphavseti.valpha\_s, alphavseti.tx, pd.tshift, pd.period, opstruct.timeRange, timeType);

alphavseti.Q\_alpha \= Q\_alpha;
btdstruct.alphavseti \= alphavseti;


if(strcmpi(timeType, 'ton'))
 %directly calculate stretch factor vs cycle time
 pd \= BehaviorTriggeredData.createProblemStructForRateFunFitting (var, 'ton', opstruct.pdegree, opstruct.timeRange, \[], deltaT);
 
 if all(size(pd.alpha\_0\) \=\= size(alphavseti.alpha\_ton))
 pd.alpha\_0 \= alphavseti.alpha\_ton;
 end
 pd.params\_0 \= alphavseti.staticParams;
 pd.tparams\_0 \= alphavseti.temporalParams;
 
 pd.Q\_alpha \= Q\_alpha \* eye(nstim) \* pd.period / diff(pd.timeRange);
 \[alphavston, scaledValues] \= fitRateFunWithTemporalScalingND(pd);
 
 btdstruct.scaledValues \= scaledValues;
 btdstruct.alphavston \= alphavston;
end


end

function \[btdstruct, ScaledRates] \= adaptedRatesVsVar (btdstruct, period, rescale\_type)
opstruct \= btdstruct.varops;
switchStim \= find(\[opstruct.stim.switch]);

if(isfield(btdstruct, 'BayesAlphavsEti\_U'))
 scaledValues \= btdstruct.BayesAlphavsEti\_U.scaledValues;
elseif(isfield(btdstruct, 'BayesAlphavsEti\_OL'))
 scaledValues \= btdstruct.BayesAlphavsEti\_OL.scaledValues;
elseif(isfield(btdstruct, 'BayesAlphavsEti'))
 scaledValues \= btdstruct.BayesAlphavsEti.scaledValues;
else
 scaledValues \= btdstruct.scaledValues;
end
tton \= scaledValues.turnTon;
teti \= scaledValues.turnEti;
rton \= scaledValues.runTon;
reti \= scaledValues.runEti;

tval \= scaledValues.tval;
rval \= scaledValues.rval;
deltaT \= scaledValues.deltaT;

tvalid \= teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
rvalid \= reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);

if(strcmpi(opstruct.stim(switchStim).ramptype, 'square'))
 thigh \= tton \> opstruct.adaptationTime \& tton \< period/2 \& tvalid;
 tlow \= tton \> period/2 \+ opstruct.adaptationTime \& tton \< period \& tvalid;
 tup \= tton \> 0 \& tton \< opstruct.adaptationTime \& tvalid;
 tdown \= tton \> period/2 \& tton \< period/2 \+ opstruct.adaptationTime \& tvalid;
 
 rhigh \= rton \> opstruct.adaptationTime \& rton \< period/2 \& rvalid;
 rlow \= rton \> period/2 \+ opstruct.adaptationTime \& rton \< period \& rvalid;
 rup \= rton \> 0 \& rton \< opstruct.adaptationTime \& rvalid;
 rdown \= rton \> period/2 \& rton \< period/2 \+ opstruct.adaptationTime \& rvalid;
else

 thigh \= tton \> opstruct.adaptationTime \& tton \< (period/2\) \& tvalid;
 tlow \= tton \> (period/2 \+ opstruct.adaptationTime) \& tton \< period \& tvalid;
 tup \= tton \< opstruct.adaptationTime \& tvalid;
 tdown \= tton \>(period/2\) \& tton\<(period/2 \+ opstruct.adaptationTime) \& tvalid;
 
 rhigh \= rton \> opstruct.adaptationTime \& rton \< (period/2\) \& rvalid;
 rlow \= rton \> (period/2 \+ opstruct.adaptationTime) \& rton \< period \& rvalid;
 rup \= rton \< opstruct.adaptationTime \& rvalid;
 rdown \= rton \>(period/2\) \& rton\<(period/2 \+ opstruct.adaptationTime) \& rvalid;
end

if(strcmpi(rescale\_type, 'input'))
 for j \= 1:size(rval, 2\)
 lx \= linspace(\-3\*std(rval(rvalid,j)), 3\*std(rval(rvalid,j)), opstruct.numLxBins);
 ScaledRates.scaledRFHigh(j) \= turnRates(tval(thigh, j), rval(rhigh, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFLow(j) \= turnRates(tval(tlow, j), rval(rlow, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFUp(j) \= turnRates(tval(tup, j), rval(rup, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFDown(j) \= turnRates(tval(tdown, j), rval(rdown, j), deltaT, \[], opstruct);
 end
 
elseif(strcmpi(rescale\_type, 'output'))
 
 alphaT \= scaledValues.alphaT;
 turnX \= scaledValues.turnX;
 runX \= scaledValues.runX;

 for j \= 1:size(rval, 2\)
 lx \= linspace(\-3\*std(runX(rvalid,j)), 3\*std(runX(rvalid,j)), opstruct.numLxBins);
 ScaledRates.scaledRFHigh(j) \= scaledturnRates(turnX(thigh, j), alphaT(thigh, j), runX(rhigh, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFLow(j) \= scaledturnRates(turnX(tlow, j), alphaT(tlow, j), runX(rlow, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFUp(j) \= scaledturnRates(turnX(tup,j), alphaT(tup,j), runX(rup, j), deltaT, \[], opstruct);
 ScaledRates.scaledRFDown(j) \= scaledturnRates(turnX(tdown,j), alphaT(tdown,j), runX(rdown, j), deltaT, \[], opstruct);
 end
end

btdstruct.scaledRFUp \= ScaledRates.scaledRFUp;
btdstruct.scaledRFDown \= ScaledRates.scaledRFDown;
btdstruct.scaledRFLow \= ScaledRates.scaledRFLow;
btdstruct.scaledRFHigh \= ScaledRates.scaledRFHigh;
end

function rf \= turnRates2D(xt, xr, deltaT, tinds, rinds, nBins)

td(:,1\) \= xt(tinds, 1\);
td(:,2\) \= xt(tinds, 2\);
rd(:,1\) \= xr(rinds, 1\);
rd(:,2\) \= xr(rinds, 2\);
lx(:,1\) \= linspace(\-3\*std(rd(:,1\)), 3\*std(rd(:,1\)), nBins);
lx(:,2\) \= linspace(\-3\*std(rd(:,2\)), 3\*std(rd(:,2\)), nBins);
\[lxx, lxy] \= meshgrid(lx(:,1\), lx(:,2\));
lxdata \= \[lxx(:) lxy(:)];



h \= makeIm(rd(:,1\), rd(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
ht \= makeIm(td(:,1\), td(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
rhist \= reshape(h, size(lxx));
thist \= reshape(ht, size(lxx));

rf.lx \= lx;
rf.rate(:,1\) \= 1/deltaT \* sum(thist, 1\)./sum(rhist, 1\);
rf.rate\_eb(:,1\) \= 1/deltaT \* sqrt(sum(thist, 1\))./sum(rhist, 1\);
rf.rate(:,2\) \= 1/deltaT \* sum(thist, 2\)./sum(rhist, 2\);
rf.rate\_eb(:,2\) \= 1/deltaT \* sqrt(sum(thist, 2\))./sum(rhist, 2\);


end
 
function rf \= scaledturnRates (xt, alphaT, xr, deltaT, lx, opstruct)

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

if(isempty(lx))
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
end
existsAndDefault('lx', linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins));

\[nt, \~, tbins] \= histcounts(xt, binEdgesFromCenters(lx));
nr \= histcounts(xr, binEdgesFromCenters(lx));

for i\=1:length(lx), at(i) \= mean(alphaT(tbins\=\=i)); sat(i) \= std(alphaT(tbins\=\=i)); end

rf.lx \= lx;
rf.rate \= 1/deltaT \* at .\* nt./nr;
rf.rate\_eb \= 1/deltaT \* at .\* sqrt(nt) ./ nr;

nlogp \= @(p) \-sum(polyval(p, xt)) \+ deltaT\*sum(exp(polyval(p,xr)));
p0 \= \[mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
rf.rateFitLin \= fminunc(nlogp, p0, op);
p0 \= \[0 rf.rateFitLin];
rf.rateFitQuad \= fminunc(nlogp, p0, op);

end 

function rf \= turnRates (xt, xr, deltaT, lx, opstruct)

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

if(isempty(lx))
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
end
existsAndDefault('lx', linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins));

nt \= histcounts(xt, binEdgesFromCenters(lx));
nr \= histcounts(xr, binEdgesFromCenters(lx));

rf.lx \= lx;
rf.rate \= 1/deltaT \* nt ./ nr;
rf.rate\_eb \= 1/deltaT \* sqrt(nt) ./ nr;

nlogp \= @(p) \-sum(polyval(p, xt)) \+ deltaT\*sum(exp(polyval(p,xr)));
nlogp2 \= @(p) \-sum(polyval(p, xt)) \-sum(log(deltaT\*ones(1,length(xt)))) \+ deltaT\*sum(exp(polyval(p,xr)));
p0 \= \[mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
%p0 \= \[0\.5 \-1\.6];
\[rf.rateFitLin, nllh\_lin] \= fminunc(nlogp, p0, op);
p0 \= \[0 rf.rateFitLin];
\[rf.rateFitQuad, nllh\_quad] \= fminunc(nlogp, p0, op);
rf.rateFitLin\_llh \= \- nlogp2(rf.rateFitLin);
rf.rateFitQuad\_llh \= \- nlogp2(rf.rateFitQuad);

end 

function \[btdstruct, HS\_stats] \= measureHSstats (btdstruct, var, dt)

opstruct \= btdstruct.varops;
switchStim \= find(\[opstruct.stim.switch]);

taxis \= \-(\-opstruct.kernelTime:0\.5:opstruct.kernelTime);

if(switchStim\>0\)
 
 for j \= 1:size(var, 2\)
 maxT \= 1\.25;
 period \= opstruct.stim(j).period;
 tBins \= 0:dt:round(period/2\-maxT);
 nt \= dt/abs(median(diff(taxis)));
 
 firsths.name \= 'hsnum';
 firsths.validop \= @(x) x \=\= 1;
 
 onehs.name \= 'numhs';
 onehs.validop \= @(x) x\=\=1;
 
 tvalid.name \= 'start\_eti';
 tvalid.validop \= @(x) x\>\= min(opstruct.timeRange) \& x\< max(opstruct.timeRange);
 
 lowvartime.name \= \[opstruct.stim(j).gqname '\_var\_toff'];
 
 
 acchs \= \[btdstruct.btd.acchs]';
 rejhs \= \[btdstruct.btd.rejhs]';
 acchseti \= \[acchs.start\_eti]';
 rejhseti \= \[rejhs.start\_eti]';
 
 accnhs \= \[acchs.hsnum]';
 rejnhs \= \[rejhs.hsnum]';
 firstacchs \= accnhs \=\= 1;
 firstrejhs \= rejnhs \=\= 1;
 

 delta\_t\_stim \= median(diff(btdstruct.btd(1\).all.eti));
 for i\=1:(length(tBins)\-1\)
 
 lowvartime.validop \= @(x) x \> tBins(i) \& x \< tBins(i\+1\);

 newtaxis \= 0:delta\_t\_stim:maxT;
 dm\_turn \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', opstruct.stim(j).gqname, newtaxis, 'conditions', \[onehs lowvartime tvalid]);
 dm\_acchs \= btdstruct.btd.behaviorTriggeredDataMatrix('acchs', 'start', opstruct.stim(j).gqname, newtaxis, 'conditions', \[firsths lowvartime tvalid] );
 dm\_rejhs \= btdstruct.btd.behaviorTriggeredDataMatrix('rejhs', 'start', opstruct.stim(j).gqname, newtaxis, 'conditions', \[firsths lowvartime tvalid]);
 
 meanDeltaAll \= sum(dm\_turn,2\)\*delta\_t\_stim/maxT;
 meanDeltaAll \= meanDeltaAll(isfinite(meanDeltaAll)); 
 HS\_stats.AllAvg(i) \= mean(meanDeltaAll);
 HS\_stats.AllAvg\_err(i) \= std(meanDeltaAll)/sqrt(length(meanDeltaAll));
 
 meanDeltaAcchs \= sum(dm\_acchs,2\)\*delta\_t\_stim/maxT;
 meanDeltaAcchs \= meanDeltaAcchs(isfinite(meanDeltaAcchs)); 
 HS\_stats.AccAvg(i) \= mean(meanDeltaAcchs);
 HS\_stats.AccAvg\_err(i) \= std(meanDeltaAcchs)/sqrt(length(meanDeltaAcchs)); %makes false assumption about independence of HS; ok if only 1 (or 2\) first headsweeps per 1\.5s of experiment
 
 meanDeltaRejhs \= sum(dm\_rejhs,2\)\*delta\_t\_stim/maxT;
 meanDeltaRejhs \= meanDeltaRejhs(isfinite(meanDeltaRejhs)); 
 HS\_stats.RejAvg(i) \= mean(meanDeltaRejhs);
 HS\_stats.RejAvg\_err(i) \= std(meanDeltaRejhs)/sqrt(length(meanDeltaRejhs));
 
 HS\_stats.numAcc(i) \= length(meanDeltaAcchs);
 HS\_stats.numRej(i) \= length(meanDeltaRejhs);
 
% nhs \= sum(isfinite(dm\_acchs),1\);
% dm\_acchs(\~isfinite(dm\_acchs)) \= 0;
% tta\_acchs \= sum(dm\_acchs, 1\)./nhs;
% ttv\_acchs \= sum( (dm\_acchs\-tta\_acchs).^2, 1\)./nhs;
% 
% dm\_rejhs(\~isfinite(dm\_rejhs)) \= 0;
% tta\_rejhs \= sum(dm\_rejhs, 1\)./sum(isfinite(dm\_rejhs), 1\);
% ttv\_rejhs \= sum( (dm\_rejhs\-tta\_rejhs).^2, 1 )./(sum(isfinite(dm\_rejhs), 1\)\-1\);
% 
% HS\_stats.tx \= taxis;
% HS\_stats.AccTTA{i} \= tta\_acchs;
% HS\_stats.RejTTA{i} \= tta\_rejhs;
% 
% HS\_stats.SDall(i) \= sqrt( sum(vt(taxis \> 0 \& taxis \< 1\.5\))/(nt^2\) );
% 
% 
% HS\_stats.AccAvg(i) \= sum(tta\_acchs(taxis \> 0 \& taxis \< 1\.5\))/nt;
% HS\_stats.AccAvg\_err(i) \= sqrt( sum(ttv\_acchs(taxis \> 0 \& taxis \< 1\.5\))/(nt^2\) );
% HS\_stats.RejAvg(i) \= sum(tta\_rejhs(taxis \> 0 \& taxis \< 1\.5\));
% HS\_stats.RejAvg\_err(i) \= sqrt( sum(ttv\_rejhs(taxis \> 0 \& taxis \< 1\.5\))/(nt^2\) );
% 
% HS\_stats.numAcc(i) \= size(dm\_acchs, 1\);
% HS\_stats.numRej(i) \= size(dm\_rejhs, 1\);
 
 end
 HS\_stats.tt \= tBins(1:end\-1\);
 btdstruct.HSavgs \= HS\_stats;
 
 
 end
end
end

function \[btdstruct, Kernels] \= measureKernelsVsVar (btdstruct, var, bootstrap)



opstruct \= btdstruct.varops;
switchStim \= find(\[opstruct.stim.switch]);

firsths.name \= 'hsnum';
firsths.validop \= @(x) x \=\= 1;

if(switchStim\>0\)
 
 for j \= 1:size(var, 2\)
 
 period \= var(j).period;
 
 tton \= var(j).turn.ton;
 ttoff \= var(j).turn.toff;
 teti \= var(j).turn.eti;
 
 accton \= var(j).acchs.ton;
 acctoff \= var(j).acchs.toff;
 rejton \= var(j).rejhs.ton;
 rejtoff \= var(j).rejhs.toff;
 acceti \= var(j).acchs.eti;
 rejeti \= var(j).rejhs.eti;
 
 tt \= \[btdstruct.btd.turn]';
 turneti \= \[tt.start\_eti]';
 turntnum \= \[tt.tnum]';
 acchs \= \[btdstruct.btd.acchs]';
 rejhs \= \[btdstruct.btd.rejhs]';
 acchseti \= \[acchs.start\_eti]';
 rejhseti \= \[rejhs.start\_eti]';
 
 accnhs \= \[acchs.hsnum]';
 rejnhs \= \[rejhs.hsnum]';
 firstacchs \= accnhs \=\= 1;
 firstrejhs \= rejnhs \=\= 1;

 turnvalid \= turneti \>\= min(btdstruct.varops.timeRange) \& turneti \< max(btdstruct.varops.timeRange);
 acchsvalid \= acchseti \>\= min(btdstruct.varops.timeRange) \& acchseti \< max(btdstruct.varops.timeRange);
 rejhsvalid \= rejhseti \>\= min(btdstruct.varops.timeRange) \& rejhseti \< max(btdstruct.varops.timeRange);

 
 
 taxis \= \-(\-opstruct.kernelTime:opstruct.kernelDt:opstruct.kernelTime);
 
 if strcmp(opstruct.stim(j).gqname, 'led1ValDiff')
 gqname\_levels \= \['led1Val'];
 elseif strcmp(opstruct.stim(j).gqname, 'led2ValDiff')
 gqname\_levels \= \['led2Val'];
 end
 
 if strcmp(opstruct.stim(j).gqname, 'led1ValDiff') \|\| strcmp(opstruct.stim(j).gqname, 'led2ValDiff')
 dm\_val\_lvl \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', gqname\_levels, taxis);
 dm\_val\_lvl \= dm\_val\_lvl(turnvalid, :);
 end
 
 \[dm\_val,\~,dm\_expnum] \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', opstruct.stim(j).gqname, taxis);
 dm\_val \= dm\_val(turnvalid, :);
 dm\_expnum \= dm\_expnum(turnvalid, :);
 turntnum \= turntnum(turnvalid, :);
 
 dm\_acchs \= btdstruct.btd.behaviorTriggeredDataMatrix('acchs', 'end', opstruct.stim(j).gqname, taxis);
 dm\_acchs \= dm\_acchs(acchsvalid \& firstacchs, :);
 
 dm\_rejhs \= btdstruct.btd.behaviorTriggeredDataMatrix('rejhs', 'end', opstruct.stim(j).gqname, taxis);
 dm\_rejhs \= dm\_rejhs(rejhsvalid \& firstrejhs, :);

 
 if(strcmpi(opstruct.stim(switchStim).ramptype, 'square'))
 
 tH \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> 0 \& tton \< (period/2\-opstruct.adaptationTime) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> 0 \& ttoff \< (period/2\-opstruct.adaptationTime) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 
 accH \= accton \> opstruct.adaptationTime \& accton \< acctoff \& acceti \>\= min(opstruct.timeRange) \& acceti \< max(opstruct.timeRange);
 accL \= acctoff \> opstruct.adaptationTime \& acctoff \< accton \& acceti \>\= min(opstruct.timeRange) \& acceti \< max(opstruct.timeRange);
 accU \= accton \> 0 \& accton \< (period/2\-opstruct.adaptationTime) \& acceti \>\= min(opstruct.timeRange) \& acceti \< max(opstruct.timeRange);
 accD \= acctoff \> 0 \& acctoff \< (period/2\-opstruct.adaptationTime) \& acceti \>\= min(opstruct.timeRange) \& acceti \< max(opstruct.timeRange);
 rejH \= rejton \> opstruct.adaptationTime \& rejton \< rejtoff \& rejeti \>\= min(opstruct.timeRange) \& rejeti \< max(opstruct.timeRange);
 rejL \= rejtoff \> opstruct.adaptationTime \& rejtoff \< rejton \& rejeti \>\= min(opstruct.timeRange) \& rejeti \< max(opstruct.timeRange);
 rejU \= rejton \> 0 \& rejton \< (period/2\-opstruct.adaptationTime) \& rejeti \>\= min(opstruct.timeRange) \& rejeti \< max(opstruct.timeRange);
 rejD \= rejtoff \> 0 \& rejtoff \< (period/2\-opstruct.adaptationTime) \& rejeti \>\= min(opstruct.timeRange) \& rejeti \< max(opstruct.timeRange);
 else
 tH \= tton \> opstruct.adaptationTime \& tton \> (3\*max(tton)/8\) \& tton \< (5\*max(tton)/8\) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff \> opstruct.adaptationTime \& ttoff \> (3\*max(ttoff)/8\) \& ttoff \< (5\*max(ttoff)/8\) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 end
 
 if strcmp(opstruct.stim(j).gqname, 'led1ValDiff') \|\| strcmp(opstruct.stim(j).gqname, 'led2ValDiff')
 dm \= dm\_val\_lvl(tH, :);
 dm(\~isfinite(dm)) \= 0;
 Kernels.High\_lvl(j).taxis \= taxis;
 Kernels.High\_lvl(j).tta \= sum(dm)./sum(isfinite(dm\_val(tH,:)));
 Kernels.High\_lvl(j).tta \= Kernels.High\_lvl(j).tta \- mean(btdstruct.btd.behaviorTriggeredAverage('turn','start', gqname\_levels , 10:0\.1:15\));
 Kernels.High\_lvl(j).nturns \= nnz(tH);
 
 dm \= dm\_val\_lvl(tL, :);
 dm(\~isfinite(dm)) \= 0;
 Kernels.Low\_lvl(j).taxis \= taxis;
 Kernels.Low\_lvl(j).tta \= sum(dm)./sum(isfinite(dm\_val(tL,:)));
 Kernels.Low\_lvl(j).tta \= Kernels.Low\_lvl(j).tta \- mean(btdstruct.btd.behaviorTriggeredAverage('turn','start', gqname\_levels , 10:0\.1:15\));
 Kernels.Low\_lvl(j).nturns \= nnz(tL);
 end
 
 dm \= dm\_val(tH, :);
 dm\_e \= dm\_expnum(tH, :);
 dm\_tnum \= turntnum(tH, :);
 dm(\~isfinite(dm)) \= 0;
 Kernels.High(j).taxis \= taxis;
 Kernels.High(j).tta \= sum(dm)./sum(isfinite(dm\_val(tH,:))); 
 Kernels.High(j).nturns \= nnz(tH);
 Kernels.High(j).dm \= dm;
 Kernels.High(j).dm\_e \= dm\_e;
 Kernels.High(j).dm\_tnum \= dm\_tnum;
% code for bootstrapping TTA randomly sampling from experiments and tracks:
 if (bootstrap \=\= 1\)
 \[meanTTA, meanBS, stdBS] \= bootstrapTTAfromBTDM(dm, dm\_e, dm\_tnum, taxis, 100\);
 Kernels.High(j).bootstrapKer \= meanTTA; 
 Kernels.High(j).bootstrapMean \= meanBS;
 Kernels.High(j).bootstrapStd \= stdBS; 
 end
 
 dm \= dm\_val(tL, :);
 dm\_e \= dm\_expnum(tL, :);
 dm\_tnum \= turntnum(tL, :);
 dm(\~isfinite(dm)) \= 0;
 Kernels.Low(j).taxis \= taxis;
 Kernels.Low(j).tta \= sum(dm)./sum(isfinite(dm\_val(tL,:)));
 Kernels.Low(j).nturns \= nnz(tL);
 Kernels.Low(j).dm \= dm;
 Kernels.Low(j).dm\_e \= dm\_e;
 Kernels.Low(j).dm\_tnum \= dm\_tnum;
% code for bootstrapping TTA randomly sampling from experiments and tracks:
 if (bootstrap \=\= 1\)
 \[meanTTA, meanBS, stdBS] \= bootstrapTTAfromBTDM(dm, dm\_e, dm\_tnum, taxis, 100\);
 Kernels.Low(j).bootstrapKer \= meanTTA;
 Kernels.Low(j).bootstrapMean \= meanBS;
 Kernels.Low(j).bootstrapStd \= stdBS;
 end
 
 dm \= dm\_val(tU, :);
 dm(\~isfinite(dm)) \= 0;
 Kernels.Up(j).taxis \= taxis;
 Kernels.Up(j).tta \= sum(dm)./sum(isfinite(dm\_val(tU,:)));
 Kernels.Up(j).nturns \= nnz(tU);
 
 dm \= dm\_val(tD, :);
 dm(\~isfinite(dm)) \= 0;
 Kernels.Down(j).taxis \= taxis;
 Kernels.Down(j).tta \= sum(dm)./sum(isfinite(dm\_val(tD,:)));
 Kernels.Down(j).nturns \= nnz(tD);
 
 if(strcmpi(opstruct.stim(switchStim).ramptype, 'square'))
 dm\_acc \= dm\_acchs(accH, :);
 dm\_acc(\~isfinite(dm\_acc)) \= 0;
 dm\_rej \= dm\_rejhs(rejH, :);
 dm\_rej(\~isfinite(dm\_rej)) \= 0;
 Kernels.High(j).tta\_acchs \= sum(dm\_acc)./sum(isfinite(dm\_acchs(accH, :)));
 Kernels.High(j).tta\_rejhs \= sum(dm\_rej)./sum(isfinite(dm\_rejhs(rejH, :)));
 dm\_acc \= dm\_acchs(accL, :);
 dm\_acc(\~isfinite(dm\_acc)) \= 0;
 dm\_rej \= dm\_rejhs(rejL, :);
 dm\_rej(\~isfinite(dm\_rej)) \= 0;
 Kernels.Low(j).tta\_acchs \= sum(dm\_acc)./sum(isfinite(dm\_acchs(accL, :)));
 Kernels.Low(j).tta\_rejhs \= sum(dm\_rej)./sum(isfinite(dm\_rejhs(rejL, :)));
 dm\_acc \= dm\_acchs(accU, :);
 dm\_acc(\~isfinite(dm\_acc)) \= 0;
 dm\_rej \= dm\_rejhs(rejU, :);
 dm\_rej(\~isfinite(dm\_rej)) \= 0;
 Kernels.Up(j).tta\_acchs \= sum(dm\_acc)./sum(isfinite(dm\_acchs(accU, :)));
 Kernels.Up(j).tta\_rejhs \= sum(dm\_rej)./sum(isfinite(dm\_rejhs(rejU, :)));
 dm\_acc \= dm\_acchs(accD, :);
 dm\_acc(\~isfinite(dm\_acc)) \= 0;
 dm\_rej \= dm\_rejhs(rejD, :);
 dm\_rej(\~isfinite(dm\_rej)) \= 0;
 Kernels.Down(j).tta\_acchs \= sum(dm\_acc)./sum(isfinite(dm\_acchs(accD, :)));
 Kernels.Down(j).tta\_rejhs \= sum(dm\_rej)./sum(isfinite(dm\_rejhs(rejD, :)));
 end
 
 end

else
 
 for j \= 1:size(var, 2\)
 teti \= var(j).turn.eti;
 turnvalid \= teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 
 taxis \= \-(\-2:opstruct.kernelDt:opstruct.kernelTime);
 dm\_val \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', opstruct.stim(j).gqname, taxis);
 dm\_conv \= btdstruct.btd.behaviorTriggeredDataMatrix('turn', 'start', \[opstruct.stim(j).gqname 'TurnLin'], 0\);
 dm\_val \= dm\_val(turnvalid, :);
 dm\_val(\~isfinite(dm\_val)) \= 0;
 dm\_conv \= dm\_conv(turnvalid);
 Kernels(j).taxis \= taxis;
 Kernels(j).tta \= sum(dm\_val)./sum(isfinite(dm\_conv));
 end
 
end


btdstruct.Kernels \= Kernels;


end

function \[btdstruct, Rates] \= measureRatesVsVar (btdstruct, var)
 

opstruct \= btdstruct.varops;
switchStim \= find(\[opstruct.stim.switch]);

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';


if(switchStim\>0\)
 
 for j \= 1:size(var, 2\)

 period \= var(j).period;
 
 deltaT \= median(diff(var(j).fullensemble.eti));
 tton \= var(j).turn.ton;
 ttoff \= var(j).turn.toff;
 teti \= var(j).turn.eti;
 rton \= var(j).noturn.ton;
 rtoff \= var(j).noturn.toff;
 reti \= var(j).noturn.eti;
 
 if(strcmpi(opstruct.stim(switchStim).ramptype, 'square'))
 
 tH \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> 0 \& tton \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> 0 \& ttoff \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange); 
 rH \= rton \> opstruct.adaptationTime \& rton \< rtoff \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rL \= rtoff \> opstruct.adaptationTime \& rtoff \< rton \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rU \= rton \> 0 \& rton \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rD \= rtoff \> 0 \& rtoff \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 else
 
 tH \= tton\>(period/2\-opstruct.adaptationTime) \& tton\<(period/2\+opstruct.adaptationTime) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tL \= ttoff\>(period/2\-opstruct.adaptationTime) \& ttoff\<(period/2\+opstruct.adaptationTime) \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tU \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 tD \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 rH \= rton\>(period/2\-opstruct.adaptationTime) \& rton\<(period/2\+opstruct.adaptationTime) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rL \= rtoff\>(period/2\-opstruct.adaptationTime) \& rtoff\<(period/2\+opstruct.adaptationTime) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rU \= rton \> opstruct.adaptationTime \& rton \< rtoff \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 rD \= rtoff \> opstruct.adaptationTime \& rtoff \< rton \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 %rH \= rton \> opstruct.adaptationTime \& rton \> (7\*max(rton)/16\) \& rton \< (9\*max(rton)/16\) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 %rL \= rtoff \> opstruct.adaptationTime \& rtoff \> (7\*max(rtoff)/16\) \& rtoff \< (9\*max(rtoff)/16\) \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 end
 
 xt \= var(j).turn.x\_conv(tH);
 xr \= var(j).noturn.x\_conv(rH);
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins); 
 Rates.rfHighVar(j) \= turnRates (xt, xr, deltaT, lx, opstruct); 
 
 xt \= var(j).turn.x\_conv\_HK(tH);
 xr \= var(j).noturn.x\_conv\_HK(rH);
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins); 
 Rates.rfHighVar\_HK(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 if strcmp(opstruct.stim(j).gqname, 'led1ValDiff') \|\| strcmp(opstruct.stim(j).gqname, 'led2ValDiff')
 xt \= var(j).turn.x\_conv\_lvl(tH);
 xr \= var(j).noturn.x\_conv\_lvl(rH);
 lx \= linspace(mean(xr)\-3\*std(xr), mean(xr)\+3\*std(xr), opstruct.numLxBins); 
 Rates.rfHighVar\_lvl(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 xt \= var(j).turn.x\_conv\_lvl(tL);
 xr \= var(j).noturn.x\_conv\_lvl(rL); 
 lx \= linspace(mean(xr)\-3\*std(xr), mean(xr)\+3\*std(xr), opstruct.numLxBins);
 Rates.rfLowVar\_lvl(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 end
 
% xt \= var(j).turn.x\_conv\_ber120(tH);
% xr \= var(j).noturn.x\_conv\_ber120(rH);
% lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins); 
% Rates.rfHighVar\_ber120(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 xt \= var(j).turn.x\_conv(tL);
 xr \= var(j).noturn.x\_conv(rL); 
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 Rates.rfLowVar(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 xt \= var(j).turn.x\_conv\_LK(tL);
 xr \= var(j).noturn.x\_conv\_LK(rL); 
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 Rates.rfLowVar\_LK(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
% xt \= var(j).turn.x\_conv\_ber120(tL);
% xr \= var(j).noturn.x\_conv\_ber120(rL); 
% lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
% Rates.rfLowVar\_ber120(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 if(opstruct.adaptationTime \> 0\)
 xt \= var(j).turn.x\_conv(tU);
 xr \= var(j).noturn.x\_conv(rU);
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 Rates.rfUp(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 xt \= var(j).turn.x\_conv(tD);
 xr \= var(j).noturn.x\_conv(rD);
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 Rates.rfDown(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 end
 end
 
 if(size(var, 2\) \=\= 2\) 
 xt2D(:,1\) \= var(1\).turn.x\_conv;
 xt2D(:,2\) \= var(2\).turn.x\_conv;
 xr2D(:,1\) \= var(1\).noturn.x\_conv;
 xr2D(:,2\) \= var(2\).noturn.x\_conv;
 Rates.Rates2D.rfHighVar \= turnRates2D (xt2D, xr2D, deltaT, tH, rH, opstruct.numLxBins);
 Rates.Rates2D.rfLowVar \= turnRates2D (xt2D, xr2D, deltaT, tL, rL, opstruct.numLxBins);
 if(opstruct.adaptationTime \> 0\)
 Rates.Rates2D.rfUp \= turnRates2D (xt2D, xr2D, deltaT, tU, rU, opstruct.numLxBins);
 Rates.Rates2D.rfDown \= turnRates2D (xt2D, xr2D, deltaT, tD, rD, opstruct.numLxBins);
 end
 end
 
 btdstruct.Rates \= Rates;
 
else
 
 for j \= 1:size(var, 2\)
 deltaT \= median(diff(var(j).fullensemble.eti));
 
 xt \= var(j).turn.x\_conv;
 expnt \= var(j).turn.expnum;
 xr \= var(j).noturn.x\_conv;
 expnr \= var(j).noturn.expnum;
 
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 
 Rates.rf(j) \= turnRates (xt, xr, deltaT, lx, opstruct);
 
 for k\=1:max(expnt)
 
 xt\_sep \= xt(expnt \=\= k);
 xr\_sep \= xr(expnr \=\= k);
 lx \= linspace(\-3\*std(xr\_sep), 3\*std(xr\_sep), opstruct.numLxBins);
 RatesSepExp{k}.rf(j) \= turnRates (xt\_sep, xr\_sep, deltaT, lx, opstruct);
 end
 
 end
 btdstruct.RatesSepExp \= RatesSepExp;
 btdstruct.Rates \= Rates;
 
end

end

function \[btdstruct, rateVtime] \= measureRateVtime(var, deltaT, dt)

if( isfield(var.turn, 'ton') )
 tton \= var.turn.ton;
 aton \= var.noturn.ton;
 tx\_ton \= 0:dt:var.period;
 rateVtime.rate\_ton \= 60\* histc(tton, tx\_ton)./histc(aton, tx\_ton) / deltaT;
 rateVtime.tx\_ton \= tx\_ton;
end

teti \= var.turn.eti;
aeti \= var.noturn.eti;
tx \= 0:dt:max(aeti);
rateVtime.rate \= 60\* histc(teti, tx)./histc(aeti, tx) / deltaT;

rateVtime.tx \= tx;
btdstruct.rateVtime \= rateVtime;

end

function \[meanTTA, meanBS, stdBS] \= bootstrapTTAfromBTDM(BTDM,expnum,tnum,taxis,numBootSamp)


datamat \= BTDM; 
datamat \= datamat'; %(assumes BTDM is in the form (turns x taxis) )

expmat \= repmat(expnum,\[1 length(taxis)]); %matrix of experiment numbers
expmat \= expmat';

tnummat \= repmat(tnum,\[1 length(taxis)]); % matrix of track numbers
tnummat \= tnummat';

%numtracks \= cell(length(numBootSamp\*max(expnum)),1\);
drawtracks \= cell(length(numBootSamp\*max(expnum)),1\);
for i\=1:numBootSamp\*max(expnum) 
 drawexp(i) \= round( (max(expnum)\-1\)\*rand) \+1; %array of random experiments to sample
 numtracks(i) \= max( tnum(expnum \=\= drawexp(i) )); %number of tracks in each experiment in drawexp
 drawtracks{i} \= round((numtracks(i)\-1\)\*rand(1,numtracks(i)))\+1; %cell array of random tracks to draw from each experiment in drawexp
end

 
for k \= 1:numBootSamp
 clear sampledat;
 sampledat \= datamat(expmat \=\= drawexp(1\) \& tnummat \=\= drawtracks{1}(1\));
 for l \= 2:length(drawtracks{1}) 
 sampledat \= cat(1,sampledat, datamat(expmat \=\= drawexp(1\) \& tnummat \=\= drawtracks{1}(l)));
 end
 for i\=2:max(expnum) 
 for j\=1:length(drawtracks{(k\-1\)\*max(expnum)\+i})
 sampledat \= cat(1, sampledat, datamat(expmat \=\= drawexp((k\-1\)\*max(expnum)\+i) \& tnummat \=\= drawtracks{(k\-1\)\*max(expnum)\+i}(j)));
 end
 end
 sampledat(\~isfinite(sampledat)) \= 0;
 sdatmat \= vec2mat(sampledat,length(taxis));
 meanTTA(k,:) \= mean(sdatmat,1\);
% samdatmat{k} \= sdatmat;
end

meanBS \= mean(meanTTA, 1\);
stdBS \= std(meanTTA , \[], 1\);

end
\-\-\-

\#\#\# Folder: Variance Adaptation Paper/Rate Funs (ID: Variance Adaptation Paper.Rate Funs)

\-\-\-

\#\#\# File: fitRescaledRates.m (ID: Variance Adaptation Paper.Rate Funs.1\)


function RescaleStruct \= fitRescaledRates( btdvar, opstruct, degree, rescale\_type, nExpTest )
% function RescaleStruct \= fitRescaledRates( btdvar, opstruct, degree, rescale\_type, nExpTest )

% jack\-knife calculation of fit parameters and log\-likelihood for fit to a rescaling model rate function

% degree \= 1 or 2 for r\=exp(ax\+b) or r\=exp(ax^2\+bx\+c) respectively
% rescale\_type \= {'input', 'output', 'output\_rect'} or some subset of those

% nExpTest is the number of experiments from the total number that is excluded from the fits. 


op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

nBins \= opstruct.numLxBins;
deltaT \= median(diff(btdvar.fullensemble.eti));

nexps \= max(btdvar.fullensemble.expnum);

% find high and low rates from all the data
\[tL\_all, tH\_all, rL\_all, rH\_all] \= getLowHighData(btdvar, opstruct, 1:nexps);
rates.lxL \= linspace(\-3\*std(rL\_all), 3\*std(rL\_all), nBins);
rates.lxH \= linspace(\-3\*std(rH\_all), 3\*std(rH\_all), nBins);
rates.lx\_all \= linspace(\-3\*std(\[rL\_all; rH\_all]), 3\*std(\[rL\_all;rH\_all]), nBins);
ntL \= histcounts(tL\_all, binEdgesFromCenters(rates.lxL));
nrL \= histcounts(rL\_all, binEdgesFromCenters(rates.lxL));
ntH \= histcounts(tH\_all, binEdgesFromCenters(rates.lxH));
nrH \= histcounts(rH\_all, binEdgesFromCenters(rates.lxH));
nt\_all \= histcounts(\[tL\_all; tH\_all], binEdgesFromCenters(rates.lx\_all));
nr\_all \= histcounts(\[rL\_all; rH\_all], binEdgesFromCenters(rates.lx\_all));
rates.rL \= 1\./deltaT \*ntL./nrL;
rates.rL\_eb \= 1\./deltaT \* sqrt(ntL)./nrL;
rates.rH \= 1\./deltaT \*ntH./nrH;
rates.rH\_eb \= 1\./deltaT \* sqrt(ntH)./nrH;
rates.rall \= 1\./deltaT\*nt\_all./nr\_all;
rates.rall\_eb \= 1\./deltaT \* sqrt(nt\_all)./nr\_all;

RescaleStruct.rates \= rates;

if(degree\=\=1\)
 p0 \= @(xt, xr) \[mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
else
 p0 \= @(xt, xr) \[\-0\.05 mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
end




% fit all data to one rate function
ratefun\_all \= @(rateP, dat) exp(polyval(rateP, dat));
nlogP \= @(p, xt, xr) \-sum(log(ratefun\_all(p, xt) ) ) \+ sum(ratefun\_all(p, xr)\*deltaT);
fitfun\_all \= @(p) nlogP(p, tH\_all, rH\_all) \+ nlogP(p, tL\_all, rL\_all);
fp0 \= p0(\[tH\_all;tL\_all], \[rH\_all;rL\_all]);
\[all.rP, all.nLL] \= fminunc(fitfun\_all, fp0, op);


expInds \= nchoosek(1:nexps, nExpTest);

% if(size(expInds,1\)\>200\)
% n \= 200;
% else
 n \= size(expInds, 1\);
% end

nLL\_test\_real \= \[];
array \= 1:size(expInds,1\);
for i\=1:n
 tic
 qq \= datasample(array, 1, 'Replace', false);
 array \= setdiff(array, qq);
 \[tL\_test, tH\_test, rL\_test, rH\_test] \= getLowHighData(btdvar, opstruct, expInds(qq,:));
 \[tL\_fit, tH\_fit, rL\_fit, rH\_fit] \= getLowHighData(btdvar, opstruct, setdiff(1:nexps, expInds(qq,:)));
 
 nturns(i) \= length(\[tL\_fit;tH\_fit]);
 nruns(i) \= length(\[rL\_fit;rH\_fit]);
 meanR(i) \= nturns(i)/(nruns(i)\*deltaT);
 
 % null model (mean rate)
 nLL\_meanR(i) \= \-nturns(i)\*log(meanR(i)) \+ nruns(i)\*(meanR(i)\*deltaT);
 
 % no adaptation
 ratefun \= @(rateP, dat) exp(polyval(rateP, dat));
 nlogP \= @(p, xt, xr) \-sum(log(ratefun(p, xt) ) ) \+ sum(ratefun(p, xr)\*deltaT);
 nlogP\_all \= @(p, tlow, thigh, rlow, rhigh) nlogP(p, tlow, rlow) \+ nlogP(p, thigh, rhigh);
 nlogP\_all\_fit \= @(p) nlogP\_all(p, tL\_fit, tH\_fit, rL\_fit, rH\_fit);
 p0\_noadapt \= p0(\[tH\_fit;tL\_fit], \[rH\_fit;rL\_fit]);
 
 \[fp\_noadapt{i}, nLL\_noadapt\_fit(i)] \= fminunc(nlogP\_all\_fit, all.rP, op);
 nLL\_noadapt\_test(i) \= nlogP\_all(fp\_noadapt{i}, tL\_test, tH\_test, rL\_test, rH\_test) ;
 
 for k\=1:length(rescale\_type)
 
 if(strcmpi(rescale\_type{k}, 'input'))
 ratefun \= @(alpha, rateP, dat) exp(polyval(rateP, alpha.\*dat));
 elseif(strcmpi(rescale\_type{k}, 'output\_rect'))
 ratefun \= @(alpha, rateP, dat) alpha.\*(exp(polyval(rateP, dat)) \- exp(rateP(end))) \+ exp(rateP(end));
 elseif(strcmpi(rescale\_type{k}, 'output'))
 ratefun \= @(alpha, rateP, dat) alpha.\*( exp(polyval(rateP, dat)) );
 end
 
 fitfun{k} \= ratefun;
 
 alpha\_base \= 1;
 nlogP \= @(p, xt, xr) \-sum(log(ratefun(alpha\_base, p, xt) ) ) \+ sum(ratefun(alpha\_base, p, xr)\*deltaT);
 nlogP\_resc \= @(p, xt, xr) \-sum(log(ratefun(p(end), p(1:end\-1\), xt) ) ) \+ sum(ratefun(p(end), p(1:end\-1\), xr)\*deltaT);
 
% % fit High var. part first
% p0H \= p0(tH\_fit, rH\_fit);
% nlogPH \= @(p) nlogP(p, tH\_fit, rH\_fit);
% \[fpH, \~] \= fminunc(nlogPH, p0H, op);

 %all resc.
 nlogP\_all \= @(p, tlow, thigh, rlow, rhigh) nlogP\_resc(p, tlow, rlow) \+ nlogP(p(1:end\-1\), thigh, rhigh);
 nlogP\_all\_fit \= @(p) nlogP\_all(p, tL\_fit, tH\_fit, rL\_fit, rH\_fit);
 
 \[fp, nLL\_fit(k,i)] \= fminunc(nlogP\_all\_fit, \[all.rP, 1], op);
 nLL\_test(k, i) \= nlogP\_all(fp, tL\_test, tH\_test, rL\_test, rH\_test) ;
 nLL\_all(k,i) \= nlogP\_all(fp, \[tL\_fit;tL\_test], \[tH\_fit;tH\_test], \[rL\_fit;rL\_test], \[rH\_fit;rH\_test]);
 if(degree\=\=2\)
 rP\_quad(k,i) \= fp(1\);
 end
 rP\_lin(k,i) \= fp(end\-2\);
 rP\_r0(k,i) \= fp(end\-1\);
 alpha\_resc(k,i) \= fp(end);
 
 
 end
 if(any(imag(nLL\_test(:,i))\~\=0\)\=\=0\)
 nLL\_test\_real \= \[nLL\_test\_real, nLL\_test(:,i)];
 end
 
% if(size(nLL\_test\_real, 2\)\>\=200\)
% break
% end
 
 toc
end





for k\=1:length(rescale\_type)
 inds\_test{k} \= find(imag(nLL\_test(k,:))\=\=0\);
 ninds(k) \= length(inds\_test{k});
end
if( any( ninds \< size(expInds,1\)) )
 m \= find( ninds\=\=min(ninds) );
 realinds\_test \= inds\_test{m};
else
 realinds\_test \= inds\_test{1};
end

RescaleStruct.models \= rescale\_type;
RescaleStruct.ratefuns \= fitfun;
RescaleStruct.imaginds\_test \= inds\_test;
RescaleStruct.realinds\_test \= realinds\_test;
RescaleStruct.null.nturns \= nturns;
RescaleStruct.null.nruns \= nruns;
RescaleStruct.null.meanR \= meanR;
RescaleStruct.null.nLL\_meanR \= nLL\_meanR;
RescaleStruct.null.fP\_noadapt \= fp\_noadapt;
RescaleStruct.null.nLL\_noadapt\_fit \= nLL\_noadapt\_fit;
RescaleStruct.null.nLL\_noadapt\_test \= nLL\_noadapt\_test;
RescaleStruct.adapt.nLL\_fit \= nLL\_fit;
RescaleStruct.adapt.nLL\_test \= nLL\_test;
RescaleStruct.adapt.nLL\_all \= nLL\_all;
RescaleStruct.adapt.alpha \= alpha\_resc;
RescaleStruct.adapt.linR \= rP\_lin;
if(degree\=\=2\)
 RescaleStruct.adapt.quadR \= rP\_quad;
end
RescaleStruct.adapt.r0 \= exp(rP\_r0\);


end

% 
% for i\=1:n
% tic
% 
% \[rHfit, rindsHfit] \= datasample(rdatH, round(jack\_knife\*length(rdatH)), 'Replace', false);
% \[tHfit, tindsHfit] \= datasample(tdatH, round(jack\_knife\*length(tdatH)), 'Replace', false);
% \[rLfit, rindsLfit] \= datasample(rdatL, round(jack\_knife\*length(rdatL)), 'Replace', false);
% \[tLfit, tindsLfit] \= datasample(tdatL, round(jack\_knife\*length(tdatL)), 'Replace', false);
% if(jack\_knife\=\=1\)
% rindsHtest \= rindsHfit;
% rindsLtest \= rindsLfit;
% tindsHtest \= tindsHfit;
% tindsLtest \= tindsLfit;
% else
% rindsHtest \= setdiff(1:length(rdatH),rindsHfit);
% tindsHtest \= setdiff(1:length(tdatH),tindsHfit);
% rindsLtest \= setdiff(1:length(rdatL),rindsLfit);
% tindsLtest \= setdiff(1:length(tdatL),tindsLfit);
% end
% 
% for k\=1:length(rescale\_type)
% 
% if(strcmpi(rescale\_type{k}, 'input'))
% ratefun \= @(alpha, rateP, dat) exp(polyval(rateP, alpha.\*dat));
% elseif(strcmpi(rescale\_type{k}, 'output\_rect'))
% ratefun \= @(alpha, rateP, dat) alpha.\*(exp(polyval(rateP, dat)) \- exp(rateP(end))) \+ exp(rateP(end));
% elseif(strcmpi(rescale\_type{k}, 'output'))
% ratefun \= @(alpha, rateP, dat) alpha.\*( exp(polyval(rateP, dat)) );
% end
% 
% rates.fitfun{k} \= ratefun;
% 
% alpha\_base \= 1;
% nlogP \= @(p, xt, xr) \-sum(log(ratefun(alpha\_base, p, xt) ) ) \+ sum(ratefun(alpha\_base, p, xr)\*deltaT);
% nlogP\_resc \= @(p, xt, xr) \-sum(log(ratefun(p(end), p(1:end\-1\), xt) ) ) \+ sum(ratefun(p(end), p(1:end\-1\), xr)\*deltaT);
% 
% 
% % fit High var. part first
% 
% p0H \= p0(tHfit, rHfit);
% nlogPH \= @(p) nlogP(p, tHfit, rHfit);
% \[fpH, \~] \= fminunc(nlogPH, p0H, op);
% 
% 
% %all resc.
% 
% nlogP\_all \= @(p, tlow, thigh, rlow, rhigh) nlogP\_resc(p, tdatL(tlow), rdatL(rlow)) \+ nlogP(p(1:end\-1\), tdatH(thigh), rdatH(rhigh));
% 
% nlogP\_all\_fit \= @(p) nlogP\_all(p, tindsLfit, tindsHfit, rindsLfit, rindsHfit);
% \[fp, LL\_fit(k,i)] \= fminunc(nlogP\_all\_fit, \[fpH, 1], op);
% LL\_test(k,i) \= nlogP\_all(fp, tindsLtest, tindsHtest, rindsLtest, rindsHtest) ;
% LL\_all(k,i) \= nlogP\_all(fp, \[tindsLtest tindsLfit], \[tindsHtest tindsHfit], \[rindsLtest rindsLfit], \[rindsHtest rindsHfit]);
% 
% if(degree\=\=2\)
% rP\_quad(k,i) \= fp(1\);
% end
% rP\_lin(k,i) \= fp(end\-2\);
% rP\_r0(k,i) \= fp(end\-1\);
% alpha\_resc(k,i) \= fp(end);
% 
% 
% % nlogP\_all\_test \= @(p) nlogP\_all(p, tindsLtest, tindsHtest, rindsLtest, rindsHtest);
% % \[fp\_test{k}{i}, LL\_test.fit(k,i)] \= fminunc(nlogP\_all\_test, \[fpH, 1], op);
% % LL\_test.test(k,i) \= nlogP\_all(fp\_test{k}{i}, tindsLfit, tindsHfit, rindsLfit, rindsHfit) ;
% 
% % fit low var. part first
% % p0L \= p0(tdatL(tindsL), rdatL(rindsL));
% % nlogPL \= @(p) nlogP(p, tdatL(tindsL), rdatL(rindsL));
% % \[fpL, llL] \= fminunc(nlogPL, p0L, op);
% 
% % nlogP\_all \= @(p) nlogP\_resc(p, tdata(tH), rdata(rH)) \+ nlogP(p(1:end\-1\), tdata(tL), rdata(rL));
% % \[fp, LL.LtoH] \= fminunc(nlogP\_all, \[fpL, 1], op);
% %
% % rP.LtoH \= fp(1:end\-1\);
% % alpha.LtoH \= fp(end);
% 
% %all no rescaling, sep. rates
% % nlogP\_noresc \= @(p) nlogP(p(1:degree\+1\), tdata(tL), rdata(rL)) \+ nlogP(p(degree\+2:end), tdata(tH), rdata(rH));
% % \[\~, LL0] \= fminunc(nlogP\_noresc, \[fpL fpH], op);
% 
% end
% 
% 
% toc
% end
% 
% for k\=1:length(rescale\_type)
% 
% inds{k} \= find(imag(LL\_test(k,:))\=\=0\);
% ninds(k) \= length(inds{k});
% end
% if( any( ninds \< n\*length(rescale\_type)) )
% m \= find( ninds\=\=min(ninds) );
% realinds \= inds{m};
% end
% 
% JK.nLL\_fit \= LL\_fit(:,realinds);
% JK.nLL\_test \= LL\_test(:,realinds);
% JK.nLL\_all \= LL\_all(:,realinds);
% JK.alpha \= alpha\_resc(:,realinds);
% JK.rP.lin \= rP\_lin(:,realinds);
% if(degree\=\=2\)
% JK.rP.quad \= rP\_quad(:,realinds);
% end
% JK.rP.r0 \= rP\_r0(:,realinds);
% end


function \[tL, tH, rL, rH] \= getLowHighData(btdvar, opstruct, expInds)


tnum \= btdvar.turn.expnum;
rnum \= btdvar.noturn.expnum;

tvalid \= tnum \=\= expInds;
rvalid \= rnum \=\= expInds;

tdata \= repmat(btdvar.turn.x\_conv, \[1, size(tvalid,2\)]);
rdata \= repmat(btdvar.noturn.x\_conv, \[1, size(rvalid,2\)]);
tdata \= tdata(tvalid);
rdata \= rdata(rvalid);
 
tton \= repmat(btdvar.turn.ton, \[1, size(tvalid,2\)]); tton \= tton(tvalid);
ttoff \= repmat(btdvar.turn.toff, \[1, size(tvalid,2\)]); ttoff \= ttoff(tvalid);
teti \= repmat(btdvar.turn.eti, \[1, size(tvalid,2\)]); teti \= teti(tvalid);
rton \= repmat(btdvar.noturn.ton, \[1, size(rvalid,2\)]); rton \= rton(rvalid);
rtoff \= repmat(btdvar.noturn.toff, \[1, size(rvalid,2\)]); rtoff \= rtoff(rvalid);
reti \= repmat(btdvar.noturn.eti, \[1, size(rvalid,2\)]); reti \= reti(rvalid);


tH \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
tL \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
tU \= tton \> 0 \& tton \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
tD \= ttoff \> 0 \& ttoff \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
rH \= rton \> opstruct.adaptationTime \& rton \< rtoff \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
rL \= rtoff \> opstruct.adaptationTime \& rtoff \< rton \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
rU \= rton \> 0 \& rton \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
rD \= rtoff \> 0 \& rtoff \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);


tH \= tdata(tH);
tL \= tdata(tL);
rH \= rdata(rH);
rL \= rdata(rL);
end




\-\-\-

\#\#\# File: subMeanFromStim.m (ID: Variance Adaptation Paper.Rate Funs.2\)

function btdstruct \= subMeanFromStim(btdstruct)



for i \= 1:length(btdstruct.btd)
 btdstruct.btd(1, i).glt(1, 1\).yData \= btdstruct.btd(1, i).glt(1, 1\).yData \- 128;
end



end


\-\-\-

\#\#\# File: findRates.m (ID: Variance Adaptation Paper.Rate Funs.3\)


function \[btdstruct, RatesinCycle] \= findRates(btdstruct, opstruct, T, tau)
% function \[btdstruct, RatesinCycle] \= findRates(btdstruct, opstruct, T, tau)

% Finds high and low rate functions for time bins of duration T within each cycle (defined by btdstruct.var(1\).period),
% Excludes the first tau seconds. Does it for first and second 10min separately

if (\~isfield(btdstruct, 'var'))
 btdstruct \= BehaviorTriggeredData.prepVarianceSwitchingAnalysis\_Gepner(btdstruct, opstruct);
end
var \= btdstruct.var;

if(\~isfield(btdstruct, 'varops'))
 fn \= {'stim', 'numLxBins', 'adaptationTime', 'Q\_alpha', 'numTimeBins', 'timeRange'};
 for j \= 1:length(fn)
 btdstruct.varops.(fn{j}) \= opstruct.(fn{j});
 end
end

nstim \= size(var, 2\);
period \= var(1\).period;

for j\=1:nstim
 deltaT \= median(diff(var(j).fullensemble.eti));
 tton \= var(j).turn.ton;
 teti \= var(j).turn.eti;
 rton \= var(j).noturn.ton;
 reti \= var(j).noturn.eti;
 
 
 n \= period \- tau;
 n \= round(n/T);
 
 for i\=1:n
 t1 \= tau \+ (i\-1\)\*T;
 t2 \= tau \+ i\*T;
 
 rH \= rton\>\=t1 \& rton\<\=t2 \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
 tH \= tton\>\=t1 \& tton\<\=t2 \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
 xt \= var(j).turn.x\_conv(tH);
 xr \= var(j).noturn.x\_conv(rH);
 lx \= linspace(\-3\*std(xr), 3\*std(xr), opstruct.numLxBins);
 RatesinCycle{i}(j) \= turnRates (xt, xr, deltaT, lx);
 
 
 end
 
 
end

btdstruct.RatesinCycle \= RatesinCycle;

end

function rf \= turnRates (xt, xr, deltaT, lx)

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

existsAndDefault('lx', linspace(\-3\*std(xr), 3\*std(xr), 20\));

nt \= histcounts(xt, binEdgesFromCenters(lx));
nr \= histcounts(xr, binEdgesFromCenters(lx));

rf.lx \= lx;
rf.rate \= 1/deltaT \* nt ./ nr;
rf.rate\_eb \= 1/deltaT \* sqrt(nt) ./ nr;

nlogp \= @(p) \-sum(polyval(p, xt)) \+ deltaT\*sum(exp(polyval(p,xr)));
p0 \= \[mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
rf.rateFitLin \= fminunc(nlogp, p0, op);
p0 \= \[0 rf.rateFitLin];
rf.rateFitQuad \= fminunc(nlogp, p0, op);

end 






\-\-\-

\#\#\# File: plotMultiSensoryFits.m (ID: Variance Adaptation Paper.Rate Funs.4\)

function \[ RF ] \= plotMultiSensoryFits( fitstruct, varstruct, opstruct, color)


% Rescaled Rates

\[adim,po] \= blank8x10Figure();
pp \= \[adim.lx3, adim.h0 \- adim.h, adim.w3, adim.h];
pos \= {pp, pp, pp};
pos{2}(1\) \= adim.cx3;
pos{3}(1\) \= 2\*pos{2}(1\) \- pos{1}(1\);
pos{3}(2\) \= pos{1}(2\);

pos2 \= pos; % 2nd row of figure (3 columns each)
pos2{1}(1\) \= pos{1}(1\);
pos2{1}(2\) \= adim.cx3 \+ 0\.15;
pos2{2}(2\) \= pos2{1}(2\);
pos2{3}(2\) \= pos2{1}(2\);

pos3 \= pos2;
pos3{1}(2\) \= 2\*pos2{1}(2\) \- pos{1}(2\);
pos3{2}(2\) \= pos3{1}(2\);
pos3{3}(2\) \= pos3{1}(2\);

pos4 \= pos3;
pos4{1}(2\) \= 2\*pos3{1}(2\) \- pos2{1}(2\);
pos4{2}(2\) \= pos4{1}(2\);
pos4{3}(2\) \= pos4{1}(2\);

RedsHL \= {1/255\*\[243 127 129], 1/255\*\[127 20 22]};
BluesHL \= {1/255\*\[74 137 165], 1/255\*\[57 70 156]};

positions \= {pos{1}, pos2{1}, pos2{2}, pos2{3}, pos3{1}, pos3{2}, pos3{3}};

lograte \= 1;

for k\=1:length(fitstruct.ratefuns)
 
 for i\=1:length(fitstruct.nLL\_meanR)
 if(strncmpi(fitstruct.models{k}, 'ind', 3\))
 ao \= fitstruct.rP{k}{i}(1\);
 bo \= fitstruct.rP{k}{i}(2\);
 co \= fitstruct.rP{k}{i}(3\);
 al \= fitstruct.rP{k}{i}(4\);
 bl \= fitstruct.rP{k}{i}(5\);
 cl \= fitstruct.rP{k}{i}(6\);
 elseif(strncmpi(fitstruct.models{k}, 'mult', 3\))
 a(i) \= fitstruct.rP{k}{i}(1\);
 b(i) \= fitstruct.rP{k}{i}(2\);
 c(i) \= fitstruct.rP{k}{i}(3\);
 d(i) \= fitstruct.rP{k}{i}(4\);
 e(i) \= fitstruct.rP{k}{i}(5\);
 elseif(strncmpi(fitstruct.models{k}, 'add', 3\))
 theta(i) \= fitstruct.rP{k}{i}(1\);
 add\_quad(i) \= fitstruct.rP{k}{i}(2\);
 add\_lin(i) \= fitstruct.rP{k}{i}(3\);
 r0(i) \= fitstruct.rP{k}{i}(4\);
 end
 end
 
end

model\_params \= {};
if(any(strncmpi(fitstruct.models, 'ind', 3\)))
 params\_ind \= \[mean(ao) mean(bo) mean(co) mean(al) mean(bl) mean(cl)];
 model\_params{end\+1} \= params\_ind;
end
if(any(strncmpi(fitstruct.models, 'add', 3\)))
 params\_add \= \[mean(theta) mean(add\_quad) mean(add\_lin) mean(r0\)];
 model\_params{end\+1} \= params\_add;
end
if(any(strncmpi(fitstruct.models, 'mult', 3\)))
 params\_mult \= \[mean(a) mean(b) mean(c) mean(d) mean(e)];
 model\_params{end\+1} \= params\_mult;
end


nBins \= opstruct.numLxBins;
deltaT \= median(diff(varstruct(1\).fullensemble.eti));

for i\=1:length(varstruct)
 td(:,i) \= varstruct(i).turn.x\_conv;
 rd(:,i) \= varstruct(i).noturn.x\_conv;
end

Rates2D \= turnRates2D(td, rd, deltaT, nBins, fitstruct.ratefuns, model\_params);

colormap jet
paxis \= \[0 .2];
pticks \= \[0 .1 .2];

RF{1}.pos \= positions{1}; %\#ok\<\*AGROW\>
RF{1}.ax \= axes('Position', positions{1});
pcolor(Rates2D.lx(:,1\),Rates2D.lx(:,2\), Rates2D.thist./(.2\*.2\*sum(sum(Rates2D.thist)))); axis square; shading interp; colorbar
RF{1}.ax.YAxis.TickValues \= \[\-2 0 2];
clear caxis
caxis(gca, paxis); a \= colorbar; a.Ticks \= pticks;

nm \= length(model\_params);
for k\=1:nm
 RF{k\+1}.pos \= positions{k\+1};
 RF{k\+1}.ax \= axes('Position', positions{k\+1});
 pcolor(Rates2D.lx(:,1\),Rates2D.lx(:,2\), Rates2D.pred\_thist\_ROG{k}); axis square; shading interp;
 title(fitstruct.models{k});
 clear caxis
 caxis(gca, paxis); a \= colorbar; a.Ticks \= pticks;
end
set(gcf, 'renderer', 'painters');
return

% RF{k\+nm\+1}.ax.XAxis.TickValues \= \[\-2 0 2];
% RF{k\+nm\+1}.ax.YAxis.TickValues \= \[\-2 0 2];
% RF{k\+nm\+1}.pos \= positions{k\+nm\+1};
% RF{k\+nm\+1}.ax \= axes('Position', positions{k\+nm\+1});
% pcolor(Rates2D.lx(:,1\),Rates2D.lx(:,2\), Rates2D.pred\_thist{k}); axis square; shading interp;
% clear caxis
% caxis(gca, paxis); a \= colorbar; a.Ticks \= pticks;
% RF{k\+nm\+1}.ax.XAxis.TickValues \= \[\-2 0 2];
% RF{k\+nm\+1}.ax.YAxis.TickValues \= \[\-2 0 2];
% end

% set(gcf, 'renderer', 'opengl');

% return

end

function rf \= turnRates2D(td, rd, deltaT, nBins, ratefuns, params)

lx(:,1\) \= linspace(\-3\*std(rd(:,1\)), 3\*std(rd(:,1\)), nBins);
lx(:,2\) \= linspace(\-3\*std(rd(:,2\)), 3\*std(rd(:,2\)), nBins);
% lx(:,1\) \= linspace(\-2\.5, 2\.5, nBins);
% lx(:,2\) \= linspace(\-2\.5, 2\.5, nBins);

\[lxx, lxy] \= meshgrid(lx(:,1\), lx(:,2\));
lxdata \= \[lxx(:) lxy(:)];

h \= makeIm(rd(:,1\), rd(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
ht \= makeIm(td(:,1\), td(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
rhist \= reshape(h, size(lxx));
thist \= reshape(ht, size(lxx));

rf.lx \= lx;
rf.rhist \= rhist;
rf.thist \= thist;
rf.rate(:,1\) \= 1/deltaT \* sum(thist, 1\)./sum(rhist, 1\);
rf.rate\_eb(:,1\) \= 1/deltaT \* sqrt(sum(thist, 1\))./sum(rhist, 1\);
rf.rate(:,2\) \= 1/deltaT \* sum(thist, 2\)./sum(rhist, 2\);
rf.rate\_eb(:,2\) \= 1/deltaT \* sqrt(sum(thist, 2\))./sum(rhist, 2\);

rf.muO\_turn \= mean(td(:,1\));
rf.muL\_turn \= mean(td(:,2\));
rf.muOL\_turn \= mean(td(:,1\).\*td(:,2\),1\);

xyall\_gaussian \= reshape(mvnpdf(lxdata, mean(rd,1\), \[std(rd(:,1\)) 0;0 std(rd(:,2\))]), size(lxx));
% xyall\_gaussian \= reshape(mvnpdf(lxdata, \[0 0], eye(2\)), size(lxx));

if(\~isempty(ratefuns))
 for k\=1:length(ratefuns)
 
 pred\_rate{k} \= reshape(ratefuns{k}(params{k}, lxdata), size(lxx));
 

 pred\_thist\_ROG{k} \= pred\_rate{k}.\*xyall\_gaussian;
 pred\_thist{k} \= pred\_rate{k}.\*rhist;
 
 rf.pred\_thist\_ROG{k} \= pred\_thist\_ROG{k}./(prod(median(diff(lx,1\)))\*sum(sum(pred\_thist\_ROG{k})));
 rf.pred\_thist{k} \= pred\_thist{k}./(prod(median(diff(lx,1\)))\*sum(sum(pred\_thist{k})));
 
 rf.muO\_turn\_pred(k) \= (prod(median(diff(lx,1\))))\*sum(sum(repmat(lx(:,1\)',\[length(lx(:,2\)),1]).\*rf.pred\_thist{k}));
 rf.muL\_turn\_pred(k) \= (prod(median(diff(lx,1\))))\*sum(sum( repmat(lx(:,2\),\[1,length(lx(:,1\))]).\*rf.pred\_thist{k}));
 rf.muOL\_turn\_pred(k) \= (prod(median(diff(lx,1\))))\*sum(sum(repmat(lx(:,1\)',\[length(lx(:,2\)),1]).\*repmat(lx(:,2\), \[1, length(lx(:,1\))]).\*rf.pred\_thist{k}));
 
 rf.muO\_turn\_pred\_ROG(k) \= (prod(median(diff(lx,1\))))\*sum(sum(repmat(lx(:,1\)',\[length(lx(:,2\)),1]).\*rf.pred\_thist\_ROG{k}));
 rf.muL\_turn\_pred\_ROG(k) \= (prod(median(diff(lx,1\))))\*sum(sum( repmat(lx(:,2\),\[1,length(lx(:,1\))]).\*rf.pred\_thist\_ROG{k}));
 rf.muOL\_turn\_pred\_ROG(k) \= (prod(median(diff(lx,1\))))\*sum(sum(repmat(lx(:,1\)',\[length(lx(:,2\)),1]).\*repmat(lx(:,2\), \[1, length(lx(:,1\))]).\*rf.pred\_thist\_ROG{k}));
 end
end


end
 
 
 
 


\-\-\-

\#\#\# File: plotScaledRates.m (ID: Variance Adaptation Paper.Rate Funs.5\)

function \[ RF ] \= plotScaledRates( struct, color, fit\_test )


lograte \= 1; %whether to plot rate functions on semi\-log or not
deltaT\=.05; % used to nornalize by animal\-hours. this shouldn't be hard\-coded, but it is for now

% Rescaled Rates

\[adim,po] \= blank8x10Figure();
pp \= \[adim.lx3, adim.h0 \- adim.h, adim.w3, adim.h];
pos \= {pp, pp, pp};
pos{2}(1\) \= adim.cx3;
pos{3}(1\) \= 2\*pos{2}(1\) \- pos{1}(1\);
pos{3}(2\) \= pos{1}(2\);

pos2 \= pos; % 2nd row of figure (3 columns each)
pos2{1}(1\) \= pos{1}(1\);
pos2{1}(2\) \= adim.cx3 \+ 0\.15;
pos2{2}(2\) \= pos2{1}(2\);
pos2{3}(2\) \= pos2{1}(2\);

pos3 \= pos2;
pos3{1}(2\) \= 2\*pos2{1}(2\) \- pos{1}(2\);
pos3{2}(2\) \= pos3{1}(2\);
pos3{3}(2\) \= pos3{1}(2\);

pos4 \= pos3;
pos4{1}(2\) \= 2\*pos3{1}(2\) \- pos2{1}(2\);
pos4{2}(2\) \= pos4{1}(2\);
pos4{3}(2\) \= pos4{1}(2\);

RedsHL \= {1/255\*\[243 127 129], 1/255\*\[127 20 22]};
BluesHL \= {1/255\*\[74 137 165], 1/255\*\[57 70 156]};

positions \= {pos{1}, pos{2}, pos{3}, pos2{2}, pos3{2}};

if(strcmpi(color, 'red'))
 colors \= RedsHL;
 col \= \[1 0 0];
 ymax \= 12;
else
 colors \= BluesHL;
 col \= \[0 0 1];
 ymax \= 18;
end
barcolors \= {\[0 .5 0], \[.2 .9 0], \[0\.5 1 0], col};

rates \= struct.rates;

rPfit \= \[ mean(struct.adapt.quadR,2 ), mean(struct.adapt.linR,2 ), log(mean(struct.adapt.r0, 2\)) ];
alphas \= mean(struct.adapt.alpha, 2\);

% plot fit\-rate functions for each model

for k\=1:length(struct.models)\+1
 
 RF{k}.pos \= positions{k}; %\#ok\<\*AGROW\>
 RF{k}.ax \= axes('Position', positions{k});
 
 h(1\) \= errorbar (rates.lxL, 60\*rates.rL, 60\*rates.rL\_eb, 'color', colors{1}, 'marker', 'o', 'linestyle', 'none');
 hold all;
 h(2\) \= errorbar (rates.lxH, 60\*rates.rH, 60\*rates.rH\_eb, 'color', colors{2}, 'marker', 's','MarkerFaceColor', colors{2}, 'linestyle', 'none');
 
 
 % for k\=1:length(struct.models)
 if(k\>length(struct.models))
 ratefun \= @(params,dat) exp(polyval(params, dat));
 rP\_temp \= reshape(cell2mat(struct.null.fP\_noadapt), \[length(struct.models) length(struct.null.nturns)]);
 rP \= mean(rP\_temp, 2\);
 h(3\) \= plot (rates.lx\_all, 60\*ratefun(rP, rates.lx\_all), 'color', colors{1}, 'linestyle', ':', 'LineWidth', 1\.7\);
 h(3\) \= plot (rates.lx\_all, 60\*ratefun(rP, rates.lx\_all), 'color', colors{2}, 'linestyle', '\-', 'LineWidth', 1\);
 else
 ratefun \= struct.ratefuns{k};
 alpha \= alphas(k);
 rP \= rPfit(k,:);
 
 h(3\) \= plot (rates.lxL, 60\*ratefun(alpha, rP, rates.lxL), 'color', colors{1}, 'linestyle', ':', 'LineWidth', 1\.7\);
 h(4\) \= plot (rates.lxH, 60\*ratefun(1, rP, rates.lxH), 'color', colors{2}, 'linestyle', '\-', 'LineWidth', 1\);
 end
 % end
 
 
 ax \= gca;
 ax.Box \= 'off';
 
 ax.YLabel.String \= 'turn rate (min^{\-1})';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'Filtered Stimulus Value';
 ax.XLabel.FontSize \= 10;
 
 ax.XAxis.Color \= col;
 
 RF{k}.handles \= h;
 
 
 set(\[RF{k}.ax], 'YLim', \[0\.5 ymax]);
 if(lograte)
 set(\[RF{k}.ax], 'YScale', 'log');
 set(\[RF{k}.ax], 'YLim', \[0\.5 ymax]);
 set(\[RF{k}.ax], 'YTick', \[0 1 2 5 10 15 20]);
 set(\[RF{k}.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '15', '20'});
 end
 
end

k \= k\+1;


if(strcmpi(fit\_test, 'fit'))
 
 RF{k}.pos \= positions{k}; %\#ok\<\*AGROW\>
 RF{k}.ax \= axes('Position', positions{k});

 LL\_null \= \-struct.null.nLL\_noadapt\_fit; %jwolk
% LL\_null2 \= \-struct.null.nLL\_meanR;
 LLs\_norm \= \-struct.adapt.nLL\_fit \- LL\_null;
 
 deltaT\=.05;
 norm \= deltaT\*struct.null.nruns/3600;
 LLs\_norm \= LLs\_norm./norm;
 
 LLs \= mean(LLs\_norm,2\);
 LLs\_err \= std(LLs\_norm, 0, 2\);%./sqrt(size(struct.adapt.nLL\_fit, 2\));
 
 for q\=1:length(LLs)
 
 a \= bar(q, LLs(q));
 a.BarWidth \= .8;
 a.EdgeColor \= col;
 a.FaceColor \= col;
 a.FaceAlpha \= 0\.5;
 hold on;
 errorbar(q, LLs(q), LLs\_err(q), 'color', col, 'LineWidth', 2, 'CapSize', 0\);
 end
 ax \= gca;
 RF{k}.ax \= ax; 
 ax.XAxis.TickValues \= \[];
 
 
elseif(strcmpi(fit\_test, 'test'))
 
 inds \= struct.realinds\_test;
 LL\_null\_fit \= \-struct.null.nLL\_noadapt\_fit(inds);
 LL\_null\_test \= \-struct.null.nLL\_noadapt\_test(inds);
 
 LL\_fit \= \-struct.adapt.nLL\_fit(:,inds) \- LL\_null\_fit;
 LL\_test \= \-struct.adapt.nLL\_test(:,inds) \- LL\_null\_test;
 
 norm \= deltaT\*struct.null.nruns(inds)/3600; % normalize by animal hours
 meanNorm \= mean(norm);
 LL\_test \= LL\_test./norm;
 LL\_fit \= LL\_fit./norm;
 
 LL\_fit \= LL\_fit.\*meanNorm;
 LL\_test \= LL\_test.\*meanNorm;
 
 meanLL\_fit \= mean(LL\_fit,2\);
 errLL\_fit\= std(LL\_fit, 0, 2\)./sqrt(length(inds));
 meanLL\_test \= mean(LL\_test,2\);
 errLL\_test \= std(LL\_test, 0, 2\)./sqrt(length(inds));
 
 
 %log\-likelihood for fit part, bar graph
% RF{k}.pos \= pos3{1}; %\#ok\<\*AGROW\>
% RF{k}.ax \= axes('Position', pos3{1});
% for q\=1:length(meanLL\_fit)
% 
% a \= bar(q, meanLL\_fit(q));
% a.BarWidth \= .8;
% a.EdgeColor \= col;
% a.FaceColor \= col;
% a.FaceAlpha \= 0\.5;
% hold on;
% errorbar(q, meanLL\_fit(q), errLL\_fit(q), 'color', col, 'LineWidth', 2, 'CapSize', 0\);
% end
% ax \= gca;
% RF{k}.ax \= ax; 
% ax.XAxis.TickValues \= \[];
 
 %log\-likelihood for test part, bar graph
 RF{k}.pos \= pos3{2}; %\#ok\<\*AGROW\>
 RF{k}.ax \= axes('Position', pos3{2});
 for q\=\[1,2,3]
 
 a \= bar(q, meanLL\_test(q));
 a.BarWidth \= .8;
 a.EdgeColor \= col;
 a.FaceColor \= col;
 a.FaceAlpha \= 0\.5;
 hold on;
 errorbar(q, meanLL\_test(q), errLL\_test(q), 'color', col, 'LineWidth', 2, 'CapSize', 0\);
 end
 ax \= gca;
 RF{k}.ax \= ax;
 ax.XAxis.TickValues \= \[];
 ax.YAxis.Limits(1\) \= 0;
 
% RF{k}.pos \= pos4{1};
% RF{k}.ax \= axes('Position', pos4{1});
% plot(LL\_fit(3,:), LL\_fit(1,:), 'k.', LL\_fit(3,:), LL\_fit(3,:), 'k\-\-');
% ax \= gca;
% axis equal;
 
 RF{k\+1}.pos \= pos4{2};
 RF{k\+1}.ax \= axes('Position', pos4{2});
 plot(LL\_test(3,:), LL\_test(1,:), 'k.', LL\_test(3,:), LL\_test(3,:), 'k\-\-');
 ax \= gca;
 
 RF{k\+2}.pos \= pos4{3};
 RF{k\+2}.ax \= axes('Position', pos4{3});
 histogram(LL\_test(1,:)\-LL\_test(3,:), 15, 'FaceColor', 'k', 'FaceAlpha', 0\.8\);
 ax \= gca;
% axis equal;
% for q\=1:length(LLs)
% 
% a \= bar(q, LLs(q));
% a.BarWidth \= .8;
% a.EdgeColor \= col;
% a.FaceColor \= col;
% a.FaceAlpha \= 0\.5;
% hold on;
% errorbar(q, LLs(q), LLs\_err(q), 'color', col, 'LineWidth', 2, 'CapSize', 0\);
% end

% a.Parent.YLim \= \[ round(min(LLs), \-4\), round(max(LLs), \-4\)];
 
end
 
 
 
 
 


\-\-\-

\#\#\# File: fitMultiSensoryRate.m (ID: Variance Adaptation Paper.Rate Funs.6\)


function fitStruct \= fitMultiSensoryRate( btdvar, nBins, pdegree, multiType, nExpTest)
% function fitStruct \= fitMultiSensoryRate( btdvar, opstruct, multiType, nExpTest)

% very similar to fitRescaledRates.m, but this one is for 2\-stimulus data:
% calculates fit parameters and log\-likelihoods for 2\-stim rate function


% nBins: number of bins the stimulus is divided into for rate\-function plotting

% nExpTest is the number of experiments that are excluded from the fit

% multiType: {'ind', 'add', 'mult'} or just one of them, for r \= r(xo)\+r(xl), r\=r(cos(th)\*xo\+sin(th)\*xl) or r\=r(xo)\*r(xl) respectively

% pdegree: 1 or 2\.
% note: if pdegree\=1, add and mult are the same rate function

nexps \= max(btdvar(1\).fullensemble.expnum);
deltaT \= median(diff(btdvar(1\).fullensemble.eti));
theta0 \= deg2rad(45\);

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';



for i\=1:length(btdvar)
 varstruct \= btdvar(i);
 td(:,i) \= varstruct.turn.x\_conv;
 rd(:,i) \= varstruct.noturn.x\_conv;
 teti \= varstruct.turn.eti;
 reti \= varstruct.noturn.eti;
end

fitStruct.Rates \= turnRates2D(td, rd, deltaT, nBins);


if(pdegree\=\=1\)
 p0 \= @(xt, xr) \[mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
else
 p0 \= @(xt, xr) \[\-0\.05 mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
end




% fit all data to one rate function
% ratefun \= @(rateP, dat) exp(polyval(rateP, dat));
% nlogP \= @(p, xt, xr) \-sum(log(ratefun(p, xt) ) ) \+ sum(ratefun(p, xr)\*deltaT);
% fitfun \= @(p) nlogP(p, tH\_all, rH\_all) \+ nlogP(p, tL\_all, rL\_all);
% fp0 \= p0(\[tH\_all;tL\_all], \[rH\_all;rL\_all]);
% \[all.rP, all.nLL] \= fminunc(fitfun, fp0, op);


expInds \= nchoosek(1:nexps, nExpTest);

% if(size(expInds,1\)\>200\)
% n \= 200;
% else
n \= size(expInds, 1\);
% end

nLL\_test\_real \= \[];
array \= 1:size(expInds,1\);
for i\=1:n
 tic
 qq \= datasample(array, 1, 'Replace', false);
 array \= setdiff(array, qq);
 
 tnum \= btdvar(1\).turn.expnum;
 rnum \= btdvar(1\).noturn.expnum;
 
 ttest \= tnum \=\= expInds(qq,:);
 rtest \= rnum \=\= expInds(qq,:);
 fitExps \= setdiff(1:nexps, expInds(qq,:));
 tfit \= tnum \=\= fitExps;
 rfit \= rnum \=\= fitExps;
 
 tdata1 \= repmat(td(:,1\), \[1, size(tfit,2\)]);
 tdata2 \= repmat(td(:,2\), \[1, size(tfit,2\)]);
 rdata1 \= repmat(rd(:,1\), \[1, size(rfit,2\)]);
 rdata2 \= repmat(rd(:,2\), \[1, size(rfit,2\)]);
 tdata\_fit(:,1\) \= tdata1(tfit);
 tdata\_fit(:,2\) \= tdata2(tfit);
 rdata\_fit(:,1\) \= rdata1(rfit);
 rdata\_fit(:,2\) \= rdata2(rfit);
 tdata1 \= repmat(td(:,1\), \[1, size(ttest,2\)]);
 tdata2 \= repmat(td(:,2\), \[1, size(ttest,2\)]);
 rdata1 \= repmat(rd(:,1\), \[1, size(rtest,2\)]);
 rdata2 \= repmat(rd(:,2\), \[1, size(rtest,2\)]);
 tdata\_test(:,1\) \= tdata1(ttest);
 tdata\_test(:,2\) \= tdata2(ttest);
 rdata\_test(:,1\) \= rdata1(rtest);
 rdata\_test(:,2\) \= rdata2(rtest);
 
 nturns\_fit(i) \= size(tdata\_fit, 1\);
 nruns\_fit(i) \= size(rdata\_fit, 1\);
 meanR\_fit(i)\= nturns\_fit(i)/(nruns\_fit(i)\*deltaT);
 nturns\_test(i) \= size(tdata\_test, 1\);
 nruns\_test(i) \= size(rdata\_test, 1\);
 meanR\_test(i)\= nturns\_test(i)/(nruns\_test(i)\*deltaT);
 
 % null model (mean rate)
 nLL\_meanR\_fit(i) \= \-nturns\_fit(i)\*log(meanR\_fit(i)) \+ nruns\_fit(i)\*(meanR\_fit(i)\*deltaT);
 nLL\_meanR\_test(i) \= \-nturns\_test(i)\*log(meanR\_test(i)) \+ nruns\_test(i)\*(meanR\_test(i)\*deltaT);
 
 if(pdegree\=\=1\)
 ratefun \= @(rP, dat) exp( rP(1\) \* dat(:,1\) \+ rP(2\) \* dat(:,2\) \+ rP(3\) );
 fitfun \= ratefun;
 p01 \= p0(tdata\_fit(:,1\), rdata\_fit(:,1\));
 p02 \= p0(tdata\_fit(:,2\), rdata\_fit(:,2\));
 p0fit \= \[p01(1\) p02];
 nlogP \= @(p, xt, xr) \-sum(log(ratefun(p, xt) ) ) \+ sum(ratefun(p, xr)\*deltaT);
 
 nlogP\_fit \= @(p) nlogP(p, tdata\_fit, rdata\_fit);
 \[fp, nLL\_fit(i)] \= fminunc(nlogP\_fit, p0fit, op);
 nLL\_test(i) \= nlogP(fp, tdata\_test, rdata\_test) ;
 nLL\_all(i) \= nlogP(fp, \[tdata\_fit;tdata\_test], \[rdata\_fit; rdata\_test]);
 rateP{i} \= fp;
 if(imag(nLL\_test(i))\=\=0\)
 nLL\_test\_real \= \[nLL\_test\_real, nLL\_test(:,i)];
 end
 elseif(pdegree\=\=2\)
 for k\=1:length(multiType)
 if(strncmpi(multiType{k}, 'add', 3\))
 ratefun \= @(rP, dat) exp( rP(2\) \* (cos(rP(1\))\*dat(:,1\) \+ sin(rP(1\))\*dat(:,2\)).^2 \+ rP(3\) \* (cos(rP(1\))\*dat(:,1\) \+ sin(rP(1\))\*dat(:,2\)) \+ rP(4\) );
 p01 \= p0(tdata\_fit(:,1\), rdata\_fit(:,1\));
 p0fit \= \[theta0 0 0\.5 p01(end)];
 elseif(strncmpi(multiType{k}, 'multiply', 3\))
 ratefun \= @(rP, dat) exp( rP(1\)\*dat(:,1\).^2 \+ rP(2\)\*dat(:,1\) \+ rP(3\)\*dat(:,2\).^2 \+ rP(4\)\*dat(:,2\) \+ rP(5\) );
 p01 \= p0(tdata\_fit(:,1\), rdata\_fit(:,1\));
 p02 \= p0(tdata\_fit(:,2\), rdata\_fit(:,2\));
 p0fit \= \[p01(1:2\), p02];
 elseif(strncmpi(multiType{k}, 'independent', 3\))
 ratefun \= @(rP, dat) exp( rP(1\)\*dat(:,1\).^2 \+ rP(2\)\*dat(:,1\) \+ rP(3\) ) \+ exp( rP(4\)\*dat(:,2\).^2 \+ rP(5\)\*dat(:,2\) \+ rP(6\) );
 p01 \= p0(tdata\_fit(:,1\), rdata\_fit(:,1\));
 p02 \= p0(tdata\_fit(:,2\), rdata\_fit(:,2\));
 p0fit \= \[p01, p02];
 end
 
 fitfun{k} \= ratefun;
 
 nlogP \= @(p, xt, xr) \-sum(log(ratefun(p, xt) ) ) \+ sum(ratefun(p, xr)\*deltaT);
 
 nlogP\_fit \= @(p) nlogP(p, tdata\_fit, rdata\_fit);
 \[fp, nLL\_fit(k,i)] \= fminunc(nlogP\_fit, p0fit, op);
 nLL\_test(k, i) \= nlogP(fp, tdata\_test, rdata\_test) ;
 nLL\_all(k,i) \= nlogP(fp, \[tdata\_fit;tdata\_test], \[rdata\_fit; rdata\_test]);
 rateP{k}{i} \= fp;
 
 BIC\_fit(k,i) \= log(nturns\_fit(i)\+nruns\_fit(i))\*length(fp) \+ 2\*nLL\_fit(k,i);
 BIC\_test(k,i) \= log(nturns\_test(i)\+nruns\_test(i))\*length(fp) \+ 2\*nLL\_test(k,i);
 AIC(k,i) \= 2\*length(fp) \+ 2\*nLL\_fit(k,i);
 
 end
 if(any(imag(nLL\_test(:,i))\~\=0\)\=\=0\)
 nLL\_test\_real \= \[nLL\_test\_real, nLL\_test(:,i)];
 end
 end
 

 
 if(size(nLL\_test\_real, 2\)\>\=500\)
 break
 end
 
 clear tdata\_fit tdata\_test rdata\_fit rdata\_test
 toc
end

for k\=1:size(nLL\_fit, 1\)
 inds\_test{k} \= find(imag(nLL\_test(k,:))\=\=0\);
 ninds(k) \= length(inds\_test{k});
end
if( any( ninds \< size(expInds,1\)) )
 m \= find( ninds\=\=min(ninds) );
 realinds\_test \= inds\_test{m};
else
 realinds\_test \= inds\_test{1};
end


fitStruct.models \= multiType;
fitStruct.ratefuns \= fitfun;
fitStruct.meanR\_fit \= meanR\_fit;
fitStruct.meanR\_test \= meanR\_test;
fitStruct.nturns\_fit \= nturns\_fit;
fitStruct.nturns\_test \= nturns\_test;
fitStruct.nruns\_fit \= nruns\_fit;
fitStruct.nruns\_test \= nruns\_test;
fitStruct.nLL\_meanR\_fit \= nLL\_meanR\_fit;
fitStruct.nLL\_meanR\_test \= nLL\_meanR\_test;
fitStruct.nLL\_fit \= nLL\_fit;
fitStruct.nLL\_test \= nLL\_test;
fitStruct.nLL\_all \= nLL\_all;
fitStruct.BIC\_fit \= BIC\_fit;
fitStruct.BIC\_test \= BIC\_test;
fitStruct.AIC \= AIC;
fitStruct.rP \= rateP;
fitStruct.realinds\_test \= realinds\_test;


end

function rf \= turnRates2D(td, rd, deltaT, nBins)

lx(:,1\) \= linspace(\-3\*std(rd(:,1\)), 3\*std(rd(:,1\)), nBins);
lx(:,2\) \= linspace(\-3\*std(rd(:,2\)), 3\*std(rd(:,2\)), nBins);
\[lxx, lxy] \= meshgrid(lx(:,1\), lx(:,2\));
lxdata \= \[lxx(:) lxy(:)];

h \= makeIm(rd(:,1\), rd(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
ht \= makeIm(td(:,1\), td(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
rhist \= reshape(h, size(lxx));
thist \= reshape(ht, size(lxx));

rf.lx \= lx;
rf.rhist \= rhist;
rf.thist \= thist;
rf.rate(:,1\) \= 1/deltaT \* sum(thist, 1\)./sum(rhist, 1\);
rf.rate\_eb(:,1\) \= 1/deltaT \* sqrt(sum(thist, 1\))./sum(rhist, 1\);
rf.rate(:,2\) \= 1/deltaT \* sum(thist, 2\)./sum(rhist, 2\);
rf.rate\_eb(:,2\) \= 1/deltaT \* sqrt(sum(thist, 2\))./sum(rhist, 2\);


end

\-\-\-

\#\#\# File: fitRate.m (ID: Variance Adaptation Paper.Rate Funs.7\)

function \[fitParams, logP, logP95] \= fitRate(ratefun, x0, turndata, rundata, dt, nBins, histaxis)
%function \[fitParams, logP, logP95] \= fitRate(ratefun, x0, turndata, rundata, histaxis)
 

 
 nstim \= size(turndata, 1\);
 if(nstim\>2\)
 nstim \= size(turndata, 2\);
 end
 
 fitfun \= @(x) \-sum(log(max(ratefun(x, turndata), 1E\-100\))) \+ dt\*sum(max(0,ratefun(x, rundata)));

 
 op \= optimset('fmincon');
 op.Algorithm \= 'interior\-point';
 op.MaxFunEvals \= 1e4;
 op.MaxIter \= 1e4;
 %op.LargeScale \= 'off';
 problem.solver \= 'fmincon';
 problem.options \= op;
 
 problem.x0 \= x0;
 if(nstim\=\=1\) %1stim
 if(length(x0\)\=\=2\)
 problem.lb \= \[0 \-Inf];
 problem.ub \= \[10 Inf];
 else
 problem.lb \= \[\-5 0 \-Inf];
 problem.ub \= \[5 10 Inf];
 end
 elseif(nstim\=\=2\) %2stim
 if(length(x0\)\=\=2\)
 problem.lb \= \[0 \-Inf];
 problem.ub \= \[5 Inf]; 
 elseif(length(x0\)\=\=3\)
 problem.lb \= \[0 0 \-Inf];
 problem.ub \= \[1 1 Inf];
 else
 problem.lb \= \[\-1 \-1 \-1 0 0 \-Inf];
 problem.ub \= \[1 1 1 3 3 Inf];
 end
 end

 problem.objective \= fitfun;
 fitParams \= fmincon(problem);
 logP \= fitfun(fitParams);
 
% ratefunOneParam \= @(x, xdata) ratefun(\[x(1\), fitParams(2\)], xdata);
% fitfunOneParam \= @(x) \-sum(log(max(ratefunOneParam(x, turndata), 1E\-100\))) \+ dt\*sum(max(0,ratefunOneParam(x, rundata)));
% 
% edge \= 3\.84;
% xup \= linspace(fitParams(1\), fitParams(1\)\+1, 1e3\);
% xdown \= linspace(fitParams(1\)\-3, fitParams(1\), 1e3\);
% xx \= \[xdown xup];
% 
% 
% for j\=1:length(xx)
% ratio(j) \= \-2\*log(fitfunOneParam(xx(j)) / fitfunOneParam(fitParams(1\)));
% end
% indup \= find(ratio(end/2\+1:end)\<\-edge, 1, 'first');
% inddown \= find(ratio(1:end/2\)\<\-edge, 1, 'last');
% edgeParams(1\) \= xup(indup);
% edgeParams(2\) \= xdown(inddown);
% logP95 \= \[fitfunOneParam(edgeParams(1\)) fitfunOneParam(edgeParams(2\))];
 
if(nstim\=\=1\)
 if (existsAndDefault('histaxis', \[]))
 ht \= histcounts(turndata, binEdgesFromCenters(histaxis));
 hr \= histcounts(rundata, binEdgesFromCenters(histaxis));
 r \= ht./hr \* 60/dt;
 eb \= sqrt(ht)./hr \* 60/dt;
 errorbar (histaxis, r, eb, 'ko');
 hold on;
 plot (histaxis, ratefun(fitParams, histaxis) \*60\);
% plot(histaxis, 60\*ratefunOneParam(edgeParams(1\), histaxis), histaxis, 60\*ratefunOneParam(edgeParams(2\), histaxis));
 hold off
 end
elseif(nstim\=\=2\)
 if(size(turndata,2\)\=\=size(rundata,2\)) 
 adata \= \[turndata; rundata];
 else
 adata \= \[turndata, rundata];
 end
 
 if (existsAndDefault('histaxis', \[]))
 lx(:,1\) \= linspace(percentile(adata(:,1\),0\.01\), percentile(adata(:,1\),.99\), nBins);
 lx(:,2\) \= linspace(percentile(adata(:,2\),0\.01\), percentile(adata(:,2\),.99\), nBins);
 \[lxx, lxy] \= meshgrid(lx(:,1\), lx(:,2\));
 lxdata \= \[lxx(:) lxy(:)];
 h \= makeIm(adata(:,1\), adata(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
 ht \= makeIm(turndata(:,1\), turndata(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
 hist\_all \= reshape(h, size(lxx));
 hist\_turn \= reshape(ht, size(lxx));
 rate(:,1\) \= 60/dt \* sum(hist\_turn, 1\)./sum(hist\_all, 1\);
 rate\_eb(:,1\) \= 60/dt \* sqrt(sum(hist\_turn, 1\))./sum(hist\_all, 1\);
 rate(:,2\) \= 60/dt \* sum(hist\_turn, 2\)./sum(hist\_all, 2\);
 rate\_eb(:,2\) \= 60/dt \* sqrt(sum(hist\_turn, 2\))./sum(hist\_all, 2\);
 
 for k\=1:2
 errorbar (lx(:,k), rate(:,k), rate\_eb(:,k), 'marker', 'o', 'linestyle', '\-\-');
 hold on;
 rateFit \= reshape(ratefun(fitParams, lxdata), size(lxx));
 plot(lx(:,k), 60 \* sum(rateFit.\*hist\_all, k)./sum(hist\_all, k));
 end
 end
end
end
\-\-\-

\#\#\# File: fitLowHighRates.m (ID: Variance Adaptation Paper.Rate Funs.8\)

function \[ fP, LL ] \= fitLowHighRates( lowvar, highvar, opstruct, degree, rescale\_type )
%function \[ fP, LL ] \= fitLowHighRates( lowvar, highvar, opstruct, degree, rescale\_type )

% fit one\-stimulus data to rescaling rate function
% rescale\_type \= {'input', 'output', 'output\_rect'} or any combination of those
% degree: rate function polynomial degree in the exponential: degree\=1: r\=exp(ax\+b) or degree\=2: r\=exp(ax^2\+bx\+c)

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

nBins \= opstruct.numLxBins;
deltaT \= median(diff(lowvar.var.fullensemble.eti));

tetiH \= highvar.var.turn.eti;
tetiL \= lowvar.var.turn.eti;
retiH \= highvar.var.noturn.eti;
retiL \= lowvar.var.noturn.eti;

tH \= tetiH \>\= min(opstruct.timeRange) \& tetiH \< max(opstruct.timeRange);
tL \= tetiL \>\= min(opstruct.timeRange) \& tetiL \< max(opstruct.timeRange);
rH \= retiH \>\= min(opstruct.timeRange) \& retiH \< max(opstruct.timeRange);
rL \= retiL \>\= min(opstruct.timeRange) \& retiL \< max(opstruct.timeRange);

tdatH \= highvar.var.turn.x\_conv(tH);
tdatL \= lowvar.var.turn.x\_conv(tL);
rdatH \= highvar.var.noturn.x\_conv(rH);
rdatL \= lowvar.var.noturn.x\_conv(rL);

rates.lxL \= linspace(\-3\*std(rdatL), 3\*std(rdatL), nBins);
rates.lxH \= linspace(\-3\*std(rdatH), 3\*std(rdatH), nBins);
rates.lx\_all \= linspace(\-3\*std(\[rdatL; rdatH]), 3\*std(\[rdatL; rdatH]), nBins);
ntL \= histcounts(tdatL, binEdgesFromCenters(rates.lxL));
nrL \= histcounts(rdatL, binEdgesFromCenters(rates.lxL));
ntH \= histcounts(tdatH, binEdgesFromCenters(rates.lxH));
nrH \= histcounts(rdatH, binEdgesFromCenters(rates.lxH));
nt\_all \= histcounts(\[tdatL; tdatH], binEdgesFromCenters(rates.lx\_all));
nr\_all \= histcounts(\[rdatL; rdatH], binEdgesFromCenters(rates.lx\_all));
rates.rL \= 1\./deltaT \*ntL./nrL;
rates.rH \= 1\./deltaT \*ntH./nrH;
rates.rall \= 1\./deltaT\*nt\_all./nr\_all;


if(degree\=\=1\)
 p0 \= @(xt, xr) \[mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
else
 p0 \= @(xt, xr) \[\-0\.05 mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
end




 
 for k\=1:length(rescale\_type)
 
 if(strcmpi(rescale\_type{k}, 'input'))
 ratefun \= @(alpha, rateP, dat) exp(polyval(rateP, alpha.\*dat));
 elseif(strcmpi(rescale\_type{k}, 'output\_rect'))
 ratefun \= @(alpha, rateP, dat) alpha.\*(exp(polyval(rateP, dat)) \- exp(rateP(end))) \+ exp(rateP(end));
 elseif(strcmpi(rescale\_type{k}, 'output'))
 ratefun \= @(alpha, rateP, dat) alpha.\*( exp(polyval(rateP, dat)) );
 end
 
 rates.fitfun{k} \= ratefun;
 
 alpha\_base \= 1;
 nlogP \= @(p, xt, xr) \-sum(log(ratefun(alpha\_base, p, xt) ) ) \+ sum(ratefun(alpha\_base, p, xr)\*deltaT);
 nlogP\_resc \= @(p, xt, xr) \-sum(log(ratefun(p(end), p(1:end\-1\), xt) ) ) \+ sum(ratefun(p(end), p(1:end\-1\), xr)\*deltaT);
 
 
 % fit High var. part first
 tic
 p0H \= p0(tdatH, rdatH);
 nlogPH \= @(p) nlogP(p, tdatH, rdatH); % r(xH) \= exp( a\*x \+ b);
 \[fP.fpH, \~] \= fminunc(nlogPH, p0H, op); % p \= \[a b];
 toc
 
 %all \- rescale Low Data
 tic
 nlogP\_all \= @(p) nlogP\_resc(p, tdatL, rdatL) \+ nlogP(p(1:end\-1\), tdatH, rdatH);
 % nlogP\_all\_fit \= @(p) nlogP\_all(p, tindsLfit, tindsHfit, rindsLfit, rindsHfit);
 
 % r(xH) \= exp(a\*xH \+ b); r(xL) \= exp( a\* (alphaL\*xL) \+ b );
 \[fP.rescL, LL.rescL(k)] \= fminunc(nlogP\_all, \[fP.fpH, 1], op); % p \= \[a, b, alphaL];
 toc
 
 % fit nlogP to a quadratic function, and find the confidence interval for alphaL
 nLLfit \= @(x, xdata) x(1\)\*(xdata\-x(2\)).^2 \+ x(3\);
 alphas \= linspace(1, 2\.5, 30\);
 ll \= @(alpha) nlogP\_all(\[fP.rescL(1:end\-1\), alpha]);
 for i\=1:length(alphas), lla(i) \= ll(alphas(i)); end
 aa \= lsqcurvefit(nLLfit, \[1, fP.rescL(1\), \-min(lla)], alphas, \-lla);
 fP.s\_alphaL \= 1\.645/sqrt(\-2\*aa(1\)); % \-\-\- 90 percent confidence interval for alpha ( eqn. (2\) in http://sites.stat.psu.edu/\~abs12/stat504/Lecture/lec3\_4up.pdf )
 
 return
 
 % fit low var. part first
 p0L \= p0(tdatL, rdatL);
 nlogPL \= @(p) nlogP(p, tdatL, rdatL);
 \[fP.fpL, \~] \= fminunc(nlogPL, p0L, op);
 
 % all \- Rescale High Data
 
 % r(xH) \= exp(a\*(alphaH\*xH) \+ b); r(xL) \= exp( a\*xL \+ b );
 nlogP\_all \= @(p, tlow, thigh, rlow, rhigh) nlogP\_resc(p, tdatH(thigh), rdatH(rhigh)) \+ nlogP(p(1:end\-1\), tdatL(tlow), rdatL(rlow));
 nlogP\_all\_fit \= @(p) nlogP\_all(p, tindsLfit, tindsHfit, rindsLfit, rindsHfit);
 \[fP.rescH, LL.rescH(k)] \= fminunc(nlogP\_all\_fit, \[fP.fpL, 1], op);

 
 %all no rescaling, sep. rates
 % nlogP\_noresc \= @(p) nlogP(p(1:degree\+1\), tdata(tL), rdata(rL)) \+ nlogP(p(degree\+2:end), tdata(tH), rdata(rH));
 % \[\~, LL0] \= fminunc(nlogP\_noresc, \[fpL fpH], op);
 
 end
 
end





\-\-\-

\#\#\# File: fitCorrelatedRates.m (ID: Variance Adaptation Paper.Rate Funs.9\)

function \[ fP, LL, rates, fitRates, varHL] \= fitCorrelatedRates( varstruct, opstruct, degree, coordinates )
%function \[ fP, LL, rates, fitRates, varHL] \= fitCorrelatedRates( varstruct, opstruct, degree, coordinates )

% % outputs:
% fP are fit params for different rate models
% LL are log\-likelihoods for different rate models
% rates are the actual rate functions
% fitRates are the fit functions for different models
% varHL are the var structures containing turn and run data

% inputs:
% degree \= 1 or 2 for rate functions being exponentials of a 1st or 2nd degree polynomial
% coordinates: 'OL' fits different rate functions in odor\-light space
% 'UV' fits different rate functions in u\-v space (u\=cos(th)\*xo\+sin(th)\*xl)



theta0 \= deg2rad(45\); % initial guess

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

nBins \= opstruct.numLxBins;
deltaT \= median(diff(varstruct(1\).fullensemble.eti));


for i\=1:length(varstruct)
 btdvar \= varstruct(i);
 tdata(i,:) \= btdvar.turn.x\_conv;
 rdata(i,:) \= btdvar.noturn.x\_conv;
 tton \= btdvar.turn.ton;
 ttoff \= btdvar.turn.toff;
 teti \= btdvar.turn.eti;
 rton \= btdvar.noturn.ton;
 rtoff \= btdvar.noturn.toff;
 reti \= btdvar.noturn.eti;
end

tH \= tton \> opstruct.adaptationTime \& tton \< ttoff \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
tL \= ttoff \> opstruct.adaptationTime \& ttoff \< tton \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
tU \= tton \> 0 \& tton \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
tD \= ttoff \> 0 \& ttoff \< opstruct.adaptationTime \& teti \>\= min(opstruct.timeRange) \& teti \< max(opstruct.timeRange);
rH \= rton \> opstruct.adaptationTime \& rton \< rtoff \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
rL \= rtoff \> opstruct.adaptationTime \& rtoff \< rton \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
rU \= rton \> 0 \& rton \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);
rD \= rtoff \> 0 \& rtoff \< opstruct.adaptationTime \& reti \>\= min(opstruct.timeRange) \& reti \< max(opstruct.timeRange);

for i\=1:length(varstruct)
 tdatH(i,:) \= tdata(i,tH);
 tdatL(i,:) \= tdata(i,tL);
 rdatH(i,:) \= rdata(i,rH);
 rdatL(i,:) \= rdata(i,rL);
end

if(degree\=\=1\)
 p0 \= @(xt, xr) \[mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
else
 p0 \= @(xt, xr) \[\-0\.05 mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];
end

if(strcmpi(coordinates, 'OL'))
 
 rate \= @(rateP, dat) exp(polyval(rateP, dat));
 rate\_resc \= @(a, rateP, dat) exp(polyval(rateP, a.\*dat));
 rate2d \= @(rP, dat) exp( rP(1\) \* dat(1,:) \+ rP(2\) \* dat(2,:) \+ rP(3\) );
 
 nlogP \= @(p, xt, xr) \-sum(log(rate(p, xt) )) \+ sum(rate(p, xr)\*deltaT);
 nlogP2d \= @(p, xt, xr) \-sum(log(rate2d(p, xt))) \+ sum(rate2d(p, xr)\*deltaT);
 
 poH \= p0(tdatH(1,:), rdatH(1,:));
 plH \= p0(tdatH(2,:), rdatH(2,:));
 poL \= p0(tdatL(1,:), rdatL(1,:));
 plL \= p0(tdatL(2,:), rdatL(2,:));
 
 % rH(o,l) \= boH \* xoH \+ blH \* xlH \+ c;
 ff \= @(p) nlogP2d(p, tdatH, rdatH); % p \= \[boH, blH, c]
 ff0 \= \[poH(1\) plH];
 tic
 \[fP.olH, LL.olH] \= fminunc(ff, ff0, op);
 toc
 
 % rL(o,l) \= boL \* xoL \+ blL \* xlH \+ c;
 ff \= @(p) nlogP2d(p, tdatL, rdatL); % p \= \[boL, blL, c]
 ff0 \= \[poL(1\) plL];
 ff0 \= fP.olH;
 tic
 \[fP.olL, LL.olL] \= fminunc(ff, ff0, op);
 toc
 
 % rH(o,l) \= boH \* xoH \+ blH \* xlH \+ c; rL(o,l) \= boL \* xoL \+ blL \* xlH \+ c;
 ff \= @(p) nlogP2d( \[p(1:2\) p(end)], tdatH, rdatH) \+ nlogP2d( p(3:end), tdatL, rdatL); % p \= \[boH, blH, boL, blL, c]
 ff0 \= \[fP.olH(1:2\) fP.olL];
 tic
 \[fP.ol, LL.ol] \= fminunc(ff, ff0, op);
 toc
 
 
 
elseif(strcmpi(coordinates, 'UV'))
 UVdat \= @(xdat, theta) \[cos(theta)\*xdat(1,:) \+ sin(theta)\*xdat(2,:); \-sin(theta)\*xdat(1,:) \+ cos(theta)\*xdat(2,:)];
 Udat \= @(xdat, theta) cos(theta)\*xdat(1,:) \+ sin(theta)\*xdat(2,:);
 Vdat \= @(xdat, theta) \-sin(theta)\*xdat(1,:) \+ cos(theta)\*xdat(2,:);
 
 rate \= @(rateP, dat) exp(polyval(rateP, dat));
 rate\_resc \= @(a, rateP, dat) exp(polyval(rateP, a.\*dat));
 ratefunUV \= @(theta, rPu, rPv, tdat) exp(polyval(rPu, Udat(tdat, theta))).\*exp(rPv\*Vdat(tdat, theta));
 ratefunUV\_resc \= @(aU, aV, theta, rPu, rPv, dat) exp(polyval(rPu, aU.\*Udat(dat, theta))).\*exp(rPv\*aV.\*Vdat(dat, theta));
 
 nlogPU \= @(p, xt, xr) \-sum(log(rate(p(2:end), Udat(xt, p(1\)) ) )) \+ sum(rate(p(2:end), Udat(xr, p(1\)))\*deltaT);
 nlogPV \= @(p, xt, xr) \-sum(log(rate(p(2:end), Vdat(xt, p(1\)) ) )) \+ sum(rate(p(2:end), Vdat(xr, p(1\)))\*deltaT);
 nlogPU\_resc \= @(p, xt, xr) \-sum(log(rate\_resc(p(1\), p(3:end), Udat(xt, p(2\)) ) )) \+ sum(rate\_resc(p(1\), p(3:end), Udat(xr, p(2\)))\*deltaT);
 nlogPV\_resc \= @(p, xt, xr) \-sum(log(rate\_resc(p(1\), p(3:end), Vdat(xt, p(2\)) ) )) \+ sum(rate\_resc(p(1\), p(3:end), Vdat(xr, p(2\)))\*deltaT);
 nlogPuv \= @(p, xt, xr) \-sum(log(ratefunUV(p(1\), p(2:end\-1\), p(end), xt))) \+ sum(ratefunUV(p(1\), p(2:end\-1\), p(end), xr)\*deltaT);
 nlogPuv\_resc \= @(p, xt, xr) \-sum(log(ratefunUV\_resc(p(1\), p(2\), p(3\), p(4:end\-1\), p(end), xt))) \+ sum(ratefunUV\_resc(p(1\), p(2\), p(3\), p(4:end\-1\), p(end), xr)\*deltaT);
 
 
 tUH \= Udat(tdatH, theta0\);
 rUH \= Udat(rdatH, theta0\);
 tUL \= Udat(tdatL, theta0\);
 rUL \= Udat(rdatL, theta0\);
 tVH \= Vdat(tdatH, theta0\);
 rVH \= Vdat(rdatH, theta0\);
 
 
 puH \= p0(tUH, rUH);
 pvH \= p0(tVH, rVH);
 puL \= p0(tUL, rUL);
 puAll \= p0(\[tUH tUL], \[rUH rUL]);
 
 % 1: r(uH) \= a\*u\_H(theta) \+ b
 tic
 ff \= @(p) nlogPU(p, tdatH, rdatH); % p \= \[theta, a, b]
 ff0 \= \[theta0 puH];
 \[fP.uH, LL.uH] \= fminunc(ff, ff0, op);
 toc
 
 theta \= fP.uH(1\);
 rates.u\_H \= UVrates(tdatH, rdatH, theta, deltaT, nBins, 1\);
 fitRates.u\_H \= rate( fP.uH(2:end), rates.u\_H.lx );
 
 % 2: r(uL) \= a\*u\_L(theta) \+ b
 tic
 ff \= @(p) nlogPU(p, tdatL, rdatL); % p \= \[theta, a, b]
 ff0 \= \[theta0 puL];
 \[fP.uL, LL.uL] \= fminunc(ff, ff0, op);
 toc
 theta \= fP.uL(1\);
 rates.u\_L \= UVrates(tdatL, rdatL, theta, deltaT, nBins, 1\);
 fitRates.u\_L \= rate( fP.uL(2:end), rates.u\_L.lx );
 
 % 3: fit theta\_low with fixed rateP(high)
 tic
 ff \= @(p) nlogPU(\[p, fP.uH(2:end)], tdatL, rdatL); % p \= \[theta, a, b]
 ff0 \= \[theta0];
 \[fP.thetaL, LL.uL\_fixedrateH] \= fminunc(ff, ff0, op);
 toc
 
 
 % 4: r(uH) \= a \* uH(theta) \+ b; r(uL) \= a \* uL(theta) \+ b;
 ff \= @(p) nlogPU(p, tdatH, rdatH) \+ nlogPU(p, tdatL, rdatL); % p \= \[theta, a, b]
 ff0 \= \[fP.uH];
 tic
 \[fP.u\_noresc, LL.u\_noresc] \= fminunc(ff, ff0, op);
 toc

 % 5: r(uH) \= a \* uH(thetaH) \+ b; r(uL) \= a \* uL(thetaL) \+ b;
% ff \= @(p) nlogPU(\[p(1\) p(3:end)], tdatH, rdatH) \+ nlogPU(\[p(2\) p(3:end)], tdatL, rdatL);
% ff0 \= \[theta0 theta0 fP.u\_noresc(2:end)];
% tic
% \[fP.u\_theta, LL.u\_theta] \= fminunc(ff, ff0, op); % p \= \[thetaH, thetaL, a, b]
% toc
 
 % r(uH) \= aH \* uH(theta) \+ b; r(uL) \= aL \* uL(theta)) \+ b; \- same as resc. model below
 % ff \= @(p) nlogPU(\[p(1\) p(2\) p(end)], tdatH, rdatH) \+ nlogPU(\[p(1\) p(3\) p(end)], tdatL, rdatL);
 % ff0 \= \[theta0 1 1 fP.u\_noresc(end)];
 % tic
 % \[fP.u\_lin, LL.u\_lin] \= fminunc(ff, ff0, op); % p \= \[theta, aH, aL, b]
 % toc
 
 % 5: r(u) \= lambda(alpha\_u \* u)
 % r(uH) \= a \* uH(theta) \+ b; r(uL) \= a \* ( alphaU \* uL(theta)) \+ b;
 ff \= @(p) nlogPU(p(2:end), tdatH, rdatH) \+ nlogPU\_resc(p, tdatL, rdatL);
 ff0 \= \[1 fP.u\_noresc];
 tic
 \[fP.u\_resc, LL.u\_resc] \= fminunc(ff, ff0, op); % params \= \[alphaU, theta, a, b]
 toc
 theta \= fP.u\_resc(2\);
 rates.uH\_resc \= UVrates(tdatH, rdatH, theta, deltaT, nBins, 1\);
 rates.uL\_resc \= UVrates(tdatL, rdatL, theta, deltaT, nBins, 1\);
 fitRates.uH\_resc \= rate\_resc( 1, fP.u\_resc(3:end), rates.uH\_resc.lx );
 fitRates.uL\_resc \= rate\_resc( fP.u\_resc(1\), fP.u\_resc(3:end), rates.uL\_resc.lx );
 
 % 6: r(vH) \= a \* vH(theta) \+ b; r(vL) \= a \* ( alphaV \* vL(theta)) \+ b;
 ff \= @(p) nlogPV(p(2:end), tdatH, rdatH) \+ nlogPV\_resc(p, tdatL, rdatL);
 ff0 \= \[1 theta0 pvH];
 tic
 \[fP.v\_resc, LL.v\_resc] \= fminunc(ff, ff0, op); % p \= \[alphaV, theta, a, b]
 toc
 
 % r(uH) \= a \* uH(thetaH) \+ b; r(uL) \= a \* ( alpha\_L \* uL(thetaL)) \+ b;
% ff \= @(p) nlogPU(\[p(1\) p(4:end)], tdatH, rdatH) \+ nlogPU\_resc(p(2:end), tdatL, rdatL);
% ff0 \= \[theta0 fP.u\_resc];
% tic
% \[fP.u\_theta\_resc, LL.u\_theta\_resc] \= fminunc(ff, ff0, op); % p \= \[thetaH, alphaU, thetaL, a, b]
% toc
 

% 7: r(u,v) \= lambda(u, v) with fixed theta:
% r(uH,vH) \= a \* u\_H(theta) \+ b \+ c \* v\_H(theta); r(uL,vL) \= a \* u\_L(theta) \+ b \+ c \* v\_L(theta)
theta \= fP.u\_resc(2\);
ff \= @(p) nlogPuv\_resc(\[1 1 theta p(1:end)], tdatH, rdatH) \+ nlogPuv\_resc(\[1 1 theta p(1:end)], tdatL, rdatL);
ff0 \= \[fP.u\_resc(3:end) fP.v\_resc(3:end\-1\)];
tic
\[fP.uv, LL.uv] \= fminunc(ff, ff0, op); % params \= \[a, b, c] 
toc

% 8: r(u,v) \= lambda(alpha\_u\*u, alpha\_v\*v) with fixed theta:
% r(uH,vH) \= a \* u\_H(theta) \+ b \* v\_H(theta) \+ c ; r(uL,vL) \= alpha\_u \*(a \* u\_L(theta)) \+ alpha\_v \*(b \* v\_L(theta))\+ c
theta \= fP.u\_resc(2\);
ff \= @(p) nlogPU(\[theta p(3:3\+degree\-1\) p(end)], tdatH, rdatH) \+ nlogPU\_resc(\[p(1\) theta p(3:3\+degree\-1\) p(end)], tdatL, rdatL) \+ nlogPV(\[theta p(3\+degree:3\+2\*degree\-1\) p(end)], tdatH, rdatH) \+ nlogPV\_resc(\[p(2\) theta p(3\+degree:3\+2\*degree\-1\) p(end)], tdatL, rdatL);
ff0 \= \[fP.u\_resc(1\) 1 fP.u\_resc(3:end\-1\) fP.v\_resc(3:end)];
tic
\[fP.uv\_resc\_fixedTheta, LL.uv\_resc\_fixedTheta] \= fminunc(ff, ff0, op); % params \= \[alpha\_u, alpha\_v, a, b, c] 
toc

end
end

function rf \= UVrates(tdat, rdat, theta, deltaT, nBins, stimNum)

if(\~isempty(stimNum))
 if(stimNum \=\= 1\)
 NewDat \= @(xdat, theta) cos(theta)\*xdat(1,:) \+ sin(theta)\*xdat(2,:);
 elseif(stimNum\=\=2\)
 NewDat \= @(xdat, theta) \-sin(theta)\*xdat(1,:) \+ cos(theta)\*xdat(2,:);
 end
 
 xt \= NewDat(tdat, theta);
 xr \= NewDat(rdat, theta);
 lx \= linspace(\-3\*std(xr), 3\*std(xr), nBins);
 
 
 nt \= histcounts(xt, binEdgesFromCenters(lx));
 nr \= histcounts(xr, binEdgesFromCenters(lx));
 
 rf.lx \= lx;
 rf.rate \= 1/deltaT \* nt ./ nr;
 rf.rate\_eb \= 1/deltaT \* sqrt(nt) ./ nr;
 
else
 UVdat \= @(xdat, theta) \[cos(theta)\*xdat(1,:) \+ sin(theta)\*xdat(2,:); \-sin(theta)\*xdat(1,:) \+ cos(theta)\*xdat(2,:)];
 
 xt \= UVdat(tdat, theta);
 xr \= UVdat(rdat, theta);
 td(:,1\) \= xt(1,:);
 td(:,2\) \= xt(2,:);
 rd(:,1\) \= xr(1,:);
 rd(:,2\) \= xr(2,:);
 lx(:,1\) \= linspace(\-3\*std(rd(:,1\)), 3\*std(rd(:,1\)), nBins);
 lx(:,2\) \= linspace(\-3\*std(rd(:,2\)), 3\*std(rd(:,2\)), nBins);
 \[lxx, lxy] \= meshgrid(lx(:,1\), lx(:,2\));
 lxdata \= \[lxx(:) lxy(:)];
 
 
 
 h \= makeIm(rd(:,1\), rd(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
 ht \= makeIm(td(:,1\), td(:,2\), binEdgesFromCenters(lx(:,1\)), binEdgesFromCenters(lx(:,2\)));
 rhist \= reshape(h, size(lxx));
 thist \= reshape(ht, size(lxx));
 
 rf.lx \= lx';
 rf.rate(1,:) \= 1/deltaT \* sum(thist, 1\)./sum(rhist, 1\);
 rf.rate\_eb(1,:) \= 1/deltaT \* sqrt(sum(thist, 1\))./sum(rhist, 1\);
 rf.rate(2,:) \= 1/deltaT \* sum(thist, 2\)./sum(rhist, 2\);
 rf.rate\_eb(2,:) \= 1/deltaT \* sqrt(sum(thist, 2\))./sum(rhist, 2\);
end
end

\-\-\-

\#\#\# File: RescaleXtoMatchRates.m (ID: Variance Adaptation Paper.Rate Funs.10\)

clear rates\_err

nBins \= 5;
varL \= or42a\_R2\.var;
varH \= or42a\_R8\.var;

lxs \= @(alpha, varstruct) linspace(\-3\*std(alpha\*varstruct.noturn.x\_conv), 3\*std(alpha\*varstruct.noturn.x\_conv), nBins);

alphas \= linspace(1, 2, 30\);

lxL \= lxs(1, varL);
lxH \= lxs(1, varH);
\[trL, trL\_eb] \= turnRate(1, varL, nBins);
\[trH, trH\_eb] \= turnRate(1, varH, nBins);

for i\=1:length(alphas)
 tic
 a \= alphas(i);
 
 lxL\_s{i} \= lxs(a, varL);
 trL\_s{i} \= turnRate(a, varL, nBins);
 
 if(lxL\_s{i}(end)\>lxH(end))
 rates\_err(i) \= immse(trH, interp1(lxL\_s{i}, trL\_s{i}, lxH));
 else
 rates\_err(i) \= immse(trL\_s{i}, interp1(lxH, trH, lxL\_s{i}));
 end
 toc 
end


% op \= optimoptions('fmincon');
% op.Display \= 'off';
% op.Algorithm \= 'quasi\-newton';
% problem.options \= op;
% problem.solver \= 'fmincon';
% problem.objective \= dist;
% problem.x0 \= 1;
% problem.lb \= .6;
% problem.ub \= 1\.4;


function \[rate, rate\_eb] \= turnRate(alpha, varstruct, nBins)

deltaT \= median(diff(varstruct.fullensemble.eti));

xt \= alpha \* varstruct.turn.x\_conv;
xr \= alpha \* varstruct.noturn.x\_conv;

lx \= linspace(\-3\*std(xr), 3\*std(xr), nBins);

nt \= histcounts(xt, binEdgesFromCenters(lx));
nr \= histcounts(xr, binEdgesFromCenters(lx));

rate \= 1/deltaT \* nt ./ nr;
rate\_eb \= 1/deltaT \* sqrt(nt) ./ nr;

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

nlogp \= @(p) \-sum(polyval(p, xt)) \+ deltaT\*sum(exp(polyval(p,xr)));
p0 \= \[mean(xt)/var(xr) log(length(xt)/(length(xr)\*deltaT))];

fP \= fminunc(nlogp, p0, op);
rate \= exp(polyval(fP, lx));

end


\-\-\-

\#\#\# Folder: Variance Adaptation Paper/Bayesian Estimator (ID: Variance Adaptation Paper.Bayesian Estimator)

\-\-\-

\#\#\# File: fit2DLL.m (ID: Variance Adaptation Paper.Bayesian Estimator.1\)



clear zz zz\_big zz\_42a ZZ zz\_berlin Z\_42a Z\_berlin dts taus dts2 taus2
new\_axes \= 0; % if you want to use other dt,tau axes and interpolate

%LLs \= \[LogLBerlin, LogL42a\_fine];
LLs \= \[LogL\_Berlin, LogL\_42a];

for k\=1:length(LLs)

LLstruct \= LLs(k);
dts{k} \= LLstruct.dts;
taus{k} \= LLstruct.taus;

nll{k} \= LLstruct.LL.logP\_fitR;
zz{k} \= \-nll{k} \+ min(min(nll{k}));

a1 \= \[.05 .1:.1:.3];
a3 \= \[1\.2 2 3];
a2 \= .5:.1:1;
dts\_new \= \[a2];
taus\_new \= taus{k};

\[lxx, lxy] \= meshgrid(taus{k}, dts{k});
\[lxx2, lxy2] \= meshgrid(taus\_new, dts\_new);
lxdata \= \[lxx(:) lxy(:)];

lxdata2 \= \[lxx2(:) lxy2(:)];
nll\_new{k} \= interp2(lxx, lxy, nll{k}, lxx2, lxy2, 'spline');
zz\_new{k} \= \-nll\_new{k} \+ min(min(nll\_new{k}));
end

if(new\_axes)
 zz\_42a \= zz\_new{2};
 zz\_berlin \= zz\_new{1};
 tauaxis\_42a \= taus\_new;
 tauaxis\_ber \= taus\_new;
 dtaxis\_42a \= dts\_new;
 dtaxis\_ber \= dts\_new;
 ldata \= lxdata2;
 ldata2 \= lxx2;
else
 zz\_42a \= zz{2};
 zz\_berlin \= zz{1};
 tauaxis\_42a \= taus{2};
 dtaxis\_42a \= dts{2};
 tauaxis\_ber \= taus{1};
 dtaxis\_ber \= dts{1};
 ldata \= lxdata;
 ldata2 \= lxx;
end
 

Z\_42a \= zz\_42a;
Z\_berlin \= zz\_berlin;

% fit log\-likelihood to a quadratic (to the log of a 2\-dim normal distribution)
% fitfun \=\= C \+ log( normPDF(x,y) )

fitfun \= @(x, xd) x(6\) \- log(2\*pi\*sqrt(x(3\)^2\*x(4\)^2 \- x(5\)^2\)) \- (x(3\)^2\*x(4\)^2\)/(2\*x(3\)^2\*x(4\)^2\-x(5\)^2\) \* ( (xd(:,1\)\-x(1\)).^2\./x(3\)^3 \-2\*x(5\)\*(xd(:,1\)\-x(1\)).\*(xd(:,2\)\-x(2\))./(x(3\)^2\*x(4\)^2\) \+ (xd(:,2\)\-x(2\)).^2\./x(4\)^2 );
op \= optimoptions('lsqcurvefit');
op.MaxFunctionEvaluations \= 1e4;
op.MaxIter \= 1e4;

problem2\.solver \= 'lsqcurvefit';
problem2\.options \= op;
problem2\.objective \= fitfun;
problem2\.ub \= \[20 2 20 5 10 Inf];
problem2\.lb \= \[0 0 0 0 0 \-Inf];

% berlin: trim logL to only fit the region where logL\>\=\-7 (relative to best value)
Z\_berlin\_fine \= Z\_berlin(6:8,4:9\);
dts\_ber \= dtaxis\_ber(6:8\);
taus\_ber \= tauaxis\_ber(4:9\);

\[lxx, lxy] \= meshgrid(taus\_ber, dts\_ber);
lxdata \= \[lxx(:) lxy(:)];

x0 \= \[8 .5 5 .1 0\.1 min(min(Z\_berlin\_fine))];
problem2\.xdata \= lxdata;
problem2\.ydata \= Z\_berlin\_fine(:);
problem2\.x0 \= x0;
fitP\_berlin \= lsqcurvefit(problem2\);

% 42a
Z\_42a\_fine \= Z\_42a(:,:);
dts\_42a \= dtaxis\_42a(:);
taus\_42a \= tauaxis\_42a(:);


\[lxx, lxy] \= meshgrid(taus\_42a, dts\_42a);
lxdata \= \[lxx(:) lxy(:)];

x0 \= \[8 .5 5 .1 0\.1 min(min(Z\_42a\_fine))];
problem2\.xdata \= lxdata;
problem2\.ydata \= Z\_42a\_fine(:);
problem2\.x0 \= x0;
fitP\_42a \= lsqcurvefit(problem2\);



% covariance matrix

cm\_ber \= \[round(fitP\_berlin(3\))^2 fitP\_berlin(5\); fitP\_berlin(5\) fitP\_berlin(4\)^2]; % covariance matrix
\[V, D] \= eig(cm\_ber);
D\_ber \= abs(D);

cm\_42a \= \[round(fitP\_42a(3\))^2 fitP\_42a(5\); fitP\_42a(5\) fitP\_42a(4\)^2]; % covariance matrix
\[V, D] \= eig(cm\_42a);
D\_42a \= abs(D);

ss \= 4\.605; % 90% confidence
ss \= 5\.991; % 95% confidence

% confidence regions: see http://www.visiondummy.com/2014/04/draw\-error\-ellipse\-representing\-covariance\-matrix/
conf\_berlin\_dt \= 2\*sqrt(ss\*D\_ber(1,1\));
conf\_berlin\_tau \= 2\*sqrt(ss\*D\_ber(2,2\));

conf\_42a\_dt \= 2\*sqrt(ss\*D\_42a(1,1\));
conf\_42a\_tau \= 2\*sqrt(ss\*D\_42a(2,2\));


return

\-\-\-

\#\#\# File: AlphaEstimate.m (ID: Variance Adaptation Paper.Bayesian Estimator.2\)


function out \= AlphaEstimate(btdstruct, opstruct, timeType, isconvolved, Ddt, deltaT, taxis, period, tshift)
% function \[btdstruct, bayesalpha] \= AlphaEstimate(btdstruct, opstruct, RescaleStruct, isconvolved, Ddt, deltaT, taxis, period, tshift)
% Finds the stimulus at deltaT intervals, and calculates the Bayes\-Optimal estimates of its variance


if(\~isfield(btdstruct, 'btd'))
 disp('cannot calculate Bayes\-Optimal estimate without btds');
 return
end

timeField \= 'eti';
nexps \= length(btdstruct.btd);
switchStim \= find(\[opstruct.stim.switch]);
gq \= opstruct.stim(switchStim).gqname;
 
gq\_ton \= \[gq '\_var\_ton'];
gq\_toff \= \[gq '\_var\_toff'];

if(strcmpi(gq, 'led1ValDiff'))
 ind \= findField(btdstruct.btd(1\), 'led1Val');
 gq\_conv \= \[gq 'TurnLin'];
elseif(strcmpi(gq, 'led2ValDiff'))
 ind \= findField(btdstruct.btd(1\), 'led2Val');
 gq\_conv \= \[gq 'TurnLin'];
elseif(strcmpi(gq, 'led2m1ValDiff'))
 ind \= findField(btdstruct.btd(1\), 'led2m1Val');
 gq\_conv \= 'linU';
end

if(\~isfield(btdstruct, 'var') \|\| ind\<\=0 \|\| any(btdstruct.btd.findField(gq\_conv) \<\= 0\))
 btdstruct \= BehaviorTriggeredData.prepVarianceSwitchingAnalysis\_Gepner(btdstruct, opstruct);
end
if(nargin\<7\)
 pd \= BehaviorTriggeredData.createProblemStructForRateFunFitting (btdstruct.var, timeField, opstruct.pdegree, opstruct.timeRange, \[], deltaT);
 taxis \= pd.tx;
 period \= pd.period;
 tshift \= pd.tshift;
end



if(strcmpi(gq, 'led1ValDiff'))
 ind \= findField(btdstruct.btd(1\), 'led1Val');
 gq\_conv \= \[gq 'TurnLin'];
elseif(strcmpi(gq, 'led2ValDiff'))
 ind \= findField(btdstruct.btd(1\), 'led2Val');
 gq\_conv \= \[gq 'TurnLin'];
elseif(strcmpi(gq, 'led2m1ValDiff'))
 ind \= findField(btdstruct.btd(1\), 'led2m1Val');
 gq\_conv \= 'linU';
end

ind\_diff \= findField(btdstruct.btd(1\), gq);
ind\_conv \= findField(btdstruct.btd(1\), gq\_conv);
ind\_on \= findField(btdstruct.btd(1\), gq\_ton);

btd \= btdstruct.btd;

mS\_all\_eti \= \[];
vS\_all\_eti \= \[];
mS\_all\_ton \= \[];
vS\_all\_ton \= \[];

tx \= mod(taxis\+tshift, period);
tcycle \= 0:deltaT:period;

for i\=1:nexps
 
 glt \= btd(i).glt(ind);
 glt\_conv \= btd(i).glt(ind\_conv);
 glt\_on \= btd(i).glt(ind\_on);
 glt\_diff \= btd(i).glt(ind\_diff);
 
 xval \= interp1(glt.xData, glt.yData, taxis); % stimulus
 xd \= diff(xval);
 xdiff(i,:) \= \[0 xd]; % stimulus derivative
 
 xdiff2(i,:) \= interp1(glt\_diff.xData, glt\_diff.yData/120, taxis);
 
 xo(i,:) \= interp1(glt\_conv.xData, glt\_conv.yData, taxis); % convolved stimulus
 

 
 \[\~,\~,\~,sconv] \= meanyvsx(tx, xo(i,:), tcycle);
 \[\~,\~,\~,s] \= meanyvsx(tx, xdiff(i,:), tcycle);
 
 xdiff(i,:) \= xdiff(i,:)./mean(s(round(end/2\)\+1:end)); % normalize the amplitude of the white noise stimulus derivative
 xo(i,:) \= xo(i,:)./mean(sconv(round(end/2\)\+1:end));
 
 \[\~,\~,\~,son1] \= meanyvsx(tx, xdiff(i,:), tcycle);
% \[\~,\~,\~,son2] \= meanyvsx(tx, xdiff2(i,:), tcycle);
 \[\~,\~,\~,son\_conv] \= meanyvsx(tx, xo(i,:), tcycle);
 
 
 if(isconvolved)
 \[mS\_eti(i,:), vS\_eti(i,:)] \= BayesianVarEstimate(1, Ddt, xo(i,:));
 else
 \[mS\_eti(i,:), vS\_eti(i,:)] \= BayesianVarEstimate(1, Ddt, xdiff(i,:));
 end
 \[mS\_ton(i,:), vS\_ton(i,:), tx\_ton] \= meanEstinCycle(mS\_eti(i,:), vS\_eti(i,:), taxis, tshift, period, opstruct.timeRange, timeType);
 
 mS\_all\_eti \= \[mS\_all\_eti mS\_eti(i,:)];
 vS\_all\_eti \= \[vS\_all\_eti vS\_eti(i,:)];
 mS\_all\_ton \= \[mS\_all\_ton mS\_ton(i,:)];
 vS\_all\_ton \= \[vS\_all\_ton vS\_ton(i,:)];

end

\[msigma, vsigma, tt] \= meanEstinCycle(mS\_all\_eti, vS\_all\_eti, taxis, 0, max(taxis), opstruct.timeRange, 'ton');
\[msigma\_ton, vsigma\_ton, tton] \= meanEstinCycle(mS\_all\_ton, vS\_all\_ton, tx\_ton, tshift, period, opstruct.timeRange, 'ton');

out.tx \= tt;
out.sigma \= msigma;
out.vsigma \= vsigma;
out.tx\_ton \= tton;
out.sigma\_ton \= msigma\_ton;
out.vsigma\_ton \= vsigma\_ton;

end
\-\-\-

\#\#\# File: plotBayesOptLL.m (ID: Variance Adaptation Paper.Bayesian Estimator.3\)



\[adim,po] \= blank8x10Figure(fignum);
pp \= \[adim.lx3, adim.h0 \- adim.h, adim.w3, adim.h];
poss \= {pp, pp, pp};

poss{2}(1\) \= adim.cx3;
poss{3}(1\) \= 2\*poss{2}(1\) \- poss{1}(1\);
poss{3}(2\) \= poss{1}(2\);

poss2 \= poss; % 2nd row of figure (3 columns each)
poss2{1}(1\) \= poss{1}(1\);
poss2{1}(2\) \= adim.cx3 \+ 0\.15;
poss2{2}(2\) \= poss2{1}(2\);
poss2{3}(2\) \= poss2{1}(2\);

positions \= {poss2{1}, poss2{2}};

j\=1;


h{j}.pos \= positions{j};
h{j}.ax \= axes('Position', positions{j});
b \= pcolor(taus, dts, \-LogLBerlin.LL.logP\_fitR \+ min(min(LogLBerlin.LL.logP\_fitR)) ); shading interp; axis square
clear caxis
caxis(gca, \[\-100 0]);
colorbar
b.Parent.XAxis.TickValues \= \[0\.5 10 20 30];
b.Parent.XAxis.TickLabels \= {'0', '10', '20', '30'};

set(gcf, 'renderer', 'opengl')

j \= 2;
h{j}.pos \= positions{j};
h{j}.ax \= axes('Position', positions{j});
a \= pcolor(taus, dts, \-LogL42a.LL.logP\_fitR \+ min(min(LogL42a.LL.logP\_fitR)) ); shading interp; axis square
a.Parent.XAxis.TickValues \= \[0\.5 10 20 30];
a.Parent.XAxis.TickLabels \= {'0', '10', '20', '30'};
clear caxis
caxis(gca, \[\-100 0]);
a \= colorbar; a.Visible \= 'off';

set(gcf, 'renderer', 'opengl')
\-\-\-

\#\#\# File: logLikelihood\_BayesOptimal.m (ID: Variance Adaptation Paper.Bayesian Estimator.4\)

function SF \= logLikelihood\_BayesOptimal(btdstruct, dts, taus, bayes\_sig, sigtoalpha, alphastruct)
%function SF \= logLikelihood\_BayesOptimal(btdstruct, dts, taus, bayes\_sig, sigtoalpha, alphastruct)

deltaT \= median(diff(btdstruct.var.fullensemble.eti));

SimData.sim \= bayes\_sig;
SimData.dts \= dts;
SimData.taus \= taus;
SimData.sigtoalpha \= sigtoalpha;



tton \= btdstruct.var.turn.ton';
rton \= btdstruct.var.noturn.ton';
teti \= btdstruct.var.turn.eti';
reti \= btdstruct.var.noturn.eti';
xt \= btdstruct.var.turn.x\_conv';
xr \= btdstruct.var.noturn.x\_conv';

Data.alphastruct \= alphastruct;

Data.tton \= tton;
Data.rton \= rton;
Data.xt \= xt;
Data.xr \= xr;

\[fP, LL] \= LL\_fromFitData(Data, SimData, deltaT);
SF.dts \= dts;
SF.taus \= taus;
SF.fP \= fP;
SF.LL \= LL;

end

function \[fP,LL] \= LL\_fromFitData(Data, SimData, deltaT)

op \= optimoptions('fminunc');
op.Algorithm \= 'quasi\-newton';

sim \= SimData.sim;
dts \= SimData.dts;
taus \= SimData.taus;
sigtoalpha \= SimData.sigtoalpha;

alphastruct \= Data.alphastruct;

gainFun \= @(x, xdata) 1\./(sqrt(xdata.^2 \+ x.^2\))./mean(1\./(sqrt(xdata.^2 \+ x.^2\))); 
logR \= @(fitparams, xdata) polyval(fitparams, xdata);


for n\=1:size(Data.tton, 1\)
 tic
 
 teti \= alphastruct.scaledValues.turnEti';
 reti \= alphastruct.scaledValues.runEti';
 tton \= alphastruct.scaledValues.turnTon';
 rton \= alphastruct.scaledValues.runTon';
 xt \= alphastruct.scaledValues.turnX';
 xr \= alphastruct.scaledValues.runX';
 
 tx \= alphastruct.tx;
 alpha \= alphastruct.alpha;
 tval \= xt.\* interp1(tx, alpha, teti, 'spline');
 rval \= xr.\* interp1(tx, alpha, reti, 'spline');
 logPdata \= @(params) \-sum(logR(params, tval)) \+ deltaT\*sum(exp(logR(params, rval)));
 fp0 \= alphastruct.params;
 \[fP.fp\_data, logP\_data] \= fminunc(logPdata, fp0, op);
 
 tx\_ton \= alphastruct.tx\_ton;
 alpha\_ton \= alphastruct.alpha\_ton;
 tval \= xt.\* interp1(tx\_ton, alpha\_ton, tton, 'spline');
 rval \= xr.\* interp1(tx\_ton, alpha\_ton, rton, 'spline');
 logPdata \= @(params) \-sum(logR(params, tval)) \+ deltaT\*sum(exp(logR(params, rval)));
% \[fP.fp\_data\_ton, logP\_data\_ton] \= fminunc(logPdata, fp0, op);
 
 
 for i\=1:length(dts)
 disp(\['dt \= ' num2str(dts(i))]);
 for k\=1:length(taus)
 disp(\['tau \= ' num2str(taus(k))]);
 tic
 
 tx \= sim{i}{k}.tx;
 inds \= tx\>\=min(reti);
 alphaSim.tx \= tx(inds);
 sigma \= sim{i}{k}.sigma;
 alpha \= @(StoA) gainFun(StoA, sigma(inds));
 
 %fit only rate params
 alphaSim.alpha \= alpha(sigtoalpha);
 alphaSim \= normAlpha(alphaSim, alphastruct.scaledValues, 'eti', \[], \[], \[]);
 tval \= xt.\* interp1(alphaSim.tx, alphaSim.alpha, teti, 'spline');
 rval \= xr.\* interp1(alphaSim.tx, alphaSim.alpha, reti, 'spline');
 logPdata \= @(params) \-sum(logR(params, tval)) \+ deltaT\*sum(exp(logR(params, rval)));
 \[fP.fp\_fit(i,k,:), logP\_fit(i,k)] \= fminunc(logPdata, fP.fp\_data, op);
 logP\_nofit(i,k) \= logPdata(fP.fp\_data);
 
 toc
 %fit also alpha

% findNormAlpha \= @(s0\) normAlpha(alphaSim, alphastruct.scaledValues, 'eti', \[], sigma(inds), s0\);
% tval \= @(s0\) xt.\* interp1(alphaSim.tx, findNormAlpha(s0\), teti, 'spline');
% rval \= @(s0\) xr.\* interp1(alphaSim.tx, findNormAlpha(s0\), reti, 'spline');
% logPdata \= @(params) \-sum(logR(params(2:end), tval(params(1\)))) \+ deltaT\*sum(exp(logR(params(2:end), rval(params(1\)))));
% \[fP.fp\_fit(i,k,:), logP\_fit\_alpha(i,k)] \= fminunc(logPdata, \[1\.5 fP.fp\_data], op);
% disp(\['s0 \= ' num2str(fP.fp\_fit(i,k,1\))]);
% toc
% logP\_nofit(i,k) \= logPdata(fP.fp\_data);
 
% alphaSim.tx\_ton \= sim{i}{k}.tx\_ton;
% sigma\_ton \= sim{i}{k}.sigma\_ton;
% alphaSim.alpha\_ton \= gainFun(sigtoalpha, sigma\_ton);
% alphaSim \= normAlpha(alphaSim, alphastruct.scaledValues, 'ton', \[]);
% tval \= xt.\* interp1(alphaSim.tx\_ton, alphaSim.alpha\_ton, tton, 'spline');
% rval \= xr.\* interp1(alphaSim.tx\_ton, alphaSim.alpha\_ton, rton, 'spline');
% logPdata \= @(params) \-sum(logR(params, tval)) \+ deltaT\*sum(exp(logR(params, rval)));
% \[fP.fp\_fit\_ton(i,k,:), logP\_fit\_ton(i,k)] \= fminunc(logPdata, fP.fp\_data\_ton, op);
% logP\_nofit\_ton(i,k) \= logPdata(fP.fp\_data\_ton);
 
 end
 end
end

LL.logP\_data(n) \= logP\_data;
% LL.logP\_data\_ton(n) \= logP\_data\_ton;

LL.logP\_fitR(:,:,n) \= logP\_fit;
LL.logP\_nofit(:,:,n) \= logP\_nofit;
% LL.logP\_fitR\_ton(:,:,n) \= logP\_fit\_ton;
% LL.logP\_nofit\_ton(:,:,n) \= logP\_nofit\_ton;

end





function fitstruct \= normAlpha (fitstruct, data, timeType, expnum, sigma, s0\)
if (length(fitstruct) \> 1\)
 for j \= 1:length(fitstruct)
 fitstruct(j) \= normAlpha (fitstruct(j), data, j);
 end
 return;
end
if (existsAndDefault('expnum', \[]))
 tinds \= data.turnExpnum \=\= expnum;
 rinds \= data.runExpnum \=\= expnum;
else
 tinds \= true(size(data.turnT));
 rinds \= true(size(data.runT));
end

if(\~isfield(fitstruct, 'alpha'))
 gainFun \= @(x) 1\./(sqrt(sigma.^2 \+ x.^2\))./mean(1\./(sqrt(sigma.^2 \+ x.^2\))); 
 fitstruct.alpha \= gainFun(s0\);
end

if(strcmpi(timeType, 'ton'))
 if(isfield(data, 'runTon'))
 runT \= data.runTon;
 turnT \= data.turnTon;
 else
 runT \= data.runT;
 turnT \= data.turnT;
 end
 nr\_ton \= histcounts(runT(rinds), binEdgesFromCenters(fitstruct.tx\_ton));
 nt\_ton \= histcounts(turnT(tinds), binEdgesFromCenters(fitstruct.tx\_ton));
 wton \= (nr\_ton \+ nt\_ton)/sum(nr\_ton \+ nt\_ton);
 wton \= wton(:);
 alpha\_ton \= fitstruct.alpha\_ton';
 norm\_factor \= sum(alpha\_ton.\*repmat(wton, \[1 size(alpha\_ton,2\)]),1\);
 alpha\_ton \= alpha\_ton ./ repmat(norm\_factor, \[size(alpha\_ton,1\) 1]);
 fitstruct.alpha\_ton \= alpha\_ton';
else
 nr\_t \= histcounts(data.runT(rinds), binEdgesFromCenters(fitstruct.tx));
 nt\_t \= histcounts(data.turnT(tinds), binEdgesFromCenters(fitstruct.tx));
 wt \= (nr\_t \+ nt\_t)/sum(nr\_t \+ nt\_t);
 wt \= wt(:);
 alpha \= fitstruct.alpha';
 norm\_factor \= sum(alpha.\*repmat(wt, \[1 size(alpha,2\)]),1\);
 alpha \= alpha ./ repmat(norm\_factor, \[size(alpha,1\) 1]);
 fitstruct.alpha \= alpha';
end

if(\~isempty(s0\))
 fitstruct \= fitstruct.alpha;
end


end


\-\-\-

\#\#\# File: make2D\_LLplot.m (ID: Variance Adaptation Paper.Bayesian Estimator.5\)



exponential \= 0;
new\_axes \= 0; % if you want to define new \[dt,tau] grid and interpolate

conf\_region \= 1; % draw confidence ellipse, with radii found with fit2DLL.m


t\=\-pi:0\.01:pi;

x0\_42a\=11; % tau\_best
y0\_42a\=.7; % dt\_best
tau\=5; % tau confidence radius
dt\=.15; % dt confidence radius
x1\=x0\_42a\+tau\*cos(t);
y1\=y0\_42a\+dt\*sin(t);

x0\_ber\=6; 
y0\_ber\=.85;
tau\=2\.5;
dt\=.07;
t\=\-pi:0\.01:pi;
xb1\=x0\_ber\+tau\*cos(t);
yb1\=y0\_ber\+dt\*sin(t);

LLs \= \[LogL\_Berlin, LogL\_42a];

clear dts taus
for k\=1:2

LLstruct \= LLs(k);
% LLstruct\_fine \= LLs\_fine(k);

dts{k} \= LLstruct.dts;
taus{k} \= LLstruct.taus;

nll{k} \= LLstruct.LL.logP\_fitR;
zz{k} \= \-nll{k} \+ min(min(nll{k}));


a1 \= \[.05 .1 .2 .3 .4];
a3 \= \[1\.1:.4:1\.9, 3];
a2 \= .5:.2:1;
dts\_new \= \[a1 a2 a3];
taus\_new \= taus{1};

\[lxx, lxy] \= meshgrid(taus{k}, dts{k});
\[lxx2, lxy2] \= meshgrid(taus\_new, dts\_new);
lxdata \= \[lxx(:) lxy(:)];

lxdata2 \= \[lxx2(:) lxy2(:)];
nll\_new{k} \= interp2(lxx, lxy, nll{k}, lxx2, lxy2, 'nearest');
zz\_new{k} \= \-nll\_new{k} \+ min(min(nll\_new{k}));
end

if(new\_axes)
 zz\_42a \= zz\_new{2};
 zz\_berlin \= zz\_new{1};
 tauaxis\_42a \= taus\_new;
 tauaxis\_ber \= taus\_new;
 dtaxis\_42a \= dts\_new;
 dtaxis\_ber \= dts\_new;
else
 zz\_42a \= zz{2};
 zz\_berlin \= zz{1};
 tauaxis\_42a \= taus{2};
 dtaxis\_42a \= dts{2};
 tauaxis\_ber \= taus{1};
 dtaxis\_ber \= dts{1};
end
 
if(exponential)
 Z\_42a \= exp(zz\_42a);
 Z\_berlin \= exp(zz\_berlin);
 paxis \= \[0 1];
 pticks \= \[0 0\.2 0\.4 0\.6 0\.8 1];
else
 Z\_42a \= zz\_42a;
 Z\_berlin \= zz\_berlin;
 paxis \= \[\-14 0];
 pticks \= \[\-14 \-7 0];
end


subplot(1,2,2\)
b1 \= pcolor(tauaxis\_42a, dtaxis\_42a, Z\_42a ); shading interp; axis square
if(conf\_region)
 hold on; plot(x1, y1, 'w:', 'LineWidth', 2\);% plot(x2, y2, 'w:', 'LineWidth', 1\.5\); plot(x3, y3, 'w:', 'LineWidth', 1\.5\); plot(x4, y4, 'w:', 'LineWidth', 1\.5\);
 plot(x0\_42a, y0\_42a, 'w.', 'MarkerSize', 20\);
 hold off;
end
b1\.Parent.YAxis.Limits \= \[min(dtaxis\_42a) 2];
b1\.Parent.XAxis.Limits \= \[min(tauaxis\_42a) 25];
b1\.Parent.XAxis.TickValues \= \[0\.5 10 20 30];
b1\.Parent.XAxis.TickLabels \= {'0', '10', '20', '30'};
clear caxis
caxis(gca, paxis);
a1 \= colorbar; a1\.Visible \= 'off';
subplot(1,2,1\)
b2 \= pcolor(tauaxis\_ber, dtaxis\_ber, Z\_berlin ); shading interp; axis square
if(conf\_region)
 hold on; plot(xb1, yb1, 'w:', 'LineWidth', 2\);
 plot(x0\_ber, y0\_ber, 'w.', 'MarkerSize', 20\);
 hold off;
end
b2\.Parent.YAxis.Limits \= \[min(dtaxis\_ber) 2];
b2\.Parent.XAxis.Limits \= \[min(tauaxis\_ber) 20];
clear caxis
caxis(gca, paxis );
a2 \= colorbar;
b2\.Parent.XAxis.TickValues \= \[0\.5 10 20 30];
b2\.Parent.XAxis.TickLabels \= {'0', '10', '20', '30'};
set(gcf, 'renderer', 'painters');

a2\.Position(1\) \= .47;
a1\.Position(1\) \= .9;
b1\.Parent.Position(1\) \= .65;
b2\.Parent.Position(1\) \= .06;
b1\.Parent.Position(2:3\) \= b2\.Parent.Position(2:3\);
a2\.Position(2\) \= .29;
a2\.Position(4\) \= .45;
a2\.Position(2\) \= .3;
a2\.Position(4\) \= .43;
a2\.Ticks \= pticks;
a2\.FontSize \= 12;
b1\.Parent.FontSize \= 12;
b2\.Parent.FontSize \= 12;
b1\.Parent.XAxis.TickValues \= \[0\.5 10 20 30];
b2\.Parent.XAxis.TickValues \= \[0\.5 10 20 30];
b1\.Parent.YAxis.TickValues \= \[0\.5 1 1\.5 2 2\.5 3];
b2\.Parent.YAxis.TickValues \= \[0\.5 1 1\.5 2 2\.5 3];
\-\-\-

\#\#\# File: BayesOptimal\_DtTau.m (ID: Variance Adaptation Paper.Bayesian Estimator.6\)

function SF \= BayesOptimal\_DtTau(btdstruct, dts, taus, isconvolved)
%function SF \= BayesOptimal\_DtTau(btdstruct, dts, taus, isconvolved)

% btdstruct needs to contain the btd field which contains the stimulus
% isconvolved \= 0 or 1\. whether the filtered or raw stimulus is used to estimate the variance.
% dts,taus: arrays of desired values


SF.dts \= dts;
SF.taus \= taus;


VarEst \= @(dt, tau) AlphaEstimate(btdstruct, btdstruct.varops, 'eti', isconvolved, dt/tau, dt, 60:dt:1200, btdstruct.var.period, btdstruct.var.tshift);

for i\=1:length(dts)
 for k\=1:length(taus)
 tic
 SF.sim{i}{k} \= VarEst(dts(i), taus(k));
 toc
 end
end
\-\-\-

\#\#\# File: BayesianVarEstimate.m (ID: Variance Adaptation Paper.Bayesian Estimator.7\)


function \[mean, var] \= BayesianVarEstimate(s0, Ddt, StimVal)
% function \[mean, var] \= BayesianVarEstimate(s0, Ddt, StimVal)
% Evaluate Bayesian\-optimal estimate of variance, see DeWeese\&Zador: https://www.mitpressjournals.org/doi/pdf/10\.1162/089976698300017403

clear Ps meanvar;

dS \= 0\.5;
sigmas \= 0\.05:dS:5; %sigma axis for integration

\[S1, S2] \= meshgrid(sigmas, sigmas);

Nxs \= @(x, s) normpdf(x, 0, s); %(3\.22\) from paper linked above \- Distribution of stimuli given stddev; P(x\|s)
Nss \= @(s1,s2\) normpdf(s1, s2, sqrt(2\*Ddt)); % (3\.21\) \- Diffusion prior on stddev P(sigma1 \| sigma2\), D\=diffusion constant, dt \= time step


%First time step after change from slow to shigh

Psx\_0 \= @(s) Nxs(StimVal(1\), s).\* Nss(s, s0\);
omega \= dS\*trapz( Psx\_0(sigmas) );
Ps(1,:) \= Psx\_0(sigmas)/omega;

%Psx \= Psx\_0;

Psx \= Psx\_0(sigmas)/omega;
% tic
for n\=2:length(StimVal)
 
 Pss\_n \= dS\*trapz(Nss(S1, S2\).\*repmat(Psx, length(sigmas), 1\), 2\);
 Psx\_n \= Nxs(StimVal(n), sigmas).\*Pss\_n';
 omega \= dS\*trapz(Psx\_n);
 Psx \= Psx\_n/omega;
 Ps(n,:) \= Psx;

end
% toc

for n\=1:length(StimVal)
 mean(n) \= trapz( sigmas.\* Ps(n,:) ) / trapz(Ps(n,:));
 var(n) \= trapz( sigmas.^2\.\* Ps(n,:) ) / trapz(Ps(n,:)) \- mean(n)^2 ;
end

% shadedErrorPlot(1:n, meanvar, svar);

return




dX \= 0\.5;
stims \= \-10:dX:10; %x axis for integration
\[X, S] \= meshgrid(stims, sigmas);

if(xfirst)
 
 %First time step after change from slow to shigh
 
 Psx\_0 \= @(x, s) Nxs(x,s).\*Nss(s, slow);
 omega \= dS\*trapz( Psx\_0(X,S), 1\); 
 Ps(1,:) \= dX\*trapz( Nxs(X, shigh).\*Psx\_0(X,S)./omega, 2\); 
 Psx \= Psx\_0;
 
 tic
 for n\=2:N
 
 % (2\.3\) \- P(s\_i \| x\_(j \= Int( s \* P(s) \* ds ) \= mean sigma
 meanvar(n) \= trapz( sigmas.\*Ps(n,:) )/trapz(Ps(n,:));
 end
 
 
 
 
 
 
else
 
 Psx\_0 \= @(x, s) Nxs(x,s).\*Nss(s, slow);
 omega \= dS\*trapz(Psx\_0(X,S), 1\);
 Px(1,:) \= dS\*trapz(S.\*Psx\_0(X,S), 1\);
 meanvar(1\) \= trapz(Nxs(stims, shigh).\*Px(1,:)./omega)/trapz(Nxs(stims, shigh));
 Psx \= Psx\_0;
 
 tic
 for n\=2:N
 
 % (2\.3\) \- P(s\_i \| x\_(j \= Int( P(s\|x) \* s \* ds ) \= mean sigma (s), given stim. (x)
 Px(n,:) \= dS\*trapz(S.\*Psx\_n(X,S), 1\);
 
 % ~~\= Int(  \* P(x\|s\_high) \* dx) \= mean sigma
 meanvar(n) \= trapz(Nxs(stims, shigh).\*Px(n,:)./omega)/trapz(Nxs(stims, shigh));
 
 % update P(s \| x)
 Psx \= Psx\_n; 
 end
 toc

 
end
 
plot(meanvar);
end
 
\-\-\-

\#\#\# Folder: Variance Adaptation Paper/Figures (ID: Variance Adaptation Paper.Figures)

\-\-\-

\#\#\# File: VarAdaptPlots.m (ID: Variance Adaptation Paper.Figures.1\)

function ah \= VarAdaptPlots (btdstruct, names, colors, pos, exptype, deltaT, estimator, simtype, dt\_opt, tau\_opt, params\_opt, StimNum, pdegree, multiType)
% function ah \= VarAdaptPlots (btdstruct, names, colors, pos, exptype, deltaT, estimator, simtype, dt\_opt, tau\_opt, params\_opt, StimNum, pdegree, multiType)

% see VarAdaptFigures for examples on how to use this script to plot stuff


switch exptype
 
 
 case '2stimRF'
 
 for j\=1:length(btdstruct)
 
 if(isfield(btdstruct(j), 'RatesU'))
 Rates \= btdstruct(j).RatesU;
 elseif(isfield(btdstruct(j), 'Rates'))
 Rates \= btdstruct(j).Rates;
 else
 Rates \= btdstruct(j);
 end
 
 
 
 lx\_low \= Rates.rfLowVar(1\).lx;
 lx\_high \= Rates.rfHighVar(1\).lx;
 rateX\_low \= 60\*Rates.rfLowVar(1\).rate;
 rateX\_low\_eb \= 60\*Rates.rfLowVar(1\).rate\_eb;
 rateX\_high \= 60\*Rates.rfHighVar(1\).rate;
 rateX\_high\_eb \= 60\*Rates.rfHighVar(1\).rate\_eb;
 
 ly\_low \= Rates.rfLowVar(2\).lx;
 ly\_high \= Rates.rfHighVar(2\).lx;
 rateY\_low \= 60\*Rates.rfLowVar(2\).rate;
 rateY\_low\_eb \= 60\*Rates.rfLowVar(2\).rate\_eb;
 rateY\_high \= 60\*Rates.rfHighVar(2\).rate;
 rateY\_high\_eb \= 60\*Rates.rfHighVar(2\).rate\_eb;
 
 if(pdegree\=\=2\)
 rateX\_fit\_low \= 60\*exp(polyval(Rates.rfLowVar(1\).rateFitQuad, lx\_low));
 rateX\_fit\_high \= 60\*exp(polyval(Rates.rfHighVar(1\).rateFitQuad, lx\_high));
 rateY\_fit\_low \= 60\*exp(polyval(Rates.rfLowVar(2\).rateFitQuad, ly\_low));
 rateY\_fit\_high \= 60\*exp(polyval(Rates.rfHighVar(2\).rateFitQuad, ly\_high));
 else
 rateX\_fit\_low \= 60\*exp(polyval(Rates.rfLowVar(1\).rateFitLin, lx\_low));
 rateX\_fit\_high \= 60\*exp(polyval(Rates.rfHighVar(1\).rateFitLin, lx\_high));
 rateY\_fit\_low \= 60\*exp(polyval(Rates.rfLowVar(2\).rateFitLin, ly\_low));
 rateY\_fit\_high \= 60\*exp(polyval(Rates.rfHighVar(2\).rateFitLin, ly\_high));
 end
 
 
 ah{1}(j).pos \= pos{j}{1}; %\#ok\<\*AGROW\>
 ah{1}(j).ax \= axes('Position', pos{j}{1});
 ah{1}(j).name \= names{j};
 
 
 h(1\) \= errorbar (lx\_low, rateX\_low, rateX\_low\_eb, 'color', colors{1}{1}, 'marker', 'o', 'linestyle', 'none');
 hold all;
 h(2\) \= plot (lx\_low, rateX\_fit\_low, 'color', colors{1}{1}, 'linestyle', '\-\-', 'LineWidth', 2\);
 
 h(3\) \= errorbar (lx\_high, rateX\_high, rateX\_high\_eb, 'color', colors{1}{2}, 'marker', 's', 'MarkerFaceColor', colors{1}{2}, 'linestyle', 'none');
 h(4\) \= plot (lx\_high, rateX\_fit\_high, 'color', colors{1}{2}, 'linestyle', '\-', 'LineWidth', 2\);
 hold off;
 
 ah{1}(j).handles \= h;
 title(names{j});
 ax \= gca;
 ax.Box \= 'off';
 % set(ax, 'YScale', 'log');
 ax.YLim \= \[0 15];
 ax.YTick \= \[0 5 10 15 20];
 ax.YLabel.String \= 'turn rate (min^{\-1})';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'Filtered Stimulus Value';
 ax.XLabel.FontSize \= 10;
 ax.XAxis.Color \= 'r';
 
 ah{2}(j).pos \= pos{j}{2}; %\#ok\<\*AGROW\>
 ah{2}(j).ax \= axes('Position', pos{j}{2});
 ah{2}(j).name \= names{j};
 
 hold on
 
 h2(1\) \= errorbar (ly\_low, rateY\_low, rateY\_low\_eb, 'color', colors{2}{1}, 'marker', 'o', 'linestyle', 'none');
 hold all;
 h2(2\) \= plot (ly\_low, rateY\_fit\_low, 'color', colors{2}{1}, 'linestyle', '\-\-', 'LineWidth', 2\);
 
 h2(3\) \= errorbar (ly\_high, rateY\_high, rateY\_high\_eb, 'color', colors{2}{2}, 'marker', 's', 'MarkerFaceColor', colors{2}{2}, 'linestyle', 'none');
 h2(4\) \= plot (ly\_high, rateY\_fit\_high, 'color', colors{2}{2}, 'linestyle', '\-', 'LineWidth', 2\);
 
 ah{2}(j).handles \= h2;
 title(names{j});
 ax \= gca;
 ax.Box \= 'off';
 % set(ax, 'YScale', 'log');
 ax.YLim \= \[0 15];
 ax.YTick \= \[0 5 10 15 20];
 ax.YLabel.String \= 'turn rate (min^{\-1})';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'Filtered Stimulus Value';
 ax.XLabel.FontSize \= 10;
 ax.XAxis.Color \= 'b';
 
 % set(ax, 'YScale', 'log');
 
 
 
 
 end
 
 case 'ScaleFactorVTime'
 
 op \= optimoptions('fminunc');
 op.Algorithm \= 'quasi\-newton';
 problem.options \= op;
 problem.solver \= 'fminunc';
 
 for j\=1:length(btdstruct)
 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 axis square
 ah(j).name \= names{j};
 
 clear tSim aSim sSim vSim tEst aEst vEst
 
 deltaT \= median(diff(btdstruct(j).var(1\).fullensemble.eti));

 if(strcmpi(estimator, 'PPF'))
 if(isfield(btdstruct, 'var\_uv'))
 if(StimNum \=\= 1\)
 alphastruct \= btdstruct(j).alphavseti\_U;
 else
 alphastruct \= btdstruct(j).alphavseti\_UV;
 end
 else
 alphastruct \= btdstruct(j).alphavseti;
 end
 elseif(strcmpi(estimator, 'Bayes'))
 if(isfield(btdstruct, 'var\_uv'))
 if(StimNum \=\= 1\)
 alphastruct \= btdstruct(j).BayesAlphavsEti\_U;
 else
 alphastruct \= btdstruct(j).BayesAlphavsEti\_UV;
 end
 else
 alphastruct \= btdstruct(j).BayesAlphavsEti\_OL;
 end
 
 end
 
 tx\_ton \= alphastruct.tx\_ton;
 alpha\_ton \= alphastruct.alpha\_ton;
 valpha\_ton \= sqrt(alphastruct.valpha\_ton);
 if(size(alpha\_ton,1\)\>size(alpha\_ton,2\))
 alpha\_ton \= alpha\_ton';
 end
 nstim \= size(alpha\_ton, 1\);
 
 tshift \= 3;
 
 if(nstim\=\=2\)
 period \= btdstruct(j).var\_uv(1\).period;
 else
 period \= btdstruct(j).var.period;
 end
 
 dt \= median(diff(tx\_ton));
 
 for k\=1:size(alpha\_ton, 1\)
 alpha\_shift(k,:) \= circshift(alpha\_ton(k,:), round(length(tx\_ton)/2\));
 if(nstim\=\=2\)
 valpha\_shift(k,:) \= circshift(valpha\_ton(k, k,:), round(length(tx\_ton)/2\));
 else
 valpha\_shift(k,:) \= circshift(valpha\_ton(k,:), round(length(tx\_ton)/2\));
 end
 aEst(k,:) \= \[alpha\_shift(k, round(end\-tshift/dt):end), alpha\_shift(k,:)];
 vEst(k,:) \= \[valpha\_shift(k, round(end\-tshift/dt):end), valpha\_shift(k,:)];
 end
 tx\_shift \= \-fliplr(tx\_ton);
 % tEst \= \[\-tshift:dt:tx\_ton(1\), tx\_ton];
 tEst \= \[tx\_shift(round(end\-tshift/dt):end), tx\_ton];
 if(max(tEst)\>50\)
 ind \= find(tEst\>50, 1\);
 tEst \= tEst(1:ind);
 aEst \= aEst(k, 1:ind);
 vEst \= vEst(k, 1:ind);
 end
 
 if(strcmpi(simtype, 'LowHigh'))
 
 sim \= btdstruct(j).LowHighSim;
 if(strcmpi(estimator, 'PPF'))
 txSim \= sim.alphavseti{end}.tx\_ton;
 alphaSim \= sim.alphavseti{end}.alpha\_ton;
 valphaSim \= sqrt(sim.alphavseti{end}.valpha\_ton);
 elseif(strcmpi(estimator, 'Bayes'))
 txSim \= sim.BayesAlphavsEti{end}.tx\_ton;
 alphaSim \= sim.BayesAlphavsEti{end}.alpha\_ton;
 valphaSim \= sqrt(sim.BayesAlphavsEti{end}.valpha\_ton);
 end
 dt \= median(diff(txSim));
 tx\_shift \= circshift(txSim, round(length(txSim/2\)));
 alphaSim\_shift \= circshift(alphaSim, round(length(txSim)/2\));
 valphaSim\_shift \= circshift(valphaSim, round(length(txSim)/2\));
 
 tSim \= \[\-(txSim(1:round(1\+tshift/dt))), txSim];
 aSim \= \[alphaSim\_shift(round(end\-tshift/dt):end), alphaSim\_shift];
 aSim \= aSim./mean(aSim);
 vSim \= \[valphaSim\_shift(round(end\-tshift/dt):end), valphaSim\_shift];
 
 elseif(strcmpi(simtype, 'Optimal'))
 
 isconvolved \= 0;
 
 tton \= btdstruct(j).var.turn.ton;
 rton \= btdstruct(j).var.noturn.ton;
 teti \= btdstruct(j).var.turn.eti;
 reti \= btdstruct(j).var.noturn.eti;
 xt \= btdstruct(j).var.turn.x\_conv;
 xr \= btdstruct(j).var.noturn.x\_conv;
 
% gainFun \= @(x, xdata) 1\./(sqrt(xdata.^2 \+ x(1\)))./mean(1\./(sqrt(xdata.^2 \+ x(1\))));
 gainFun \= @(x, xdata) 1\./(sqrt(xdata.^2 \+ x^2\));
 VarEst \= @(dt, tau) AlphaEstimate(btdstruct(j), btdstruct(j).varops, 'eti', isconvolved, dt/tau, dt, 60:dt:1200, btdstruct(j).var.period, btdstruct(j).var.tshift);
 
 
 for i\=1:length(dt\_opt)
 tic
 sim{i} \= VarEst(dt\_opt(i), tau\_opt(i));
 toc
 end

 for k\=1:length(sim)
 
 tx\_ton \= sim{k}.tx\_ton;
 txSim{k} \= sim{k}.tx\_ton;
 tx \= sim{k}.tx;
 dt \= median(diff(txSim{k}));
 sigma \= sim{k}.sigma;
 sigma\_ton \= sim{k}.sigma\_ton;
 ssigma\_ton \= sqrt(sim{k}.vsigma\_ton);
 
 fpar \= params\_opt{j};
 
 data \= alphastruct.scaledValues;
 
 alphaup.alpha\_ton \= gainFun(fpar, sigma\_ton\+ssigma\_ton);
 alphaup.tx\_ton \= tx\_ton;
 alphaup \= normAlpha(alphaup, data, 'ton', \[]);
 
 alpha.tx\_ton \= tx\_ton;
 alpha.alpha\_ton \= gainFun(fpar, sigma\_ton);
 alpha \= normAlpha(alpha, data, 'ton', \[]);
 
 alphaSim{k} \= alpha.alpha\_ton;
 salphaSim{k} \= alphaup.alpha\_ton \- alpha.alpha\_ton;
 
 alphaSim\_shift{k} \= circshift(alphaSim{k}, round(length(txSim{k})/2\));
 salphaSim\_shift{k} \= circshift(salphaSim{k}, round(length(txSim{k})/2\));
 aSim{k} \= \[alphaSim\_shift{k}(round(end\-tshift/dt):end), alphaSim\_shift{k}];
 npoints \= length(aSim{k}) \- length(alphaSim{k});
 sSim{k} \= \[salphaSim\_shift{k}(round(end\-tshift/dt):end), salphaSim\_shift{k}];
 tSim{k} \= \[txSim{k}(end\-npoints\+1:end)\-period, txSim{k}];
 end
 
 end
 
 
 
 if(isempty(estimator))
 
 temp \= shadedErrorPlot({tEst tEst}, mat2cell(aEst, \[1 1], length(aEst)), mat2cell(vEst, \[1 1], length(vEst)));
 h(1\) \= temp(1\);
 h(2\) \= temp(2\);
 h(3\) \= temp(3\);
 h(4\) \= temp(4\);
 pp \= h(1\).Parent;
 pp.Children(1\).Color \= colors{j}{1}{1};
 pp.Children(2\).Color \= colors{j}{1}{2};
 pp.Children(1\).LineWidth \= 1\.5;
 pp.Children(2\).LineWidth \= 1\.5;
 pp.Children(3\).FaceColor \= colors{j}{1}{2};
 pp.Children(4\).FaceColor \= colors{j}{2}{2};
 pp.Children(3\).FaceAlpha \= .5;
 pp.Children(4\).FaceAlpha \= 1;
 
 % uistack(pp.Children(2\),'top');
 
 elseif(strcmpi(simtype, 'LowHigh'))
 
 temp \= shadedErrorPlot({tEst tSim}, {aEst aSim}, {vEst vSim});
 h(1\) \= temp(1\);
 h(2\) \= temp(2\);
 h(3\) \= temp(3\);
 h(4\) \= temp(4\);
 pp \= h(1\).Parent;
 pp.Children(1\).Color \= colors{j}{1}{1};
 pp.Children(2\).Color \= \[0\.1 0\.1 0\.1 .3];
 pp.Children(1\).LineWidth \= 1\.5;
 pp.Children(2\).LineWidth \= 1\.2;
 pp.Children(3\).FaceColor \= colors{j}{1}{2};
 pp.Children(4\).FaceColor \= \[0\.6 0\.6 0\.6];
 pp.Children(3\).FaceAlpha \= 1;
 pp.Children(4\).FaceAlpha \= .3;
 
 elseif(strcmpi(simtype, 'Optimal'))
 
 
 if(strcmpi(btdstruct(j).var.gqname, 'led1ValDiff'))
 calpha \= autumn;
 else
 calpha \= winter;
 end
 
 % calpha \= winter;
 
 N \= length(tSim);
 tSim{end\+1} \= tEst;
 aSim{end\+1} \= aEst;
 sSim{end\+1} \= vEst;
 temp \= shadedErrorPlot(tSim, aSim, sSim);
 
 h(1\) \= temp(1\);
 h(2\) \= temp(2\);
 h(3\) \= temp(3\);
 h(4\) \= temp(4\);
 pp \= h(1\).Parent;
 
 nn \= floor(length(calpha)/N);
 for k\=1:N
 pp.Children(k).Color \= calpha(nn\*k,:);
 cols(k,:) \= calpha(nn\*k,:);
 pp.Children(k).LineWidth \= 1\.5;
 pp.Children(k\+1\+N).FaceColor \= calpha(nn\*k,:);
 pp.Children(k\+1\+N).FaceAlpha \= .2;
 end
 %pp.Children(N\+1\).Color \= colors{j}{1}{1};
 pp.Children(N\+1\).Color \= 'k';
 pp.Children(N\+1\).LineWidth \= 1\.5;
 %pp.Children(end).FaceColor \= colors{j}{1}{2};
 pp.Children(end).FaceColor \= \[.6 .6 .6];
 pp.Children(end).FaceAlpha \= .6;
 
 ax \= gca;
 if(std(tau\_opt)\>std(dt\_opt))
 paraxis \= tau\_opt;
 else
 paraxis \= dt\_opt;
 end
 ax.CLim \= \[min(paraxis) max(paraxis)];
 a{j} \= colorbar;
 a{j}.Parent.Colormap \= cols;
 lims \= a{j}.Limits;
 int \= diff(lims)/N;
 for q\=1:N, xx(q) \= lims(1\) \+ q\*int \- int/2; end
 a{j}.Ticks \= xx;
 a{j}.TickLabels \= strsplit(num2str(paraxis));
 a{j}.TickLength \= 0;
 
 else
 
 if(nstim\=\=2\)
 h \= shadedErrorPlot({tEst tEst}, {aEst(1,:) aEst(2,:)},{vEst(1,:) vEst(2,:)}, {vEst(1,:) vEst(2,:)}, {colors{j}{1}{1}, colors{j}{1}{2}});
 pp \= h.Parent;
 pp.Children(1\).LineWidth \= 1\.5;
 pp.Children(2\).LineWidth \= 1\.5;
 else
 temp \= shadedErrorPlot(tEst, aEst, vEst);
 h(1\) \= temp(1\);
 h(2\) \= temp(2\);
 pp \= h(1\).Parent;
 pp.Children(1\).Color \= colors{j}{1}{1};
 pp.Children(1\).LineWidth \= 1\.5;
 pp.Children(2\).FaceColor \= colors{j}{1}{2};
 end
 
 
 end
 %
 
 ax \= gca;
 ax.YLim \= \[0\.6 1\.6];
 ax.YAxis(1\).Limits \= ax.YLim;
 hold on
 h(end\+1\) \= plot(\[0 0], \[ax.YLim(1\) ax.YLim(2\)], 'k\-\-', 'linewidth', 1\.5\);
 h(end\+1\) \= plot(\[period/2 period/2], \[ax.YLim(1\) ax.YLim(2\)], 'k\-\-', 'linewidth', 1\.5\);
 hold off
 
 ax.YAxis(1\).Color \= colors{j}{1}{1};
 ax.YLabel.String \= '\\alpha';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'time in cycle (s)';
 ax.XLabel.FontSize \= 10;
 
 
 ARatio \= .66;
 
 ax \= h(1\).Parent;
 ax.DataAspectRatio(1\) \= ARatio\*ax.DataAspectRatio(1\);
 ax.Box \= 'off';
 
 
 
 
 end
 
 case '1stimRF'
 
 SF \= 60;
 
 
 for j \= 1:length(btdstruct)
 
 
 if( strncmpi(btdstruct(j).var(StimNum).gqname, 'led2', 4\))
 stim \= 'blue';
 elseif( strncmpi(btdstruct(j).var(StimNum).gqname, 'led1', 4\))
 stim \= 'red';
 end
 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 
 if(isfield(btdstruct(j), 'RatesU'))
 Rates \= btdstruct(j).RatesU;
 stim \= 'purple';
 elseif(isfield(btdstruct(j), 'Rates'))
 Rates \= btdstruct(j).Rates;
 else
 Rates \= btdstruct(j);
 end
 
 if(nargin\>5\)
 k \= StimNum;
 else
 k\=1;
 end
 
 lx\_low \= Rates.rfLowVar(k).lx;
 lx\_high \= Rates.rfHighVar(k).lx;
 rate\_low \= SF\*Rates.rfLowVar(k).rate;
 rate\_eb\_low \= SF\*Rates.rfLowVar(k).rate\_eb;
 rate\_high \= SF\*Rates.rfHighVar(k).rate;
 rate\_eb\_high \= SF\*Rates.rfHighVar(k).rate\_eb;
 
 if(pdegree\=\=1\)
 
 fitRate\_low \= SF\*exp(polyval(Rates.rfLowVar(k).rateFitLin, lx\_low));
 fitRate\_high \= SF\*exp(polyval(Rates.rfHighVar(k).rateFitLin, lx\_high));
 elseif(pdegree\=\=2\)
 fitRate\_low \= SF\*exp(polyval(Rates.rfLowVar(k).rateFitQuad, lx\_low));
 fitRate\_high \= SF\*exp(polyval(Rates.rfHighVar(k).rateFitQuad, lx\_high));
 end
 
 h(1\) \= errorbar (lx\_low, rate\_low, rate\_eb\_low, 'color', colors{j}{1}, 'marker', 'o', 'linestyle', 'none'); %'MarkerSize', 5, 'CapSize', 5
 hold all;
 h(2\) \= errorbar (lx\_high, rate\_high, rate\_eb\_high, 'color', colors{j}{2}, 'marker', 's', 'MarkerFaceColor', colors{j}{2}, 'linestyle', 'none');
 
 if(pdegree\>0\)
 h(3\) \= plot (lx\_low, fitRate\_low, 'color', colors{j}{1}, 'linestyle', ':', 'LineWidth', 2\);
 h(4\) \= plot (lx\_high, fitRate\_high, 'color', colors{j}{2}, 'linestyle', '\-', 'LineWidth', 2\);
 end
 
 title(names{j});
 
 ax \= gca;
 ax.Box \= 'off';
 % axis square
 
 ax.YLim \= \[0 15];
 % ax.YTick \= \[0 5 10];
 ax.YLabel.String \= 'turn rate (min^{\-1})';
 ax.YLabel.FontSize \= 10;
 ax.XTick \= \[\-10 \-5 0 5 10];
 ax.XLabel.String \= 'Filtered Stimulus Value';
 ax.XLabel.FontSize \= 10;
 
 if(strcmpi(stim, 'red'))
 ax.XAxis.Color \= 'r';
 elseif(strcmpi(stim, 'blue'))
 ax.XAxis.Color \= 'b';
 else
 ax.XAxis.Color \= \[.6 0 0\.4];
 end
 ah(j).handles \= h;
 
 
 % set(ah(j).ax, 'Children', h);
 
 
 end

 case '1stimRF\_full\_low\_ker'
 
 SF \= 60;
 
 
 for j \= 1:length(btdstruct)
 
 
 if( strncmpi(btdstruct(j).var(StimNum).gqname, 'led2', 4\))
 stim \= 'blue';
 elseif( strncmpi(btdstruct(j).var(StimNum).gqname, 'led1', 4\))
 stim \= 'red';
 end
 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 
 if(isfield(btdstruct(j), 'RatesU'))
 Rates \= btdstruct(j).RatesU;
 stim \= 'purple';
 elseif(isfield(btdstruct(j), 'Rates'))
 Rates \= btdstruct(j).Rates;
 else
 Rates \= btdstruct(j);
 end
 
 if(nargin\>5\)
 k \= StimNum;
 else
 k\=1;
 end
 
 lx\_low\_full \= Rates.rfLowVar(k).lx;
 lx\_low\_low \= Rates.rfLowVar\_LK(k).lx;
 rate\_low\_full \= SF\*Rates.rfLowVar(k).rate;
 rate\_eb\_low\_full \= SF\*Rates.rfLowVar(k).rate\_eb;
 rate\_low\_low \= SF\*Rates.rfLowVar\_LK(k).rate;
 rate\_eb\_low\_low \= SF\*Rates.rfLowVar\_LK(k).rate\_eb;
 
 
 if(pdegree\=\=1\) 
 fitRate\_low\_full \= SF\*exp(polyval(Rates.rfLowVar(k).rateFitLin, lx\_low\_full)); 
 fitRate\_low\_low \= SF\*exp(polyval(Rates.rfLowVar\_LK(k).rateFitLin, lx\_low\_low));
 elseif(pdegree\=\=2\)
 fitRate\_low\_full \= SF\*exp(polyval(Rates.rfLowVar(k).rateFitQuad, lx\_low\_full));
 fitRate\_low\_low \= SF\*exp(polyval(Rates.rfLowVar\_LK(k).rateFitQuad, lx\_low\_low));
 end
 
 
 
 h(1\) \= errorbar (lx\_low\_full, rate\_low\_full, rate\_eb\_low\_full, 'color', colors{j}{1}, 'marker', 'o', 'linestyle', 'none'); %'MarkerSize', 5, 'CapSize', 5
 hold all;
 h(2\) \= errorbar (lx\_low\_low, rate\_low\_low, rate\_eb\_low\_low, 'color', colors{j}{2}, 'marker', 's', 'MarkerFaceColor', colors{j}{2}, 'linestyle', 'none');
 
 if(pdegree\>0\)
 h(3\) \= plot (lx\_low\_full, fitRate\_low\_full, 'color', colors{j}{1}, 'linestyle', ':', 'LineWidth', 2\);
 h(4\) \= plot (lx\_low\_full, fitRate\_low\_low, 'color', colors{j}{2}, 'linestyle', '\-', 'LineWidth', 2\);
 end
 
 title(names{j});
 
 ax \= gca;
 ax.Box \= 'off';
 % axis square
 
 ax.YLim \= \[0 15];
 % ax.YTick \= \[0 5 10];
 ax.YLabel.String \= 'turn rate (min^{\-1})';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'Filtered Stimulus Value';
 ax.XLabel.FontSize \= 10;
 
 if(strcmpi(stim, 'red'))
 ax.XAxis.Color \= 'r';
 elseif(strcmpi(stim, 'blue'))
 ax.XAxis.Color \= 'b';
 else
 ax.XAxis.Color \= \[.6 0 0\.4];
 end
 ah(j).handles \= h;
 
 
 % set(ah(j).ax, 'Children', h);
 
 
 end

 case '1stimRF\_full\_high\_ker'
 
 SF \= 60;
 
 
 for j \= 1:length(btdstruct)
 
 
 if( strncmpi(btdstruct(j).var(StimNum).gqname, 'led2', 4\))
 stim \= 'blue';
 elseif( strncmpi(btdstruct(j).var(StimNum).gqname, 'led1', 4\))
 stim \= 'red';
 end
 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 
 if(isfield(btdstruct(j), 'RatesU'))
 Rates \= btdstruct(j).RatesU;
 stim \= 'purple';
 elseif(isfield(btdstruct(j), 'Rates'))
 Rates \= btdstruct(j).Rates;
 else
 Rates \= btdstruct(j);
 end
 
 if(nargin\>5\)
 k \= StimNum;
 else
 k\=1;
 end
 
 
 lx\_high\_full \= Rates.rfHighVar(k).lx;
 lx\_high\_high \= Rates.rfHighVar\_HK(k).lx;
 rate\_high\_full \= SF\*Rates.rfHighVar(k).rate;
 rate\_eb\_high\_full \= SF\*Rates.rfHighVar(k).rate\_eb;
 rate\_high\_high \= SF\*Rates.rfHighVar\_HK(k).rate;
 rate\_eb\_high\_high \= SF\*Rates.rfHighVar\_HK(k).rate\_eb;
 
 if(pdegree\=\=1\)
 
 fitRate\_high\_full \= SF\*exp(polyval(Rates.rfHighVar(k).rateFitLin, lx\_high\_full));
 fitRate\_high\_high \= SF\*exp(polyval(Rates.rfHighVar\_HK(k).rateFitLin, lx\_high\_high));
 elseif(pdegree\=\=2\)
 fitRate\_high\_full \= SF\*exp(polyval(Rates.rfHighVar(k).rateFitQuad, lx\_high\_full));
 fitRate\_high\_high \= SF\*exp(polyval(Rates.rfHighVar\_HK(k).rateFitQuad, lx\_high\_high));
 end
 
 
 
 h(1\) \= errorbar (lx\_high\_full, rate\_high\_full, rate\_eb\_high\_full, 'color', colors{j}{1}, 'marker', 'o', 'linestyle', 'none'); %'MarkerSize', 5, 'CapSize', 5
 hold all;
 h(2\) \= errorbar (lx\_high\_high, rate\_high\_high, rate\_eb\_high\_high, 'color', colors{j}{2}, 'marker', 's', 'MarkerFaceColor', colors{j}{2}, 'linestyle', 'none');
 
 if(pdegree\>0\)
 h(3\) \= plot (lx\_high\_full, fitRate\_high\_full, 'color', colors{j}{1}, 'linestyle', ':', 'LineWidth', 2\);
 h(4\) \= plot (lx\_high\_full, fitRate\_high\_high, 'color', colors{j}{2}, 'linestyle', '\-', 'LineWidth', 2\);
 end
 
 title(names{j});
 
 ax \= gca;
 ax.Box \= 'off';
 % axis square
 
 ax.YLim \= \[0 15];
 % ax.YTick \= \[0 5 10];
 ax.YLabel.String \= 'turn rate (min^{\-1})';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'Filtered Stimulus Value';
 ax.XLabel.FontSize \= 10;
 
 if(strcmpi(stim, 'red'))
 ax.XAxis.Color \= 'r';
 elseif(strcmpi(stim, 'blue'))
 ax.XAxis.Color \= 'b';
 else
 ax.XAxis.Color \= \[.6 0 0\.4];
 end
 ah(j).handles \= h;
 
 
 % set(ah(j).ax, 'Children', h);
 
 
 end 

 case '1stimRF\_both\_ker'
 
 SF \= 60;
 
 
 for j \= 1:length(btdstruct)
 
 
 if( strncmpi(btdstruct(j).var(StimNum).gqname, 'led2', 4\))
 stim \= 'blue';
 elseif( strncmpi(btdstruct(j).var(StimNum).gqname, 'led1', 4\))
 stim \= 'red';
 end
 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 
 if(isfield(btdstruct(j), 'RatesU'))
 Rates \= btdstruct(j).RatesU;
 stim \= 'purple';
 elseif(isfield(btdstruct(j), 'Rates'))
 Rates \= btdstruct(j).Rates;
 else
 Rates \= btdstruct(j);
 end
 
 if(nargin\>5\)
 k \= StimNum;
 else
 k\=1;
 end
 
 
 lx\_high\_full \= Rates.rfHighVar(k).lx;
 lx\_high\_high \= Rates.rfHighVar\_HK(k).lx;
 rate\_high\_full \= SF\*Rates.rfHighVar(k).rate;
 rate\_eb\_high\_full \= SF\*Rates.rfHighVar(k).rate\_eb;
 rate\_high\_high \= SF\*Rates.rfHighVar\_HK(k).rate;
 rate\_eb\_high\_high \= SF\*Rates.rfHighVar\_HK(k).rate\_eb;
 
 lx\_low\_full \= Rates.rfLowVar(k).lx;
 lx\_low\_low \= Rates.rfLowVar\_LK(k).lx;
 rate\_low\_full \= SF\*Rates.rfLowVar(k).rate;
 rate\_eb\_low\_full \= SF\*Rates.rfLowVar(k).rate\_eb;
 rate\_low\_low \= SF\*Rates.rfLowVar\_LK(k).rate;
 rate\_eb\_low\_low \= SF\*Rates.rfLowVar\_LK(k).rate\_eb;
 
 if(pdegree\=\=1\)
 
 fitRate\_high\_full \= SF\*exp(polyval(Rates.rfHighVar(k).rateFitLin, lx\_high\_full));
 fitRate\_high\_high \= SF\*exp(polyval(Rates.rfHighVar\_HK(k).rateFitLin, lx\_high\_high));
 fitRate\_low\_full \= SF\*exp(polyval(Rates.rfLowVar(k).rateFitLin, lx\_low\_full)); 
 fitRate\_low\_low \= SF\*exp(polyval(Rates.rfLowVar\_LK(k).rateFitLin, lx\_low\_low));
 elseif(pdegree\=\=2\)
 fitRate\_high\_full \= SF\*exp(polyval(Rates.rfHighVar(k).rateFitQuad, lx\_high\_full));
 fitRate\_high\_high \= SF\*exp(polyval(Rates.rfHighVar\_HK(k).rateFitQuad, lx\_high\_high));
 fitRate\_low\_full \= SF\*exp(polyval(Rates.rfLowVar(k).rateFitQuad, lx\_low\_full));
 fitRate\_low\_low \= SF\*exp(polyval(Rates.rfLowVar\_LK(k).rateFitQuad, lx\_low\_low));
 end
 
 
 
 h(1\) \= errorbar (lx\_high\_full, rate\_high\_full, rate\_eb\_high\_full, 'color', colors{1}, 'marker', 'o', 'linestyle', 'none'); %'MarkerSize', 5, 'CapSize', 5
 hold all;
 h(2\) \= errorbar (lx\_high\_high, rate\_high\_high, rate\_eb\_high\_high, 'color', colors{2}, 'marker', 's', 'MarkerFaceColor', colors{2}, 'linestyle', 'none');
 h(3\) \= errorbar (lx\_low\_full, rate\_low\_full, rate\_eb\_low\_full, 'color', colors{3}, 'marker', 'o', 'linestyle', 'none'); %'MarkerSize', 5, 'CapSize', 5
 h(4\) \= errorbar (lx\_low\_low, rate\_low\_low, rate\_eb\_low\_low, 'color', colors{4}, 'marker', 's', 'MarkerFaceColor', colors{4}, 'linestyle', 'none');
 if(pdegree\>0\)
 h(5\) \= plot (lx\_high\_full, fitRate\_high\_full, 'color', colors{1}, 'linestyle', ':', 'LineWidth', 2\);
 h(6\) \= plot (lx\_high\_full, fitRate\_high\_high, 'color', colors{2}, 'linestyle', '\-', 'LineWidth', 2\);
 h(7\) \= plot (lx\_low\_full, fitRate\_low\_full, 'color', colors{3}, 'linestyle', ':', 'LineWidth', 2\);
 h(8\) \= plot (lx\_low\_full, fitRate\_low\_low, 'color', colors{4}, 'linestyle', '\-', 'LineWidth', 2\);
 end
 
 title(names{j});
 
 ax \= gca;
 ax.Box \= 'off';
 % axis square
 
 ax.YLim \= \[0 15];
 % ax.YTick \= \[0 5 10];
 ax.YLabel.String \= 'turn rate (min^{\-1})';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'Filtered Stimulus Value';
 ax.XLabel.FontSize \= 10;
 
 if(strcmpi(stim, 'red'))
 ax.XAxis.Color \= 'r';
 elseif(strcmpi(stim, 'blue'))
 ax.XAxis.Color \= 'b';
 else
 ax.XAxis.Color \= \[.6 0 0\.4];
 end
 ah(j).handles \= h;
 
 
 % set(ah(j).ax, 'Children', h);
 
 
 end
 
 case '1stimRF\_levels'
 
 SF \= 60;
 
 
 for j \= 1:length(btdstruct)
 
 
 if( strncmpi(btdstruct(j).var(StimNum).gqname, 'led2', 4\))
 stim \= 'blue';
 elseif( strncmpi(btdstruct(j).var(StimNum).gqname, 'led1', 4\))
 stim \= 'red';
 end
 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 
 if(isfield(btdstruct(j), 'RatesU'))
 Rates \= btdstruct(j).RatesU;
 stim \= 'purple';
 elseif(isfield(btdstruct(j), 'Rates'))
 Rates \= btdstruct(j).Rates;
 else
 Rates \= btdstruct(j);
 end
 
 if(nargin\>5\)
 k \= StimNum;
 else
 k\=1;
 end
 
 lx\_low \= Rates.rfLowVar\_lvl(k).lx;
 lx\_high \= Rates.rfHighVar\_lvl(k).lx;
 rate\_low \= SF\*Rates.rfLowVar\_lvl(k).rate;
 rate\_eb\_low \= SF\*Rates.rfLowVar\_lvl(k).rate\_eb;
 rate\_high \= SF\*Rates.rfHighVar\_lvl(k).rate;
 rate\_eb\_high \= SF\*Rates.rfHighVar\_lvl(k).rate\_eb;
 
 if(pdegree\=\=1\)
 
 fitRate\_low \= SF\*exp(polyval(Rates.rfLowVar\_lvl(k).rateFitLin, lx\_low));
 fitRate\_high \= SF\*exp(polyval(Rates.rfHighVar\_lvl(k).rateFitLin, lx\_high));
 elseif(pdegree\=\=2\)
 fitRate\_low \= SF\*exp(polyval(Rates.rfLowVar\_lvl(k).rateFitQuad, lx\_low));
 fitRate\_high \= SF\*exp(polyval(Rates.rfHighVar\_lvl(k).rateFitQuad, lx\_high));
 end
 
 h(1\) \= errorbar (lx\_low, rate\_low, rate\_eb\_low, 'color', colors{j}{1}, 'marker', 'o', 'linestyle', 'none'); %'MarkerSize', 5, 'CapSize', 5
 hold all;
 h(2\) \= errorbar (lx\_high, rate\_high, rate\_eb\_high, 'color', colors{j}{2}, 'marker', 's', 'MarkerFaceColor', colors{j}{2}, 'linestyle', 'none');
 
 if(pdegree\>0\)
 h(3\) \= plot (lx\_low, fitRate\_low, 'color', colors{j}{1}, 'linestyle', ':', 'LineWidth', 2\);
 h(4\) \= plot (lx\_high, fitRate\_high, 'color', colors{j}{2}, 'linestyle', '\-', 'LineWidth', 2\);
 end
 
 title(names{j});
 
 ax \= gca;
 ax.Box \= 'off';
 % axis square
 
 ax.YLim \= \[0 15];
 % ax.YTick \= \[0 5 10];
 ax.YLabel.String \= 'turn rate (min^{\-1})';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'Filtered Stimulus Value';
 ax.XLabel.FontSize \= 10;
 
 if(strcmpi(stim, 'red'))
 ax.XAxis.Color \= 'r';
 elseif(strcmpi(stim, 'blue'))
 ax.XAxis.Color \= 'b';
 else
 ax.XAxis.Color \= \[.6 0 0\.4];
 end
 ah(j).handles \= h;
 
 
 % set(ah(j).ax, 'Children', h);
 
 
 end 

 case '1stimRF\_lev\_120kernel'
 
 SF \= 60;
 
 
 for j \= 1:length(btdstruct)
 
 
 if( strncmpi(btdstruct(j).var(StimNum).gqname, 'led2', 4\))
 stim \= 'blue';
 elseif( strncmpi(btdstruct(j).var(StimNum).gqname, 'led1', 4\))
 stim \= 'red';
 end
 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 
 if(isfield(btdstruct(j), 'RatesU'))
 Rates \= btdstruct(j).RatesU;
 stim \= 'purple';
 elseif(isfield(btdstruct(j), 'Rates'))
 Rates \= btdstruct(j).Rates;
 else
 Rates \= btdstruct(j);
 end
 
 if(nargin\>5\)
 k \= StimNum;
 else
 k\=1;
 end
 
 lx\_low \= Rates.rfLowVar\_ber120(k).lx;
 lx\_high \= Rates.rfHighVar\_ber120(k).lx;
 rate\_low \= SF\*Rates.rfLowVar\_ber120(k).rate;
 rate\_eb\_low \= SF\*Rates.rfLowVar\_ber120(k).rate\_eb;
 rate\_high \= SF\*Rates.rfHighVar\_ber120(k).rate;
 rate\_eb\_high \= SF\*Rates.rfHighVar\_ber120(k).rate\_eb;
 
 if(pdegree\=\=1\)
 
 fitRate\_low \= SF\*exp(polyval(Rates.rfLowVar(k).rateFitLin, lx\_low));
 fitRate\_high \= SF\*exp(polyval(Rates.rfHighVar(k).rateFitLin, lx\_high));
 elseif(pdegree\=\=2\)
 fitRate\_low \= SF\*exp(polyval(Rates.rfLowVar(k).rateFitQuad, lx\_low));
 fitRate\_high \= SF\*exp(polyval(Rates.rfHighVar(k).rateFitQuad, lx\_high));
 end
 
 h(1\) \= errorbar (lx\_low, rate\_low, rate\_eb\_low, 'color', colors{j}{1}, 'marker', 'o', 'linestyle', 'none'); %'MarkerSize', 5, 'CapSize', 5
 hold all;
 h(2\) \= errorbar (lx\_high, rate\_high, rate\_eb\_high, 'color', colors{j}{2}, 'marker', 's', 'MarkerFaceColor', colors{j}{2}, 'linestyle', 'none');
 
 if(pdegree\>0\)
 h(3\) \= plot (lx\_low, fitRate\_low, 'color', colors{j}{1}, 'linestyle', ':', 'LineWidth', 2\);
 h(4\) \= plot (lx\_high, fitRate\_high, 'color', colors{j}{2}, 'linestyle', '\-', 'LineWidth', 2\);
 end
 
 title(names{j});
 
 ax \= gca;
 ax.Box \= 'off';
 % axis square
 
 ax.YLim \= \[0 15];
 % ax.YTick \= \[0 5 10];
 ax.YLabel.String \= 'turn rate (min^{\-1})';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'Filtered Stimulus Value';
 ax.XLabel.FontSize \= 10;
 
 if(strcmpi(stim, 'red'))
 ax.XAxis.Color \= 'r';
 elseif(strcmpi(stim, 'blue'))
 ax.XAxis.Color \= 'b';
 else
 ax.XAxis.Color \= \[.6 0 0\.4];
 end
 ah(j).handles \= h;
 
 
 % set(ah(j).ax, 'Children', h);
 
 
 end 
 
 case '1stimScaledRF'
 
 for j\=1:length(btdstruct)
 
 SF \= 60\*deltaT/0\.05;
 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', ah(j).pos);
 ah(j).name \= names{j};
 
 if(isfield(btdstruct(j), 'ScaledRatesU'))
 ScaledRates \= btdstruct(j).ScaledRatesU;
 elseif(isfield(btdstruct(j), 'ScaledRates'))
 ScaledRates \= btdstruct(j).ScaledRates;
 else
 ScaledRates \= btdstruct(j);
 end
 rfH \= ScaledRates.scaledRFHigh(1\);
 rfL \= ScaledRates.scaledRFLow(1\);
 rfU \= ScaledRates.scaledRFUp(1\);
 rfD \= ScaledRates.scaledRFDown(1\);
 
 if(pdegree \=\= 1\)
 fitH \= rfH.rateFitLin;
 fitL \= rfL.rateFitLin;
 fitU \= rfU.rateFitLin;
 fitD \= rfD.rateFitLin;
 else
 fitH \= rfH.rateFitQuad;
 fitL \= rfL.rateFitQuad;
 fitU \= rfU.rateFitQuad;
 fitD \= rfD.rateFitQuad;
 end
 
 h(1\) \= errorbar(rfH.lx, SF\*rfH.rate, SF\*rfH.rate\_eb, 'color', colors{j}{1}, 'marker', 'o', 'linestyle', 'none');
 hold all
 h(2\) \= errorbar(rfL.lx, SF\*rfL.rate, SF\*rfL.rate\_eb, 'color', colors{j}{2}, 'marker', 's', 'linestyle', 'none');
 h(3\) \= errorbar(rfU.lx, SF\*rfU.rate, SF\*rfU.rate\_eb, 'color', 'm', 'marker', '^', 'linestyle', 'none');
 h(4\) \= errorbar(rfD.lx, SF\*rfD.rate, SF\*rfD.rate\_eb, 'color', 'c', 'marker', 'v', 'linestyle', 'none');
 %
 h(5\) \= plot(rfH.lx, SF\*exp(polyval(fitH, rfH.lx)), 'color', colors{j}{1});
 h(6\) \= plot( rfL.lx, SF\*exp(polyval(fitL, rfL.lx)), 'color', colors{j}{2});
 h(7\) \= plot(rfU.lx, SF\*exp(polyval(fitU, rfU.lx)), 'color', 'm');
 h(8\) \= plot( rfD.lx, SF\*exp(polyval(fitD, rfD.lx)), 'color', 'c');
 
 ax \= gca;
 %
 % if(log)
 % ax.YScale \= 'log';
 % ax.YLim \= \[0\.4 20];
 % ax.YTick \= \[1 2 5 10 20];
 % ax.YMinorTick \= 'off';
 % ax.YTickLabel \= {'1', '2', '5', '10', '20', '30'};
 % end
 ax.YLabel.String \= 'turn rate (min^{\-1})';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'Scaled Stimulus Value \- \\alpha\\cdotx';
 ax.XLabel.FontSize \= 10;
 ax.Box \= 'off';
 
 
 title(names{j});
 ah(j).handles \= h;
 end
 
 case '2stimPPF'
 
 for j\=1:length(btdstruct)
 
 tshift \= 3;
 
 period \= btdstruct(j).var.period;
 
 if(strcmpi(estimator, 'PPF'))
 tx \= btdstruct(j).alphavseti.tx\_ton;
 dt \= round(period)/length(tx);
 alpha \= btdstruct(j).alphavseti.alpha\_ton(1,:);
 beta \= btdstruct(j).alphavseti.alpha\_ton(2,:);
 valpha \= sqrt(squeeze(btdstruct(j).alphavseti.valpha\_ton(1,1,:)));
 vbeta \= sqrt(squeeze(btdstruct(j).alphavseti.valpha\_ton(2,2,:)));
 elseif(strcmpi(estimator, 'Bayes'))
 if(strncmpi(multiType, 'add', 3\))
 BayesStruct \= btdstruct(j).BayesAlphavsEti\_OL.add;
 elseif(strncmpi(multiType, 'mult', 3\))
 BayesStruct \= btdstruct(j).BayesAlphavsEti\_OL.multiply;
 else
 BayesStruct \= btdstruct(j).BayesAlphavsEti\_OL;
 end
 tx \= BayesStruct.tx\_ton;
 dt \= round(period)/length(tx);
 alpha \= BayesStruct.alpha\_ton(1,:);
 beta \= BayesStruct.alpha\_ton(2,:);
 valpha \= sqrt(squeeze(BayesStruct.valpha\_ton(1,1,:)))';
 vbeta \= sqrt(squeeze(BayesStruct.valpha\_ton(2,2,:)))';
 
 end

 tx\_shift \= \-fliplr(tx);
 % tEst \= \[\-tshift:dt:tx\_ton(1\), tx\_ton];
 alpha\_shift \= circshift(alpha, round(length(tx)/2\));
 beta\_shift \= circshift(beta, round(length(tx)/2\));
 valpha\_shift \= circshift(valpha, round(length(tx)/2\));
 vbeta\_shift \= circshift(vbeta, round(length(tx)/2\));
 
 tEst \= \[tx\_shift(round(end\-tshift/dt):end), tx];
 aEst \= \[alpha\_shift(round(end\-tshift/dt):end), alpha\_shift];
 vaEst \= \[valpha\_shift(round(end\-tshift/dt):end), valpha\_shift];
 bEst \= \[beta\_shift(round(end\-tshift/dt):end), beta\_shift];
 vbEst \= \[vbeta\_shift(round(end\-tshift/dt):end), vbeta\_shift];

 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', ah(j).pos);
 ah(j).name \= names{j};
 
 h(1,:) \= shadedErrorPlot({tEst tEst}, {aEst bEst}, {vaEst, vbEst}, {vaEst, vbEst}, {colors{1}, colors{2}});
 
 
 pp \= h(1,:).Parent;
 pp.XTick \= \[0 20 pp.XLim(2\)];
 pp.XTickLabel \= {'0', '20', num2str(round(period))};
 
 pp.Children(1\).LineWidth \= 1\.5;
 pp.Children(2\).LineWidth \= 1\.5;
 
 ax \= gca;
 ax.YLim \= \[0\.6 1\.7];
 hold on
 plot(\[0 0], \[ax.YLim(1\) ax.YLim(2\)], 'k\-\-', 'linewidth', 1\.5\);
 plot(\[period/2 period/2], \[ax.YLim(1\) ax.YLim(2\)], 'k\-\-', 'linewidth', 1\.5\);
 
 ax.YLabel.String \= '\\alpha';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'time in cycle (s)';
 ax.XLabel.FontSize \= 10;
 
 
 ax.DataAspectRatio \= \[30 1 1];
 
 ax.Box \= 'off';
 title(names{j});
 ah(j).handles \= h;
 
 
 end
 
 
 
 case 'TTA'
 
 
 lowp \= @(x) lowpass1D(x, 2\.5\);
 
 for j\=1:length(btdstruct)
 
 
 if( strncmpi(btdstruct(j).var.gqname, 'led2', 4\))
 stim \= 'blue';
 elseif( strncmpi(btdstruct(j).var.gqname, 'led1', 4\))
 stim \= 'red';
 end
 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 ttaxis \= btdstruct(j).Kernels.High.taxis;
 ttaL \= btdstruct(j).Kernels.Low.tta;
 ttaH \= btdstruct(j).Kernels.High.tta;
 SFLmax \= max(abs(lowp(ttaL)));
 SFHmax \= max(abs(lowp(ttaH)));
 SFLmin \= min(lowp(ttaL));
 SFHmin \= min(lowp(ttaH));
 ttaL \= ttaL/SFLmax;
 ttaH \= ttaH/SFHmax;

 
 
 h(1\) \= plot (ttaxis, lowp(ttaL), 'color', colors{j}{1}, 'LineWidth', 1\.5\);
 hold all
 h(2\) \= plot (ttaxis, lowp(ttaH), 'color', colors{j}{2}, 'LineWidth', 1\.5\);
 
 
 title(names{j});
 
 % axis square
 ax \= gca;
 ax.Box \= 'off';
 ax.XLim \= \[min(ttaxis) max(ttaxis)];
 ax.XLim \= \[\-6 1];
 ax.YLim \= \[min(ttaH) max(ttaH)];
 ax.YTick \= 0;
 ax.YTickLabel \= '0';
 
 if(strcmpi(stim, 'red'))
 ax.YAxis.Color \= 'r';
 ax.YLabel.String \= {'Avg. Red'; 'Intensity Derivative (Scaled)'};
 elseif(strcmpi(stim, 'blue'))
 ax.YAxis.Color \= 'b';
 ax.YLabel.String \= {'Avg. Blue'; 'Intensity Derivative (Scaled)'};
 if(strcmpi(btdstruct(j).var.gqname, 'led2Val'))
 ax.YAxis.Color \= 'b';
 ax.YLabel.String \= {'Avg. Blue'; 'Intensity (Scaled)'};
 end
 end
 
 ax.YLabel.FontSize \= 8;
 ax.XLabel.String \= {'time (s)'; 'rel. to turn start'};
 ax.XLabel.FontSize \= 10;
 h(3\) \= plot(\[0 0], \[min(ax.YLim) max(ax.YLim)], 'k:', 'LineWidth', 1\.5\);
 h(4\) \= plot(\[min(ax.XLim) max(ax.XLim)], \[0 0], 'k\-\-', 'LineWidth', 0\.1\);
 
 ah(j).handles \= h;
 
 end
 
 case 'TTA\_levels'
 
 
 lowp \= @(x) lowpass1D(x, 2\.5\);
 
 for j\=1:length(btdstruct)
 
 
 if( strncmpi(btdstruct(j).var.gqname, 'led2', 4\))
 stim \= 'blue';
 elseif( strncmpi(btdstruct(j).var.gqname, 'led1', 4\))
 stim \= 'red';
 end
 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 ttaxis \= btdstruct(j).Kernels.High\_lvl.taxis;
 ttaL \= btdstruct(j).Kernels.Low\_lvl.tta;
 ttaH \= btdstruct(j).Kernels.High\_lvl.tta;
 SFLmax \= max(lowp(ttaL));
 SFHmax \= max(lowp(ttaH));
 SFLmin \= min(lowp(ttaL));
 SFHmin \= min(lowp(ttaH));
 ttaL \= ttaL/(SFLmax\-SFLmin);
 ttaH \= ttaH/(SFHmax\-SFHmin);
 
 h(1\) \= plot (ttaxis, lowp(ttaL), 'color', colors{j}{1}, 'LineWidth', 1\.5\);
 hold all
 h(2\) \= plot (ttaxis, lowp(ttaH), 'color', colors{j}{2}, 'LineWidth', 1\.5\);
 
 
 title(names{j});
 
 % axis square
 ax \= gca;
 ax.Box \= 'off';
 ax.XLim \= \[min(ttaxis) max(ttaxis)];
 ax.XLim \= \[\-6 1];
 ax.YLim \= \[min(ttaH) max(ttaH)];
 ax.YTick \= 0;
 ax.YTickLabel \= '0';
 
 if(strcmpi(stim, 'red'))
 ax.YAxis.Color \= 'r';
 ax.YLabel.String \= {'Avg. Red'; 'Intensity (Scaled)'};
 elseif(strcmpi(stim, 'blue'))
 ax.YAxis.Color \= 'b';
 ax.YLabel.String \= {'Avg. Blue'; 'Intensity (Scaled)'};
 end
 
 ax.YLabel.FontSize \= 8;
 ax.XLabel.String \= {'time (s)'; 'rel. to turn start'};
 ax.XLabel.FontSize \= 10;
 h(3\) \= plot(\[0 0], \[min(ax.YLim) max(ax.YLim)], 'k:', 'LineWidth', 1\.5\);
 h(4\) \= plot(\[min(ax.XLim) max(ax.XLim)], \[0 0], 'k:', 'LineWidth', 1\.5\);
 
 ah(j).handles \= h;
 
 end
 
 case 'TTA\_bootstrap'
 
 
 lowp \= @(x) lowpass1D(x, 2\.5\);
 
 
 
 ah.pos \= pos{1}; %\#ok\<\*AGROW\>
 ah.ax \= axes('Position', pos{1});
 ah.name \= names{1};
 
 ttaxis \= btdstruct.High.taxis;
 ttaL \= btdstruct.Low.bootstrapMean;
 ttaH \= btdstruct.High.bootstrapMean;
 ttaLs \= btdstruct.Low.bootstrapStd;
 ttaHs \= btdstruct.High.bootstrapStd;
 SFLmax \= max(abs(lowp(ttaL)));
 SFHmax \= max(abs(lowp(ttaH)));
 SFLmin \= min(lowp(ttaL));
 SFHmin \= min(lowp(ttaH));
 ttaL \= ttaL/(SFLmax);
 ttaH \= ttaH/(SFHmax);
 ttaLs \= ttaLs/(SFLmax);
 ttaHs \= ttaHs/(SFHmax);
 
 temp \= shadedErrorPlot({ttaxis ttaxis}, {lowp(ttaL) lowp(ttaH)}, {lowp(ttaLs) lowp(ttaHs)});
 h(1\) \= temp(1\);
 h(2\) \= temp(2\);
 h(3\) \= temp(3\);
 
 title(names{1});
 pp \= h(1\).Parent;
% pp.Children(1\).Color \= 1/255\*\[74 137 165];
% pp.Children(2\).Color \= \[.8 0\.2 0\.6];
% pp.Children(1\).LineWidth \= 1\.5;
% pp.Children(2\).LineWidth \= 1\.2;
% pp.Children(3\).FaceColor \= 1/255\*\[57 70 156];
% pp.Children(4\).FaceColor \= \[.4 0 0\.6];
% pp.Children(3\).FaceAlpha \= 0\.5;
% pp.Children(4\).FaceAlpha \= .3;
 pp.Children(1\).Color \= colors{1}{1};
 pp.Children(2\).Color \= colors{1}{2};
 pp.Children(1\).LineWidth \= 1\.5;
 pp.Children(2\).LineWidth \= 1\.2;
 pp.Children(3\).FaceColor \= colors{1}{1};
 pp.Children(4\).FaceColor \= colors{1}{2};
 pp.Children(3\).FaceAlpha \= 0\.5;
 pp.Children(4\).FaceAlpha \= 0\.3;
 % axis square
 ax \= gca;
 ax.Box \= 'off';
 ax.XLim \= \[min(ttaxis) max(ttaxis)];
 ax.XLim \= \[\-6 1];
 ax.YLim \= \[min(ttaH) max(ttaH)];
 ax.YTick \= 0;
 ax.YTickLabel \= '0';
 
 if(strncmpi(names, 'Berlin',6\))
 ax.YAxis.Color \= 'b';
 ax.YLabel.String \= {'Avg. Blue'; 'Intensity Derivative (Scaled)'};
 else
 ax.YAxis.Color \= 'r';
 ax.YLabel.String \= {'Avg. Red'; 'Intensity Derivative (Scaled)'};
 end 
 
 ax.YLabel.FontSize \= 8;
 ax.XLabel.String \= {'time (s)'; 'rel. to turn start'};
 ax.XLabel.FontSize \= 10;
 hold on;
 h(4\) \= plot(\[0 0], \[min(ax.YLim) max(ax.YLim)], 'k:', 'LineWidth', 1\.5\);
 h(5\) \= plot(\[min(ax.XLim) max(ax.XLim)], \[0 0], 'k\-\-', 'LineWidth', 0\.1\);
 
 ah.handles \= h;
 hold off;
 
 
 case 'TTA\-AccRej'
 
 for j\=1:length(btdstruct)
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 taxis \= btdstruct(j).Kernels.Low.taxis;
 ttaL \= btdstruct(j).Kernels.Low.tta;
 ttaH \= btdstruct(j).Kernels.High.tta;
 ttaD \= btdstruct(j).Kernels.Down.tta;
 ttaU \= btdstruct(j).Kernels.Up.tta;
 
 
 AccL \= btdstruct(j).Kernels.Low.tta\_acchs; AccL \= AccL/max(abs(AccL));
 RejL \= btdstruct(j).Kernels.Low.tta\_rejhs; RejL \= RejL/max(abs(RejL));
 AccH \= btdstruct(j).Kernels.High.tta\_acchs; AccH \= AccH/max(abs(AccH));
 RejH \= btdstruct(j).Kernels.High.tta\_rejhs; RejH \= RejH/max(abs(RejH));
 AccU \= btdstruct(j).Kernels.Up.tta\_acchs; AccU \= AccU/max(abs(AccU));
 RejU \= btdstruct(j).Kernels.Up.tta\_rejhs; RejU \= RejU/max(abs(RejU));
 AccD \= btdstruct(j).Kernels.Down.tta\_acchs; AccD \= AccD/max(abs(AccD));
 RejD \= btdstruct(j).Kernels.Down.tta\_rejhs; RejD \= RejD/max(abs(RejD));
 
 % SFL \= max( max(abs(AccL)), max(abs(RejL)) );
 % SFH \= max( max(abs(AccH)), max(abs(RejH)) );
 % SFU \= max( max(abs(AccU)), max(abs(RejU)) );
 % SFD \= max( max(abs(AccD)), max(abs(RejD)) );
 % AccL \= AccL/SFL;
 % RejL \= RejL/SFL;
 % AccH \= AccH/SFH;
 % RejH \= RejH/SFH;
 % AccU \= AccU/SFU;
 % RejU \= RejU/SFU;
 % AccD \= AccD/SFD;
 % RejD \= RejD/SFD;
 
 h(1\) \= plot (taxis, lowpass1D(AccL, 2\.5\), ':', 'color', colors{j}{1}, 'LineWidth', 1\.5\);
 hold all
 h(2\) \= plot (taxis, lowpass1D(RejL, 2\.5\), '\-\-', 'color', colors{j}{1}, 'LineWidth', 1\.5\);
 h(3\) \= plot (taxis, lowpass1D(AccH, 2\.5\), ':', 'color', colors{j}{2}, 'LineWidth', 1\.5\);
 h(4\) \= plot (taxis, lowpass1D(RejH, 2\.5\), '\-\-', 'color', colors{j}{2}, 'LineWidth', 1\.5\);
 
 ax \= gca;
 ax.Box \= 'off';
 ax.XLim \= \[\-7 6];
 ax.YLim \= \[min(\[min(RejH), min(AccH), min(AccL), min(RejL)]) max(\[max(RejH), max(AccH), max(AccL), max(RejL)])];
 ax.YTick \= 0;
 ax.YTickLabel \= '0';
 ax.YAxis.Color \= 'r';
 
 ax.YLabel.String \= {'Avg. Red'; 'Intensity Derivative (Scaled)'};
 ax.YLabel.FontSize \= 8;
 ax.XLabel.String \= {'time (s)'; 'rel. to turn start'};
 ax.XLabel.FontSize \= 10;
 h(3\) \= plot(\[0 0], \[min(ax.YLim) max(ax.YLim)], 'k:', 'LineWidth', 1\.5\);
 h(4\) \= plot(\[min(ax.XLim) max(ax.XLim)], \[0 0], 'k\-\-', 'LineWidth', 0\.1\);
 
 ah(j).handles \= h;
 
 title(names{j});
 
 end
 
 case 'VarRamp'
 
 for j \= 1:length(btdstruct)
 
 clear h h2 h3
 nstim \= size(btdstruct(j).var, 2\);
 
 SF \= 60;
 
 k \= j\+length(btdstruct);
 kk \= j\+2\*length(btdstruct);
 
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 
 
 if(strcmpi(estimator, 'PPF'))
 GR \= btdstruct(j).gainrescaling\_PPF;
 if(nstim\=\=1\)
 ton \= btdstruct(j).alphavseti.tx\_ton;
 alpha\_s \= btdstruct(j).alphavseti.alpha\_s\_ton;
 valpha\_s \= sqrt(squeeze(btdstruct(j).alphavseti.valpha\_s\_ton));
 else
 ton \= btdstruct(j).alphavseti\_U.tx\_ton;
 alpha\_s \= btdstruct(j).alphavseti\_U.alpha\_s\_ton;
 valpha\_s \= sqrt(squeeze(btdstruct(j).alphavseti\_U.valpha\_s\_ton));
 end
 else
 GR \= btdstruct(j).gainrescaling\_Bayes;
 if(nstim\=\=1\)
 ton \= btdstruct(j).BayesAlphavsEti\_OL.tx\_ton;
 alpha\_s \= btdstruct(j).BayesAlphavsEti\_OL.alpha\_ton;
 valpha\_s \= sqrt(squeeze(btdstruct(j).BayesAlphavsEti\_OL.valpha\_ton)');
 else
 ton \= btdstruct(j).BayesAlphavsEti\_U.tx\_ton;
 alpha\_s \= btdstruct(j).BayesAlphavsEti\_U.alpha\_ton;
 valpha\_s \= sqrt(squeeze(btdstruct(j).BayesAlphavsEti\_U.valpha\_ton));
 end
 end
 
 sall \= GR.son\_all;
 sup \= sall(1:round(end/2\)\-1\);
 sdown \= sall(round(end/2\+1\):end);
 alpha\_s\_up \= alpha\_s(1:round(end/2\)\-1\);
 alpha\_s\_down \= alpha\_s(round(end/2\)\+1:end);
 fP \= GR.params.all;
 fitfun \= GR.fitfun;
 
 \[xu, aup, \~, aup\_eb] \= meanyvsx(sup, alpha\_s\_up, linspace(min(sup), max(sup), 8\));
 \[xd, adown, \~, adown\_eb] \= meanyvsx(sdown, alpha\_s\_down, linspace(min(sdown), max(sdown), 8\));
 \[xsall, aall, \~, aall\_eb] \= meanyvsx(sall, alpha\_s, linspace(min(sall), max(sall), 8\));
 
 %{
 if(nstim\=\=1\)
 rates \= btdstruct(j).Rates;
% scaled\_rates \= btdstruct(j).ScaledRates;
 else
 rates \= btdstruct(j).RatesU;
% scaled\_rates \= btdstruct(j).ScaledRatesU;
 end
 xH \= rates.rfHighVar.lx;
 rH \= SF\*rates.rfHighVar.rate;
 rH\_eb \= SF\*rates.rfHighVar.rate\_eb;
 xL \= rates.rfLowVar.lx;
 rL \= SF\*rates.rfLowVar.rate;
 rL\_eb \= SF\*rates.rfLowVar.rate\_eb;
 
 sxH \= scaled\_rates.scaledRFHigh.lx;
 srH \= SF\*scaled\_rates.scaledRFHigh.rate;
 srH\_eb \= SF\*scaled\_rates.scaledRFHigh.rate\_eb;
 sxL \= scaled\_rates.scaledRFLow.lx;
 srL \= SF\*scaled\_rates.scaledRFLow.rate;
 srL\_eb \= SF\*scaled\_rates.scaledRFLow.rate\_eb;

 
 if(nstim\=\=2\)
 ratesBR \= btdstruct(j).Rates;
 scaled\_ratesBR \= btdstruct(j).ScaledRates;
 
 xHo \= ratesBR.rfHighVar(1\).lx;
 rHo \= SF\*ratesBR.rfHighVar(1\).rate;
 rHo\_eb \= SF\*ratesBR.rfHighVar(1\).rate\_eb;
 xLo \= ratesBR.rfLowVar(1\).lx;
 rLo \= SF\*ratesBR.rfLowVar(1\).rate;
 rLo\_eb \= SF\*ratesBR.rfLowVar(1\).rate\_eb;
 
 sxHo \= scaled\_ratesBR.scaledRFHigh(1\).lx;
 srHo \= SF\*scaled\_ratesBR.scaledRFHigh(1\).rate;
 srHo\_eb \= SF\*scaled\_ratesBR.scaledRFHigh(1\).rate\_eb;
 sxLo \= scaled\_ratesBR.scaledRFLow(1\).lx;
 srLo \= SF\*scaled\_ratesBR.scaledRFLow(1\).rate;
 srLo\_eb \= SF\*scaled\_ratesBR.scaledRFLow(1\).rate\_eb;
 
 xHl \= ratesBR.rfHighVar(2\).lx;
 rHl \= SF\*ratesBR.rfHighVar(2\).rate;
 rHl\_eb \= SF\*ratesBR.rfHighVar(2\).rate\_eb;
 xLl \= ratesBR.rfLowVar(2\).lx;
 rLl \= SF\*ratesBR.rfLowVar(2\).rate;
 rLl\_eb \= SF\*ratesBR.rfLowVar(2\).rate\_eb;
 
 sxHl \= scaled\_ratesBR.scaledRFHigh(2\).lx;
 srHl \= SF\*scaled\_ratesBR.scaledRFHigh(2\).rate;
 srHl\_eb \= SF\*scaled\_ratesBR.scaledRFHigh(2\).rate\_eb;
 sxLl \= scaled\_ratesBR.scaledRFLow(2\).lx;
 srLl \= SF\*scaled\_ratesBR.scaledRFLow(2\).rate;
 srLl\_eb \= SF\*scaled\_ratesBR.scaledRFLow(2\).rate\_eb;
 
 
 end
 %}
 
 mlow \= 'o';
 mhigh \= '\*';
 cup \= \[0 0\.8 0\.4];
 cdown \= \[0 0\.4 0];
 reds \= {1/255\*\[243 127 129], 1/255\*\[127 20 22]};
 blues \= {1/255\*\[74 137 165], 1/255\*\[57 70 156]};
 purples \= {\[.8 0\.2 0\.6], \[.4 0 0\.6]};
 
 if(strcmpi(colors{j}, 'Red'))
 colorsHL \= reds;
 calpha \= {\[1 0 0], \[1 .8 .8]};
 
 elseif(strcmpi(colors{j}, 'Blue'))
 colorsHL \= blues;
 calpha \= {\[0 0 1], \[.8 .8 1]};
 
 else
 colorsHL \= purples;
 calpha \= {\[.6 0 0\.4], \[.6 0\.2 0\.4]};
 end
 
 
 markers \= {mlow, mhigh, mhigh, mlow};
 colors1 \= {cup, cup, cdown, cdown};
 colorsBR \= {reds{1} reds{2} blues{1} blues{2}};
 
 yyaxis left
 h(1,:) \= plot(ton, sall, 'k');
 
 yyaxis right
 if(size(alpha\_s, 1\) \=\= size(valpha\_s, 2\))
 valpha\_s \= valpha\_s';
 end
 temp \= shadedErrorPlot(ton, alpha\_s, valpha\_s, valpha\_s, calpha{1});
 h(2\) \= temp(1\);
 h(3\) \= temp(2\);
 
 pp \= h(2\).Parent;
 pp.Children(1\).LineWidth \= 1\.5;
 
 title(names{j});
 ax \= gca;
 ax.Box \= 'off';
 ax.XLim \= \[min(ton) max(ton)];
 ax.YAxis(1\).Limits \= \[0\.5 3\.5];
 ax.YAxis(1\).Color \= 'k';
 ax.YAxis(2\).Limits \= \[0\.5 1\.8];
 ax.YAxis(2\).TickValues \= \[0\.5 1 1\.5];
 ax.YAxis(2\).Color \= calpha{1};
 ax.YAxis(1\).Label.String \= '\\sigma\_{stim}';
 ax.YAxis(2\).Label.String \= '\\alpha';
 ax.YAxis(2\).Label.Rotation \= 0;
 ax.YAxis(1\).Label.FontSize \= 10;
 ax.YAxis(2\).Label.FontSize \= 10;
 ax.XLabel.String \= 'time in cycle (s)';
 ax.XLabel.FontSize \= 10;
 
 % set(ax, 'YScale', 'log');
 % ax.YLim \= \[0 10];
 % ax.YTick \= \[0 1 2 5 10];
 % ax.YTickLabel \= {'0', '1', '2', '5', '10'};
 
 ah(j).handles \= h;
 
 ah(k).pos \= pos{k}; %\#ok\<\*AGROW\>
 ah(k).ax \= axes('Position', pos{k});
 ah(k).name \= names{j};
 h2(1\) \= errorbar(xu, aup, aup\_eb, 'color', cup, 'linestyle', 'none', 'marker', '^', 'MarkerSize', 6\);
 hold on;
 h2(2\) \= errorbar(xd, adown, adown\_eb, 'color', cdown, 'linestyle', 'none', 'marker', 'v', 'MarkerSize', 6\);
 h2(3\) \= errorbar(xsall, aall, aall\_eb, 'color','k', 'linestyle', 'none', 'marker', '.', 'MarkerSize', 12\);
 h2(4\) \= plot(xsall, fitfun(fP, xsall), 'k\-');
 
 title(names{j});
 ax \= gca;
 ax.Box \= 'off';
 ax.XLim \= h(1\).Parent.YAxis(1\).Limits;
 ax.XLim \= \[0\.8 3];
 ax.YLim \= h(2\).Parent.YLim;
 ax.YTick \= h(2\).Parent.YTick;
 ax.YAxis.Color \= calpha{1};
 ax.XLabel.String \= '\\sigma\_{stim}';
 ax.XLabel.FontSize \= 10;
 
 ah(k).handles \= h2;
 
 continue
 ah(kk).pos \= pos{kk}; %\#ok\<\*AGROW\>
 ah(kk).ax \= axes('Position', pos{kk});
 ah(kk).name \= names{j};
 
 h3(1\) \= errorbar(xH, rH, rH\_eb, 'marker', markers{1}, 'color', colorsHL{1}, 'linestyle', 'none');
 hold on
 h3(2\) \= errorbar(xL, rL, rL\_eb, 'marker', markers{2}, 'color', colorsHL{2}, 'linestyle', 'none');
 
 
 % if(nstim\=\=2\)
 % for i\=1:length(rate)
 % n \= nstim \* (i\-1\);
 % for q\=1:nstim
 % h3(q\+n) \= errorbar(xup{i}(:,q), rate{i}(:,q), reb{i}(:,q), 'marker', markers{i}, 'color', colors1{i}, 'linestyle', 'none');
 % hold on
 % end
 % end
 % end
 title(names{j});
 ax \= gca;
 ax.Box \= 'off';
 ah(kk).handles \= h3;
 
 if(nstim\=\=2\)
 ah(kk\+1\).pos \= pos{kk\+1}; %\#ok\<\*AGROW\>
 ah(kk\+1\).ax \= axes('Position', pos{kk\+1});
 ah(kk\+1\).name \= names{j};
 h4(1\) \= errorbar(xHo, rHo, rHo\_eb, 'marker', markers{1}, 'color', colorsBR{1}, 'linestyle', 'none');
 hold on
 h4(2\) \= errorbar(xLo, rLo, rLo\_eb, 'marker', markers{1}, 'color', colorsBR{2}, 'linestyle', 'none');
 h4(3\) \= errorbar(xHl, rHl, rHl\_eb, 'marker', markers{2}, 'color', colorsBR{3}, 'linestyle', 'none');
 h4(4\) \= errorbar(xLl, rLl, rLl\_eb, 'marker', markers{1}, 'color', colorsBR{4}, 'linestyle', 'none');
 title(names{j});
 ax \= gca;
 ax.Box \= 'off';
 ah(kk\+1\).handles \= h4;
 end
 
 % set(ah(j).ax, 'Children', h);
 
 
 end
 
 
 
 case 'CO2'
 
 SF \= 60;
 
 k \= 0;
 for j \= 1:2:length(btdstruct)
 
 k \= k\+1;
 ah(k).pos \= pos{k}; %\#ok\<\*AGROW\>
 ah(k).ax \= axes('Position', pos{k});
 ah(k).name \= names{k};
 
 
 low \= btdstruct(j).Rates.rf;
 high \= btdstruct(j\+1\).Rates.rf;
 lx\_low \= low.lx;
 lx\_high \= high.lx;
 rate\_low \= SF\*low.rate;
 rate\_eb\_low \= SF\*low.rate\_eb;
 rate\_high \= SF\*high.rate;
 rate\_eb\_high \= SF\*high.rate\_eb;
 
 rateROG\_low \= SF\*exp(polyval(low.rateFitQuad, lx\_low));
 rateROG\_high \= SF\*exp(polyval(high.rateFitQuad, lx\_low));
 
 
 h(1\) \= errorbar (lx\_low, rate\_low, rate\_eb\_low, 'color', colors{k}{1}, 'marker', 'o', 'linestyle', 'none');
 hold all;
 h(2\) \= plot (lx\_low, rateROG\_low, 'color', 'k', 'linestyle', ':', 'linewidth', 1\.5\);
 
 h(3\) \= errorbar (lx\_high, rate\_high, rate\_eb\_high, 'color', colors{k}{2}, 'marker', 's', 'linestyle', 'none');
 h(4\) \= plot (lx\_high, rateROG\_high, 'color', 'k', 'linestyle', '\-\-', 'linewidth', 1\.5\);
 
 title(names{k});
 
 ax \= gca;
 ax.Box \= 'off';
 ax.YLabel.String \= 'turn rate (min^{\-1})';
 ax.YLabel.FontSize \= 10;
 ax.XLabel.String \= 'Filtered Stimulus Value';
 ax.XLabel.FontSize \= 10;
 
 % set(ax, 'YScale', 'log');
 % ax.YLim \= \[0 10];
 % ax.YTick \= \[0 1 2 5 10];
 % ax.YTickLabel \= {'0', '1', '2', '5', '10'};
 
 ah(k).handles \= h;
 
 
 % set(ah(j).ax, 'Children', h);
 
 
 end
 
 
 case 'TRate'
 
 
 for j\=1:length(btdstruct)
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 btd \= btdstruct(j);
 tx \= btd.histt(1:end\-1\);
 trate\_on \= btd.trate\_on;
 trate\_on\_eb \= btd.trate\_on\_eb;
 trate\_off \= btd.trate\_off;
 trate\_off\_eb \= btd.trate\_off\_eb;
 
 tr \= trate\_off;
 tr\_eb \= trate\_off\_eb;
 
 h \= shadedErrorPlot (tx, tr, tr\_eb, tr\_eb, colors{j});
 
 hold (ah(j).ax, 'on');
 tm1 \= max(tr(tx \< max(tx) / 2\));
 tm2 \= max(tr(tx \> max(tx) / 2\));
 x1 \= find(tr \=\= tm1\);
 x2 \= find(tr \=\= tm2\);
 
 
 plot(\[tx(x1\) tx(x2\)], \[tm1 tm1], 'k:', \[tx(x1\) tx(x2\)], \[tm2 tm2], 'k:');
 
 hold (ah(j).ax, 'off');
 
 ah(j).handles \= h;
 title(names{j});
 
 ax \= gca;
 ax.Box \= 'off';
 
 end
 
 
 case 'blah'
 
 n \= 1;
 for j\=1:length(btdstruct)/2
 ah(j).pos \= pos{j}; %\#ok\<\*AGROW\>
 ah(j).ax \= axes('Position', pos{j});
 ah(j).name \= names{j};
 
 btd\_l \= btdstruct(n);
 btd\_h \= btdstruct(n\+1\);
 lx\_low \= btd\_l.lx{1};
 rate\_low \= btd\_l.rate{1};
 rate\_eb\_low \= btd\_l.rate\_eb{1};
 rateROG\_low \= btd\_l.rateExp2{1};
 rateExp\_low \= btd\_l.rateExp1{1};
 lx\_high \= btd\_h.lx{1};
 rate\_high \= btd\_h.rate{1};
 rate\_eb\_high \= btd\_h.rate\_eb{1};
 rateROG\_high \= btd\_h.rateExp2{1};
 rateExp\_high \= btd\_h.rateExp1{1};
 h(1\) \= errorbar (lx\_low, rate\_low, rate\_eb\_low, 'color', colors{j}{1}, 'marker', 'o', 'linestyle', 'none');
 hold all;
 h(2\) \= plot (lx\_low, rateROG\_low, 'color', colors{j}{1}, 'linestyle', '\-\-');
 
 h(3\) \= errorbar (lx\_high, rate\_high, rate\_eb\_high, 'color', colors{j}{2}, 'marker', 's', 'linestyle', 'none');
 h(4\) \= plot (lx\_high, rateROG\_high, 'color', colors{j}{2}, 'linestyle', '\-\-');
 
 title(names{j});
 
 ax \= gca;
 ax.Box \= 'off';
 
 n \= n\+2;
 
 % set(ax, 'YScale', 'log');
 end
 
end
\-\-\-

\#\#\# File: VarAdaptFigures.m (ID: Variance Adaptation Paper.Figures.2\)


% This script can be used to plot different things from our Variance Adaptation paper

% Load the appropriate matfile and run the section that you need
% Each section calls VarAdaptPlots.m with different parameters and sets of experiments


%%
% run this first to set all the colors and figure positions

RedsHL \= {1/255\*\[243 127 129], 1/255\*\[127 20 22]};
BluesHL \= {1/255\*\[74 137 165], 1/255\*\[57 70 156]};
PurpleHL \= {\[.8 0\.2 0\.6], \[.4 0 0\.6]};
CyanHL \= {\[0 .2 .4], \[0 .8 .8]};
Red \= \[1 0 0];
Blue \= \[0 0 1];
Cyan \= \[1 0 0\.6];

RedAll \= {\[1 0 0], \[1 .8 .8]};
BlueAll \= {\[0 0 1], \[.8 .8 1]};
PurpleAll \= {\[.6 0 0\.4], \[.8 0\.6 0\.8]};
CyanAll \= {\[0 .4 .6], \[.6 \-8\.2 .8]};

n \= get(gcf);
if(n.Number \=\= 1\)
 fignum \= 1;
else
 fignum \= n.Number \+ \-1;
end
\[adim,po] \= blank8x10Figure(fignum);
pp \= \[adim.lx3, adim.h0 \- adim.h, adim.w3, adim.h];
pos \= {pp, pp, pp};

pos{2}(1\) \= adim.cx3;
pos{3}(1\) \= 2\*pos{2}(1\) \- pos{1}(1\);
pos{3}(2\) \= pos{1}(2\);

pos2 \= pos; % 2nd row of figure (3 columns each)
pos2{1}(1\) \= pos{1}(1\);
pos2{1}(2\) \= adim.cx3 \+ 0\.15;
pos2{2}(2\) \= pos2{1}(2\);
pos2{3}(2\) \= pos2{1}(2\);

pos3 \= pos2;
pos3{1}(2\) \= 2\*pos2{1}(2\) \- pos{1}(2\);
pos3{2}(2\) \= pos3{1}(2\);
pos3{3}(2\) \= pos3{1}(2\);

pos4 \= pos3;
pos4{1}(2\) \= 2\*pos3{1}(2\) \- pos2{1}(2\);
pos4{2}(2\) \= pos4{1}(2\);
pos4{3}(2\) \= pos4{1}(2\);


%%
\[adim,po] \= blank8x10Figure(fignum);

btds\_40 \= \[berlin\_40, or42a\_40];
btds\_120 \= \[berlin\_120, or42a\_120];

SF\_120 \= VarAdaptPlots(btds\_120, {'', ''}, {{BlueAll}, {RedAll}}, {pos{3}, pos3{3}}, 'ScaleFactorVTime', 1, 'Bayes', '');
SF\_40 \= VarAdaptPlots(btds\_40, {'', ''}, {{BlueAll}, {RedAll}}, {pos{2}, pos3{2}}, 'ScaleFactorVTime', 1, 'Bayes', '');

SF\_120(1\).ax.XLim \= \[\-3 30];
SF\_120(2\).ax.XLim \= \[\-3 30];
SF\_40(1\).ax.XLim \= \[\-3 30];
SF\_40(2\).ax.XLim \= \[\-3 30];

%%
% Unisensory, T\=120s (Figure 1\)

\[adim,po] \= blank8x10Figure(fignum);

log \= 1;
fitdegree \= 2; % 0 means don't plot the rate fits; 1,2 mean plot exponential fit with 1st or 2nd deg. polynomial

load('Z:\\Var.Adapt Ruben\\Matfiles\\Uni\-Sensory\\T120s\\berlin.mat'); % this is berlin\_120
load('Z:\\Var.Adapt Ruben\\Matfiles\\Uni\-Sensory\\T120s\\or42a.mat'); % this is or42a\_120


btds \= \[berlin\_120, or42a\_120];
lines\_120 \= {'berlin', 'or42a'};

tta \= VarAdaptPlots(btds, lines\_120, {BluesHL, RedsHL}, {pos{1}, pos3{1}}, 'TTA');
RF \= VarAdaptPlots(btds, lines\_120, {BluesHL, RedsHL}, {pos{2}, pos3{2}}, '1stimRF', 1, \[], \[], \[], \[], \[], 1, fitdegree);
SF \= VarAdaptPlots(btds, {'', ''}, {{BlueAll}, {RedAll}}, {pos{3}, pos3{3}}, 'ScaleFactorVTime', 1, 'Bayes', '');

set(\[RF(1\).ax], 'YLim', \[0 18]);
set(\[RF(2\).ax], 'YLim', \[0 12]);
set(\[RF(2\).ax], 'YTick', \[0 5 10]);

if(log)
 set(\[RF.ax], 'YScale', 'log');
 set(\[RF(1\).ax], 'YLim', \[0\.5 18]);
 set(\[RF(2\).ax], 'YLim', \[0\.5 12]);

 set(\[RF.ax], 'YTick', \[0 1 2 5 10 15 20]);
 set(\[RF.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '15', '20'});

end

%%
% UniSensory, T\=40s (Figure 3\)

n \= get(gcf);
if(n.Number \=\= 1\)
 fignum \= 1;
else
 fignum \= n.Number \+ 1;
end
\[adim,po] \= blank8x10Figure(fignum);

log \= 1;

% load matfiles from:
% Z:\\Var.Adapt Ruben\\Matfiles\\Uni\-Sensory\\T40s\\dt\=0\.1\\eti\\Quad Rate\\

pdegree \= 2;
btds \= berlin\_40;
colHL \= RedsHL;
colAll \= RedAll;

tta \= VarAdaptPlots(btds, {''}, {colHL}, {pos2{1}}, 'TTA');
RF \= VarAdaptPlots(btds, {''}, {colHL}, {pos2{2}}, '1stimRF', 0, \[], \[], \[], \[], \[], 1, pdegree);
SF \= VarAdaptPlots(btds, {''}, {{colAll}}, {pos3{1}}, 'ScaleFactorVTime', 0\.1, 'Bayes', 'LowHigh');

if(log)
 set(\[RF.ax], 'YScale', 'log');
 set(\[RF.ax], 'YLim', \[0\.5 12]);
 set(\[RF.ax], 'YTick', \[0 1 2 5 10 15 20]);
 set(\[RF.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '15', '20'});

end




%% CO2 (Figure 7\)

% load matfiles from:
% Z:\\Var.Adapt Ruben\\Matfiles\\Uni\-Sensory\\Co2\+Noise\\Gr21a and
% Z:\\Var.Adapt Ruben\\Matfiles\\Uni\-Sensory\\Co2\+Noise\\Or42a

log \= 1;

co2\_21a \= VarAdaptPlots(\[gr21a\_R2, gr21a\_R8, gr21a\_B2, gr21a\_B8], {'', ''}, {RedsHL, BluesHL}, {pos{1}, pos{3}}, 'CO2');
co2\_42a \= VarAdaptPlots(\[or42a\_R2, or42a\_R8, or42a\_B2, or42a\_B8], {'', ''}, {RedsHL, BluesHL}, {pos2{1}, pos2{3}}, 'CO2');
% co2\_42a(1\).ax.XLabel.String \= 'Filtered Stim. Value';
% co2\_42a(2\).ax.XLabel.String \= 'Filtered Stim. Value';
co2\_42a(1\).ax.XAxis.Color \= 'r';
co2\_21a(1\).ax.XAxis.Color \= 'r';
co2\_42a(2\).ax.XAxis.Color \= 'b';
co2\_21a(2\).ax.XAxis.Color \= 'b';

% co2\_21a(2\).ax.YLim(2\) \= 25;

if(log)
 set(\[co2\_21a.ax], 'YScale', 'log');
 set(\[co2\_42a.ax], 'YScale', 'log');
 
 set(co2\_21a(1\).ax, 'YLim', \[0\.5 12]);
 set(co2\_42a(1\).ax, 'YLim', \[0\.5 12]);
 set(co2\_21a(2\).ax, 'YLim', \[0\.5 18]);
 set(co2\_42a(2\).ax, 'YLim', \[0\.5 18]);
 
 set(\[co2\_21a.ax], 'YTick', \[0 1 2 5 10 15 20]);
 set(\[co2\_21a.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '15', '20'});
 set(\[co2\_42a.ax], 'YTick', \[0 1 2 5 10 15 20]);
 set(\[co2\_42a.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '15', '20'});
end



%%
%Var Step \+ Sig. Step (not used in paper)
lines1 \= {'berlin', 'berlin','or42a', 'or35a'};
lines2 \= {'RN\+Bstep64', 'BN\+Rstep64', 'BN\+Rstep96'};

ah\_step1 \= VarAdaptPlots(\[berlin\_step, berlin\_step2, or42a\_step, or35a\_step], lines1, {Blue, Blue, Red, Red}, {pos{1}, pos{2}, pos2{1}, pos2{2}}, 'TRate');

% ah\_step2 \= VarStepRatePlots(\[RN\_Bstep64, BN\_Rstep64, BN\_Rstep96], lines2, {Blue, Red, Red}, {pos3{1}, pos3{2}, pos3{3}}, 'TRate');


%%
% Var Ramps (Figure 4\)

\[adim,po] \= blank8x10Figure();
log \= 1;
deltaT \= 1;
pdegree \= 2;

% load matfiles from:
% Z:\\Var.Adapt Ruben\\Matfiles\\Uni\-Sensory\\Ramps\\dt\=1\\Quad Rate

lines \= {''};
btds \= \[or42a\_ramp];
col \= 'Red';
colHL \= RedsHL;

SF \= VarAdaptPlots(btds, lines, {col}, {pos{1}, pos{2}}, 'VarRamp', deltaT, 'Bayes');

% RF \= VarAdaptPlots(btds, lines, {colHL}, {pos{3}, pos3{3}}, '1stimScaledRF', deltaT, \[], \[], \[], \[], \[], \[], pdegree);

ah\_ramp(1\).ax.XLabel.String \= 'time in cycle (s)';

if(log)
 set(\[RF.ax], 'YScale', 'log');
 set(\[RF.ax], 'YLim', \[0\.5 12]);

 set(\[RF.ax], 'YTick', \[0 1 2 5 10 15 20]);
 set(\[RF.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '15', '20'});

end

%%
% Corr Ramp (not used in paper)
% figure()

\[adim,po] \= blank8x10Figure(fignum);

log \= 1;
deltaT \= 1;
lines \= {''};
btds \= rbcorr\_ramp;

col \= PurpleAll;

SF \= VarAdaptPlots(btds, lines, {col}, {pos{1}, pos{2}}, 'VarRamp', deltaT, 'Bayes');
RF \= VarAdaptPlots(btds, {''}, {PurpleHL}, {pos3{1}}, '1stimRF', \[], '', \[], \[], \[], \[], 1\);
RF2 \= VarAdaptPlots(btds, {''}, {PurpleHL}, {pos3{2}}, '1stimRF', \[], '', \[], \[], \[], \[], 2\);
RF.ax.XAxis.Color \= PurpleAll{1};

if(log)
 set(\[RF.ax], 'YScale', 'log'); 
 set(\[RF.ax], 'YLim', \[0\.5 12]);
 set(\[RF2\.ax], 'YScale', 'log');
 set(\[RF2\.ax], 'YLim', \[0\.5 12]);
 
 set(\[RF.ax], 'YTick', \[0 1 2 5 10 15 20]);
 set(\[RF.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '15', '20'});
 set(\[RF2\.ax], 'YTick', \[0 1 2 5 10 15 20]);
 set(\[RF2\.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '15', '20'});

end

%%
% Corr Step (Figure 6, bottom)

\[adim,po] \= blank8x10Figure(fignum);
log \= 1;

PurpleAll \= {\[.6 0 0\.4], \[.8 0\.6 0\.8]};
colHL \= PurpleHL;

% load matfile from:
% load('Z:\\Var.Adapt Ruben\\Matfiles\\Multi\-Sensory\\Correlated\\rbcorr\_Quad.mat');

deltaT \= 0\.1;
btd \= rbcorr;

SF \= VarAdaptPlots(btd, {''}, {{PurpleAll PurpleAll}}, {pos{1}}, 'ScaleFactorVTime', deltaT, 'Bayes', \[], \[], \[], \[] , 1\);
RF \= VarAdaptPlots(btd, {''}, {PurpleHL}, {pos{2}}, '1stimRF', \[], '', \[], \[], \[], \[], 1, 1\);

RF.ax.XAxis.Color \= PurpleAll{1};
RF2\.ax.XAxis.Color \= PurpleAll{1};

if(log)
 set(\[RF.ax], 'YScale', 'log');
 set(\[RF.ax], 'YLim', \[0\.5 12]);
 
 set(\[RF2\.ax], 'YScale', 'log');
% set(\[RF2\.ax], 'YScale', 'log');
 
 set(\[RF.ax], 'YTick', \[0 1 2 5 10 15 20]);
 set(\[RF.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '15', '20'});
 set(\[RF2\.ax], 'YTick', \[0 1 2 5 10 20]);
 set(\[RF2\.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '20'});

end

%%
% Multi\-Sensory Variance Switching, T\=40s (Figure 6, top 2 rows)

\[adim,po] \= blank8x10Figure();
log \= 1;


% matfiles in: Z:\\Var.Adapt Ruben\\Matfiles\\Multi\-Sensory\\VarStep\_T40\\dt\=0\.1\\Quad Rate

rcbsw \= {'', '', ''};
% bcrsw \= {'Blue s\=1', 'Blue s\=2', 'Blue s\=3'};
% btds \= \[r1b13 r2b13 r3b13];
btds \= \[b2r13 r2b13];
pdegree \= 1;

SF \= VarAdaptPlots(btds, rcbsw, {RedAll{1} BlueAll{1}}, {pos{1}, pos2{1}, pos3{1}}, '2stimPPF', 0\.1, 'Bayes', \[],\[],\[],\[],\[],\[],'');
RF \= VarAdaptPlots(btds, rcbsw, {RedsHL, BluesHL}, {{pos{3}, pos{2}}, {pos2{3} pos2{2}}, {pos3{3} pos3{2}}}, '2stimRF', \[], \[], \[], \[], \[], \[], \[], pdegree);


RF{1}(1\).ax.YLim \= \[0 12];
RF{2}(1\).ax.YLim \= \[0 18];
RF{1}(2\).ax.YLim \= \[0 12];
RF{2}(2\).ax.YLim \= \[0 18];
% RF{1}(3\).ax.YLim \= \[0 13];
% RF{2}(3\).ax.YLim \= \[0 13];

RF{2}(1\).ax.XLim \= RF{2}(2\).ax.XLim;
RF{1}(1\).ax.XLim \= RF{1}(2\).ax.XLim;

if(log)

 set(\[RF{1}.ax], 'YScale', 'log');
 set(\[RF{2}.ax], 'YScale', 'log');

 set(\[RF{1}.ax], 'YTick', \[0 1 2 5 10 15 20]);
 set(\[RF{1}.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '15', '20'});
 set(\[RF{2}.ax], 'YTick', \[0 1 2 5 10 15 20]);
 set(\[RF{2}.ax], 'YTickLabel', {'0', '1', '2', '5', '10', '15', '20'});

end

%%
% Bayes Optimal Estimates (Figure 5, b)

% this plots optimal estimates of the variance of the stimulus in or42a\_40 or berlin\_40, converted to alpha(t) vs. cycle time

% conversion from sigma to alpha: alpha(sigma) \= 1/sqrt(sigma^2\+sigma\_0^2\);
% sigma\_0 \= params as set below (found separately for or42a\_40 and berlin\_40\)

% you need to add the btds before the Bayesian estimator to find the stimulus variance
% for example:
% load('Z:\\Var.Adapt Ruben\\Matfiles\\Uni\-Sensory\\T40s\\dt\=0\.1\\eti\\QuadRate\\or42a.mat');
% or42a\_40\_data \= BehaviorTriggeredData.loadBTDDirectory('Z:\\Var.Adapt Ruben\\BTDs\\By Expt Type\\Var. Step T\=40\\Or42a');
% or42a\_40\.btd \= or42a\_40\_data.btd;

% now you can run this section

\[adim,po] \= blank8x10Figure();

deltaT \= 0\.1;


dts1 \= \[.2 .4 .7 1\.5];
dts2 \= \[.2 .4 .85 1\.5];

taus \= \[1 1 1 1 1];
taus1 \= 12\*taus;
taus2 \= 6\*taus;

params \= {1\.9};
params2 \= {1\.3};
col \= RedAll;
col2 \= BlueAll;
 
ah \= VarAdaptPlots(\[or42a\_40], {''}, {{col}}, {pos{2}}, 'ScaleFactorVTime', deltaT, 'Bayes', 'Optimal', dts1, taus1, params, \[]);
ah2 \= VarAdaptPlots(\[berlin\_40], {''}, {{col2}}, {pos{1}}, 'ScaleFactorVTime', deltaT, 'Bayes', 'Optimal', dts2, taus2, params2, \[]);








\-\-\-

\#\#\# Folder: Variance Adaptation Paper/Rescaling vs Time (ID: Variance Adaptation Paper.Rescaling vs Time)

\-\-\-

\#\#\# File: meanEstinCycle.m (ID: Variance Adaptation Paper.Rescaling vs Time.1\)

function \[alpha\_ton, valpha\_ton, tx\_ton] \= meanEstinCycle (alpha, valpha, tx, tshift, period, trange, timeType)
% function \[alpha\_ton, valpha\_ton, tx\_ton] \= meanEstinCycle (alpha, valpha, tx, tshift, period, trange, timeType)

% if timeType\='eti' : calculates mean \+ error vs. time in cycle (t\=0:period) from estimates\+errors vs. eti (e.g. t\=60:1200\)
% if timeType\='ton' : averages mean \+ error vs. time in cycle (t\=0:period)



deltaT \= median(diff(tx));

if(size(alpha,2\)\>size(alpha,1\))
 alpha \= alpha';
end
nstim \= size(alpha,2\);

if(strcmpi(timeType, 'ton'))
 trange \= \[min(tx) max(tx)];
 tx \= repmat(tx, \[1 round(size(alpha, 1\)/length(tx))]);
end

if (\~existsAndDefault('trange', \[]))
 trange(1\) \= tx(find(mod(tx \+ tshift, period) \<\= deltaT, 1, 'first'));
 trange \= trange(1\):period:max(tx);
 trange \= \[trange(1\) trange(end)];
end
ti \= tx \>\= min(trange) \& tx \<\= max(trange);
tx \= tx(ti);
tt \= alpha(ti,:);

if(strcmpi(timeType, 'ton'))
 tc \= tx;
else
 tc \= mod(tx \+ tshift, period);
end
ii \= round(tc / deltaT);
\[\~,tx\_ton] \= meanyvsx(ii, tc, 0:(max(ii)\+0\.5\));
alpha\_ton \= zeros(length(tx\_ton), size(tt,2\));
% valpha\_ton \= zeros(size(valpha));

if(nstim\=\=2\)
 
 ww \= valpha(:,:,ti);
 valpha\_ton \= zeros(size(ww,1\), size(ww,2\), length(tx\_ton));
 
 n\=1;
 for j \= 1:length(tx\_ton)
 
 ti \= (ii \+ 1 \=\= j);
 
 
 u \= tt(ti, :)';
 wi \= ww(:,:,ti);
 
 ni(j) \= length(u);
 
 if(isempty(u) \|\| isempty(wi))
 inds(n) \= j;
 n\=n\+1;
 continue
 end
 
 for k \= 1:size(wi,3\)
 wi(:,:,k) \= inv(wi(:,:,k));
 u(:,k) \= wi(:,:,k)\*u(:,k);
 end
 valpha\_ton(:,:,j) \= inv(sum(wi,3\));
 alpha\_ton(j,:) \= (valpha\_ton(:,:,j)\*sum(u,2\))';
 end
 alpha\_ton \= alpha\_ton';
 
elseif(nstim\=\=1\)
 
 valpha \= squeeze(valpha);
 ww \= valpha(ti);
 valpha\_ton \= zeros(\[1,length(tx\_ton)]);
 
 n\=1;
 for j \= 1:length(tx\_ton)
 
 ti \= (ii \+ 1 \=\= j);
 
 
 u \= tt(ti, :)';
 wi \= ww(ti);
 
 ni(j) \= length(u);
 
 if(isempty(u) \|\| isempty(wi))
 inds(n) \= j;
 n\=n\+1;
 continue
 end
 
 for k \= 1:length(wi)
 wi(k) \= 1/wi(k);
 u(:,k) \= wi(k)\*u(:,k);
 end
 inds \= \~isinf(wi);
 valpha\_ton(j) \= inv(sum(wi(inds)));
 alpha\_ton(j,:) \= (valpha\_ton(j)\*sum(u(inds),2\))';
 end
 alpha\_ton \= alpha\_ton';
 
 
 
end

\-\-\-

\#\#\# File: normAlpha.m (ID: Variance Adaptation Paper.Rescaling vs Time.2\)

function fitstruct \= normAlpha (fitstruct, data, timeType, expnum)
% function fitstruct \= normAlpha (fitstruct, data, timeType, expnum)
% normalizes alpha(t) to have mean\=1

if (length(fitstruct) \> 1\)
 for j \= 1:length(fitstruct)
 fitstruct(j) \= normAlpha (fitstruct(j), data, j);
 end
 return;
end
if (existsAndDefault('expnum', \[]))
 tinds \= data.turnExpnum \=\= expnum;
 rinds \= data.runExpnum \=\= expnum;
else
 tinds \= true(size(data.turnT));
 rinds \= true(size(data.runT));
end

if(strcmpi(timeType, 'ton'))
 if(isfield(data, 'runTon'))
 runT \= data.runTon;
 turnT \= data.turnTon;
 else
 runT \= data.runT;
 turnT \= data.turnT;
 end
 nr\_ton \= histcounts(runT(rinds), binEdgesFromCenters(fitstruct.tx\_ton));
 nt\_ton \= histcounts(turnT(tinds), binEdgesFromCenters(fitstruct.tx\_ton));
 wton \= (nr\_ton \+ nt\_ton)/sum(nr\_ton \+ nt\_ton);
 wton \= wton(:);
 alpha\_ton \= fitstruct.alpha\_ton';
 norm\_factor \= sum(alpha\_ton.\*repmat(wton, \[1 size(alpha\_ton,2\)]),1\);
 alpha\_ton \= alpha\_ton ./ repmat(norm\_factor, \[size(alpha\_ton,1\) 1]);
 fitstruct.alpha\_ton \= alpha\_ton';
else
 nr\_t \= histcounts(data.runT(rinds), binEdgesFromCenters(fitstruct.tx));
 nt\_t \= histcounts(data.turnT(tinds), binEdgesFromCenters(fitstruct.tx));
 wt \= (nr\_t \+ nt\_t)/sum(nr\_t \+ nt\_t);
 wt \= wt(:);
 alpha \= fitstruct.alpha';
 norm\_factor \= sum(alpha.\*repmat(wt, \[1 size(alpha,2\)]),1\);
 alpha \= alpha ./ repmat(norm\_factor, \[size(alpha,1\) 1]);
 fitstruct.alpha \= alpha';
end

end
\-\-\-

\#\#\# File: BayesianModelEstimate.m (ID: Variance Adaptation Paper.Rescaling vs Time.3\)


function out \= BayesianModelEstimate(pd, btdstruct, var, opstruct, timeType, dt, Ddt, taxis, logdat, output, rescale\_type, multiType)
% function out \= BayesianModelEstimate(pd, btdstruct, var, opstruct, timeType, dt, Ddt, taxis, logdat, output, rescale\_type)
% Calculates rescaling model parameter (alpha(t)) using a Bayesian estimator, fits the rate function to r(alpha(t),x), and iterates

% see VarAdaptAll for example of how to use

% timeType \= 'eti' or 'ton'. If 'eti', estimates vs cycle time are calculated as well
% dt \-\- time step for calculation
% Ddt defines the width of the Gaussian prior
% logdat \= 0 or 1 (shouldn't make a difference)
% output \-\- see lines 256\-271\. Set as \[] to get everything outputted
% rescale\_type: 'input' or 'output'. only guaranteed to work with 'input'
% multiType \= 'add' or 'mult' sets the two\-stimulus rate function to the mulitplication or linear combination


niter \= 5; % number of times the alpha(t) estimate \+ fitting procedure is iterated
tolerance \= 20; % if Delta(log\-likelihood) drops below this number, the iteration procedure stops

% dalpha and alphamax set the alpha axis along which to find P(model\|data)
dalpha \= .5;
alphamax \= 5;

if (isempty(var))
 btdstruct \= BehaviorTriggeredData.prepVarianceSwitchingAnalysis\_Gepner(btdstruct, opstruct);
 var \= btdstruct.var;
 if(isfield(btdstruct, 'var\_uv'))
 var\_uv \= btdstruct.var\_uv;
 end
end

if(isempty(pd))
 pd\_eti \= BehaviorTriggeredData.createProblemStructForRateFunFitting (var, 'eti', opstruct.pdegree, opstruct.timeRange, \[], \[]);
 pd\_ton \= BehaviorTriggeredData.createProblemStructForRateFunFitting (var, 'ton', opstruct.pdegree, opstruct.timeRange, \[], \[]);
 pd\_toff \= BehaviorTriggeredData.createProblemStructForRateFunFitting (var, 'toff', opstruct.pdegree, opstruct.timeRange, \[], \[]);
 
 if(strcmpi(timeType, 'eti'))
 pd \= pd\_eti;
 elseif(strcmpi(timeType, 'ton'))
 pd \= pd\_ton;
 elseif(strcmpi(timeType, 'toff'))
 pd \= pd\_toff;
 end

end

pd.maxreps \= 2;
pd.pad \= 0;


fn \= fieldnames(pd);
for j \= 1:length(fn)
 eval(\[fn{j} ' \= pd.' fn{j} ';']);
end

if isempty(runEti) %\#ok\<\*NODEF\>
 runEti \= runT;
end
if isempty(turnEti)
 turnEti \= turnT;
end


if(strcmpi(timeType, 'ton'))
 separateExperiments \= true;
 pd\_ton \= pd;
else
 separateExperiments \= false;
end

if(strcmpi(timeType, 'eti') \&\& (period\+max(runT))\<(max(runEti)))
 runTon \= runT;
 turnTon \= turnT;
 runT \= runEti;
 turnT \= turnEti;
end

tx \= tx(:);

alpha \= alpha\_0;
ll \= NaN(\[1 maxreps]);
T \= max(tx) \- min(tx);
tinds \= turnT \>\= min(tx) \& turnT \< max(tx);
rinds \= runT \>\= min(tx) \& runT \< max(tx);

turnT \= turnT(tinds);
runT \= runT(rinds);
turnEti \= turnEti(tinds);
runEti \= runEti(rinds);
turnX \= turnX(tinds,:);
runX \= runX(rinds,:);
turnExpnum \= turnExpnum(tinds);
runExpnum \= runExpnum(rinds);


if(exist('pd\_ton'))
 runTon \= pd\_ton.runT;
 turnTon \= pd\_ton.turnT;
 turnTon \= turnTon(tinds);
 runTon \= runTon(rinds);
 \[runTon, I] \= sort(runTon, 'ascend');
 \[turnTon, I] \= sort(turnTon, 'ascend');
end
if(exist('runTon'))
 data.turnTon \= turnTon;
 data.runTon \= runTon;
end

\[turnT, I] \= sort(turnT, 'ascend');
turnEti \= turnEti(I);
turnX \= turnX(I, :);
turnExpnum \= turnExpnum(I);
\[runT, I] \= sort(runT, 'ascend');
runEti \= runEti(I);
runX \= runX(I, :);
runExpnum \= runExpnum(I);


if (pd.pad)
 turnXe \= \[turnX; turnX; turnX];
 turnEtie \= \[turnEti;turnEti;turnEti];
 turnTe \= \[turnT\-T; turnT; turnT \+ T]; 
 runXe \= \[runX; runX; runX];
 runTe \= \[runT\-T; runT;runT\+T];
 runEtie \= \[runEti;runEti;runEti];
 turnExpnume \= \[turnExpnum; turnExpnum; turnExpnum];
 runExpnume \= \[runExpnum; runExpnum; runExpnum];
 txe \= unique(\[tx\-T;tx;tx\+T]);
else
 turnXe \= turnX;
 turnTe \= turnT;
 turnEtie \= turnEti;
 runXe \= runX;
 runTe \= runT;
 runEtie \= runEti;
 turnExpnume \= turnExpnum; 
 runExpnume \= runExpnum; 
 txe \= unique(tx);
end

fn \= {'turnT', 'turnX', 'turnEti', 'runT', 'runX', 'runEti', 'tx', 'turnExpnum', 'runExpnum'};
for j \= 1:length(fn)
 data.(fn{j}) \= eval(fn{j});
 data.(\[fn{j} 'e']) \= eval(\[fn{j} 'e']);
end

data.tx \= taxis;
data.txe \= taxis;
data.deltaT \= median(diff(var(1\).fullensemble.eti));

 
funs.ratefun \= ratefun;
funs.temporalratemod \= \[];
funs.params \= params\_0;
funs.tparams \= tparams\_0;
funs.tparams \= \[];
funs.gradlogratefun \= gradlogratefun; %NxD gradient of log of rate
funs.hesslogratefun \= hesslogratefun; %DxDxN hessian of log of rate;


if(size(alpha, 2\)\>2\)
 alpha \= alpha';
end
theta\_0 \= alpha(1,:);


if (separateExperiments)
 erange \= \[min(data.turnExpnum) max(data.turnExpnum)];
else
 erange \= 1;
end

% set the rate function, and alpha\_0 \= 1
if(strcmpi(rescale\_type, 'input'))
 rfun \= @(alpha, rateP, dat) exp(polyval(rateP, alpha.\*repmat(dat, size(alpha))));
 alphaT0 \= ones(size(data.turnX));
 alphaR0 \= ones(size(data.runX));
elseif(strcmpi(rescale\_type, 'output'))
% rfun \= @(a, dat) a.\*repmat( exp(polyval(funs.params\_maxOutputRescaling, dat)), size(a));
 rfun \= @(alpha, rateP, dat) alpha.\*repmat( exp(polyval(rateP, dat)) \- exp(rateP(end)), size(alpha)) \+ exp(rateP(end));
 alphaT0 \= alphamax\*ones(size(data.turnX));
 alphaR0 \= alphamax\*ones(size(data.runX));
end

% fit the rate function with alpha\=1
r0 \= log(length(pd.turnT)/(length(pd.runT)\*data.deltaT));
\[params{1}, nll(1\)] \= fitScaledRate (funs, data.turnX, alphaT0, data.runX, alphaR0, data.deltaT, r0, rescale\_type, opstruct.pdegree, multiType);
 

% calculate alpha(t) and fit rate function with rescaled values, and iterate a few times to converge to the 'right' rate function
for i\=2:(niter\+1\)
 scaled \= 1;
 tic
 ratefun \= @(alpha, dat) rfun(alpha, params{i\-1}, dat);
 funs.params \= params{i\-1};
 
 
 if(strcmpi(timeType, 'ton'))
 tx \= \[]; alpha \= \[]; valpha \= \[];
 for j \= min(erange):max(erange)
 alphaTon \= BayesEstimateScalingFactor(ratefun, funs, data, theta\_0, logdat, dalpha, alphamax, Ddt, j, timeType, opstruct.pdegree, multiType);
 alphaTon \= normAlpha(alphaTon, data, \[]);
 tx \= \[tx alphaTon.tx];
 alpha \= \[alpha alphaTon.alpha];
 valpha \= \[valpha alphaTon.valpha];
 end
 \[alphastruct.alpha\_ton, alphastruct.valpha\_ton, alphastruct.tx\_ton] \= meanEstinCycle(alpha, valpha, alphaTon.tx, tshift, period, opstruct.timeRange, timeType);
 alphastruct.alpha \= alphastruct.alpha\_ton;
 alphastruct.valpha \= alphastruct.valpha\_ton;
 alphastruct.tx \= alphastruct.tx\_ton;
 alphastruct \= normAlpha(alphastruct, data, timeType);
 
 data \= addStretchedValues(data, alphastruct, timeType);
 % fit rate function with new values of alpha(t)
 \[params{i}, nll(i)] \= fitStaticRate (funs, data, scaled, opstruct.pdegree, multiType);
 
 else
 
 tic
 alphastruct \= BayesEstimateScalingFactor(ratefun, funs, data, theta\_0, logdat, dalpha, alphamax, Ddt, \[], timeType, opstruct.pdegree, multiType);
 toc
 alphastruct \= normAlpha(alphastruct, data, timeType);
 
 data \= addStretchedValues(data, alphastruct, timeType);
 % fit rate function with new values of alpha(t)
 \[params{i}, nll(i)] \= fitStaticRate (funs, data, scaled, opstruct.pdegree, multiType);
 
 \[alphastruct.alpha\_ton, alphastruct.valpha\_ton, alphastruct.tx\_ton] \= meanEstinCycle(alphastruct.alpha, alphastruct.valpha, alphastruct.tx, tshift, period, opstruct.timeRange, timeType);
 alphastruct \= normAlpha(alphastruct, data, 'ton');
 end

 alphastruct.params \= params{i};
 alphastruct.nll \= nll(i);
 alphastruct.Ddt \= Ddt;
 
 fitstruct{i\-1} \= alphastruct;
 toc
 if( abs(nll(i)\-nll(i\-1\)) \< tolerance ) % stop iterating when log\-likelihood converges
 break
 end
end

fitstruct{end}.scaledValues \= ScaledData(fitstruct{end}, data, dt, timeType);
fitstruct{end}.nll\_iterated \= nll;
fitstruct{end}.params\_iterated \= params;


if(strcmpi(timeType, 'eti'))
 if(strcmpi(output, 'tx'))
 out \= fitstruct{end}.tx;
 elseif(strcmpi(output, 'alpha'))
 out \= fitstruct{end}.alpha;
 else
 out \= fitstruct{end};
 end
else
 if(strcmpi(output, 'tx'))
 out \= fitstruct{end}.tx\_ton;
 elseif(strcmpi(output, 'alpha'))
 out \= fitstruct{end}.alpha\_ton;
 else
 out \= fitstruct{end};
 end
end

end

function fitstruct \= BayesEstimateScalingFactor(rfun, funs, data, alpha\_0, logdat, dalpha, alphamax, Ddt, expnum, timeType, pdegree, multiType) % (ratefun, dlogratefun,ddlogratefun, turnT, turnX, runT, runX, deltaT, txe, Q\_alpha, params, alpha\_0, w\_0\)

existsAndDefault('alpha\_0', 1\);

rP \= funs.params;

txe \= data.txe;
theta \= repmat(alpha\_0, \[length(txe), 1]);
dtheta \= theta;
%theta \= ones(size(txe));
innov \= zeros(length(txe), 1\);


if (existsAndDefault('expnum', \[]))
 tinds \= data.turnExpnume \=\= expnum;
 rinds \= data.runExpnume \=\= expnum;
else
 tinds \= true(size(data.turnTe));
 rinds \= true(size(data.runTe));
end

if(strcmpi(timeType, 'ton'))
 turnTe \= data.turnTon(tinds);
 runTe \= data.runTon(rinds);
else
 turnTe \= data.turnTe(tinds);
 runTe \= data.runTe(rinds);
end
turnEtie \= data.turnTe(tinds);
turnXe \= data.turnXe(tinds, :);
runEtie \= data.runTe(rinds);
runXe \= data.runXe(rinds, :);

nstim \= size(runXe, 2\);
% if(length(rP)\>3 \&\& nstim\=\=2\)
% pdegree \= 2;
% else
% pdegree \= 1;
% end

alphas \= 0\.05:dalpha:alphamax; %alpha axis for integration
\[A1, A2] \= meshgrid(alphas, alphas);

if(nstim\=\=2\)
 betamax \= alphamax;
 beta\_0 \= alpha\_0(2\);
 alpha\_0 \= alpha\_0(1\);
 betas \= 0\.05:dalpha:betamax;
 \[B1, B2] \= meshgrid(betas, betas);
 \[AB1, AB2] \= meshgrid(alphas, betas);
 \[BA1, BA2] \= meshgrid(betas, alphas);
 if(length(Ddt)\=\=3\)
 sig2d \= 2\*\[Ddt(1\), Ddt(3\); Ddt(3\), Ddt(2\)];
 if(det(sig2d)\<\=0\)
 disp('sigma matrix must be positive definite');
 fitstruct.tx\_ton \= \[];
 fitstruct.alpha\_ton \= \[];
 fitstruct.isbad \= 1;
 return
 end
 end
end


logPdat \= @(a, tdat, rdat) sum( log(rfun(a,tdat)) ) \- data.deltaT\*sum(rfun(a,rdat)); %logP(data\|model) \= sum\_turn log(rate) \- dt \* sum\_noturn rate
Pdat \= @(a, tdat, rdat) prod(data.deltaT\*rfun(a,tdat), 1\) .\* prod(exp(\-data.deltaT\*rfun(a,rdat)), 1\); % (\+ length(tdat)\*log(dt)) P(data\|model) 
Naa \= @(a1,a2\) normpdf(a1, a2, sqrt(2\*Ddt)); % Diffusion prior on alpha P(alpha1 \| alpha2\), D\=diffusion constant, dt \= time step

if(nstim\=\=2\) % calculation for odor\-light experiments
 
 scaledA \= @(xd) alphas'.\*repmat(xd(:,1\)', length(alphas), 1\);
 scaledB \= @(xd) betas'.\*repmat(xd(:,2\)', length(betas), 1\);
 scaledAmat \= @(xd) repmat( reshape(scaledA(xd), length(alphas), 1, length(xd(:,1\))), 1, length(betas), 1\);
 scaledBmat \= @(xd) repmat( reshape(scaledB(xd), \[1, size(scaledB(xd))]), length(alphas), 1, 1\);
 if(pdegree\=\=1\)
 Pdat2d \= @(tdat, rdat) exp( sum( rP(1\)\*scaledAmat(tdat) \+ rP(2\)\*scaledBmat(tdat) \+ rP(3\), 3\) \- data.deltaT\*sum(exp( rP(1\)\*scaledAmat(rdat) \+ rP(2\)\*scaledBmat(rdat) \+ rP(3\)), 3\));
 elseif(pdegree\=\=2\)
 
 
 if(strncmpi(multiType, 'add', 3\))
 Pdat2d \= @(tdat, rdat) exp( sum( rP(2\)\* (cos(rP(1\))\*scaledAmat(tdat)\+sin(rP(1\))\*scaledBmat(tdat)).^2 \+ rP(3\)\* (cos(rP(1\))\*scaledAmat(tdat)\+sin(rP(1\))\*scaledBmat(tdat)) \+ rP(4\), 3\)...
 \- data.deltaT\*sum(exp( rP(2\)\* (cos(rP(1\))\*scaledAmat(rdat)\+sin(rP(1\))\*scaledBmat(rdat)).^2 \+ rP(3\)\* (cos(rP(1\))\*scaledAmat(rdat)\+sin(rP(1\))\*scaledBmat(rdat)) \+ rP(4\) ), 3\) ); 
 elseif(strncmpi(multiType, 'mult', 3\))
 Pdat2d \= @(tdat, rdat) exp( sum( rP(1\)\*scaledAmat(tdat).^2 \+ rP(2\)\*scaledAmat(tdat) \+ rP(3\)\*scaledBmat(tdat).^2 \+ rP(4\)\*scaledBmat(tdat) \+ rP(5\), 3\)...
 \- data.deltaT\*sum(exp( rP(1\)\*scaledAmat(rdat).^2 \+ rP(2\)\*scaledAmat(rdat) \+ rP(3\)\*scaledBmat(rdat).^2 \+ rP(4\)\*scaledBmat(rdat) \+ rP(5\)), 3\));

 end
 
 end
 Naa \= @(a1, a2\) normpdf(a1, a2, sqrt(2\*Ddt(1\))) ;
 Nbb \= @(b1, b2\) normpdf(b1, b2, sqrt(2\*Ddt(2\)));

 
end
 
%First time step

ti \= findRangeInSortedData(turnTe, txe(1\), txe(2\));
ri \= findRangeInSortedData(runTe, txe(1\), txe(2\));
td \= turnXe(ti, :);
rd \= runXe(ri, :);
xt \= td.\*repmat(theta(1, :), \[size(td,1\) 1]);
xr \= rd.\*repmat(theta(1, :), \[size(rd,1\) 1]);



if(nstim\=\=1\)
 if(logdat\=\=1\)
 Pax\_0 \= logPdat(alphas, xt, xr) \+ log(Naa(alphas, alpha\_0\));
 Pax\_0 \= Pax\_0 \- max(Pax\_0\); % extra term added to keep P from being too small
 omega \= dalpha\*trapz(exp(Pax\_0\));
 
 if(omega\=\=0\)
 Pax \= exp(Pax\_0\);
 else
 Pax \= exp(Pax\_0\)/omega;
 end
 Pa(1,:) \= Pax;
 else
 Pax\_0 \= Pdat(alphas, xt, xr).\* Naa(alphas, alpha\_0\);
 omega \= dalpha\*trapz(Pax\_0\);
 
 if(omega\=\=0\)
 Pax \= Pax\_0;
 else
 Pax \= Pax\_0/omega;
 end
 Pa(1,:) \= Pax;
 end
elseif(nstim\=\=2\)
 
 if(length(Ddt)\=\=2\) % independent priors for a and b
 Pax\_0 \= Pdat2d(xt, xr).\*Naa(alphas, alpha\_0\)'.\*Nbb(betas, beta\_0\);
 
 elseif(length(Ddt)\=\=3\) %2D prior for (a,b)
 abmat \= \[AB1(:) AB2(:)];
 bamat \= \[BA1(:) BA2(:)];
 muab \= \[repmat(alpha\_0, length(alphas)\*length(betas), 1\), repmat(beta\_0, length(alphas)\*length(betas), 1\)];
 Pab\_0 \= mvnpdf(bamat, muab, sig2d);
 Pax\_0 \= Pdat2d(xt, xr).\*reshape(Pab\_0, size(BA1\));
 end
 
 fitstruct.alphas \= alphas;
 fitstruct.betas \= betas;
 fitstruct.logPdat{1} \= Pdat2d(xt, xr);
 omega \= dalpha\*dalpha\*trapz(trapz(Pax\_0\));
 
 if(omega\=\=0\)
 Pax \= Pax\_0;
 else
 Pax \= Pax\_0/omega;
 end
 Pa{1} \= Pax;
end


% fitstruct.Pdata(1,:) \= Pdat(alphas, xt, xr)./omega;
% fitstruct.logPdata(1,:) \= logPdat(alphas, xt, xr);
fitstruct.Pa(1,:) \= Pa(1,:);

if(isempty(ri))
 inds \= 1;
else
 inds \= \[];
end

for n \= 2:(length(txe) \- 1\)
% tEst \= theta(j);
 
 ti \= findRangeInSortedData(turnTe, txe(n), txe(n\+1\));
 ri \= findRangeInSortedData(runTe, txe(n), txe(n\+1\));
 if (isempty(ri))
 inds \= \[inds n];
 theta(n\+1,:) \= theta(n,:);
 continue;
 end
 
 td \= turnXe(ti, :);
 rd \= runXe(ri, :);
 xt \= td.\*repmat(theta(n, :), \[size(td,1\) 1]);
 xr \= rd.\*repmat(theta(n, :), \[size(rd,1\) 1]);

 teti \= turnEtie(ti);
 reti \= runEtie(ri);
 
 if(nstim\=\=1\)
 
 Paa\_n \= dalpha\*trapz( Naa(A1, A2\).\*repmat(Pax, length(alphas), 1\), 2\);
 
 if(logdat \=\= 1\)
 
 Pax\_n \= logPdat(alphas, xt, xr) \+ log(Paa\_n');
 Pax\_n \= Pax\_n \- max(Pax\_n);
 omega \= dalpha\*trapz( exp(Pax\_n) );
 if(omega\=\=0\)
 Pax \= exp(Pax\_n);
 else
 Pax \= exp(Pax\_n)/omega;
 end
 Pa(n,:) \= Pax;
 else
 Pax\_n \= Pdat(alphas, xt, xr).\*Paa\_n';
 omega \= dalpha\*trapz(Pax\_n);
 if(omega\=\=0\)
 Pax \= Pax\_n;
 else
 Pax \= Pax\_n/omega;
 end
 Pa(n,:) \= Pax;
 end
 fitstruct.Pa(n,:) \= Pa(n,:);
 
 elseif(nstim\=\=2\)
 
 if(length(Ddt)\=\=3\) % 2\-D prior
 
 rep \= @(X) repelem(X(:), length(X(:)));
 rep2 \= @(X) repmat(X(:), length(X(:)), 1\);
 abmat \= \[rep2(AB1\) rep2(AB2\)];
 abmat2 \= \[rep(AB1\) rep(AB2\)];
 bamat \= \[rep2(BA1\) rep2(BA2\)];
 bamat2 \= \[rep(BA1\) rep(BA2\)];
 ab \= mvnpdf(abmat, abmat2, sig2d);
 ba \= mvnpdf(bamat, bamat2, sig2d);
 ab4 \= reshape(ab, \[size(AB1\) size(AB2\)]);
 ba4 \= reshape(ba, \[size(BA1\) size(BA2\)]);
 dat4 \= repmat(Pax, \[1, 1, size(Pax)]);
 Pab\_n \= dalpha\*dalpha\*trapz(trapz(ba4\.\*dat4, 2\), 1\);
 Pax\_n \= Pdat2d(xt, xr).\*squeeze(Pab\_n);
 omega \= dalpha\*dalpha\*trapz(trapz(Pax\_n));
 
 elseif(length(Ddt)\=\=2\) % independent 1\-D priors
 
 % integrate alpha \& beta together
 % aa \= Naa(A1, A2\);
 % bb \= Nbb(B1, B2\);
 % aa2 \= repmat(reshape(aa, length(alphas), 1, length(alphas), 1\), 1, length(betas), 1, length(betas));
 % bb2 \= repmat(reshape(bb, 1, length(betas), 1, length(betas)), length(alphas), 1, length(alphas), 1\);
 % ab4 \= aa2\.\*bb2;
 % dat4 \= repmat(Pax, \[1, 1, size(Pax)]);
 % Pab\_n \= dalpha\*dalpha\*trapz(trapz(ab4\.\*dat4, 2\), 1\);
 % Pax\_n \= Pdat2d(xt, xr).\*squeeze(Pab\_n);
 
 % integrate alpha then beta
 Paa\_n \= squeeze(dalpha\*trapz( repmat(Naa(A1,A2\), 1, 1, length(betas)).\*repmat( reshape(Pax,\[1, size(Pax)]), length(alphas), 1, 1\), 2\));
 Pab\_n \= dalpha\*trapz( repmat(reshape(Nbb(B1,B2\), \[1, size(Nbb(B1,B2\))]), length(alphas),1, 1\).\*repmat( reshape(Paa\_n,\[size(Paa\_n,1\), 1, size(Paa\_n,2\)]), 1, length(betas), 1\), 3\);
 Pax\_n \= Pdat2d(xt, xr).\*Pab\_n;
 omega \= dalpha\*dalpha\*trapz(trapz(Pax\_n));
 
 end
 
 if(omega\=\=0\)
 Pax \= Pax\_n;
 else
 Pax \= Pax\_n/omega;
 end
 Pa{n} \= Pax;
 fitstruct.Pa{n} \= Pa{n};
 fitstruct.logPdat{n} \= Pdat2d(xt, xr);
 end
 
% fitstruct.Pdata(n,:) \= Pdat(alphas, xt, xr)./omega;
% fitstruct.logPdata(n,:) \= logPdat(alphas, xt, xr);



end

m\=1;
for n\=1:(length(txe)\-1\)
 if(\~ismember(n, inds))
 tEst(m) \= txe(n);
 if(nstim\=\=1\)
% if(logdat)
% Pan \= exp(Pa(n,:))/(dalpha\*trapz(exp(Pa(n,:))));
% meanEst(m) \= trapz( alphas.\* Pan ) / trapz(Pan);
% vEst(m) \= trapz( alphas.^2\.\* Pa(n,:) ) / trapz(Pa(n,:)) \- meanEst(m)^2;
% else
 meanEst(m) \= trapz( alphas.\* Pa(m,:) ) / trapz(Pa(m,:));
 vEst(m) \= trapz( (alphas\-meanEst(m)).^2\.\*Pa(m,:) ) / trapz(Pa(m,:));
 vEst2(m) \= trapz( alphas.^2\.\* Pa(n,:) ) / trapz(Pa(n,:)) \- meanEst(m)^2;
% end
 elseif(nstim\=\=2\)
 omega \= trapz(trapz(Pa{n}));
 if(omega\=\=0\)
 meanEst(1, m) \= dalpha\*trapz( alphas'.\*trapz(Pa{m}, 2\) );
 meanEst(2, m) \= dalpha\*trapz( betas.\*trapz(Pa{m}, 1\) );
 vEst(1, 1, m) \= dalpha\*trapz( (alphas\-meanEst(1,m)).^2\.\* Pa{m} );
 vEst(2, 2, m) \= dalpha\*trapz( (betas\-meanEst(2,m))'.^2\.\* Pa{m} ) ;
 vEst(1,2,m) \= trapz( (alphas\-meanEst(1,m))'.\*trapz((betas\-meanEst(2,m)).\*Pa{m}, 2\) );
 vEst(2,1,m) \= vEst(1,2,m);
 else
 meanEst(1,m) \= trapz( alphas'.\*trapz(Pa{m}, 2\) )./omega;
 meanEst(2,m) \= trapz( betas.\*trapz(Pa{m}, 1\) )./omega;
 vEst(1,1,m) \= trapz( (alphas\-meanEst(1,m))'.^2\.\* trapz(Pa{m},2\) )./omega;
 vEst(2,2,m) \= trapz( (betas\-meanEst(2,m)).^2\.\* trapz(Pa{m},1\) )./omega;
 vEst(1,2,m) \= trapz( (alphas\-meanEst(1,m))'.\*trapz((betas\-meanEst(2,m)).\*Pa{m}, 2\) )./omega;
 vEst(2,1,m) \= vEst(1,2,m);
 end
 end
 
 m \= m\+1;
 end
end

fitstruct.Ddt \= Ddt;
fitstruct.tx \= tEst;
fitstruct.alpha \= meanEst;
fitstruct.valpha \= vEst;


end


function scaledValues \= ScaledData(fitstruct, data, dt, timeType)

if(strcmpi(timeType, 'ton'))
 tx \= fitstruct.tx\_ton;
 alpha \= fitstruct.alpha\_ton;
else
 tx \= fitstruct.tx;
 alpha \= fitstruct.alpha;
end

for i\=1:size(alpha,1\)
 talpha(:,i) \= interp1(tx, alpha(i,:), data.turnTe, 'spline');
 ralpha(:,i) \= interp1(tx, alpha(i,:), data.runTe, 'spline');
end

scaledValues.deltaT \= dt;
scaledValues.turnX \= data.turnXe;
scaledValues.turnT \= data.turnTe;
scaledValues.turnEti \= data.turnEtie;
scaledValues.runX \= data.runXe;
scaledValues.runT \= data.runTe;
scaledValues.runEti \= data.runEtie;

if(isfield(data, 'turnTon'))
scaledValues.turnTon \= data.turnTon;
scaledValues.runTon \= data.runTon;
end

scaledValues.alphaT \= talpha;
scaledValues.alphaR \= ralpha;
scaledValues.tval \= data.turnXe .\* talpha;
scaledValues.rval \= data.runXe .\* ralpha;

end

function \[params, nLL, LL] \= fitScaledRate(funs, tdata, talpha, rdata, ralpha, deltaT, r0, rescale\_type, pdegree, multiType)

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';

nstim \= size(tdata, 2\);


if(nstim\=\=1\)
 rate \= @(p,xd) funs.ratefun(p, xd);
 if(pdegree\=\=1\)
 p0 \= \[0 r0];
 elseif(pdegree\=\=2\)
 p0 \= \[0 0 r0];
 end
elseif(nstim\=\=2 \&\& pdegree\=\=2\)
 if(strncmpi(multiType, 'add', 3\))
 rate \= @(p,xd) exp( p(2\)\* (cos(p(1\))\*xd(:,1\) \+ sin(p(1\))\*xd(:,2\)).^2 \+ p(3\)\* (cos(p(1\))\*xd(:,1\) \+ sin(p(1\))\*xd(:,2\)) \+ p(4\) ) ;
 p0 \= \[pi/4 0 0 r0];
 elseif(strncmpi(multiType, 'mult', 3\))
 rate \= @(p,xd) exp( p(1\)\*xd(:,1\).^2 \+ p(2\)\*xd(:,1\) \+ p(3\)\*xd(:,2\).^2 \+ p(4\)\*xd(:,2\) \+ p(5\) ) ;
 p0 \= \[0 0 0 0 r0];
 end
elseif(nstim\=\=2 \&\& pdegree\=\=1\)
 rate \= @(p,xd) exp( p(1\)\*xd(:,1\) \+ p(2\)\*xd(:,2\) \+ p(3\) );
 p0 \= \[0 0 r0];
end


if(strcmpi(rescale\_type, 'input'))
 ratefun \= @(alpha, rateP, dat) rate(rateP, alpha.\*dat);
elseif(strcmpi(rescale\_type, 'output'))
% rfun \= @(a, dat) a.\*repmat( exp(polyval(funs.params\_maxOutputRescaling, dat)), size(a));
 ratefun \= @(alpha, rateP, dat) alpha.\*( exp(polyval(rateP, dat)) \- exp(rateP(end))) \+ exp(rateP(end));
end

nlogP \= @(p) \-sum(log(ratefun(talpha, p, tdata) ) ) \+ sum(ratefun(ralpha, p,rdata)\*deltaT);

\[params, nLL] \= fminunc(nlogP, p0, op);
LL \= \-nLL \+ length(tdata)\*log(deltaT);
end


function \[params, ll] \= fitStaticRate (funs, data, scaled, pdegree, multiType)
%function params \= fitStaticRate (logratefun, params\_0, turnT, turnX, runT, runX, tx, alpha)
%maximizes log(P(data\|params)) \= sum\_turn logratefun(params, turnX\*alpha) \- sum\_run exp(logratefun(params,runX\*alpha)))\*deltaT 

nstim \= size(data.turnX, 2\);

if(scaled)
 tval \= data.tval;
 rval \= data.rval;
else
 tval \= data.turnXe;
 rval \= data.runXe;
end
teti \= data.turnEti;
reti \= data.runEti;

op \= optimoptions('fminunc');
op.Display \= 'off';
op.Algorithm \= 'quasi\-newton';


if (isempty(funs.temporalratemod) \|\| isempty(funs.tparams))
 
 funs.tparams \= \[];
 funs.temporalratemod \= @(p,td) ones(size(td));
 
 if(nstim\=\=1\)
 ratefun \= @(p,xd) funs.ratefun(p, xd);
 elseif(nstim\=\=2 \&\& pdegree\=\=2\)
 
 if(strncmpi(multiType, 'add', 3\))
 ratefun \= @(p,xd) exp( p(2\)\* (cos(p(1\))\*xd(:,1\) \+ sin(p(1\))\*xd(:,2\)).^2 \+ p(3\)\* (cos(p(1\))\*xd(:,1\) \+ sin(p(1\))\*xd(:,2\)) \+ p(4\) ) ;
 elseif(strncmpi(multiType, 'mult', 3\))
 ratefun \= @(p,xd) exp( p(1\)\*xd(:,1\).^2 \+ p(2\)\*xd(:,1\) \+ p(3\)\*xd(:,2\).^2 \+ p(4\)\*xd(:,2\) \+ p(5\) ) ;
 end
 elseif(nstim\=\=2 \&\& pdegree\=\=1\)
 ratefun \= @(p,xd) exp( p(1\)\*xd(:,1\) \+ p(2\)\*xd(:,2\) \+ p(3\) );
 end
 
% if(length(funs.params)\>5\)
% p0 \= \[funs.params(1:4\) funs.params(end)];
% end
 p0 \= funs.params;
 
 nlogP \= @(p) \-sum(log(ratefun(p, tval)) ) \+ sum(ratefun(p,rval)\*data.deltaT);
 \[params, ll, exitflag] \= fminunc(nlogP, p0, op);

 
else
 tparams \= funs.tparams;
 params \= funs.params;
 ratefun \= @(p,tp,xd, td) funs.ratefun(p, xd) .\* funs.temporalratemod(tp, td);
 nlogP \= @(p) \-sum(log(ratefun(p, tparams, tval, teti)) ) \+ sum(ratefun(p,tparams, rval, reti)\*data.deltaT);
 \[params, \~, exitflag] \= fminunc(nlogP, params, op);
 if (exitflag \<\= 0\)
 warning ('static rate fit may not have converged!');
 end
 nlogP \= @(tp) \-sum(log(ratefun(funs.params, tp, tval, teti)) ) \+ sum(ratefun(funs.params,tp, rval, reti)\*data.deltaT);
 \[tparams, \~, exitflag] \= fminunc(nlogP, tparams, op);
 if (exitflag \<\= 0\)
 warning ('static rate fit may not have converged!');
 end
 nlogP \= @(p) \-sum(log(ratefun(p(1:length(params)), p((length(params)\+1\):end), tval, teti)) ) \+ sum(ratefun(p(1:length(params)), p((length(params)\+1\):end), rval, reti)\*data.deltaT);
 p0 \= \[params tparams];
 \[p, ll, exitflag] \= fminunc(nlogP, p0, op); 
 params \= p(1:length(funs.params));
 tparams \= p((length(funs.params) \+ 1\):end);
 
end



% ll \= \-ll \+ length(tval)\*log(data.deltaT);
if (exitflag \<\= 0\)
 warning ('static rate fit may not have converged!');
end
end


function data \= addStretchedValues (data, fitstruct, timeType)

if(strcmpi(timeType, 'ton'))
 tx \= fitstruct.tx\_ton;
 alpha \= fitstruct.alpha\_ton;
else
 tx \= fitstruct.tx;
 alpha \= fitstruct.alpha;
end
 
if (length(fitstruct) \=\= 1\)
 \[data.tval, data.rval] \= stretchedValues (tx, alpha, data.turnT, data.turnX, data.runT, data.runX);
else
 data.tval \= data.turnX;
 data.rval \= data.runX;
 for j \= 1:length(fitstruct)
 ti \= data.turnExpnum \=\= j;
 ri \= data.runExpnum \=\= j;
 \[tval, rval] \= stretchedValues(tx, alpha, data.turnT(ti), data.turnX(ti,:), data.runT(ri), data.runX(ri,:));
 data.tval(ti,:) \= tval;
 data.rval(ri,:) \= rval;
 end
end
end

function \[tval, rval] \= stretchedValues (tx, alpha, turnT, turnX, runT, runX)
for i\=1:size(alpha,1\)
 tval(:,i) \= turnX(:,i) .\* interp1(tx, alpha(i,:), turnT, 'spline');
 rval(:,i) \= runX(:,i) .\* interp1(tx, alpha(i,:), runT, 'spline');
end
end



function fitstruct \= normAlpha (fitstruct, data, timeType, expnum)
if (length(fitstruct) \> 1\)
 for j \= 1:length(fitstruct)
 fitstruct(j) \= normAlpha (fitstruct(j), data, j);
 end
 return;
end
if (existsAndDefault('expnum', \[]))
 tinds \= data.turnExpnum \=\= expnum;
 rinds \= data.runExpnum \=\= expnum;
else
 tinds \= true(size(data.turnT));
 rinds \= true(size(data.runT));
end

if(strcmpi(timeType, 'ton'))
 if(isfield(data, 'runTon'))
 runT \= data.runTon;
 turnT \= data.turnTon;
 else
 runT \= data.runT;
 turnT \= data.turnT;
 end
 nr\_ton \= histcounts(runT(rinds), binEdgesFromCenters(fitstruct.tx\_ton));
 nt\_ton \= histcounts(turnT(tinds), binEdgesFromCenters(fitstruct.tx\_ton));
 wton \= (nr\_ton \+ nt\_ton)/sum(nr\_ton \+ nt\_ton);
 wton \= wton(:);
 alpha\_ton \= fitstruct.alpha\_ton';
 norm\_factor \= sum(alpha\_ton.\*repmat(wton, \[1 size(alpha\_ton,2\)]),1\);
 alpha\_ton \= alpha\_ton ./ repmat(norm\_factor, \[size(alpha\_ton,1\) 1]);
 fitstruct.alpha\_ton \= alpha\_ton';
else
 nr\_t \= histcounts(data.runT(rinds), binEdgesFromCenters(fitstruct.tx));
 nt\_t \= histcounts(data.turnT(tinds), binEdgesFromCenters(fitstruct.tx));
 wt \= (nr\_t \+ nt\_t)/sum(nr\_t \+ nt\_t);
 wt \= wt(:);
 alpha \= fitstruct.alpha';
 alpha(isnan(alpha)) \= 0; %jwolk
 norm\_factor \= sum(alpha.\*repmat(wt, \[1 size(alpha,2\)]),1\);
 alpha \= alpha ./ repmat(norm\_factor, \[size(alpha,1\) 1]);
 fitstruct.alpha \= alpha';
end

end

\-\-\-

\#\#\# Folder: @MaggotSegmentOptions (ID: @MaggotSegmentOptions)

\-\-\-

\#\#\# File: MaggotSegmentOptions.m (ID: @MaggotSegmentOptions.1\)

classdef MaggotSegmentOptions
 %Options for segmenting a maggot track
 
 properties
 
 curv\_cut \= 0\.4; %if track curvature \> curv\_cut, end a run
 autoset\_curv\_cut \= false; %if true, curvature cut is set to autoset\_curv\_cut\_mult/body length 
 autoset\_curv\_cut\_mult \= 5; 
 theta\_cut \= pi/2; %if body theta \> theta\_cut, end a run
 speed\_field \= 'speed'; %name of field that contains speed to use (normally 'speed')
 stop\_speed\_cut \= 2; %if speed \< stop\_speed\_cut, end a run
 start\_speed\_cut \= 3; %if speed \> start\_speed\_cut \&\& vel\_dp \> aligned\_dp, run can start
 aligned\_dp \= cosd(45\); %if vel\_dp \> aligned\_dp \&\& speed \> start\_speed\_cut, run can start
 
 minRunTime \= 2\.5; %if run is less than this many seconds, discard 
 minRunLength \= 0; %if run is less than this distance, discard
 
 % minStopTime \= 2; %not used right now
 % headswing\_dtheta\_dt \= deg2rad(10\); %degrees per second
 headswing\_start \= deg2rad(20\); %if body theta \> headswing\_start and not in a run, start a headswing
 
 headswing\_stop \= deg2rad(10\); %if body theta \< headswing\_stop (or changes sign), end headswing
 % avgAngleTime \= 1; %not used right now
 
 smoothBodyFromPeriFreq \= false; %if true, we smooth the body bend angle using peristalsis frequency as a guide, rather than derivation rules
 smoothBodyTime \= \[]; %if not empty, we smooth the body bend angle with this time instead of using derivation rules; overrised sbfpf above
 
 
 end
 
 methods
 end
 
end


\-\-\-

\#\#\# Folder: @WormReorientation (ID: @WormReorientation)

\-\-\-

\#\#\# File: firstTurn.m (ID: @WormReorientation.1\)

function st \= firstTurn(reo) 
% get the first turn of a reorientation or vector of reorientations
% function st \= firstTurn(reo) 
%
% outputs: 
% ST \< sharpTurn;
% inputs:
% REO \< WormReorientation;

for j \= 1:length(reo)
 st(j) \= reo(j).sharpTurn(1\); %\#ok
end
\-\-\-

\#\#\# File: getReport.m (ID: @WormReorientation.2\)

function str \= getReport(reo, varargin)
%generates a report about a run
%function getReport(reo, varargin)
%
%output: STR (a string, or cell of strings if multiple runs)
%input: reo \< WormReorientation

precision \= '%.1f';
varargin \= assignApplicable(varargin);

infostr \= \['Reorienation: duration ' num2str(diff(reo.track.getDerivedQuantity('eti', false, \[reo.startInd reo.endInd])), precision) ...
 's. Consists of ' num2str(reo.numTurns) ' turns.'];
ststr \= 'Turn sequence: ';
for j \= 1:length(reo.sharpTurn)
 ststr \= \[ststr reo.sharpTurn(j).type ' '];
end

degstr \= \['Theta in: ', num2str(rad2deg(reo.thetaIn), precision) ', Theta out: ' num2str(rad2deg(reo.thetaOut), precision) ', D Theta: ' ...
 num2str(rad2deg(reo.dTheta), precision)];

str \= {infostr, ststr, degstr};

\-\-\-

\#\#\# File: addTurn.m (ID: @WormReorientation.3\)

function addTurn(reo, st)
%WormReorientation/addTurn
%adds a turn to the reorientation
reo.track \= st.track;
reo.sharpTurn \= \[reo.sharpTurn st];
\[\~,I] \= sort(\[reo.sharpTurn.startInd]);
reo.sharpTurn \= reo.sharpTurn(I);

%reo.calculateMetrics();

\-\-\-

\#\#\# File: calculateMetrics.m (ID: @WormReorientation.4\)

function calculateMetrics(reo)
%WormReorientation/
%function calculateMetrics(reo)
%
if (length(reo) \> 1\)
 for j \= 1:length(reo)
 reo(j).calculateMetrics;
 end
 return;
end

if (isempty(reo) \|\| isempty(reo.sharpTurn))
 return;
end

reo.startInd \= reo.sharpTurn(1\).startInd;
reo.endInd \= reo.sharpTurn(end).endInd;
if (isempty(reo.prevRun))
 reo.thetaIn \= reo.sharpTurn(1\).thetaIn;
else 
 reo.thetaIn \= reo.prevRun.endTheta;
end
if (isempty(reo.nextRun))
 reo.thetaOut \= reo.sharpTurn(end).thetaOut;
else
 reo.thetaOut \= reo.nextRun.startTheta;
end

reo.dTheta \= diff(unwrap(\[reo.thetaIn;reo.thetaOut]));
 
reo.inds \= reo.startInd:reo.endInd;

reo.numTurns \= length(reo.sharpTurn);
reo.turnsequence \= \[reo.sharpTurn.typeCode];

\-\-\-

\#\#\# File: WormReorientation.m (ID: @WormReorientation.5\)

classdef WormReorientation \< TrackPart
 %a worm reorientation, consisting of multiple sharp turns
 
 properties
 sharpTurn;
 numTurns;
 thetaIn;
 thetaOut;
 dTheta;
 turnsequence;
 end
 properties (Dependent \= true)
 prevRun;
 nextRun;
 prevDir;
 nextDir;
 end
 
 methods
 function nr \= get.nextRun(obj)
 nr \= obj.getAdjacent('next', 'run');
 end
 function pr \= get.prevRun(obj)
 pr \= obj.getAdjacent('prev', 'run');
 end
 function nd \= get.nextDir(obj)
 nd \= obj.thetaOut;
 end
 function pd \= get.prevDir(obj)
 pd \= obj.thetaIn;
 end
 end
 methods
 addTurn(reo, st);
 calculateMetrics(reo);
 st \= firstTurn(reo); 
 str \= getReport(reo, varargin);
 tf \= turnsequenceEquals(reo, turnsequence);
 end
 
end


\-\-\-

\#\#\# File: turnsequenceEquals.m (ID: @WormReorientation.6\)

function tf \= turnsequenceEquals(reo, turnsequence)
% true iff reo.trunsequence \=\= turnsequence; works on vectors of reo
% element by element
% function tf \= turnsequenceEquals(reo, turnsequence)
if (isempty(reo))
 tf \= \[];
 return;
end

if (length(reo) \> 1\)
 tf \= false(size(reo));
 for j \= 1:length(reo)
 tf(j) \= reo(j).turnsequenceEquals(turnsequence);
 end
 return;
end

tf \= (length(reo.turnsequence) \=\= length(turnsequence) \&\& all(reo.turnsequence \=\= turnsequence));

\-\-\-

\#\#\# Folder: SemiAutomaticAnalysis (ID: SemiAutomaticAnalysis)

\-\-\-

\#\#\# File: createBinFileExtractionInfo.m (ID: SemiAutomaticAnalysis.1\)

function extractionInfo \= createBinFileExtractionInfo(basedir, outputdir, extractionSettings)
%function extractionInfo \= createBinFileExtractionInfo(basedir, outputdir, extractionSettings)

es.style \= 'marc';
es.imdirname \= 'Image Data';
es.extdirname \= 'Extracted';
es.data\_file\_extensions \= {'.tim', '.tmp', '.dat'};
es.processingParams \= \[];
if (nargin \=\= 0\)
 extractionInfo \= es;
 return;
end

if (exist('extractionSettings', 'var') \&\& isstruct(extractionSettings) \&\& \~isempty(extractionSettings))
 fn \= fieldnames(extractionSettings);
 for j \= 1:length(fn)
 es.(fn{j}) \= extractionSettings.(fn{j});
 end
end

fn \= recursiveDirectorySearch(basedir, '\*.mmf');

for j \= 1:length(fn)
 info(j) \= getExtraDataFiles (createOutputFileNames(parseDirectoryAndFileName(fn{j}, 'marc'), basedir, outputdir, es.imdirname, es.extdirname), es.data\_file\_extensions);
% pause
end

if (isempty(es.processingParams))
 \[\~,processingParams] \= defaultExtractionProcessingParams;
else
 processingParams \= es.processingParams;
end
\[beset, bename, infoset] \= createBatchFiles(info, processingParams);
for j \= 1:length(beset)
 extractionInfo(j).batchExtractor \= beset(j);
 extractionInfo(j).batchDestination \= bename{j};
 extractionInfo(j).fileInfo \= infoset{j};
end
 
 

\-\-\-

\#\#\# File: createBatchFiles.m (ID: SemiAutomaticAnalysis.2\)

function \[beset, bename, infoset] \= createBatchFiles(info, processingParams)
%function beset \= createBatchFiles(info, processingParams)
%

\[be, pp] \= defaultExtractionProcessingParams;
existsAndDefault('processingParams', pp);

\[f2p, oe] \= createFileToProcess(info,processingParams);
info \= info(\~oe);
f2p \= f2p(\~oe);


\[gt,\~,I] \= unique({info.genotype});
beind \= 0;
for j \= 1:length(gt)
 inf \= info(I \=\= j);
 fp \= f2p(I \=\= j);
 \[et, \~, K] \= unique({inf.experimentType});
 for k \= 1:length(et)
 beind \= beind \+ 1;
 beset(beind) \= be; %\#ok\<\*AGROW\>
 beset(beind).files\_to\_process \= fp(K \=\= k);
 bename{beind} \= \[gt{j} '\_' et{k} '\_' datestr(now, 'yyyy\-mm\-dd\_HH\-MM') '.bxx'];
 infoset{beind} \= inf(K \=\= k);
 end
 
end


\-\-\-

\#\#\# File: defaultBatchFile.bxx (ID: SemiAutomaticAnalysis.3\)

files to process:
 \-
 file stub: no file stub specified
 output file: no output file specified
 processing params:
 fstub: no fstub
 extension: mmf
 padding: 0
 outputname: no outputname
 headerinfoname: no headername
 logName: no logname
 verbosity level: 2
 startFrame: 0
 endFrame: \-1
 analysis rectangle:
 \- 0
 \- 0
 \- \-1
 \- \-1
 minArea: 5
 maxArea: 2000
 overallThreshold: 30
 winSize: 50
 nBackgroundFrames: 5
 background\_resampleInterval: 200
 background\_blur\_sigma: 0
 thresholdScaleImage: ""
 blurThresholdIm\_sigma: 10
 frame normalization method: 0
 imStackLength: 0
 maxExtractDist: 15
 showExtraction: true
 max maggot contour angle: 1\.5708
default processing params: \~
\-\-\-

\#\#\# File: parseDirectoryAndFileName.m (ID: SemiAutomaticAnalysis.4\)

function info \= parseDirectoryAndFileName (fullfilename, style, varargin)
%function info \= parseDirectoryAndFileName (fullfilename, style, varargin)
%
% used by semi\-automatic analysis
%
% parses directory structure and file name to get information about the
% experimental setup and genotype of animal in the experiment
%
% this will be used to create output files during extraction
%
% style determines the behavior of this function; currently only 'marc' is
% implemented
%
% example for style 'marc'
% image stack is 
% \\\\labnas2\\LarvalCO2\\Image Data\\ethyl acetate 2000X diluted Spatial\\50mL
% air through 2000X diluted ethyl acetate\\CS\\20110215\\1657\\CS\_stack.mmf
% info.fstub \= \\\\labnas2\\LarvalCO2\\Image Data\\ethyl acetate 2000X diluted Spatial\\50mL
% air through 2000X diluted ethyl acetate\\CS\\20110215\\1657\\CS\_stack
% info.extension \= '.mmf';
% info.descriptiveStub \= 'CS'
% info.timeStamp \= '1657'
% info.date \= '20110215'
% info.genotype \= 'CS'
% info.experimentType \= '50mL air through 2000X diluted ethyl acetate'
% info.basepath \= '\\\\labnas2\\LarvalCO2\\Image Data\\ethyl acetate 2000X diluted Spatial\\'

existsAndDefault('style', 'marc');
info.originalName \= fullfilename;
info.style \= style;
switch (lower(style))
 case ('marc')
 %directory structure is .../experiment type/genotype/YYYYMMDD/HHMM/genotypeOrSomethingDescriptive\_stack.mmf

 \[pathstr, name, info.extension] \= fileparts(fullfilename);
 info.fstub \= fullfile(pathstr, name);
 ind \= strfind(name, '\_stack');
 if (\~isempty(ind))
 info.descriptiveStub \= name(1:(ind\-1\));
 else
 info.descriptiveStub \= name;
 end
 
 \[pathstr, info.timeStamp] \= fileparts(pathstr);
 \[pathstr, info.date] \= fileparts(pathstr);
% \[pathstr, info.month] \= fileparts(pathstr);
% \[pathstr, info.year] \= fileparts(pathstr);
 \[pathstr, info.genotype] \= fileparts(pathstr);
 \[pathstr, info.experimentType] \= fileparts(pathstr);
 info.basepath \= pathstr;
 case ('janelia')
 %directory structure is
 %tracker/protocol/gal4(effector)/2011/09/27/1415/datafiles
 \[pathstr, name, info.extension] \= fileparts(fullfilename);
 info.fstub \= fullfile(pathstr, name);
 info.descriptiveStube \= name;
 \[pathstr, info.timeStamp] \= fileparts(pathstr);
 \[pathstr, info.day] \= fileparts(pathstr);
 \[pathstr, info.month] \= fileparts(pathstr);
 
 
 
 otherwise
 error (\['style ' style ' not implemented yet']);
end
 

\-\-\-

\#\#\# File: batchExtractorToString.m (ID: SemiAutomaticAnalysis.5\)

function str \= batchExtractorToString (be)

for j \= 1:length(be.files\_to\_process)
 be.files\_to\_process(j).processing\_params.fstub \= be.files\_to\_process(j).file\_stub;
 \[d,fn] \= fileparts(be.files\_to\_process(j).output\_file);
 be.files\_to\_process(j).processing\_params.headerinfoname \= fullfile(d, \[fn '\_header.txt']);
 be.files\_to\_process(j).processing\_params.logName \= fullfile(d, \[fn '\_log.txt']);
 be.files\_to\_process(j).processing\_params.outputname \= be.files\_to\_process(j).output\_file;
end

str \= WriteYamlToString(be);
str \= strrep(str, 'thresholdScaleImage: null', 'thresholdScaleImage: ""');
str \= strrep(str, '\[]', '\~'); 

str \= regexprep(str, '\[^\-] file stub:', '\\n\-\\n file stub:');
str \= regexprep(str, '\-\[ \\f\\t\\v]\+file stub:', '\-\\n file stub:');

\-\-\-

\#\#\# File: getExtraDataFiles.m (ID: SemiAutomaticAnalysis.6\)

function info \= getExtraDataFiles (info, validExtensions, invalidExtensions)
%function info \= getExtraDataFiles (info, validExtensions,invalidExtensions)
%
% creates src and destination extra data file names (.dat .tim .tmp etc.)
% to copy to a new directory based on
% information in info (info is generated by parseDirectoryAndFileName and
% refined by createOutputFileNames)
%
% uses info.originalName and looks for associated extra data with same stub
%
% copyExtraDataFiles(info), copies (.dat .tim .tmp) files only
% copyExtraDataFiles(info, {'.a', '.b', '.c'}) copies only files with .a
% .b. .c extensions
% copyExtraDataFiles(info, \[], {'.d', '.e'}) copies everything but 
%
% if validExtensions and invalidExtensions are both specified (this is
% dumb), we replace validExtensions with the set difference of
% validExtensions and invalidExtensions
%
% src and dst report the initial and final location of copied files
% this function will not overwrite existing files; copied reports true if
% the copy was carried out successfully

if (existsAndDefault('invalidExtensions', {}))
 existsAndDefault('validExtensions', {}); 
else
 existsAndDefault('validExtensions', {'.dat', '.tim', '.tmp'});
end

if (ischar(validExtensions))
 validExtensions \= {validExtensions};
end

if (ischar(invalidExtensions))
 invalidExtensions \= {invalidExtensions};
end

%remove the periods if any, then add them back to the beginning, making
%sure all extensions match pattern .ext
for j \= 1:length(validExtensions)
 validExtensions{j} \= \['.' validExtensions{j}(isstrprop(validExtensions{j}, 'alphanum'))];
end
for j \= 1:length(invalidExtensions)
 invalidExtensions{j} \= \['.' invalidExtensions{j}(isstrprop(invalidExtensions{j}, 'alphanum'))];
end


fs \= info.fstub;
if (strcmpi(info.extension, '.mmf'))
 ind \= strfind(fs, 'stack');
 if (\~isempty(ind))
 fs \= fs(1:(ind(end)\-1\));
 end
end
d \= dir(\[fs '.\*']);

for j \= 1:length(d)
 \[\~,\~,exts{j}] \= fileparts(d(j).name);
end
 
exts \= setdiff(exts, invalidExtensions);
if (\~isempty(validExtensions))
 exts \= intersect(exts, validExtensions);
end

if (isempty(exts))
 info.ext\_data\_src \= \[];
 info.ext\_data\_dst \= \[];
else
 for j \= 1:length(exts)
 info.ext\_data\_src{j} \= \[fs exts{j}];
 info.ext\_data\_dst{j} \= \[info.outputstub exts{j}];
 end
end
 
\-\-\-

\#\#\# File: defaultExtractionProcessingParams.m (ID: SemiAutomaticAnalysis.7\)

function \[be,pp] \= defaultExtractionProcessingParams ()
%function \[be,pp] \= defaultExtractionProcessingParams ()
%
% batchExtractor and processingParams are loaded from
% defaultExtractionParams.mat, in this directory
% if defaultExtractionParams.mat does not exist, they are loaded from 
% defaultBatchFile.bxx
%
thisdir \= fileparts(mfilename('fullpath'));%(which('defaultExtractionProcessingParams'));
if (exist(fullfile(thisdir, 'defaultExtractionParams.mat'), 'file'))
 load (fullfile(thisdir, 'defaultExtractionParams.mat'), 'be', 'pp');
else
 be \= ReadYaml(fullfile(thisdir, 'defaultBatchFile.bxx'));
 pp \= be.files\_to\_process.processing\_params;
 save (fullfile(thisdir, 'defaultExtractionParams.mat'), 'be', 'pp');
end

\-\-\-

\#\#\# File: createFileToProcess.m (ID: SemiAutomaticAnalysis.8\)

function \[f2p, outputexists] \= createFileToProcess(info, processing\_params)
%UNTITLED3 Summary of this function goes here
% Detailed explanation goes here

originalFieldName\_02138\.file\_stub \= 'file stub';
originalFieldName\_02138\.output\_file \= 'output file';
originalFieldName\_02138\.processing\_params \= 'processing params';

existsAndDefault('processing\_params', \[]);
pp \= processing\_params;

 

for j \= 1:length(info)
 f2p(j).file\_stub \= info(j).fstub;
 f2p(j).output\_file \= info(j).outputBinFile;
 if (\~isempty(pp))
 pp.fstub \= info(j).fstub;
 pp.extension \= info(j).extension(info(j).extension \~\= '.');
 pp.headerinfoname \= info(j).headerFile;
 pp.logName \= info(j).logFile;
 end
 f2p(j).processing\_params \= pp;

 if (nargout \>\= 2\)
 outputexists(j) \= (exist(info(j).outputBinFile, 'file') \=\= 2\);
 end
 f2p(j).originalFieldName\_02138 \= originalFieldName\_02138;
end


\-\-\-

\#\#\# File: createOutputFileNames.m (ID: SemiAutomaticAnalysis.9\)

function info \= createOutputFileNames (info, inputbasedir, outputbasedir, imdirname, extdirname)
%function info \= createOutputFileNames (info, inputbasedir, outputbasedir, imdirname, extdirname)
%
% INFO: structure created by parseDirectoryAndFileName
% INPUTBASEDIR (optional): the base directory where images are stored, this part of
% the path will be replaced with outputbasedir, assumed to be at the beginning
% of the file path
% OUTPUTBASEDIR (required if inptubasedir is defined): the base directory where extracted images are to be placed
% IMDIRNAME (optional): the name of the folder holding image data; this will be
% changed to extdirname
% EXTDIRNAME (required if imdirname is defined): the name of the folder
% holding extracted data
% pass empty brackets to bypass arguments
%
% example for style 'marc'
% image\_stack is 
% \\\\labnas2\\LarvalCO2\\Image Data\\ethyl acetate 2000X diluted Spatial\\50mL air through 2000X diluted ethyl acetate\\CS\\20110215\\1657\\CS\_stack.mmf
% info \= parseDirectoryAndFileName(image\_stack) results in:
% info.descriptiveStub \= 'CS'
% info.timeStamp \= '1657'
% info.date \= '20110215'
% info.genotype \= 'CS'
% info.experimentType \= '50mL air through 2000X diluted ethyl acetate'
% info.basepath \= '\\\\labnas2\\LarvalCO2\\Image Data\\ethyl acetate 2000X diluted Spatial\\'
%
% inputbasedir \= '\\\\labnas2\\LarvalCO2\\Image Data'
% outputbasedir \= 'E:\\LarvalCO2\\Extracted'
% imdirname \= \[]
% extdirname \= \[]
% or
% inputbasedir \= '\\\\labnas2\\'
% outputbasedir \= 'E:\\'
% imdirname \= 'Image Data'
% extdirname \= 'Extracted'
%
% both result in extracted bin file:
%'E:\\LarvalCO2\\Extracted\\ethyl acetate 2000X diluted Spatial\\50mL air through 2000X diluted ethyl acetate\\CS\\20110215\_1657\_CS\_tracks.bin'
anythingBueller \= false;
anythingBueller \= anythingBueller \| (existsAndDefault ('inputbasedir', \[]) \& existsAndDefault ('outputbasedir', \[]));
anythingBueller \= anythingBueller \| (existsAndDefault ('imdirname', \[]) \& existsAndDefault ('extdirname', \[]));
if (\~anythingBueller)
 disp ('type help createOutputFileNames for more info');
 error ('at least one pair of inputbasedir/outputbasedir or imdirname/extdirname must be defined');
end

switch (lower(info.style))
 case 'marc'
 info.outputbasepath \= swapOutDirectories (info.basepath, inputbasedir, outputbasedir, imdirname, extdirname);
 info.outputstub \= fullfile(info.outputbasepath, info.experimentType, info.genotype, \[info.date '\_' info.timeStamp '\_' info.descriptiveStub '\_tracks']);
 info.outputBinFile \= \[info.outputstub '.bin'];
 info.headerFile \= \[info.outputstub '\_header.txt'];
 info.logFile \= \[info.outputstub '\_extraction\_log.txt'];
 otherwise
 error (\['style: ' info.style ' not defined. Only ''marc'' is currently implemented']);
end
 
function outputpath \= swapOutDirectories (basepath, inputbasedir, outputbasedir, imdirname, extdirname)
 if (\~isempty(inputbasedir))
 \[common, residual] \= getCommonPath(basepath, inputbasedir);
 if (isempty(common))
 warning (\['basepath: ' basepath ' and inputbasedir ' inputbasedir ' have nothing in common']);
 else
 if (\~isSameFile(common, inputbasedir))
 basepath
 inputbasedir
 outputbasedir
 imdirname
 extdirname
 \[c, r] \= getCommonPath(inputbasedir, common);
 warning (\[c ' is common to base path and inputbasedir, but ' r ' is found only in inputbasedir']);
 end
 end
 
 outputpath \= fullfile(outputbasedir, residual);
 else
 outputpath \= basepath;
 end
 
 if (\~isempty(imdirname))
 c \= pathToCellOfStrings(outputpath);
 ind \= find(strcmpi(imdirname, c));
 if (isempty(ind))
 warning (\[imdirname ' is not parth of base path: ' basepath]);
 else
 if (length(ind) \> 1\)
 warning (\[imdirname ' appears multiple times in base path: ' basepath ' (replacing first instance only)']);
 ind \= ind(1\);
 end
 c{ind} \= extdirname;
 end
 outputpath \= fullfile(c{:});
 end
 
 if (isSameFile(basepath, outputpath))
 warning ('basepath and outputpath are identical');
 end

\-\-\-

\#\#\# Folder: @MaggotTrackPoint (ID: @MaggotTrackPoint)

\-\-\-

\#\#\# File: unCameraCalibrate.m (ID: @MaggotTrackPoint.1\)

function mtp2 \= unCameraCalibrate (mtp, camcalinfo)
 mtp2 \= mtp;
 if (isempty(camcalinfo) \|\| \~isa(camcalinfo, 'CameraCalibration'))
 return;
 end
 
 mtp2\.head \= camcalinfo.camPtsFromRealPts(mtp2\.head);
 mtp2\.tail \= camcalinfo.camPtsFromRealPts(mtp2\.tail);
 mtp2\.mid \= camcalinfo.camPtsFromRealPts(mtp2\.mid);
 mtp2\.contour \= camcalinfo.camPtsFromRealPts(mtp2\.contour);
 mtp2\.spine \= camcalinfo.camPtsFromRealPts(mtp2\.spine);
 mtp2\.loc \= camcalinfo.camPtsFromRealPts(mtp2\.loc);
 
 fn \= fieldnames(mtp2\);
 for j \= 1:length(fn)
 mtp2\.(fn{j}) \= double(mtp2\.(fn{j}));
 end
\-\-\-

\#\#\# File: drawContourAndHead.m (ID: @MaggotTrackPoint.2\)

function drawContourAndHead(pt, varargin)
%function drawContourAndHead (pt, varargin)
%@MaggotTrackPoint
%
%optional arguments and defaults
%
%offset \= \[0;0];
%contourColor \= 'k\-';
%headMarker \= 'g\*';
%tailMarker \= 'rh';


offset \= \[0;0];
contourColor \= 'k\-';
spineColor \= 'y\-';
headMarker \= 'g\*';
tailMarker \= 'rh';
varargin \= assignApplicable(varargin);
h \= pt.head \+ offset;
m \= pt.mid \+ offset;
t \= pt.tail \+ offset;
c \= pt.contour \+ repmat(offset, 1, length(pt.contour));
c(:,end\+1\) \= c(:,1\); 


plot (h(1\),h(2\),headMarker, t(1\),t(2\),tailMarker, \[t(1\),m(1\),h(1\)], \[t(2\),m(2\),h(2\)], spineColor, c(1,:), c(2,:), contourColor, varargin{:});

\-\-\-

\#\#\# File: MaggotTrackPoint.m (ID: @MaggotTrackPoint.3\)

classdef MaggotTrackPoint \< ImTrackPoint
 % MaggotTrackPoint extends ImTrackPoint by adding 
 % information about the head, tail, midline (spine), and contour
 
 properties
 targetArea \= \-1;
 threshold \= \-1;
 htValid \= false;
 head \= \[NaN NaN];
 mid \= \[NaN NaN];
 tail \= \[NaN NaN];
 contour \= \[NaN NaN];
 spine \= \[NaN NaN];
 end
 
 methods
 tp \= fromFile (tp, fid, loadIm, loadContour, camcalinfo);
 drawTrackImage(tp, camcalinfo, varargin);
 drawContourAndHead(pt, varargin);
 str \= toMWTBlobLine(tp, camcalinfo, varargin);
 mtp2 \= unCameraCalibrate (mtp, camcalinfo);
 tp \= fromJava(tp, jTP, loadIm, loadContour, camcalinfo);
 end
 
 methods
 function tp \= MaggotTrackPoint(varargin)
 tp \= tp@ImTrackPoint(varargin{:});
 if (nargin \>\= 1\) \&\& (isa(varargin{1}, 'MaggotTrackPoint'))
 op \= varargin{1};
 flist \= fieldnames(tp);
 for j \= 1:length(flist)
 tp.(flist{j}) \= op.(flist{j});
 end
 end
 end%MaggotTrackPoint
 
 end
 %}
end


\-\-\-

\#\#\# File: drawTrackImage.m (ID: @MaggotTrackPoint.4\)

function drawTrackImage (pt, camcalinfo, varargin)
%function drawTrackImage (pt, camcalinfo, varargin)
%@MaggotTrackPoint
%
%passing 'pretty', 'true' opens up the following options
%'scale', s (default 3\) \-\- scales the image to higher resolution using
%imresize
%'contourColor'
%'contourWidth'
% scale \= 3;
% drawContour \= true;
% drawHeadArrow \= true;
% contourColor \= 'r\-';
% spineColor \= 'y.';
% contourWidth \= 2;
% mhColor \= 'r';
% tmColor \= 'b\-';
% arrowSize \= 2;
% mhWidth \= 2;

if (\~exist('camcalinfo', 'var'))
 camcalinfo \= \[];
end

pretty \= false;
Axes \= \[];
varargin \= assignApplicable(varargin);
if (isempty(Axes))
 Axes \= gca;
end
%{
if (isempty(camcalinfo))
 h \= realPtsToCamera(pt.head, camcalinfo); 
 m \= realPtsToCamera(pt.mid, camcalinfo);
 t \= realPtsToCamera(pt.tail, camcalinfo);
 c \= realPtsToCamera(pt.contour, camcalinfo);
 sp \= realPtsToCamera(pt.spine, camcalinfo);
else
 %}
h \= pt.head;
m \= pt.mid;
t \= pt.tail;
c \= pt.contour;
sp \= pt.spine;
c(:,end\+1\) \= c(:,1\); %complete contour

if (\~pretty)
 drawTrackImage@ImTrackPoint(pt, camcalinfo, 'Axes', Axes, varargin{:});
 
 hold (Axes, 'on');
 % plot (Axes, h(1\),h(2\),'g\*', t(1\),t(2\),'rh', \[t(1\),m(1\),h(1\)], \[t(2\),m(2\),h(2\)],'y\-', c(1,:), c(2,:), 'r\-');
 if (\~isempty(sp) \&\& all(isfinite(sp(:))))
 plot(Axes, h(1\),h(2\),'g\*', t(1\),t(2\),'rh', sp(1,:), sp(2,:),'y.\-', c(1,:), c(2,:), 'r\-');
 else
 plot (Axes, h(1\),h(2\),'g\*', t(1\),t(2\),'rh', \[t(1\),m(1\),h(1\)], \[t(2\),m(2\),h(2\)],'y\-', c(1,:), c(2,:), 'r\-');
 end
 hold (Axes, 'off');
else
 scale \= 3;
 drawContour \= true;
 drawSpine \= true;
 drawHeadArrow \= true;
 contourColor \= 'r\-';
 spineColor \= 'y.';
 contourWidth \= 2;
 mhColor \= 'r';
 tmColor \= 'b\-';
 spineMarkerSize \= 5;
 spineLineWidth \= 2;
 arrowSize \= 2;
 mhWidth \= 2;
 varargin \= assignApplicable(varargin);
 drawTrackImage@ImTrackPoint(pt, camcalinfo, 'Axes', Axes, 'scale', scale, varargin{:});
 shading(Axes, 'interp');
 ih \= ishold(Axes);
 hold (Axes, 'on');
 if (drawContour)
 c2 \= interp1(c', 1:(1/scale):length(c));
 c2 \= lowpass1D(c2', scale); 
 plot (Axes, c2(1,\[1:end 1]), c2(2,\[1:end 1]), contourColor, 'LineWidth', contourWidth);
 
 end
 if (drawSpine \&\& pt.htValid)
 if (\~isempty(sp) \&\& all(isfinite(sp(:))))
 plot (Axes, sp(1,:), sp(2,:), spineColor, 'MarkerSize', spineMarkerSize, 'LineWidth', spineLineWidth);
 end
 end
 if (drawHeadArrow \&\& pt.htValid)
 quiver(Axes, m(1\), m(2\), h(1\)\-m(1\), h(2\)\-m(2\), 0,mhColor,'LineWidth',mhWidth,'MaxHeadSize', arrowSize);
 plot (Axes, \[t(1\) m(1\)], \[t(2\) m(2\)], tmColor, 'LineWidth', mhWidth);
 end
 if (\~ih)
 hold (Axes, 'off');
 end
end
\-\-\-

\#\#\# File: toMWTBlobLine.m (ID: @MaggotTrackPoint.5\)

function str \= toMWTBlobLine(tp, camcalinfo, varargin)
% function str \= toMWTBlobLine(tp, camcalinfo, varargin)
% produces a line of text corresponding to a line in the mwt blob file
%
% tp \< MaggotTrackPoint
% str \- character array

if (nargin \< 2\), camcalinfo \= \[]; end
varargin \= assignApplicable(varargin);

data \= zeros(10, 1\);

data(1\) \= round(tp.ind) \+ 1; %MWT starts with frame \#1, we start with frame 0
data(2\) \= tp.et;
if (\~isempty(camcalinfo))
 data(3:4\) \= camcalinfo.camPtsFromRealPts(tp.loc);
else
 data(3:4\) \= tp.loc;
end
data(5\) \= round(tp.area);
c \= \[tp.cov(1\) tp.cov(2\); tp.cov(2\) tp.cov(3\)];

\[V,D] \= eig(c);
\[\~,I] \= sort(sum(D));
data(6:7\) \= V(:,I(2\))\*D(I(2\),I(2\));
data(8\) \= D(I(1\),I(1\));

%MWT does a fit of the maggot to a line, then gives the maximum length of a line
%parallel to that fit line with endpoints on the contour, and a similar length for the perpendicular line
%in order to avoid loading the pixel values from disk again, we will just
%use the longest line within the contour and the longest line
%perpendicular to that one

if (\~isempty(camcalinfo))
 cpts \= round(camcalinfo.camPtsFromRealPts(tp.contour));
else
 cpts \= tp.contour;
end
x \= repmat(cpts(1,:), size(cpts,2\), 1\);
y \= repmat(cpts(2,:), size(cpts,2\), 1\);
dd \= (x\-x').^2 \+ (y\-y').^2; 
\[dm,I] \= max(dd(:));
%longest distance
data(9\) \= sqrt(dm);
\[I,J] \= ind2sub(size(dd), I);

%perpendicular vector
vp \= \[\-diff(cpts(2, \[I J])) diff(cpts(1,\[I J]))];
vp \= vp./sqrt(sum(vp.^2\));
dd \= abs(vp(1\)\*(x\-x') \+ vp(2\)\*(y\-y'));
data(10\) \= max(dd(:));
str1 \= \[sprintf('%d ', data(1\)) sprintf('%8g ', data(2:end))];

if (isempty(tp.spine))
 tp.spine \= repmat(tp.loc, 11\);
end
if \~(isempty(camcalinfo))
 sp \= camcalinfo.camPtsFromRealPts(tp.spine);
else
 sp \= tp.spine;
end

sp \= interp1(find(all(isfinite(sp))), sp(:,all(isfinite(sp)))', linspace(length(sp),1, 11\))'; %reverse spine direction so head is first (MWT spinesForward plugin result)

sp(1,:) \= round(sp(1,:) \- data(3\));
sp(2,:) \= round(sp(2,:) \- data(4\));
str2 \= sprintf('%d ', sp(:));

%create chain code for contour
cpts \= removeSmallLoops(cpts);
dx \= round(diff(cpts(1,\[1:end 1])));
dy \= round(diff(cpts(2,\[1:end 1])));

while (any(abs(dx) \> 1\)) 
 I \= find(abs(dx) \> 1, 1, 'first');
 n \= abs(dx(I));
 dx \= \[dx(1:(I\-1\)) repmat(sign(dx(I)), 1, n) dx((I\+1\):end)];
 dy \= \[dy(1:I) zeros(1,n\-1\) dy((I\+1\):end)];
end

while (any(abs(dy) \> 1\)) 
 I \= find(abs(dy) \> 1, 1, 'first');
 n \= abs(dy(I));
 dy \= \[dy(1:(I\-1\)) repmat(sign(dy(I)), 1, n) dy((I\+1\):end)];
 dx \= \[dx(1:I) zeros(1,n\-1\) dx((I\+1\):end)];
end
\[dx,dy] \= convert8Connectedto4Connected(dx,dy);
if (length(dx) \< 10\)
 disp('bad contour!'); 
 tp.ind
end
str3 \= sprintf('%d %d %d %s', round(cpts(1,1\)), round(cpts(2,1\)), length(dx), toKerrChainCode(dx,dy));

str \= \[str1 ' % ' str2 ' %% ' str3];
\-\-\-

\#\#\# File: fromJava.m (ID: @MaggotTrackPoint.6\)

function tp \= fromJava(tp, jTP, loadIm, loadContour, camcalinfo)

 %tp \= fromFile@ImTrackPoint(tp, fid, loadImage, loadContour, camcalinfo);
 tp \= fromJava@ImTrackPoint(tp, jTP, loadIm, loadContour, camcalinfo);
 
 %NOT SETTING TARGETAREA
 tp.threshold \= jTP.getThresh();
 tp.htValid \= jTP.getHTValid();
 if (loadContour)
% tp.contour \= properCoords(JavaConPts2Array(jTP.getContour())', camcalinfo);
 tp.contour \= properCoords(jTP.getContourArray(), camcalinfo);
 end
 
 tp.head \= properCoords(jTP.getHead(), camcalinfo);
 tp.mid \= properCoords(jTP.getMid(), camcalinfo);
 tp.tail \= properCoords(jTP.getTail(), camcalinfo);
 if (tp.htValid)
 tp.spine \= properCoords(jTP.getMidlineArray(), camcalinfo);
 end
% if (tp.htValid)
% tp.head \= properCoords(\[jTP.getHead().getX(); jTP.getHead().getY()], camcalinfo);
% tp.mid \= properCoords(\[jTP.getMid.getX(); jTP.getMid.getY()], camcalinfo);
% tp.tail \= properCoords(\[jTP.getTail.getX(); jTP.getTail.getY()], camcalinfo);
 
 %CHANGE TO GET MIDLINE ARRAY 
% else
% tp.head \= \[NaN;NaN];
% tp.mid \= \[NaN;NaN];
% tp.tail \= \[NaN;NaN];
% tp.spine \= \[NaN;NaN];
% end
 
 
 
end
\-\-\-

\#\#\# File: fromFile.m (ID: @MaggotTrackPoint.7\)

function tp \= fromFile (tp, fid, loadImage, loadContour, camcalinfo)
%MaggotTrackPoint.fromFile
%function tp \= fromFile (tp, fid, loadImage, loadContour, camcalinfo)
%

intType \= 'int32';
floatType \= 'float32';

if (\~exist('camcalinfo', 'var'))
 camcalinfo \= \[];
end
tp \= fromFile@ImTrackPoint(tp, fid, loadImage, loadContour, camcalinfo);
tp.targetArea \= int16(fread(fid,1,intType));
tp.threshold \= single(fread(fid,1,floatType));
tp.htValid \= logical(fread(fid,1,intType));
tp.head \= single(readPointsFromFile (fid, 1, intType, camcalinfo));
tp.mid \= single(readPointsFromFile (fid, 1, intType, camcalinfo));
tp.tail \= single(readPointsFromFile (fid, 1, intType, camcalinfo));
ncpts \= fread(fid,1,intType);
if (tp.threshold \< 0 \&\& tp.targetArea \< 0 \&\& ncpts \<\= 1\)
 %ncpts
 %ftell(fid)
 %pause
end
if (loadContour)
 tp.contour \= single(readPointsFromFile (fid, ncpts, intType, camcalinfo));
else
 readPointsFromFile (fid, ncpts, intType, camcalinfo);
end

nmpts \= fread(fid, 1, intType);
tp.spine \= single(readPointsFromFile (fid, nmpts, floatType, camcalinfo));
\-\-\-

\#\#\# Folder: @MaggotReorientation (ID: @MaggotReorientation)

\-\-\-

\#\#\# File: draw.m (ID: @MaggotReorientation.1\)

function draw(reo, varargin)
% draws a symbolic representation of the reorientation; not used that much
% MaggotReorientation.draw(varargin)
% outputs: none
% inputs: 
% REO \< MaggotReorientation
% optional args:
% none yet


Colors.accepted \= 'g\-';
Colors.rejected \= 'r\-';
varargin \= assignApplicable(varargin);

ih \= ishold;

center \= mean(reo.track.dq.sloc(:,reo.inds),2\);
allpts \= \[reo.track.dq.sloc(:,reo.inds) reo.track.dq.stail(:,reo.inds) reo.track.dq.shead(:,reo.inds)];
radius \= max(sqrt (sum( (allpts \- repmat(center,1,length(allpts))).^2\)));

t \= \[0:0\.1:2\*pi]; plot (center(1\) \+ radius \* cos(t), center(2\)\+radius\*sin(t), 'k\-\-'); hold on

for j \= 1:length(reo.headSwing)
 reo.headSwing(j).draw('Colors', Colors);
end

if (\~ih)
 hold off
end
\-\-\-

\#\#\# File: calculateMetrics.m (ID: @MaggotReorientation.2\)

function calculateMetrics(reo, prevRun, nextRun)
% calcuates several metrics (e.g. previous direction) and updates head sweep metrics too
% function calculateMetrics(reo)
% outputs: none
% inputs:
% REO \< MaggotReorientation
% PREVRUN \< Run, run that ended immediately before this reorientation
% started
% NEXTRUN \< Run, run that starts immediately after this reorientation
% ends

if (\~isempty(prevRun) \&\& isa(prevRun, 'Run'))
 startInd \= prevRun.endInd \+ 1;
else
 startInd \= \[];
end
if (\~isempty(nextRun) \&\& isa(nextRun, 'Run'))
 endInd \= max(startInd,nextRun.startInd \- 1\);
else
 endInd \= \[];
end


reo.numHS \= length(reo.headSwing);
if (false \&\& \~isempty(reo.headSwing))
 reo.startInd \= min(\[reo.headSwing.startInd]);
 reo.endInd \= max(\[reo.headSwing.endInd]);
else
 reo.startInd \= startInd;
 reo.endInd \= endInd;
end
reo.inds \= reo.startInd:reo.endInd;

if (\~isempty(reo.prevRun))
 reo.prevDir \= reo.prevRun.endTheta;
end
if (\~isempty(reo.nextRun))
 reo.nextDir \= reo.nextRun.startTheta;
end

for j \= 1:length(reo.headSwing)
 reo.headSwing(j).prevDir \= reo.prevDir;
 reo.headSwing(j).nextDir \= reo.nextDir;
end

\-\-\-

\#\#\# File: MaggotReorientation.m (ID: @MaggotReorientation.3\)

classdef MaggotReorientation \< TrackPart
 % periods of reorientation between runs; in our publications, a
 % reorientation is called a "turn"
 % reorientations have zero or more headSwings ("head sweeps" in
 % publications)
 
 properties
 numHS \= 0; %number of headswings in reorientation
 headSwing; %pointer to headswings in reorientation
 prevDir \= NaN; %heading direction at end of previous run 
 nextDir \= NaN; %heading direction at start of next run
 end
 properties(Dependent \= true)
 prevRun;
 nextRun;
 end
 
 
 methods %constructor
 function reo \= MaggotReorientation (track, headswings, prevRun, nextRun)
 %if no headswings (headswings \= \[]), then pass prevRun, nextRun
 %to specify interval
 switch nargin
 case 0
 return;
 case 1
 reo.track \= track;
 return
 otherwise
 reo.track \= track;
 if (\~isempty(headswings))
 for j \= 1:length(headswings)
 headswings(j).num \= j;
 end
 end
 reo.headSwing \= headswings;
 
 existsAndDefault ('prevRun', \[]);
 existsAndDefault ('nextRun', \[]);
 reo.calculateMetrics (prevRun, nextRun);
 end
 end
 end
 
 methods
 function nr \= get.nextRun(obj)
 nr \= obj.getAdjacent('next', 'run');
 end
 function pr \= get.prevRun(obj)
 pr \= obj.getAdjacent('prev', 'run');
 end
 end
 
 
 methods 
 calculateMetrics(reo, prevRun, nextRun);
 draw(reo, varargin)
 end
end


\-\-\-

\#\#\# Folder: @ESetCleaner (ID: @ESetCleaner)

\-\-\-

\#\#\# File: getReport.m (ID: @ESetCleaner.1\)

function \[num2clean,reportstring] \= getReport(ecl, eset)
% function getReport(ecl, eset)
%
% displays a report enumerating how many tracks and points will be removed,
% and for which reasons
%
% outputs: 
% NUM2CLEAN \- number of tracks that will be removed
% inputs:
% ecl \< ESetCleaner
% eset \< ExperimentSet
reportstring \= {};
sp \= eset.gatherField('speed', 'mean');

npts \= eset.evaluateTrackExpression('length(track.dq.eti)');%npts \= eset.gatherField('npts');

nt \= length(sp);
spx \= (0:(2/nt):1\) \* (max(sp) \- min(sp)) \+ min(sp);
msg \= \[num2str(sum(sp \< ecl.minSpeed)) '/' num2str(length(sp)) ' tracks fail speed test'];

if (ecl.showFigsInReport)
 figure(); hist(sp, spx); hold on;
 yl \= get(gca, 'YLim');
 plot (ecl.minSpeed \* \[1 1], yl, 'r\-\-', 'LineWidth', 3\);
 title(msg);
end
disp(msg); reportstring \= \[reportstring msg];
msg \= \[num2str(sum(npts(sp \< ecl.minSpeed))) '/' num2str(sum(npts)) ' pts removed by speed test (' num2str(sum(npts(sp \< ecl.minSpeed))/sum(npts)\*100,2\), ' %)'];
disp(msg); reportstring \= \[reportstring msg];

if (eset.expt(1\).track(1\).validDQName('ihtValid'))
 htv \= eset.gatherField('ihtValid', 'mean');
 htvx \= (0:(2/nt):1\) \* (max(htv) \- min(htv)) \+ min(htv);
 msg \= \[num2str(sum(htv \< ecl.minHTValid)) '/' num2str(length(htv)) ' tracks fail head tail valid test'];

 if (ecl.showFigsInReport)
 figure(); hist(htv, htvx); hold on;
 yl \= get(gca, 'YLim');
 plot (ecl.minHTValid \* \[1 1], yl, 'r\-\-', 'LineWidth', 3\);
 title(msg);
 end
 disp(msg); reportstring \= \[reportstring msg];
 msg \= \[num2str(sum(npts(htv \< ecl.minHTValid))) '/' num2str(sum(npts)) ' pts removed by head\-tail valid test (' num2str(sum(npts(htv \< ecl.minHTValid))/sum(npts)\*100,2\), ' %)'];
 disp(msg); reportstring \= \[reportstring msg];
else
 htv \= ones(size(sp));
end


dst \= eset.evaluateTrackExpression('max(sqrt(sum(track(1\).getDerivedQuantity(''displacement'').^2\)))');
dstx \= (0:(2/nt):1\) \* (max(dst) \- min(dst)) \+ min(dst);
msg \= \[num2str(sum(dst \< ecl.minDist)) '/' num2str(length(dst)) ' tracks fail displacement test'];

if (ecl.showFigsInReport)
 figure(); hist(dst, dstx); hold on;
 yl \= get(gca, 'YLim');
 plot (ecl.minDist \* \[1 1], yl, 'r\-\-', 'LineWidth', 3\);
 title(msg);
end
disp(msg); reportstring \= \[reportstring msg];
msg \= \[num2str(sum(npts(dst \< ecl.minDist))) '/' num2str(sum(npts)) ' pts removed by displacement test (' num2str(sum(npts(dst \< ecl.minDist))/sum(npts)\*100,2\), ' %)'];
disp(msg); reportstring \= \[reportstring msg];
nptsx \= (0:(2/nt):1\) \* (max(npts) \- min(npts)) \+ min(npts);
msg \= \[num2str(sum(npts \< ecl.minPts)) '/' num2str(length(npts)) ' tracks fail npts test'];

if (ecl.showFigsInReport)
 figure(); hist(npts, nptsx); hold on;
 yl \= get(gca, 'YLim');
 plot (ecl.minPts \* \[1 1], yl, 'r\-\-', 'LineWidth', 3\);
 title(msg);
end
disp(msg); reportstring \= \[reportstring msg];
msg \= \[num2str(sum(npts(npts \< ecl.minPts))) '/' num2str(sum(npts)) ' pts removed by npts test (' num2str(sum(npts(npts \< ecl.minPts))/sum(npts)\*100,2\), ' %)'];
disp(msg); reportstring \= \[reportstring msg];

pa \= eset.evaluateTrackExpression('max(abs(unwrap(track.getDerivedQuantity(''theta''))))');
et \= eset.evaluateTrackExpression('max(track.getDerivedQuantity(''eti'')) \- min(track.getDerivedQuantity(''eti''))');

pa \= pa / (2\*pi);
et \= et / 60;
rpm \= pa./et;

msg \= \[num2str(sum(rpm \> ecl.rpmCut \& pa \> ecl.minRevCut)) '/' num2str(length(npts)) ' tracks are too curvy (fail rpm cut)'];
disp(msg);
if (ecl.showFigsInReport)
 rpmx \= 0:0\.1:max(rpm);
 figure(); hist(rpm, rpmx); hold on;
 yl \= get(gca, 'YLim');
 plot (ecl.rpmCut \* \[1 1], yl, 'r\-\-', 'LineWidth', 3\);
 title(msg);
end
msg \= \[num2str(sum(npts(rpm \> ecl.rpmCut \& pa \> ecl.minRevCut))) '/' num2str(sum(npts)) ' pts removed by rpm test (' num2str(sum(npts(rpm \> ecl.rpmCut \& pa \> ecl.minRevCut))/sum(npts)\*100,2\), ' %)'];
disp(msg); reportstring \= \[reportstring msg];


msg \= \[num2str(sum(npts \< ecl.minPts)) '/' num2str(length(npts)) ' tracks fail npts test, ' num2str(sum(sp \< ecl.minSpeed)) ' fail speed test, ', num2str(sum(sp \< ecl.minSpeed \& npts \< ecl.minPts)) ' fail both.'];
if (ecl.showFigsInReport)
 I \= htv \>\= ecl.minHTValid;
 figure(); plot (npts(I), sp(I), 'b.', npts(\~I), sp(\~I), 'r.'); xlabel ('npts'); ylabel('speed'); hold on;
 yl \= get(gca, 'YLim');
 plot (ecl.minPts \* \[1 1], yl, 'r\-\-', 'LineWidth', 3\);
 xl \= get(gca, 'XLim');
 plot (xl, ecl.minSpeed \* \[1 1], 'r\-\-', 'LineWidth', 3\);
 legend ({'htv passes', 'htv fails'});
 title(msg);
end

msg \= \[num2str(sum(htv \< ecl.minHTValid)) '/' num2str(length(htv)) ' tracks fail head\-tail valid test, ' num2str(sum(sp \< ecl.minSpeed)) ' fail speed test, ', num2str(sum(sp \< ecl.minSpeed \& htv \< ecl.minHTValid)) ' fail both.'];
if (ecl.showFigsInReport)
 I \= npts \>\= ecl.minPts;
 figure(); plot (htv(I), sp(I), 'b.',htv(\~I), sp(\~I), 'r.'); xlabel ('htvalid'); ylabel('speed'); hold on;
 yl \= get(gca, 'YLim');
 plot (ecl.minHTValid \* \[1 1], yl, 'r\-\-', 'LineWidth', 3\);
 xl \= get(gca, 'XLim');
 plot (xl, ecl.minSpeed \* \[1 1], 'r\-\-', 'LineWidth', 3\);
 legend ({'npts passes', 'npts fails'});
 title(msg);
end

msg \= \[num2str(sum(htv \< ecl.minHTValid)) '/' num2str(length(htv)) ' tracks fail head\-tail valid test, ' num2str(sum(npts \< ecl.minPts)) ' tracks fail npts test, ', num2str(sum(npts \< ecl.minPts \& htv \< ecl.minHTValid)) ' fail both.'];
if (ecl.showFigsInReport)
 figure(); plot (htv(sp \> ecl.minSpeed), npts(sp \> ecl.minSpeed), 'b.', htv(sp \< ecl.minSpeed), npts(sp \< ecl.minSpeed),'r.'); xlabel ('htvalid'); ylabel('npts'); hold on;
 yl \= get(gca, 'YLim');
 plot (ecl.minHTValid \* \[1 1], yl, 'r\-\-', 'LineWidth', 3\);
 xl \= get(gca, 'XLim');
 plot (xl, ecl.minPts \* \[1 1], 'r\-\-', 'LineWidth', 3\);
 title(msg);
 legend ({'speed passes', 'speed fails'});
end

nv \= htv \< ecl.minHTValid \| npts \< ecl.minPts \| dst \< ecl.minDist \| sp \< ecl.minSpeed \| (rpm \> ecl.rpmCut \& pa \> ecl.minRevCut);
num2clean \= sum(nv);
msg \= \[num2str(num2clean) '/' num2str(length(htv)) ' tracks fail at least one test'];
disp(msg); reportstring \= \[reportstring msg];
msg \= \[num2str(sum(npts(nv))) '/' num2str(sum(npts)) ' pts removed by eset cleaner (' num2str(sum(npts(nv))/sum(npts)\*100,2\), ' %)'];
disp(msg); reportstring \= \[reportstring msg];

\-\-\-

\#\#\# File: ESetCleaner.m (ID: @ESetCleaner.2\)

classdef ESetCleaner
 %rules for cleaning up sets of Experiments 
 %clean(esc, eset) will use these rules to discard tracks that likely
 %contain invalid data, according to the rules below
 
 properties
 
 minHTValid \= 0\.95; %remove all tracks where mean(ihtValid) \< minHTValid
 minSpeed \= 0; %remove all tracks where mean(speed) \< minSpeed
 minDist \= 0; %remove all tracks where max(displacement) \< minDist 
 minPts \= 0; %remove all tracks with less than minPts pts
 pruneRect \= \[]; %to be implemented later
 trimRect \= \[]; % to be implemented later
 rpmCut \= 1000; %remove if the phase angle accumulated by the track (in revolutions) is greater than the elapsed time of the track (in min) times rpmCut (rec 1\)
 minRevCut \= 3; %do not remove tracks for excessive revolution if less than this many complete revolutions
 
 askFirst \= true; %whether to show report and verify cleaning prior to removing any tracks from eset
 showFigsInReport \= true; %whether to show graphs in report or just display text on command line
 
 end
 
 methods
 \[num2clean, reportstring] \= getReport(esc, eset); %displays how many tracks will be removed \& statistics of those removals
 
 clean(esc, eset); %removes tracks that likely contain invalid data
 end
 
end


\-\-\-

\#\#\# File: clean.m (ID: @ESetCleaner.3\)

function clean(ecl, eset)
% function clean(ecl, eset)
%
% removes tracks that likely contain invalid data, according to criteria 
% stored in ecl
%
% outputs: none
% inputs:
% ecl \< ESetCleaner
% eset \< ExperimentSet

if (ecl.askFirst)
 if (ecl.getReport(eset) \=\= 0\)
 %nothing to clean
 return;
 end
 
 key \= input ('continue with cleaning? : y/\[n]', 's');
 if (isempty(key) \|\| lower(key(1\)) \~\= 'y')
 return;
 end
end

for j \= 1:length(eset.expt)

 sp \= eset.expt(j).gatherField('speed', 'mean');

 if (eset.expt(j).track(1\).validDQName('ihtValid'))
 htv \= eset.expt(j).gatherField('ihtValid', 'mean');
 else
 htv \= ones(size(sp));
 end
 dst \= eset.expt(j).evaluateTrackExpression('max(sqrt(sum(track(1\).getDerivedQuantity(''displacement'').^2\)))');
 
 npts \= eset.expt(j).evaluateTrackExpression('length(track.dq.eti)');%eset.expt(j).gatherField('npts');
 
 pa \= eset.expt(j).evaluateTrackExpression('max(abs(unwrap(track.getDerivedQuantity(''theta''))))');
 et \= eset.expt(j).evaluateTrackExpression('max(track.getDerivedQuantity(''eti'')) \- min(track.getDerivedQuantity(''eti''))');
 
 % pa \= pa / (2\*pi);
 %et \= et / 60;
 rpm \= pa./et \* 60 / (2\*pi);
 
 valid \= htv \>\= ecl.minHTValid \& npts \>\= ecl.minPts \& dst \>\= ecl.minDist \& sp \>\= ecl.minSpeed \& (rpm \< ecl.rpmCut \| pa \< ecl.minRevCut \* 2\*pi);
 eset.expt(j).track \= eset.expt(j).track(valid);
end
\-\-\-

\#\#\# Folder: @SimpleScalingCameraCalibration (ID: @SimpleScalingCameraCalibration)

\-\-\-

\#\#\# File: SimpleScalingCameraCalibration.m (ID: @SimpleScalingCameraCalibration.1\)

classdef SimpleScalingCameraCalibration \< CameraCalibration
 %SimpleScalingCameraCalibration \< handle
 %maps points from camera to real points
 %after extraction, larva position and posture are measured in pixels
 %this provides a map from each point in the image (pixel location) to 
 %physical space (usually measured in centimeters). 
 %
 %in this simplified class, you provide only a scaling factor pxpercm, which is
 %applied as cm \= px/pxpercm;
 properties
 pxpercm \= 1;
 end
 
 methods %constructor
 function cc \= SimpleScalingCameraCalibration(varargin)
 %cc \= CameraCalibration(checkerim)
 %cc \= CameraCalibration (realx, realy, camx, camy);
 switch(length(varargin))
 case 0
 return;
 case 1
 cc.pxpercm \= varargin{1};
 return;
 end
 
 end 
 end
 
 methods
 function \[realim,realxaxis,realyaxis] \= morphCamToReal(cc, camim, varargin)
 realim \= camim;
 realxaxis \= (1:size(camim,2\))/cc.pxpercm;
 realyaxis \= (1:size(camim,1\))/cc.pxpercm;
 end
 function camim \= morphRealToCam(cc, realim, varargin)
 camim \= realim;
 end
 
 function campts \= camPtsFromRealPts(cc, realpts) 
 campts \= realpts\*cc.pxpercm;
 end
 function realpts \= realPtsFromCamPts(cc, campts)
 realpts \= campts/cc.pxpercm; 
 end
 function magfactor \= pixelsPerRealUnit (cc)
 magfactor \= cc.pxpercm;
 end
 function magfactor \= realUnitsPerPixel (cc)
 magfactor \= 1/cc.pxpercm;
 end
 
 end
end


\-\-\-

\#\#\# Folder: @GlobalLookupTable (ID: @GlobalLookupTable)

\-\-\-

\#\#\# File: GlobalLookupTable.m (ID: @GlobalLookupTable.1\)

classdef GlobalLookupTable \< GlobalQuantity
 %UNTITLED5 Summary of this class goes here
 % Detailed explanation goes here
 
 properties
 highResDerivationMethod \= @GlobalQuantity.oneDinterpolation\_Clipped;
 
 end
 
 methods
 
 
 %{
 function data \= eventTriggeredDataMatrix(glt, expt, trackpart, position, varargin)
 if (isa(expt, 'ExperimentSet'))
 data \= \[];
 for j \= 1:length(expt.expt)
 data \= \[data eventTriggeredDataMatrix(glt, expt.expt(j), trackpart, position, varargin{:})];
 end
 return
 end
 
 xField \= glt.xField;
 varargin \= assignApplicable(varargin);
 end
 %}
 
 function data \= makeDataMatrixStretched(glt, starts, stops, npoints, varargin)
 %like makeDataMatrix, but instead each row running over
 %center\+displacement axis, each row runs over
 %linspace(starts(j), stops(j), npoints)
 
 starts \= starts(:);
 stops \= stops(:);
 
 mult1 \= repmat(linspace(0,1,npoints), size(starts));
 mult2 \= 1\-mult1;
 da \= reshape(repmat(starts, \[npoints 1]), size(mult1\)).\*mult2 \+ reshape(repmat(stops, \[npoints 1]), size(mult2\)).\*mult1;
 data \= reshape(interp1(glt.xData, glt.yData, da(:), 'linear', NaN), size(da)); 
 end
 
 function \[avg,datamatrix] \= triggeredStretchedAverage (glt, starts, stops, npoints, varargin)
 datamatrix \= makeDataMatrixStretched(glt, starts, stops, npoints, varargin{:});
 datamatrix2 \= datamatrix;
 datamatrix2(\~isfinite(datamatrix)) \= 0; %replace unknown values with 0
 avg \= sum(datamatrix2\)./sum(isfinite(datamatrix)); %average is sum of known values / number of known values
 
 end
 
 
 function data \= makeDataMatrix(glt, centers, displacementAxis, varargin)
 % data \= makeDataMatrix(glt, centers, displacementAxis, varargin) 
 % data is a matrix of values; each (row/column \-\- figure out
 % Natalie) represents interpolated values of the lookupTable at
 % various times. The times in (row/column) j are given by
 % centers(j) \+ displacementAxis
 %
 % e.g. if centers(3\) is 104 and displacementAxis is \-10:0\.1:10,
 % then the 3rd (row/column) will represent the values of the
 % lookup table at times 94:0\.1:114
 %
 % (behavior change) the value will be the average of the values
 % in the bin rather than the interpolated value at the bin
 % center
 %
 %glt \< GlobalLookupTable
 %centers \- M vector of center positions
 %displacmentAxis \- N element list of offsets from center
 %position
 %varargin \- not used currently
 
 centers \= centers(:);
 displacementAxis \= displacementAxis(:)';
 da \= repmat(displacementAxis, size(centers));
 
 
 da \= da \+ reshape(repmat(centers, size(displacementAxis')), size(da));
 
 
 dt \= median(diff(displacementAxis));
 %08/12/2015 fixed bug where dt negative not treated correctly; 
 %could cause incorrect kernel fits, where (taxis is usually
 %descending)
 if (isfinite(dt) \&\& abs(dt) \> median(diff(glt.xData)))
 % kk \= ones(\[1 ceil(abs(dt)/median(diff(glt.xData)))]);
 % kk \= kk/(sum(kk));
 
 %adjusted 7/25/2016 to fix minor statistical aberration
 dtbins \= abs(dt)/median(diff(glt.xData));
 kk \= ones(\[1 ceil(dtbins)]);
 kk(1\) \= 1 \- (ceil(dtbins)\-dtbins)/2;
 kk(end) \= kk(1\);
 kk \= kk/sum(kk);
 
 yd \= conv(glt.yData, kk, 'valid');
 xc \= interp1(1:length(glt.xData), glt.xData, (1:length(yd)) \- 0\.5 \+ length(kk)/2\);
 
 % xe \= (min(glt.xData)\-dt/2\):dt:(max(glt.xData)\+dt/2\);
 % \[xc,yd] \= meanyvsx(glt.xData, glt.yData, xe);
 data \= reshape(interp1(xc, yd, da(:), 'linear', NaN), size(da));
 else
 if (islogical(glt.yData))
 data \= logical (reshape(interp1(glt.xData, double(glt.yData), da(:), 'nearest', 'extrap'), size(da)));
 else
 data \= reshape(interp1(glt.xData, glt.yData, da(:), 'linear', NaN), size(da));
 end
 end
 %data \= reshape(glt.highResDerivationMethod(da, glt.xData, glt.yData), length(displacementAxis), \[])';
 end
 
 function \[avg,datamatrix] \= triggeredAverage (glt, centers, displacementAxis, varargin)
 %\[avg,datamatrix] \= triggeredAverage (glt, centers, displacementAxis, varargin)
 % todo comment \= triggered average just takes the average of
 % the data matrix, keeping track of out\-of\-range values
 
 datamatrix \= makeDataMatrix(glt, centers, displacementAxis, varargin{:}); 
 datamatrix2 \= datamatrix;
 datamatrix2(\~isfinite(datamatrix)) \= 0; %replace unknown values with 0
 avg \= sum(datamatrix2\)./sum(isfinite(datamatrix)); %average is sum of known values / number of known values
 
 end
 
 function gq \= toGlobalQuantity(glt, expt, addToExpt, varargin)
 %function gq \= toGlobalQuantity(glt, expt, addToExpt, varargin)
 existsAndDefault('addToExpt', true);
 
 if (length(glt) \> 1\)
 for j \= 1:length(glt)
 gq(j) \= toGlobalQuantity(glt(j),expt,addToExpt,varargin{:}); %\#ok
 end
 return;
 end
 gq \= GlobalQuantity();
 if (\~strcmpi(glt.xField, 'eti'))
 gq \= repmat(gq,0\);
 return;
 end
 gq.xField \= 'eti';
 gq.fieldname \= glt.fieldname;
 gq.xData \= unique(expt.elapsedTime(:)');
 gq.xData \= gq.xData(isfinite(gq.xData));
 gq.yData \= GlobalLookupTable.averageInPrecedingBin(gq.xData, glt.xData, glt.yData);
 if (addToExpt)
 expt.addGlobalQuantity(gq);
 end
 end
 function \[u\_exp, s\_exp] \= theoreticalSumSqStats (glt, tta\_time, ntime\_bins, nturns)
 % function \[u\_exp, s\_exp] \= theoreticalSumSqStats (glt, tta\_time, ntime\_bins, nturns)
 
 if (length(glt) \> 1\)
 if (length(nturns) \=\= 1\)
 nturns \= nturns \* ones(size(glt));
 end
 u \= zeros(size(glt));
 s \= zeros(size(glt));
 for j \= 1:length(glt)
 \[u(j),s(j)] \= glt(j).theoreticalSumSqStats(tta\_time, ntime\_bins, nturns(j));
 end
 
 u\_exp \= sum(nturns.^2\.\*u)./sum(nturns)^2;
 s\_exp \= sqrt(sum(nturns.^3\.\*s.^2\)./sum(nturns)^3\);
 return;
 end
 
 vy \= var(glt.yData);
 dt \= median(diff(glt.xData));
 dtau \= tta\_time./(ntime\_bins \- 1\);
 vx \= vy .\* dt./dtau;
 u\_exp \= vx.\*ntime\_bins./nturns;

 s\_exp \= sqrt(2\*ntime\_bins./nturns.^2\.\*vy^2\.\*(dt./dtau).^2\);
 end
 function \[u, s, vals] \= shiftedSumSqStats (glt, centers, displacementAxis)
 
 trange \= \[min(centers) max(centers)];
 deltaT \= max(displacementAxis) \- min(displacementAxis);
 nshifts \= floor(diff(trange)/deltaT);
 
 vals \= zeros(\[1 nshifts]);
 
 for j \= 1:nshifts
 newt \= mod(centers \+ j\*deltaT \- trange(1\), diff(trange)) \+ trange(1\);
 vals(j) \= sum(glt.triggeredAverage(newt, displacementAxis).^2\);
 end
 
 u \= mean(vals);
 s \= std(vals);
 end
 
 end
 
 methods (Static)
 \[ledLookupTable, ledGlobalQuantity] \= createLedTableFromBitFile(expt, bitfilename, addToExpt)
 
 function yout \= averageInPrecedingBin(xin, xData, yData) 
 %function yout \= averageInPrecedingBin(xin, xData, yData)
 tp \= false;
 if (size(xin,1\) \> size(xin, 2\))
 xin \= xin';
 tp \= true;
 end
 \[sortx,I] \= sort(xin);\[\~,J] \= sort(I);
 xbin \= \[2\*sortx(1\)\-sortx(2\) sortx]; %bug fixed 2/17 by MHG; don't know how it worked at all before???
 \[\~,yout] \= meanyvsx(xData, double(yData), xbin);
 yout \= yout(J);
 if (tp)
 yout \= yout';
 end
 end
 
 
 end
end


\-\-\-

\#\#\# File: createLedTableFromBitFile.m (ID: @GlobalLookupTable.2\)

function \[ledLookupTable, ledGlobalQuantity] \= createLedTableFromBitFile(expt, bitfilename, addToExpt)
%UNTITLED4 Summary of this function goes here
% Detailed explanation goes here
ledLookupTable \= repmat(GlobalLookupTable(),0\);
existsAndDefault('addToExpt', true);
 
if (\~isprop(expt, 'metadata') \|\| isempty(expt.metadata))
 ds \= importdata2(expt.timfname);
else
 ds \= expt.metadata;
end

% if (\~isfield(ds, 'ledFrame'))
% 
% return;
% end

if (isfield(expt.metadata, 'ledNBytesOut'))
 try
 firstFrame \= find(ds.ledFrame \=\= 0, 1, 'first');
 if (isempty(firstFrame))
 x \= ds.bufnum;
 y \= ds.ledFrame;
 p \= polyfit(y(isfinite(y)),x(isfinite(y)),1\);
 firstFrame \= find(x \=\= round(p(2\)));
 end
 if (isempty(firstFrame))
 firstFrame \= find(ds.ledFrame \>\= 0, 1, 'first');
 firstFrame \= firstFrame \- ds.ledFrame(firstFrame);
 end
 ind \= find(isfinite(ds.ledNBytesOut) \& isfinite(ds.bufnum), 1, 'last');
 bytesperframe \= round((ds.ledNBytesOut(ind))/(ds.bufnum(ind) \- ds.bufnum(firstFrame)));
 bufaxis \= (ds.bufnum \- ds.bufnum(firstFrame))\*bytesperframe;
 valid \= isfinite(bufaxis) \& isfinite(expt.elapsedTime);
 bufaxis \= bufaxis(valid);
 et \= expt.elapsedTime(valid);
 
 bitaxis \= min(bufaxis):max(bufaxis);

 timaxis \= interp1(bufaxis, et, bitaxis);
 fid \= fopen(fixFileNameWin(bitfilename), 'rb');
 bits \= fread(fid, inf, 'uint8\=\>double');
 fclose(fid);
 sigma \= bytesperframe/3;
 catch me
 disp(me.getReport());
 return;
 end
else
 try
 firstFrame \= find(ds.ledFrame \=\= 0, 1, 'first');
 if (isempty(firstFrame))
 x \= ds.bufnum;
 y \= ds.ledFrame;
 p \= polyfit(y(isfinite(y)),x(isfinite(y)),1\);
 firstFrame \= find(x \=\= round(p(2\)));
 end
 if (isempty(firstFrame))
 firstFrame \= find(ds.ledFrame \>\= 0, 1, 'first');
 firstFrame \= firstFrame \- ds.ledFrame(firstFrame);
 end
 ind \= find(isfinite(ds.ledNBitsOut) \& isfinite(ds.bufnum), 1, 'last');
 bitsperframe \= round((ds.ledNBitsOut(ind))/(ds.bufnum(ind) \- ds.bufnum(firstFrame)));
 bufaxis \= (ds.bufnum \- ds.bufnum(firstFrame))\*bitsperframe;
 valid \= isfinite(bufaxis) \& isfinite(expt.elapsedTime);
 bufaxis \= bufaxis(valid);
 et \= expt.elapsedTime(valid);
 bitaxis \= min(bufaxis):max(bufaxis);
 timaxis \= interp1(bufaxis, et, bitaxis);
 fid \= fopen(fixFileNameWin(bitfilename), 'rb');
 bits \= fread(fid, inf, 'ubit1\=\>double');
 fclose(fid);
 sigma \= bitsperframe/3;
 catch me
 disp(me.getReport());
 return;
 end
end

allbits \= zeros(size(timaxis));
inds \= (bitaxis \>\= 0\);
allbits(inds) \= bits(1:nnz(inds));

ledLookupTable \= GlobalLookupTable();
ledLookupTable.xField \= 'eti';
ledLookupTable.fieldname \= 'ledFlicker';
ledLookupTable.xData \= timaxis;
ledLookupTable.yData \= allbits;
ledLookupTable.derivationMethod \= @GlobalLookupTable.averageInPrecedingBin;

ledLookupTable(2\) \= ledLookupTable(1\);
ledLookupTable(2\).fieldname \= 'ledFlickerDeriv';
%xData is already evenly sampled/interpolated
ledLookupTable(2\).yData \= deriv(ledLookupTable(1\).yData, sigma)/median(diff(ledLookupTable(1\).xData)); %picking sigma somewhat arbitrarily so that our derivative spans about 1 frame

ledLookupTable(3\) \= ledLookupTable(1\);
ledLookupTable(3\).fieldname \= 'ledFlickerDiff';
ledLookupTable(3\).yData \= \[0 diff(ledLookupTable(1\).yData)]/median(diff(ledLookupTable(1\).xData));

if(addToExpt)
 expt.addGlobalQuantity(ledLookupTable);
end

ledGlobalQuantity \= ledLookupTable.toGlobalQuantity(expt, addToExpt);
%{
ledGlobalQuantity \= GlobalQuantity();
ledGlobalQuantity.xField \= 'eti';
ledGlobalQuantity.fieldname \= 'ledFlicker';
ledGlobalQuantity.xData \= unique(expt.elapsedTime(:)');
ledGlobalQuantity.xData \= ledGlobalQuantity.xData(isfinite(ledGlobalQuantity.xData));
ledGlobalQuantity.yData \= GlobalLookupTable.averageInPrecedingBin(ledGlobalQuantity.xData, timaxis, allbits);
%}
end


\-\-\-

\#\#\# Folder: @MWTTrackPoint (ID: @MWTTrackPoint)

\-\-\-

\#\#\# File: fromMWTString.m (ID: @MWTTrackPoint.1\)

function tp \= fromMWTString (tp, str, camcalinfo)
%function tp \= fromMWTString (tp, str, camcalinfo)
numSpinePts \= 11;


% expr \= \[numtok('frame') numtok('et') numtok('comx') numtok('comy') numtok('area') numtok('v1x') numtok('v1y') numtok('cov2') numtok('len') numtok('wid') ...
% '(%\\s\*)(?\[\-,\\d,\\.,\\s]\*)(%%\\s\*)' numtok('ctrx0') numtok('ctry0') numtok('ncpts') '(?\[\\S]\*)']
expr \= '(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\-,\\d,\\.]\+)(\\s\+)(%\\s\*)(?\[\-,\\d,\\.,\\s]\*)(%%\\s\*)(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\-,\\d,\\.]\+)(\\s\+)(?\[\\S]\*)';

bob \= regexp(str, expr, 'names');

if (isempty(bob))
 \[nums,\~,\~,ind] \= sscanf(str, '%g', 10\);

 tp.ind \= nums(1\);
 tp.et \= nums(2\);

 tp.loc \= \[nums(3\);nums(4\)];

 tp.area \= nums(5\);
 % 
 % 
 % v1 \= \[num(6\);num(7\)];
 % v2 \= \[num(8\);num(9\)];
 % d1 \= sqrt(sum(v1\.^2\));
 % d2 \= sqrt(sum(v2\.^2\));
 % 
 % v1 \= v1/d1;
 % v2 \= v2/d2;
 ind \= ind \+ find(str(ind:end) \=\= '%', 1,'first');
 \[spn,\~,\~,ind2] \= sscanf(str(ind:end), '%g', \[2 numSpinePts]);
 spn(1,:) \= spn(1,:) \+ tp.loc(1\);
 spn(2,:) \= spn(2,:) \+ tp.loc(2\);
 tp.spine \= spn;

 ind \= ind \+ ind2;
 ind \= ind \+ find(str(ind:end) \=\= '%', 1,'first') \+ 1;

 \[ctr0,\~,\~,ind2] \= sscanf(str(ind:end), '%g', \[2 1]);
 ind \= ind \+ ind2;
 \[npts,\~,\~,ind2] \= sscanf(str(ind:end), '%d', 1\);
 ind \= ind \+ ind2;
 ccstr \= regexp(str(ind:end), '\\S\*', 'match', 'once');

 \[x,y] \= unpackKerrChainCode(ccstr, npts);
 x \= x\+ctr0(1\);
 y \= y\+ctr0(2\);
 tp.contour \= \[x;y];
else
 tp.ind \= sscanf(bob.frame,'%d');
 tp.loc \= \[sscanf(bob.comx,'%g');sscanf(bob.comy,'%g')];
 tp.et \= sscanf(bob.et,'%g');
 tp.area \= sscanf(bob.area,'%g');
 spn \= reshape(sscanf(bob.spinestr, '%g'),2,\[]);
 spn(1,:) \= spn(1,:) \+ tp.loc(1\);
 spn(2,:) \= spn(2,:) \+ tp.loc(2\);
 tp.spine \= spn;
 ctr0 \= \[sscanf(bob.ctrx0,'%g');sscanf(bob.ctry0,'%g')];
 npts \= sscanf(bob.ncpts,'%d');
 \[x,y] \= unpackKerrChainCode(bob.ctrstr, npts);
 x \= x\+ctr0(1\);
 y \= y\+ctr0(2\);
 tp.contour \= \[x;y];
 v1 \= \[sscanf(bob.v1x,'%g');sscanf(bob.v1y,'%g')];
 cov1 \= sqrt(sum(v1\.^2\));
 v \= v1\./cov1;
 D \= \[cov1,0;0,sscanf(bob.cov2,'%g')];
 V \= \[v,\[\-v(2\);v(1\)]];
 c \= V\*D/V;
 tp.cov \= \[c(1\) c(2\) c(4\)];
end

if (\~isempty(camcalinfo))
 tp.loc \= cameracalibration.realPtsFromCamPts(tp.loc);
 tp.spine \= cameracalibration.realPtsFromCamPts(tp.spine);
 tp.contour \= cameracalibration.realPtsFromCamPts(tp.contour);
end

tp.head \= tp.spine(:,end);
tp.tail \= tp.spine(:,1\);
tp.mid \= tp.spine(:,ceil(size(tp.spine,2\)/2\));
tp.htValid \= true;

function patt \= numtok(tokenName)
patt \= \['(?\<' tokenName '\>\[\-,\\d,\\.]\+)(\\s\+)'];

\-\-\-

\#\#\# File: MWTTrackPoint.m (ID: @MWTTrackPoint.2\)

classdef MWTTrackPoint \< MaggotTrackPoint
 %represents a track point as defined by Rex Kerr's Multi Worm Tracker
 %includes facilities to read from a .blob(s) file
 
 properties
 end
 
 methods
 tp \= fromMWTString (tp, str, camcalinfo);
 end
 
end


\-\-\-

\#\#\# Folder: @ImTrackPoint (ID: @ImTrackPoint)

\-\-\-

\#\#\# File: recalculateCovariance.m (ID: @ImTrackPoint.1\)

function pt \= recalculateCovariance(pt, targetArea, fid)
%function pt \= recalculateCovariance(pt, targetArea, fid)

if (\~exist('targetArea','var'))
 warning ('ITP:RCC', 'need a targetArea to find object');
 return;
end

if (\~exist('fid','var') \&\& isempty(pt.imData))
 warning ('ITP:RCC', 'no image data \& no reload info');
 return;
end

if (isempty(pt.imData))
 fseek(fid, pt.locInFile,'bof');
 pt2 \= pt.fromFile(fid, true, true, \[]);
 im \= pt2\.imData;
else
 im \= pt.imData;
end

\[bwim, thresh] \= thresholdToTargetArea(im, targetArea,pt.loc' \- double(pt.imOffset) \+ 1\);
im \= im \- thresh;
im(\~bwim) \= 0;
\[c,com] \= imCov(im);
pt.cov \= \[c(1,1\);c(1,2\);c(2,2\)];
pt.loc \= (com \+ double(pt.imOffset) \- 1\)';
pt.area \= nnz(bwim(:));
\-\-\-

\#\#\# File: ImTrackPoint.m (ID: @ImTrackPoint.2\)

classdef ImTrackPoint \< TrackPoint
 %Augments TrackPoint by including an excerpted image
 
 
 properties
 imOffset \= int16(\[0 0]); %location of imagedata origin from camera origin (always in pixels)
 imData \= uint8(\[]); %matrix representing image
 end
 methods
 tp \= fromFile (tp, fid, loadIm, loadContour, camcalinfo)
 drawTrackImage(tp, camcalinfo, varargin)
 im \= overlayImageOnExisting (pt, imx, imy, im, camcalinfo, varargin)
 tp \= fromJava(tp, jTP, loadIm, loadContour, camcalinfo)
 end
 
 methods %constructor
 function tp \= ImTrackPoint(varargin)
 tp \= tp@TrackPoint(varargin{:}); 
 if (nargin \>\= 1\) \&\& (isa(varargin{1}, 'ImTrackPoint'))
 op \= varargin{1};
 flist \= fieldnames(tp);
 for j \= 1:length(flist)
 tp.(flist{j}) \= op.(flist{j});
 end
 end
 end%trackpoint
 end
 
end


\-\-\-

\#\#\# File: overlayImageOnExisting.m (ID: @ImTrackPoint.3\)

function im \= overlayImageOnExisting (pt, imx, imy, im, camcalinfo, varargin)
%function im \= overlayImageOnExisting (pt, imx, imy, im, camcalinfo, varargin)
%PT \< ImTrackPoint
%IMX \- image x axis
%IMY \- image y axis
%IM \- image \-\- size \= \[length(imy), length(imx), nchannels]
%
%optional arguments, with defaults
%fid \= \[];
%mode \= 'add' or 'a'; %if 'replace' or 'r', replace the data in im, 
% if 'a', add to it
% if 'max', take maximum of im, pt.imData
%channel \= \[]; % if a number, only replace data in that channel
%
%clipToContour \= false; if true, restrict image to region in and near the
% contour; only active if pt has a contour or 
% if contour is passed as an extra argument
%contour \= (pt.contour) or \[] ; a 2xN contour of the animal

fid \= \[];
clipToContour \= true;
existsAndDefault('camcalinfo', \[]);
mode \= 'a';
if (any(strcmp('contour', properties(pt))))
 contour \= double(pt.contour);
else
 contour \= \[];
end
channel \= \[];

varargin \= assignApplicable(varargin);


if (isempty(pt.imData))
 if (\~isempty(fid) \&\& fid \> 0\)
 try
 fseek(fid, pt.locInFile, \-1\);
 pt2 \= pt.fromFile(fid, true, true, camcalinfo);
 pt.imData \= pt2\.imData;
 catch me
 warning('ITP:DTI' , me.getReport);
 return;
 end
 else
 return;
 end
end

x \= double(pt.imOffset(1\)\-1\) \+ (1:size(pt.imData,2\));
y \= double(pt.imOffset(2\)\-1\) \+ (1:size(pt.imData,1\));

if (\~isempty(camcalinfo))
 
 rpts \= camcalinfo.realPtsFromCamPts(\[x(1\) x(end); y(1\) y(end)]);
 x \= linspace(rpts(1,1\), rpts(1,end), length(x));
 y \= linspace(rpts(2,1\), rpts(2,end), length(y));
end

uu \= find(imx \>\= min(x), 1, 'first'):find(imx \<\= max(x), 1, 'last');
vv \= find(imy \>\= min(y), 1, 'first'):find(imy \<\= max(y), 1, 'last');

if (isempty(uu) \|\| isempty(vv)) %no overlap
 return;
end

\[uu,vv] \= meshgrid(uu,vv);
imd \= interp2(x,y,double(pt.imData), imx(uu(:)), imy(vv(:)), '\*linear', NaN);

if (clipToContour \&\& \~isempty(contour))
 pointsOutside \= 2;
 mask \= reshape(inpolygon(imx(uu(:)), imy(vv(:)), contour(1,:), contour(2,:)), size(uu));
 mask \= imdilate(mask, ones(2\*pointsOutside\+1\));
 %mask \= zeros(size(uu));
 imd(\~mask(:)) \= NaN;
end

valid \= isfinite(imd(:));
uu \= uu(valid);
vv \= vv(valid);
imd \= imd(valid);

uu \= uu(:); vv \= vv(:); imd \= imd(:);
% 
% 
% 
% xx \= interp1(x, 1:length(x), imx(uu(:)), '\*nearest', 'NaN');
% yy \= interp1(y, 1:length(y), imy(vv(:)), '\*nearest', 'NaN');
% 
% 
% \[xx,yy] \= meshgrid(x,y);
% x \= interp1(imx, 1:length(imx), xx(:), '\*nearest', NaN);
% y \= interp1(imy, 1:length(imy), yy(:), '\*nearest', NaN);
% valid \= isfinite(x) \& isfinite(y);
% imd \= double(pt.imData(valid));
% x \= x(valid);
% y \= y(valid);
if (isempty(channel))
 channel \= 1:size(im,3\);
end
% 
% for j \= 1:length(channel)
% plane{j} \= im(:,:,channel(j));
% end
% xx \= xx(:);
% yy \= yy(:);
% imd \= imd(:);

for j \= 1:length(channel)
% inds \= sub2ind(size(im), y, x, repmat(channel(j),size(x)));
 inds \= sub2ind(size(im), vv, uu, repmat(channel(j),size(vv)));
 switch(mode) 
 case {'a', 'add'}
 im(inds) \= im(inds) \+ imd;
 case {'r', 'replace'}
 im(inds) \= imd;
 case {'m', 'max'}
 im(inds) \= max(im(inds), imd);
 end
end



\-\-\-

\#\#\# File: drawTrackImage.m (ID: @ImTrackPoint.4\)

function drawTrackImage (pt, camcalinfo, varargin)
%function drawTrackImage (pt, camcalinfo, varargin)
%@ImTrackPoint
%
%optional arguments, with defaults
%fid \= \[];
%scale \= 1;
%cropSize \= \[];
%Axes \= \[];
%patchOptions \= {};
%underlayImData \= \[]; underlayImData.x, underlayImData.y, underlayImData.im
%showCov \= false;
%
%clipToContour \= false; if true, restrict image to region in and near the
% contour; only active if pt has a contour or 
% if contour is passed as an extra argument
%contour \= (pt.contour) or \[] ; a 2xN contour of the animal

fid \= \[];
existsAndDefault('camcalinfo', \[]);
scale \= 1;
cropSize \= \[];
Axes \= \[];
underlayImData \= \[];
patchOptions \= {};
showCov \= false;
clipToContour \= false;
underlayScale \= \-1;
if (any(strcmp('contour', properties(pt))))
 contour \= double(pt.contour);
else
 contour \= \[];
end
varargin \= assignApplicable(varargin);

if (isempty(Axes))
 Axes \= gca;
end

if (isempty(pt.imData))
 if (\~isempty(fid) \&\& fid \> 0\)
 try
 fseek(fid, pt.locInFile, \-1\);
 pt2 \= pt.fromFile(fid, true, true, camcalinfo);
 pt.imData \= pt2\.imData;
 catch me
 warning('ITP:DTI' , me.getReport);
 return;
 end
 else
 return;
 end
end

x \= double(pt.imOffset(1\)\-1\) \+ (1:size(pt.imData,2\));
y \= double(pt.imOffset(2\)\-1\) \+ (1:size(pt.imData,1\));

if (\~isempty(camcalinfo))
 rpts \= camcalinfo.realPtsFromCamPts(\[x(1\) x(end); y(1\) y(end)]);
 x \= linspace(rpts(1,1\), rpts(1,end), length(x));
 y \= linspace(rpts(2,1\), rpts(2,end), length(y));
 
 
end


if (clipToContour \&\& \~isempty(contour))
 pointsOutside \= 2;
 \[xx,yy] \= meshgrid(x,y);
 mask \= reshape(inpolygon(xx(:), yy(:), contour(1,:), contour(2,:)), size(xx));
 mask \= imdilate(mask, ones(2\*pointsOutside\+1\));
else
 mask \= true(size(pt.imData));
end

cm \= gray(64\);

if (isempty(underlayImData))
 im \= pt.imData;
 im(\~mask) \= 0;
else
 if (underlayScale \> 0\)
 underlayImData.im \= double(underlayImData.im)/double(max(0\.01,max(underlayImData.im(:))))\*underlayScale;
 im \= pt.overlayImageOnExisting(underlayImData.x, underlayImData.y, zeros(size(underlayImData.im)), camcalinfo, 'mode', 'max', 'clipToContour',clipToContour, 'contour', contour);
 im \= im/max(im(:));
 im \= max(underlayImData.im, im);
 else
 im \= pt.overlayImageOnExisting(underlayImData.x, underlayImData.y, double(underlayImData.im), camcalinfo, 'mode', 'max', 'clipToContour',clipToContour, 'contour', contour);
 %\[xx,yy] \= meshgrid(x,y);
 %uim \= interp2(underlayImData.x, underlayImData.y, underlayImData.im, xx, yy,'\*nearest');
 %im \= double(pt.imData) \+ double(uim);
 
 im \= im/max(im(:));
 end
 x \= underlayImData.x;
 y \= underlayImData.y;
end

if (scale \=\= 1 \|\| \~isempty(underlayImData))
 if (size(im,3\) \> 1\)
 set(image (x,y,double(im)), 'Parent', Axes);
 else
 set(imagesc (x,y,double(im)), 'Parent', Axes, patchOptions{:}); shading (Axes, 'flat'); colormap(Axes, cm);
 end
else
 im2 \= imresize(double(im), scale);
 x2 \= interp1(x, (0:(size(im2,2\)\- 1\))\*length(x)/size(im2,2\) \+ 1, 'linear');
 y2 \= interp1(y, (0:(size(im2,1\)\- 1\))\*length(y)/size(im2,1\) \+ 1, 'linear');
 set(pcolor(Axes, x2,y2,im2\), patchOptions{:}); shading (Axes, 'interp'); colormap (Axes, cm);
end

if (showCov)
 hold(Axes, 'on');
 axes(Axes);
 c \= \[pt.cov(1\) pt.cov(2\);pt.cov(2\) pt.cov(3\)];
 \[v,d] \= eig(c);
 plot (pt.loc(1\),pt.loc(2\), 'r.', 'MarkerSize', 20\)
 set(ellipse(3\*sqrt(d(1,1\)), 3\*sqrt(d(2,2\)), atan2(v(2,1\),v(1,1\)), pt.loc(1\), pt.loc(2\),'r\-'),'LineWidth',3\);
 hold(Axes, 'off');
end

if (isempty(cropSize))
 axis (Axes, 'equal')
 axis (Axes, 'tight')
else
 c \= \[mean(x) mean(y)];
 axis(Axes, \[c(1\)\-cropSize(1\)/2, c(1\)\+cropSize(1\)/2,c(2\)\-cropSize(2\)/2, c(2\)\+cropSize(2\)/2]);
end

\-\-\-

\#\#\# File: fromJava.m (ID: @ImTrackPoint.5\)

function tp \= fromJava(tp, jTP, loadIm, loadContour, camcalinfo)

 %tp \= fromJava@TrackPoint(tp, jTP, loadIm, loadContour, camcalinfo);
 tp \= fromJava@TrackPoint(tp, jTP, loadIm, loadContour, camcalinfo);
 
 r \= jTP.getRect();
 tp.imOffset \= \[r(1\) r(2\)];
 if (loadIm)
 tp.imData \= jTP. getRawIm().getIntArray()';%Probably need to convert(/transpose?) this
 end
 
end
\-\-\-

\#\#\# File: fromFile.m (ID: @ImTrackPoint.6\)

function tp \= fromFile (tp, fid, loadImage, loadContour, camcalinfo)
%ImTrackPoint.fromFile
%function tp \= fromFile (tp, fid, loadImage, loadContour, camcalinfo)
%
%loadContour: ignored
%ts \= tic;
intType \= 'int32';
%floatType \= 'float32';

if (\~exist('camcalinfo', 'var'))
 camcalinfo \= \[];
end
%tic
tp \= fromFile@TrackPoint(tp, fid, loadImage, loadContour, camcalinfo);

w \= fread(fid,1,intType);
h \= fread(fid,1,intType);
if (w \~\=0 \&\& h \~\= 0\)
 tp.imOffset \= int16(fread(fid,\[1 2],intType));
 if (loadImage)
 tp.imData \= transpose(uint8(fread(fid,\[w h], 'uchar')));
 else
 fread(fid, \[w h], 'uchar');
% fseek(fid,w\*h,'cof'); %move ahead the size of the image
 end
end
%toc(ts)
%pause;
%toc

\-\-\-

\#\#\# Folder: .git (ID: .git)

\-\-\-

\#\#\# File: config (ID: .git.1\)

\[core]
 repositoryformatversion \= 0
 filemode \= true
 bare \= false
 logallrefupdates \= true
 ignorecase \= true
 precomposeunicode \= true
\[remote "origin"]
 url \= https://github.com/samuellab/MAGATAnalyzer\-Matlab\-Analysis.git
 fetch \= \+refs/heads/\*:refs/remotes/origin/\*
\[branch "master"]
 remote \= origin
 merge \= refs/heads/master

\-\-\-

\#\#\# File: HEAD (ID: .git.2\)

ref: refs/heads/master

\-\-\-

\#\#\# File: description (ID: .git.3\)

Unnamed repository; edit this file 'description' to name the repository.

\-\-\-

\#\#\# File: index (ID: .git.4\)

Could not read file: 'utf\-8' codec can't decode byte 0xb2 in position 15: invalid start byte

\-\-\-

\#\#\# File: packed\-refs (ID: .git.5\)

\# pack\-refs with: peeled fully\-peeled sorted 
d9d72b2b43c82af949aa0df034e1a6b9093d47ed refs/remotes/origin/master
3514e41c427013d4a78da4805697c297b96e95ed refs/remotes/origin/minorUpdates

\-\-\-

\#\#\# Folder: .git/objects (ID: .git.objects)

\-\-\-

\#\#\# Folder: .git/objects/pack (ID: .git.objects.pack)

\-\-\-

\#\#\# File: pack\-b038a3974a4ee6706ecdb4ffab521662e21f493f.idx (ID: .git.objects.pack.1\)

Could not read file: 'utf\-8' codec can't decode byte 0xff in position 0: invalid start byte

\-\-\-

\#\#\# File: pack\-b038a3974a4ee6706ecdb4ffab521662e21f493f.pack (ID: .git.objects.pack.2\)

Could not read file: 'utf\-8' codec can't decode byte 0x97 in position 12: invalid start byte

\-\-\-

\#\#\# File: pack\-b038a3974a4ee6706ecdb4ffab521662e21f493f.rev (ID: .git.objects.pack.3\)

Could not read file: 'utf\-8' codec can't decode byte 0xaa in position 15: invalid start byte

\-\-\-

\#\#\# Folder: .git/objects/info (ID: .git.objects.info)

\-\-\-

\#\#\# Folder: .git/info (ID: .git.info)

\-\-\-

\#\#\# File: exclude (ID: .git.info.1\)

\# git ls\-files \-\-others \-\-exclude\-from\=.git/info/exclude
\# Lines that start with '\#' are comments.
\# For a project mostly in C, the following would be a good set of
\# exclude patterns (uncomment them if you want to use them):
\# \*.\[oa]
\# \*\~

\-\-\-

\#\#\# Folder: .git/logs (ID: .git.logs)

\-\-\-

\#\#\# File: HEAD (ID: .git.logs.1\)

0000000000000000000000000000000000000000 d9d72b2b43c82af949aa0df034e1a6b9093d47ed Gil Raitses  1732056242 \-0500 clone: from https://github.com/samuellab/MAGATAnalyzer\-Matlab\-Analysis.git

\-\-\-

\#\#\# Folder: .git/logs/refs (ID: .git.logs.refs)

\-\-\-

\#\#\# Folder: .git/logs/refs/heads (ID: .git.logs.refs.heads)

\-\-\-

\#\#\# File: master (ID: .git.logs.refs.heads.1\)

0000000000000000000000000000000000000000 d9d72b2b43c82af949aa0df034e1a6b9093d47ed Gil Raitses  1732056242 \-0500 clone: from https://github.com/samuellab/MAGATAnalyzer\-Matlab\-Analysis.git

\-\-\-

\#\#\# Folder: .git/logs/refs/remotes (ID: .git.logs.refs.remotes)

\-\-\-

\#\#\# Folder: .git/logs/refs/remotes/origin (ID: .git.logs.refs.remotes.origin)

\-\-\-

\#\#\# File: HEAD (ID: .git.logs.refs.remotes.origin.1\)

0000000000000000000000000000000000000000 d9d72b2b43c82af949aa0df034e1a6b9093d47ed Gil Raitses  1732056242 \-0500 clone: from https://github.com/samuellab/MAGATAnalyzer\-Matlab\-Analysis.git

\-\-\-

\#\#\# Folder: .git/hooks (ID: .git.hooks)

\-\-\-

\#\#\# File: commit\-msg.sample (ID: .git.hooks.1\)

\#!/bin/sh
\#
\# An example hook script to check the commit log message.
\# Called by "git commit" with one argument, the name of the file
\# that has the commit message. The hook should exit with non\-zero
\# status after issuing an appropriate message if it wants to stop the
\# commit. The hook is allowed to edit the commit message file.
\#
\# To enable this hook, rename this file to "commit\-msg".

\# Uncomment the below to add a Signed\-off\-by line to the message.
\# Doing this in a hook is a bad idea in general, but the prepare\-commit\-msg
\# hook is more suited to it.
\#
\# SOB\=$(git var GIT\_AUTHOR\_IDENT \| sed \-n 's/^\\(.\*\>\\).\*$/Signed\-off\-by: \\1/p')
\# grep \-qs "^$SOB" "$1" \|\| echo "$SOB" \>\> "$1"

\# This example catches duplicate Signed\-off\-by lines.

test "" \= "$(grep '^Signed\-off\-by: ' "$1" \|
 sort \| uniq \-c \| sed \-e '/^\[ ]\*1\[ ]/d')" \|\| {
 echo \>\&2 Duplicate Signed\-off\-by lines.
 exit 1
}

\-\-\-

\#\#\# File: pre\-rebase.sample (ID: .git.hooks.2\)

\#!/bin/sh
\#
\# Copyright (c) 2006, 2008 Junio C Hamano
\#
\# The "pre\-rebase" hook is run just before "git rebase" starts doing
\# its job, and can prevent the command from running by exiting with
\# non\-zero status.
\#
\# The hook is called with the following parameters:
\#
\# $1 \-\- the upstream the series was forked from.
\# $2 \-\- the branch being rebased (or empty when rebasing the current branch).
\#
\# This sample shows how to prevent topic branches that are already
\# merged to 'next' branch from getting rebased, because allowing it
\# would result in rebasing already published history.

publish\=next
basebranch\="$1"
if test "$\#" \= 2
then
 topic\="refs/heads/$2"
else
 topic\=\`git symbolic\-ref HEAD\` \|\|
 exit 0 ;\# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/\*)
 ;;
\*)
 exit 0 ;\# we do not interrupt others.
 ;;
esac

\# Now we are dealing with a topic branch being rebased
\# on top of master. Is it OK to rebase it?

\# Does the topic really exist?
git show\-ref \-q "$topic" \|\| {
 echo \>\&2 "No such branch $topic"
 exit 1
}

\# Is topic fully merged to master?
not\_in\_master\=\`git rev\-list \-\-pretty\=oneline ^master "$topic"\`
if test \-z "$not\_in\_master"
then
 echo \>\&2 "$topic is fully merged to master; better remove it."
 exit 1 ;\# we could allow it, but there is no point.
fi

\# Is topic ever merged to next? If so you should not be rebasing it.
only\_next\_1\=\`git rev\-list ^master "^$topic" ${publish} \| sort\`
only\_next\_2\=\`git rev\-list ^master ${publish} \| sort\`
if test "$only\_next\_1" \= "$only\_next\_2"
then
 not\_in\_topic\=\`git rev\-list "^$topic" master\`
 if test \-z "$not\_in\_topic"
 then
 echo \>\&2 "$topic is already up to date with master"
 exit 1 ;\# we could allow it, but there is no point.
 else
 exit 0
 fi
else
 not\_in\_next\=\`git rev\-list \-\-pretty\=oneline ^${publish} "$topic"\`
 /usr/bin/perl \-e '
 my $topic \= $ARGV\[0];
 my $msg \= "\* $topic has commits already merged to public branch:\\n";
 my (%not\_in\_next) \= map {
 /^(\[0\-9a\-f]\+) /;
 ($1 \=\> 1\);
 } split(/\\n/, $ARGV\[1]);
 for my $elem (map {
 /^(\[0\-9a\-f]\+) (.\*)$/;
 \[$1 \=\> $2];
 } split(/\\n/, $ARGV\[2])) {
 if (!exists $not\_in\_next{$elem\-\>\[0]}) {
 if ($msg) {
 print STDERR $msg;
 undef $msg;
 }
 print STDERR " $elem\-\>\[1]\\n";
 }
 }
 ' "$topic" "$not\_in\_next" "$not\_in\_master"
 exit 1
fi

\<\<\\DOC\_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 \* Once a topic branch forks from "master", "master" is never
 merged into it again (either directly or indirectly).

 \* Once a topic branch is fully cooked and merged into "master",
 it is deleted. If you need to build on top of it to correct
 earlier mistakes, a new topic branch is created by forking at
 the tip of the "master". This is not strictly necessary, but
 it makes it easier to keep your history simple.

 \* Whenever you need to test or publish your changes to topic
 branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT\_DIR/config mechanism.

With this workflow, you would want to know:

(1\) ... if a topic branch has ever been merged to "next". Young
 topic branches can have stupid mistakes you would rather
 clean up before publishing, and things that have not been
 merged into other branches can be easily rebased without
 affecting other people. But once it is published, you would
 not want to rewind it.

(2\) ... if a topic branch has been fully merged to "master".
 Then you can delete it. More importantly, you should not
 build on top of it \-\- other people may already want to
 change things related to the topic as patches against your
 "master", so if you need further changes, it is better to
 fork the topic (perhaps with the same name) afresh from the
 tip of "master".

Let's look at this example:

 o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o "next"
 / / / /
 / a\-\-\-a\-\-\-b A / /
 / / / /
 / / c\-\-\-c\-\-\-c\-\-\-c B /
 / / / \\ /
 / / / b\-\-\-b C \\ /
 / / / / \\ /
 \-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o\-\-\-o "master"


A, B and C are topic branches.

 \* A has one fix since it was merged up to "next".

 \* B has finished. It has been fully merged up to "master" and "next",
 and is ready to be deleted.

 \* C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1\):

 git rev\-list ^master ^topic next
 git rev\-list ^master next

 if these match, topic has not merged in next at all.

To compute (2\):

 git rev\-list master..topic

 if this is empty, it is fully merged to "master".

DOC\_END

\-\-\-

\#\#\# File: sendemail\-validate.sample (ID: .git.hooks.3\)

\#!/bin/sh

\# An example hook script to validate a patch (and/or patch series) before
\# sending it via email.
\#
\# The hook should exit with non\-zero status after issuing an appropriate
\# message if it wants to prevent the email(s) from being sent.
\#
\# To enable this hook, rename this file to "sendemail\-validate".
\#
\# By default, it will only check that the patch(es) can be applied on top of
\# the default upstream branch without conflicts in a secondary worktree. After
\# validation (successful or not) of the last patch of a series, the worktree
\# will be deleted.
\#
\# The following config variables can be set to change the default remote and
\# remote ref that are used to apply the patches against:
\#
\# sendemail.validateRemote (default: origin)
\# sendemail.validateRemoteRef (default: HEAD)
\#
\# Replace the TODO placeholders with appropriate checks according to your
\# needs.

validate\_cover\_letter () {
 file\="$1"
 \# TODO: Replace with appropriate checks (e.g. spell checking).
 true
}

validate\_patch () {
 file\="$1"
 \# Ensure that the patch applies without conflicts.
 git am \-3 "$file" \|\| return
 \# TODO: Replace with appropriate checks for this patch
 \# (e.g. checkpatch.pl).
 true
}

validate\_series () {
 \# TODO: Replace with appropriate checks for the whole series
 \# (e.g. quick build, coding style checks, etc.).
 true
}

\# main \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

if test "$GIT\_SENDEMAIL\_FILE\_COUNTER" \= 1
then
 remote\=$(git config \-\-default origin \-\-get sendemail.validateRemote) \&\&
 ref\=$(git config \-\-default HEAD \-\-get sendemail.validateRemoteRef) \&\&
 worktree\=$(mktemp \-\-tmpdir \-d sendemail\-validate.XXXXXXX) \&\&
 git worktree add \-fd \-\-checkout "$worktree" "refs/remotes/$remote/$ref" \&\&
 git config \-\-replace\-all sendemail.validateWorktree "$worktree"
else
 worktree\=$(git config \-\-get sendemail.validateWorktree)
fi \|\| {
 echo "sendemail\-validate: error: failed to prepare worktree" \>\&2
 exit 1
}

unset GIT\_DIR GIT\_WORK\_TREE
cd "$worktree" \&\&

if grep \-q "^diff \-\-git " "$1"
then
 validate\_patch "$1"
else
 validate\_cover\_letter "$1"
fi \&\&

if test "$GIT\_SENDEMAIL\_FILE\_COUNTER" \= "$GIT\_SENDEMAIL\_FILE\_TOTAL"
then
 git config \-\-unset\-all sendemail.validateWorktree \&\&
 trap 'git worktree remove \-ff "$worktree"' EXIT \&\&
 validate\_series
fi

\-\-\-

\#\#\# File: pre\-commit.sample (ID: .git.hooks.4\)

\#!/bin/sh
\#
\# An example hook script to verify what is about to be committed.
\# Called by "git commit" with no arguments. The hook should
\# exit with non\-zero status after issuing an appropriate message if
\# it wants to stop the commit.
\#
\# To enable this hook, rename this file to "pre\-commit".

if git rev\-parse \-\-verify HEAD \>/dev/null 2\>\&1
then
 against\=HEAD
else
 \# Initial commit: diff against an empty tree object
 against\=$(git hash\-object \-t tree /dev/null)
fi

\# If you want to allow non\-ASCII filenames set this variable to true.
allownonascii\=$(git config \-\-type\=bool hooks.allownonascii)

\# Redirect output to stderr.
exec 1\>\&2

\# Cross platform projects tend to avoid non\-ASCII filenames; prevent
\# them from being added to the repository. We exploit the fact that the
\# printable range starts at the space character and ends with tilde.
if \[ "$allownonascii" !\= "true" ] \&\&
 \# Note that the use of brackets around a tr range is ok here, (it's
 \# even required, for portability to Solaris 10's /usr/bin/tr), since
 \# the square bracket bytes happen to fall in the designated range.
 test $(git diff\-index \-\-cached \-\-name\-only \-\-diff\-filter\=A \-z $against \|
 LC\_ALL\=C tr \-d '\[ \-\~]\\0' \| wc \-c) !\= 0
then
 cat \<\<\\EOF
Error: Attempt to add a non\-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

 git config hooks.allownonascii true
EOF
 exit 1
fi

\# If there are whitespace errors, print the offending file names and fail.
exec git diff\-index \-\-check \-\-cached $against \-\-

\-\-\-

\#\#\# File: applypatch\-msg.sample (ID: .git.hooks.5\)

\#!/bin/sh
\#
\# An example hook script to check the commit log message taken by
\# applypatch from an e\-mail message.
\#
\# The hook should exit with non\-zero status after issuing an
\# appropriate message if it wants to stop the commit. The hook is
\# allowed to edit the commit message file.
\#
\# To enable this hook, rename this file to "applypatch\-msg".

. git\-sh\-setup
commitmsg\="$(git rev\-parse \-\-git\-path hooks/commit\-msg)"
test \-x "$commitmsg" \&\& exec "$commitmsg" ${1\+"$@"}
:

\-\-\-

\#\#\# File: fsmonitor\-watchman.sample (ID: .git.hooks.6\)

\#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

\# An example hook script to integrate Watchman
\# (https://facebook.github.io/watchman/) with git to speed up detecting
\# new and modified files.
\#
\# The hook is passed a version (currently 2\) and last update token
\# formatted as a string and outputs to stdout a new update token and
\# all files that have been modified since the update token. Paths must
\# be relative to the root of the working tree and separated by a single NUL.
\#
\# To enable this hook, rename this file to "query\-watchman" and set
\# 'git config core.fsmonitor .git/hooks/query\-watchman'
\#
my ($version, $last\_update\_token) \= @ARGV;

\# Uncomment for debugging
\# print STDERR "$0 $version $last\_update\_token\\n";

\# Check the hook interface version
if ($version ne 2\) {
 die "Unsupported query\-fsmonitor hook version '$version'.\\n" .
 "Falling back to scanning...\\n";
}

my $git\_work\_tree \= get\_working\_dir();

my $retry \= 1;

my $json\_pkg;
eval {
 require JSON::XS;
 $json\_pkg \= "JSON::XS";
 1;
} or do {
 require JSON::PP;
 $json\_pkg \= "JSON::PP";
};

launch\_watchman();

sub launch\_watchman {
 my $o \= watchman\_query();
 if (is\_work\_tree\_watched($o)) {
 output\_result($o\-\>{clock}, @{$o\-\>{files}});
 }
}

sub output\_result {
 my ($clockid, @files) \= @\_;

 \# Uncomment for debugging watchman output
 \# open (my $fh, "\>", ".git/watchman\-output.out");
 \# binmode $fh, ":utf8";
 \# print $fh "$clockid\\n@files\\n";
 \# close $fh;

 binmode STDOUT, ":utf8";
 print $clockid;
 print "\\0";
 local $, \= "\\0";
 print @files;
}

sub watchman\_clock {
 my $response \= qx/watchman clock "$git\_work\_tree"/;
 die "Failed to get clock id on '$git\_work\_tree'.\\n" .
 "Falling back to scanning...\\n" if $? !\= 0;

 return $json\_pkg\-\>new\-\>utf8\-\>decode($response);
}

sub watchman\_query {
 my $pid \= open2(\\\*CHLD\_OUT, \\\*CHLD\_IN, 'watchman \-j \-\-no\-pretty')
 or die "open2() failed: $!\\n" .
 "Falling back to scanning...\\n";

 \# In the query expression below we're asking for names of files that
 \# changed since $last\_update\_token but not from the .git folder.
 \#
 \# To accomplish this, we're using the "since" generator to use the
 \# recency index to select candidate nodes and "fields" to limit the
 \# output to file names only. Then we're using the "expression" term to
 \# further constrain the results.
 my $last\_update\_line \= "";
 if (substr($last\_update\_token, 0, 1\) eq "c") {
 $last\_update\_token \= "\\"$last\_update\_token\\"";
 $last\_update\_line \= qq\[\\n"since": $last\_update\_token,];
 }
 my $query \= \<\<" END";
 \["query", "$git\_work\_tree", {$last\_update\_line
 "fields": \["name"],
 "expression": \["not", \["dirname", ".git"]]
 }]
 END

 \# Uncomment for debugging the watchman query
 \# open (my $fh, "\>", ".git/watchman\-query.json");
 \# print $fh $query;
 \# close $fh;

 print CHLD\_IN $query;
 close CHLD\_IN;
 my $response \= do {local $/; };

 \# Uncomment for debugging the watch response
 \# open ($fh, "\>", ".git/watchman\-response.json");
 \# print $fh $response;
 \# close $fh;

 die "Watchman: command returned no output.\\n" .
 "Falling back to scanning...\\n" if $response eq "";
 die "Watchman: command returned invalid output: $response\\n" .
 "Falling back to scanning...\\n" unless $response \=\~ /^\\{/;

 return $json\_pkg\-\>new\-\>utf8\-\>decode($response);
}

sub is\_work\_tree\_watched {
 my ($output) \= @\_;
 my $error \= $output\-\>{error};
 if ($retry \> 0 and $error and $error \=\~ m/unable to resolve root .\* directory (.\*) is not watched/) {
 $retry\-\-;
 my $response \= qx/watchman watch "$git\_work\_tree"/;
 die "Failed to make watchman watch '$git\_work\_tree'.\\n" .
 "Falling back to scanning...\\n" if $? !\= 0;
 $output \= $json\_pkg\-\>new\-\>utf8\-\>decode($response);
 $error \= $output\-\>{error};
 die "Watchman: $error.\\n" .
 "Falling back to scanning...\\n" if $error;

 \# Uncomment for debugging watchman output
 \# open (my $fh, "\>", ".git/watchman\-output.out");
 \# close $fh;

 \# Watchman will always return all files on the first query so
 \# return the fast "everything is dirty" flag to git and do the
 \# Watchman query just to get it over with now so we won't pay
 \# the cost in git to look up each individual file.
 my $o \= watchman\_clock();
 $error \= $output\-\>{error};

 die "Watchman: $error.\\n" .
 "Falling back to scanning...\\n" if $error;

 output\_result($o\-\>{clock}, ("/"));
 $last\_update\_token \= $o\-\>{clock};

 eval { launch\_watchman() };
 return 0;
 }

 die "Watchman: $error.\\n" .
 "Falling back to scanning...\\n" if $error;

 return 1;
}

sub get\_working\_dir {
 my $working\_dir;
 if ($^O \=\~ 'msys' \|\| $^O \=\~ 'cygwin') {
 $working\_dir \= Win32::GetCwd();
 $working\_dir \=\~ tr/\\\\/\\//;
 } else {
 require Cwd;
 $working\_dir \= Cwd::cwd();
 }

 return $working\_dir;
}

\-\-\-

\#\#\# File: pre\-receive.sample (ID: .git.hooks.7\)

\#!/bin/sh
\#
\# An example hook script to make use of push options.
\# The example simply echoes all push options that start with 'echoback\='
\# and rejects all pushes when the "reject" push option is used.
\#
\# To enable this hook, rename this file to "pre\-receive".

if test \-n "$GIT\_PUSH\_OPTION\_COUNT"
then
 i\=0
 while test "$i" \-lt "$GIT\_PUSH\_OPTION\_COUNT"
 do
 eval "value\=\\$GIT\_PUSH\_OPTION\_$i"
 case "$value" in
 echoback\=\*)
 echo "echo from the pre\-receive\-hook: ${value\#\*\=}" \>\&2
 ;;
 reject)
 exit 1
 esac
 i\=$((i \+ 1\))
 done
fi

\-\-\-

\#\#\# File: prepare\-commit\-msg.sample (ID: .git.hooks.8\)

\#!/bin/sh
\#
\# An example hook script to prepare the commit log message.
\# Called by "git commit" with the name of the file that has the
\# commit message, followed by the description of the commit
\# message's source. The hook's purpose is to edit the commit
\# message file. If the hook fails with a non\-zero status,
\# the commit is aborted.
\#
\# To enable this hook, rename this file to "prepare\-commit\-msg".

\# This hook includes three examples. The first one removes the
\# "\# Please enter the commit message..." help message.
\#
\# The second includes the output of "git diff \-\-name\-status \-r"
\# into the message, just before the "git status" output. It is
\# commented because it doesn't cope with \-\-amend or with squashed
\# commits.
\#
\# The third example adds a Signed\-off\-by line to the message, that can
\# still be edited. This is rarely a good idea.

COMMIT\_MSG\_FILE\=$1
COMMIT\_SOURCE\=$2
SHA1\=$3

/usr/bin/perl \-i.bak \-ne 'print unless(m/^. Please enter the commit message/..m/^\#$/)' "$COMMIT\_MSG\_FILE"

\# case "$COMMIT\_SOURCE,$SHA1" in
\# ,\|template,)
\# /usr/bin/perl \-i.bak \-pe '
\# print "\\n" . \`git diff \-\-cached \-\-name\-status \-r\`
\# if /^\#/ \&\& $first\+\+ \=\= 0' "$COMMIT\_MSG\_FILE" ;;
\# \*) ;;
\# esac

\# SOB\=$(git var GIT\_COMMITTER\_IDENT \| sed \-n 's/^\\(.\*\>\\).\*$/Signed\-off\-by: \\1/p')
\# git interpret\-trailers \-\-in\-place \-\-trailer "$SOB" "$COMMIT\_MSG\_FILE"
\# if test \-z "$COMMIT\_SOURCE"
\# then
\# /usr/bin/perl \-i.bak \-pe 'print "\\n" if !$first\_line\+\+' "$COMMIT\_MSG\_FILE"
\# fi

\-\-\-

\#\#\# File: post\-update.sample (ID: .git.hooks.9\)

\#!/bin/sh
\#
\# An example hook script to prepare a packed repository for use over
\# dumb transports.
\#
\# To enable this hook, rename this file to "post\-update".

exec git update\-server\-info

\-\-\-

\#\#\# File: pre\-merge\-commit.sample (ID: .git.hooks.10\)

\#!/bin/sh
\#
\# An example hook script to verify what is about to be committed.
\# Called by "git merge" with no arguments. The hook should
\# exit with non\-zero status after issuing an appropriate message to
\# stderr if it wants to stop the merge commit.
\#
\# To enable this hook, rename this file to "pre\-merge\-commit".

. git\-sh\-setup
test \-x "$GIT\_DIR/hooks/pre\-commit" \&\&
 exec "$GIT\_DIR/hooks/pre\-commit"
:

\-\-\-

\#\#\# File: pre\-applypatch.sample (ID: .git.hooks.11\)

\#!/bin/sh
\#
\# An example hook script to verify what is about to be committed
\# by applypatch from an e\-mail message.
\#
\# The hook should exit with non\-zero status after issuing an
\# appropriate message if it wants to stop the commit.
\#
\# To enable this hook, rename this file to "pre\-applypatch".

. git\-sh\-setup
precommit\="$(git rev\-parse \-\-git\-path hooks/pre\-commit)"
test \-x "$precommit" \&\& exec "$precommit" ${1\+"$@"}
:

\-\-\-

\#\#\# File: pre\-push.sample (ID: .git.hooks.12\)

\#!/bin/sh

\# An example hook script to verify what is about to be pushed. Called by "git
\# push" after it has checked the remote status, but before anything has been
\# pushed. If this script exits with a non\-zero status nothing will be pushed.
\#
\# This hook is called with the following parameters:
\#
\# $1 \-\- Name of the remote to which the push is being done
\# $2 \-\- URL to which the push is being done
\#
\# If pushing without using a named remote those arguments will be equal.
\#
\# Information about the commits which are being pushed is supplied as lines to
\# the standard input in the form:
\#
\#    
\#
\# This sample shows how to prevent push of commits where the log message starts
\# with "WIP" (work in progress).

remote\="$1"
url\="$2"

zero\=$(git hash\-object \-\-stdin \&2 "Found WIP commit in $local\_ref, not pushing"
 exit 1
 fi
 fi
done

exit 0

\-\-\-

\#\#\# File: update.sample (ID: .git.hooks.13\)

\#!/bin/sh
\#
\# An example hook script to block unannotated tags from entering.
\# Called by "git receive\-pack" with arguments: refname sha1\-old sha1\-new
\#
\# To enable this hook, rename this file to "update".
\#
\# Config
\# \-\-\-\-\-\-
\# hooks.allowunannotated
\# This boolean sets whether unannotated tags will be allowed into the
\# repository. By default they won't be.
\# hooks.allowdeletetag
\# This boolean sets whether deleting tags will be allowed in the
\# repository. By default they won't be.
\# hooks.allowmodifytag
\# This boolean sets whether a tag may be modified after creation. By default
\# it won't be.
\# hooks.allowdeletebranch
\# This boolean sets whether deleting branches will be allowed in the
\# repository. By default they won't be.
\# hooks.denycreatebranch
\# This boolean sets whether remotely creating branches will be denied
\# in the repository. By default this is allowed.
\#

\# \-\-\- Command line
refname\="$1"
oldrev\="$2"
newrev\="$3"

\# \-\-\- Safety check
if \[ \-z "$GIT\_DIR" ]; then
 echo "Don't run this script from the command line." \>\&2
 echo " (if you want, you could supply GIT\_DIR then run" \>\&2
 echo " $0   )" \>\&2
 exit 1
fi

if \[ \-z "$refname" \-o \-z "$oldrev" \-o \-z "$newrev" ]; then
 echo "usage: $0   " \>\&2
 exit 1
fi

\# \-\-\- Config
allowunannotated\=$(git config \-\-type\=bool hooks.allowunannotated)
allowdeletebranch\=$(git config \-\-type\=bool hooks.allowdeletebranch)
denycreatebranch\=$(git config \-\-type\=bool hooks.denycreatebranch)
allowdeletetag\=$(git config \-\-type\=bool hooks.allowdeletetag)
allowmodifytag\=$(git config \-\-type\=bool hooks.allowmodifytag)

\# check for no description
projectdesc\=$(sed \-e '1q' "$GIT\_DIR/description")
case "$projectdesc" in
"Unnamed repository"\* \| "")
 echo "\*\*\* Project description file hasn't been set" \>\&2
 exit 1
 ;;
esac

\# \-\-\- Check types
\# if $newrev is 0000\...0000, it's a commit to delete a ref.
zero\=$(git hash\-object \-\-stdin \&2
 echo "\*\*\* Use 'git tag \[ \-a \| \-s ]' for tags you want to propagate." \>\&2
 exit 1
 fi
 ;;
 refs/tags/\*,delete)
 \# delete tag
 if \[ "$allowdeletetag" !\= "true" ]; then
 echo "\*\*\* Deleting a tag is not allowed in this repository" \>\&2
 exit 1
 fi
 ;;
 refs/tags/\*,tag)
 \# annotated tag
 if \[ "$allowmodifytag" !\= "true" ] \&\& git rev\-parse $refname \> /dev/null 2\>\&1
 then
 echo "\*\*\* Tag '$refname' already exists." \>\&2
 echo "\*\*\* Modifying a tag is not allowed in this repository." \>\&2
 exit 1
 fi
 ;;
 refs/heads/\*,commit)
 \# branch
 if \[ "$oldrev" \= "$zero" \-a "$denycreatebranch" \= "true" ]; then
 echo "\*\*\* Creating a branch is not allowed in this repository" \>\&2
 exit 1
 fi
 ;;
 refs/heads/\*,delete)
 \# delete branch
 if \[ "$allowdeletebranch" !\= "true" ]; then
 echo "\*\*\* Deleting a branch is not allowed in this repository" \>\&2
 exit 1
 fi
 ;;
 refs/remotes/\*,commit)
 \# tracking branch
 ;;
 refs/remotes/\*,delete)
 \# delete tracking branch
 if \[ "$allowdeletebranch" !\= "true" ]; then
 echo "\*\*\* Deleting a tracking branch is not allowed in this repository" \>\&2
 exit 1
 fi
 ;;
 \*)
 \# Anything else (is there anything else?)
 echo "\*\*\* Update hook: unknown type of update to ref $refname of type $newrev\_type" \>\&2
 exit 1
 ;;
esac

\# \-\-\- Finished
exit 0

\-\-\-

\#\#\# File: push\-to\-checkout.sample (ID: .git.hooks.14\)

\#!/bin/sh

\# An example hook script to update a checked\-out tree on a git push.
\#
\# This hook is invoked by git\-receive\-pack(1\) when it reacts to git
\# push and updates reference(s) in its repository, and when the push
\# tries to update the branch that is currently checked out and the
\# receive.denyCurrentBranch configuration variable is set to
\# updateInstead.
\#
\# By default, such a push is refused if the working tree and the index
\# of the remote repository has any difference from the currently
\# checked out commit; when both the working tree and the index match
\# the current commit, they are updated to match the newly pushed tip
\# of the branch. This hook is to be used to override the default
\# behaviour; however the code below reimplements the default behaviour
\# as a starting point for convenient modification.
\#
\# The hook receives the commit with which the tip of the current
\# branch is going to be updated:
commit\=$1

\# It can exit with a non\-zero status to refuse the push (when it does
\# so, it must not modify the index or the working tree).
die () {
 echo \>\&2 "$\*"
 exit 1
}

\# Or it can make any necessary changes to the working tree and to the
\# index to bring them to the desired state when the tip of the current
\# branch is updated to the new commit, and exit with a zero status.
\#
\# For example, the hook can simply run git read\-tree \-u \-m HEAD "$1"
\# in order to emulate git fetch that is run in the reverse direction
\# with git push, as the two\-tree form of git read\-tree \-u \-m is
\# essentially the same as git switch or git checkout that switches
\# branches while keeping the local changes in the working tree that do
\# not interfere with the difference between the branches.

\# The below is a more\-or\-less exact translation to shell of the C code
\# for the default behaviour for git's push\-to\-checkout hook defined in
\# the push\_to\_deploy() function in builtin/receive\-pack.c.
\#
\# Note that the hook will be executed from the repository directory,
\# not from the working tree, so if you want to perform operations on
\# the working tree, you will have to adapt your code accordingly, e.g.
\# by adding "cd .." or using relative paths.

if ! git update\-index \-q \-\-ignore\-submodules \-\-refresh
then
 die "Up\-to\-date check failed"
fi

if ! git diff\-files \-\-quiet \-\-ignore\-submodules \-\-
then
 die "Working directory has unstaged changes"
fi

\# This is a rough translation of:
\#
\# head\_has\_history() ? "HEAD" : EMPTY\_TREE\_SHA1\_HEX
if git cat\-file \-e HEAD 2\>/dev/null
then
 head\=HEAD
else
 head\=$(git hash\-object \-t tree \-\-stdin  1\)
 \[\~,datamatrix] \= averageFromSubField(expt(1\), subfield, field, centerpos, offsetinds, varargin{:});
 for j \= 2:length(expt)
 \[\~,dm] \= averageFromSubField(expt(j), subfield, field, centerpos, offsetinds, varargin{:});
 datamatrix \= \[datamatrix;dm]; %\#ok
 end
 qv \= mean(datamatrix);
 return;
end
 
\[qv, datamatrix] \= averageDerivedQuantity(\[expt.track.(subfield)], field, centerpos, offsetinds, varargin{:});
 
\-\-\-

\#\#\# File: addJavaTime.m (ID: @Experiment.3\)

function addJavaTime(expt, timfname, varargin)
%loads timing information to the file and adds it to all tracks
%function addtime(expt, timfname)
%experiment.addtime(timfname)
%
%outputs: none
%inputs:
%EXPT: a member of the Experiment class
%TIMFNAME: the filename of a .tim file
%
%each .tim file has 3 columns; only the first is used here
%column 1: elapsed time in ms. If the time wraps to 0, a jump of 65536 ms
%is assumed to have occurred (this is what mightex cameras do)
%column 2: number of triggers sent to the camera by this frame (ignored)
%column 3: time in seconds as recorded by the system at the time the pic
%was taken (ignored)
%
%alternately, a .mdat file with the header Mightex

fixedInterpTime \= \[];
varargin \= assignApplicable(varargin);

\[ps, fn] \= fileparts(expt.fname);
existsAndDefault('timfname', fullfile(ps, \[fn '.mdat']));
try 
 \[pathstr,name,ext] \= fileparts(timfname);
catch me
 disp(me.getReport);
 return;
end

if (strcmp(timfname, 'doNOTloadTIME'))
 return;
end
t \= \[];
ismdat \= false;
if (strcmpi (ext, '.mdat'))
 try 
 expt.metadata \= loadMdat(timfname);
 col \= find(strcmpi(expt.metadata.colheaders, 'Mightex\_TimeStamp'), 1\);
 if (\~isempty(col))
 t \= expt.metadata.data(:,col);
 ismdat \= true;
 else
 try
 bufnum \= expt.metadata.bufnum;
 bufnum\_time \= expt.metadata.bufnum\_time;
 %col \= find(strcmpi(tempstruct.colheaders, 'bufnum'), 1\);
 %col2 \= find(strcmpi(tempstruct.colheaders, 'bufnum\_time'), 1\);
 tpf \= diff(bufnum\_time)./diff(bufnum); %time per frame
 tpm \= median(tpf(isfinite(tpf))); %median time per frame
 
 tvalid \= isfinite(tpf) \& tpf \> 0\.8 \* tpm \& tpf \< 1\.2 \* tpm; %reasonable times
 bn \= bufnum(tvalid);
 bnt \= bufnum\_time(tvalid);
 p \= polyfit(bn \- bn(1\), bnt\-bnt(1\) , 1\);
 tpm \= p(1\);
 
% tpm \= mean(tpf(isfinite(tpf) \& tpf \> 0\.8 \* tpm \& tpf \< 1\.2 \* tpm)); %mean of resonable time per frames
 t \= (bufnum \- bufnum(1\)) \* tpm;
 ismdat \= true;
 catch %\#ok
 t \= NaN;
 end
 
 if (nnz(\~isfinite(t)) \> 0\.01\*length(t))
 warning ('mdat file is corrupted \- check dat file; trying to use frame added time stamp');
 disp ('disabling advanced mdat features');
 ismdat \= false;
 t \= expt.metadata.frameAddedTimeStamp;
% col \= find(strcmpi(tempstruct.colheaders, 'FrameNumber'), 1\);
 % col2 \= find(strcmpi(tempstruct.colheaders, 'frameAddedTimeStamp'), 1\);
 % t \= tempstruct.data(:,col2\);
 
 if (nnz(\~isfinite(t)) \> 0\.01\*length(t))
 error ('mdat file is hopelessly corrupt \- use dat file');
 end
 t \= t \- t(find(isfinite(t), 1, 'first'));
 end
 
 end
 catch %\#ok
 timfname \= fullfile(pathstr, \[name '.tim']);
 ismdat \= false;
 t \= \[];
 end
 if (isempty(t)) 
 timfname \= fullfile(pathstr, \[name '.tim']);
 t \= \[];
 ismdat \= false;
 end
end



if (isempty(t))
 try 
 data \= load(timfname);
 if (isempty(data))
 disp (\['failed to load timing info from ' timfname]);
 return;
 end
 t \= data(:,1\);
 catch me
 disp(me.getReport());
 disp ('failed to load timing info \-\- use add time yourself before running any functions');
 return
 end
end

expt.timfname \= timfname;


ind \= find(diff(t) \< 0, 1, 'first');
while (\~isempty(ind))
 t((ind\+1\):end) \= t((ind\+1\):end) \+ 65536;
 ind \= find(diff(t) \< 0, 1, 'first');
end

inds \= find(diff(t) \< 1\);
if \~isempty(inds)
 t(inds\+1\) \= t(inds\+1\)\+1;
end

expt.elapsedTime \= (t \- t(1\)) / 1000;
if (isempty(fixedInterpTime))
 dt \= round(median(diff(t)))/1000; %take interpolation time to nearest ms
else
 dt \= fixedInterpTime;
end
expt.dr.interpTime \= dt;
\[expt.track.dr] \= deal(expt.dr);
indx \= (1:length(t)) \- 1;
for j \= 1:length(expt.track)
 expt.track(j).addTime (indx, expt.elapsedTime);
end
%{
% only for very old data; will be removed soon

if (exist('data', 'var') \&\& size(data,2\) \> 4\)
 et2 \= (data(:,5\) \- data(2,5\))/1000;
 \[et2,I] \= unique(et2\);
 et1 \= expt.elapsedTime;
 p \= polyfit(et2(100:end), et1(I(100:end)), 1\);
 et2 \= p(1\)\*et2 \+ p(2\);
 gq \= GlobalQuantity();
 gq.xField \= 'eti';
 gq.fieldname \= 'lightTarget';
 gq.xData \= et2';
 gq.yData \= data(I,4\)';
 expt.addGlobalQuantity(gq);
 dll \= deriv(gq.yData, 10\) ./ deriv(gq.xData, 10\);
 gq.yData \= dll;
 gq.fieldname \= 'dlightTarget';
 expt.addGlobalQuantity(gq);
 if (size(data,2\) \> 5\)
 gq.fieldname \= 'projOutput';
 gq.yData \= data(I,6\)';
 expt.addGlobalQuantity(gq);
 end
end

%}

if (ismdat)
 addMetaDataFields(expt);
% addMDatFields(expt, tempstruct, expt.elapsedTime);
end

%this function handled metadata from projector experiments \-\- should be
%moved in to addMetaDataFields, if anyone cares
function addMDatFields(expt, datastruct, timestampbyrow)

header \= {'CamTargetLightLevel', 'ProjOutputValue'};
gqname \= {'lightTarget', 'projOutput'};
derivPts \= \[4, 0];
for j \= 1:length(header)
 col \= find(strcmpi(datastruct.colheaders, header{j}), 1\);
 if (\~isempty(col))
 ydat \= datastruct.data(:,col);
 xdat \= timestampbyrow(isfinite(ydat));
 ydat \= ydat(isfinite(ydat));
 gq \= GlobalQuantity;
 gq.xField \= 'eti';
 gq.xData \= xdat;
 gq.yData \= ydat;
 gq.fieldname \= gqname{j};
 gq.derivationMethod \= @GlobalQuantity.oneDinterpolation;
 expt.addGlobalQuantity(gq);
 if (derivPts(j) \> 0\)
 gq.yData \= deriv(ydat, derivPts(j))./deriv(xdat, derivPts(j));
 gq.fieldname \= \['d' gqname{j}];
 expt.addGlobalQuantity(gq);
 end
 end
end

addMetaDataFields(expt);
 
\-\-\-

\#\#\# File: makeWholeFrameImage.m (ID: @Experiment.4\)

function im \= makeWholeFrameImage (expt, ind, varargin)
%creates a mosaic image of all the individual point images for a frame
%function im \= makeWholeFrameImage (expt, ind, varargin)
%
%outputs:
%IM: a grayscale image
%inputs:
%EXPT: a member of the experiment class
%IND: the frame to make an image of
%optional parameter/value pairs:
%'imsize', \[height width], the size of the output image; default \[1944 2592] 
%experiment frame ind

imsize \= \[1944 2592];

assignApplicable(varargin);

im \= zeros(imsize);

for j \= 1:length(expt.track)
 ptind \= find(\[expt.track(j).pt.ind] \=\= ind);
 if (\~isempty(ptind))
 pt \= expt.track(j).pt(ptind);
 if (isempty(pt.imData))
 pt \= expt.reloadPoint(pt);
 end
 im(double(pt.imOffset(2\)) \+ (1:size(pt.imData,1\)), double(pt.imOffset(1\)) \+ (1:size(pt.imData,2\))) \= double(pt.imData);
 end
end
\-\-\-

\#\#\# File: addTemperatureAdjustedSpeed.m (ID: @Experiment.5\)

function addTemperatureAdjustedSpeed (expt, varargin)
% function addTemperatureAdjustedSpeed (expt, varargin)
%
% calculates mean speed vs. temp, then creates adjusted speed to take out linear contribution
% see addAdjustedField for implementation details
% EXPT \< expt

fn \= {expt.globalQuantity.fieldname};
ind \= strcmpi('temperature', fn);
if(any(ind))
 fn \= fn{find(ind, 1, 'first')};
 expt.addAdjustedField(fn, 'speed');
 return;
end
ind \= strcmpi('temp', fn);
if(any(ind))
 fn \= fn{find(ind, 1, 'first')};
 expt.addAdjustedField(fn, 'speed');
 return;
end 
\-\-\-

\#\#\# File: findNearestPointAtTime.m (ID: @Experiment.6\)

function \[pt, track, trackind, ptind] \= findNearestPointAtTime(expt, loc, atTime, varargin)

 % Location/time 
 withinDist \= 1; % cm within loc
 withinTime \= 10; % seconds within time below
 
 varargin \= assignApplicable(varargin);
 
 % Get the point
 if (\~exist ('loc', 'var') \|\| isempty (loc))
 \[x,y] \= getpts(); 
 %use last point selected
 x \= x(end);
 y \= y(end);
 else
 x \= loc(1,end);
 y \= loc(2,end);
 end
 
 % Gather points from each track
 trackInds \= \[];
 pts \= \[];
 dist \= \[];
 for i\=1:length(expt.track)
 \[newPts, newDs] \= gatherPointsInRange(expt.track(i),x,y, atTime, withinDist, withinTime);
 if \~isempty(newPts)
 pts \= \[pts newPts];
 dist \= \[dist newDs];
 newInds \= i\*ones(1,length(newPts));
 trackInds \= \[trackInds newInds];
 end
 end
 
 if \~isempty(dist)
 \[\~,sortInds] \= sort(dist);
 pt \= pts(sortInds(1\));
 trackind \= trackInds(sortInds(1\));
 track \= expt.track(trackind);
 ptind \= pt.ind;
 else
 pt \= \[];
 trackind \= \[];
 track \= \[];
 ptind \= \[];
 end
 
 
end



function \[pts, ds] \= gatherPointsInRange(track, x,y, time, withinDist, withinTime)

 timeRange \= \[time\-withinTime time\+withinTime];
 if timeRange(1\)track.pt(end).et
 timeRange(2\)\=track.pt(end).et;
 end
 
 % Check if the track has any proper time pts
 if (track.pt(end).ettimeRange(2\));
 pts \= \[];
 ds \= \[];
 return;
 end
 
 % Gather pts in time range
 tpp\=(track.pt(end).et\-track.pt(1\).et)/length(track.pt);
 ptRange \= floor((timeRange\-track.pt(1\).et)./tpp);
 if ptRange(1\)\<1
 ptRange(1\)\=1;
 end
 if ptRange(2\)\>length(track.pt)
 ptRange(2\)\=length(track.pt);
 
 end
 
 pts \= track.pt(ptRange(1\):ptRange(end));
 locs \= \[pts.loc];
 
 if \~isempty(pts)
 % Measure dist to those pts, return points within range
 dist \= (locs(1,:)\-x).^2 \+ (locs(2,:)\-y).^2;

 pts \= pts(dist
end
pt \= pt2;
\-\-\-

\#\#\# File: gatherField.m (ID: @Experiment.8\)

function qvec \= gatherField(expt, fieldname, varargin)
%gets all values of 'fieldname' for all tracks in expt
%function qvec \= gatherField(expt, fieldname, varargin)
%outputs: 
%QVEC: a kxN array of values, where N is the total number of points
% and k is the dimension of the values of fieldname
%
%inputs: 
%EXPT: a member of the Experiment class
%FIELDNAME: either a property of the Track/MaggotTrack/etc. in EXPT or
% a fieldname that can be passed to Track/getDerivedQuantity
%VARARGIN: if fieldname is passed to getDerivedQuantity, VARARGIN{:}
% is also passed, so any valid arguments to getDerivedQuantity can be
% appended here
% e.g. add 'runs', 'reorientations', 'headswings' to get field just in
% runs/reos/hs
% 'validname', fieldname
% 'validoperation', op \-\- @(x) logical(setNonFiniteToZero(x))
% gathers from the subset of points that stasify
% that satisfy op(gatherField(fieldname,varargin{:})) \=\= true

validname \= \[];
expandToInterped \= false;
validoperation \= @(x) logical(setNonFiniteToZero(x));
varargin \= assignApplicable(varargin);
if (any(strcmp(fieldname, fieldnames(expt.track(1\)))))
 if (expandToInterped \&\& all(size(expt.track(1\).(fieldname)) \=\= 1\))
 qvec \= \[]; 
 for j \= 1:length(expt.track)
 qvec \= \[qvec expt.track(j).(fieldname)\*ones(size(expt.track(j).getDerivedQuantity('eti', false, varargin{:})))];
 end
 
 else
 qvec \= \[expt.track.(fieldname)];
 end
else 
 qvec \= \[]; 
 
 for j \= 1:length(expt.track)
 
 qvec \= \[qvec expt.track(j).getDerivedQuantity(fieldname, false, varargin{:})];
 %{
 if (isempty(qvec))
 break;
 end
 %}
 end
end 

if (\~isempty(validname))
 vvec \= validoperation(expt.gatherField(validname, varargin{:}));
 qvec \= qvec(:,vvec);
end

\-\-\-

\#\#\# File: powerSpectrum.m (ID: @Experiment.9\)

function \[ps, f] \= powerSpectrum(expt, quantityName, timeInterval, varargin)
%produces the power spectrum for a qiven measured/derived quantity
%function \[ps, f] \= powerSpectrum(expt, quantityName, timeInterval,
%varargin)
%
%outputs: 
%PS: the power spectrum
%F: the frequencies at which the power spectrum is determined
%inputs:
%EXPT: a member of the experiment class
%TIME INTERVAL: the size of the window for averaging purposes
% a smaller window has greater averaging but less frequency resolution
%VARARGIN: any parameters that can be passed to TRACK/POWERSPECTRUM
w \= \[expt.track.npts];
w \= w/sum(w);
\[ps,f] \= expt.track(1\).powerSpectrum(quantityName, timeInterval, varargin);

ps \= zeros(size(ps));

for j \= 1:length(expt.track)
 ps \= ps \+ w(j)\*expt.track(j).powerSpectrum(quantityName, timeInterval, varargin);
end


 
\-\-\-

\#\#\# File: findSuppDataDir.m (ID: @Experiment.10\)

function sdd \= findSuppDataDir(exp\_fname)
%function sdd \= findSuppDataDir(exp\_fname)
%
%finds supplemental data directory for gershow lab style processing

 \[p,f] \= fileparts(exp\_fname);
 sdd \= fixFileNameWin(fullfile(p, \[f ' sup data dir']));
 if (isdir(sdd))
 return;
 end
 
 sdd \= fixFileNameWin(fullfile(p, \[f ' sup data']));
 if (isdir(sdd))
 return;
 end
 
 sdd \= fixFileNameWin(fullfile(p, \[shortenFileStub(f) ' sup data dir']));
 if (isdir(sdd))
 return;
 end
 
 sdd \= fixFileNameWin(fullfile(p, \[shortenFileStub(f) ' sup data']));
 if (isdir(sdd))
 return;
 end
 
 sdd \= '';
 

\-\-\-

\#\#\# File: updateTrackSegmentationOptions.m (ID: @Experiment.11\)

function updateTrackSegmentationOptions(expt, varargin)
% changes all tracks segmentation options to be the same as experiment's
% function updateTrackSegmentationOptions(expt, varargin)
%
% EXPT \< experiment
if (length(expt) \> 1\)
 for j \= 1:length(expt)
 expt(j).updateTrackSegmentationOptions(varargin{:});
 end
 return;
end
if (length(varargin) \>\= 1\)
 expt.so \= varargin{1};
end
\[expt.track.so] \= deal(expt.so);
\-\-\-

\#\#\# File: crosscorrelate.m (ID: @Experiment.12\)

function \[xc, np, tx, nt] \= crosscorrelate (expt, fieldname1, fieldname2, varargin)
%cross correlates track fields
%function \[xc, np, tx, nt] \= crosscorrelate (expt, fieldname1, fieldname2, varargin)
%
%cross correlates track fields (see Track.crosscorrelate)
%
%assumes same interpolation time (dr.interptime) for all tracks
%
%outputs:
%XC is the unnormalized cross correlation (normalized is xc./np)
%TX is the time axis for the cross correlation
%NP is the number of points contributing to a certain bin
%NT is the number of tracks contributing to a certain bin
%
%xc(T) \= ; \-N denotes the average
%XC is the return 1x(2N\-1\) vector XC(j) \= xc(j\-N);
%
%inputs:
%EXPT: a member of the Experiment class
%FIELDNAME1, FIELDNAME2: the names of the fields to cross\-correlate
%VARARGIN: any parameter/value pair passed to Track/crosscorrelate, see
%below
%
%we define the cross\-correlation to be
%XC(T) \= ; \-N denotes the average
%xc is the return 1x(2N\-1\) vector xc(j) \= XC(j\-N);
%
%
%arguments to pass in:
%'row', row number(s)
%if row \= m, just finds the correlation of track.dq.(fieldnames)(m,:)\\
%'inRuns', true/false
%if inRuns is true, we take the autocorrelation over the whole track, but
%first interpolate the fields over only the run indices
%this is useful if the fields are ill\-defined between runs (e.g. velocity
%direction)
%'withinRuns', true/false
%if withinRuns is true, we find the correlation only within each run
%'isangle', true/false
% if isangle is true, then we compute the correlation as cos (theta1 \-
% theta2\) instead of as theta1\*theta2
%'timerange', \[mintime maxtime] \-\- only consider data from this time range


expt.calculateDerivedQuantity('eti');
npts \= expt.evaluateTrackExpression('length(track.dq.eti)');
N \= max(npts);

xc \= zeros(\[1 2\*N\-1]);
np \= xc;
nt \= np;
tx \= ((1:(2\*N\-1\)) \- N)\*expt.track(1\).dr.interpTime;

for j \= 1:length(expt.track)
 \[x, npt] \= expt.track(j).crosscorrelate(fieldname1, fieldname2, varargin{:});
 n \= (length(x) \+ 1\) / 2;
 if (isempty(x))
 continue;
 end
 xc((N\-n\+1\):(N\+n\-1\)) \= xc((N\-n\+1\):(N\+n\-1\)) \+ x;
 np((N\-n\+1\):(N\+n\-1\)) \= np((N\-n\+1\):(N\+n\-1\)) \+ npt;
 nt((N\-n\+1\):(N\+n\-1\)) \= nt((N\-n\+1\):(N\+n\-1\)) \+ 1;
end

ind \= find(np \~\= 0\);
xc \= xc(ind);
np \= np(ind);
tx \= tx(ind);
nt \= nt(ind);
\-\-\-

\#\#\# File: addAdjustedField.m (ID: @Experiment.13\)

function addAdjustedField(expt, field1, adjfield,varargin) 
%function addAdjustedField(expt, field1, adjfield,varargin)
%
% EXPT \< Experiment
% FIELD1 \< 1\-dimensional field (e.g. temperature)
% ADJFIELD \< 1\-dimensional field (e.g. speed)
%
% calculates mean adjfield vs. field1, then creates adjusted field to take out linear contribution
% say field1 \= T; adjfield \= s. 
% approximate  \=  ~~\+ a(T\-T0\), where  ~~is mean over all
% temperatures
% s\_adj \= s\*F(T): F(T) \= 1/(1\+a/~~\*(T\-T0\));

x \= expt.gatherField(field1\);
y \= expt.gatherField(adjfield);

inds \= isfinite(x) \& isfinite(y);
x \= x(inds); y \= y(inds);
x \= \[x;x]; x(2,:) \= 1;
A \= y\*pinv(x);
my \= mean(y);

xaxis \= linspace(min(x(1,:)),max(x(1,:)), 100\);
adj\_vs\_x \= my./(A(1\)\*xaxis \+ A(2\));

gq \= GlobalQuantity;
gq.xField \= {field1, adjfield};
gq.fieldname \= \[field1 '\_adjusted\_' adjfield];
gq.xData \= xaxis;
gq.yData \= adj\_vs\_x;
gq.derivationMethod \= @GlobalQuantity.oneDinterpolationAndMultiplication;

expt.addGlobalQuantity(gq);
\-\-\-

\#\#\# File: stitchTracks.m (ID: @Experiment.14\)

function stitchTracks (expt, maxFrameInterval, maxDist, varargin)
%merges tracks that may represent the same animal
%function stitchTracks (expt, maxFrameInterval, maxDist, varargin)
%
%inputs: 
%EXPT: a member of the Experiment class
%MAXFRAMEINTERVAL: the maximum number of frames that may be missing between
% the end of track1 and the start of track2 to merge them
%MAXDIST: the maximum distance between the end of track1 and the start
% of track2 to merge them
%optional arguments
%'interactive', true/false (default true)
% if interactive, prompts user to approve all stitching first
%'stitchcollisions', true/false (default false)
% if true, stitch tracks even if they are marked as colliding at the end
% point
%'detectcollisions', true/false (default true)
% if stitchcollisions is false and detect collisions is true, we run 
% collision detection with separation maxDist before stitching
%'rectSize', (default maxDist\*3\), size of region surrounding stitch point shown on
% map of tracks in and out

 %sort into ascending order by start frame
 %{
 sf \= zeros(size(expt.track));
 for j \= 1:length(expt.track)
 sf(j) \= expt.track(j).pt(1\).ind;
 end
 %}
 
 interactive \= true;
 stitchcollisions \= false;
 rectSize \= maxDist \* 3;
 varargin \= assignApplicable(varargin);
 t \= \[expt.track];
 \[\~,I] \= sort(\[t.startFrame]);
 expt.track \= expt.track(I);

 if (\~stitchcollisions)
 expt.detectCollisions(maxDist);
 end
 
 %j \= 1;
 sf \= \[expt.track.startFrame];
 %work backwards so we only have to iterate once
 ts \= tic;
 alreadyMerged \= \[];
 for j \= length(expt.track):\-1:1
 if (\~stitchcollisions \&\& expt.track(j).iscollision(end))
 continue; %don't stitch tracks that end in collisions
 end
 
 lastValid \= j \+ find(sf((j\+1\):end) \> expt.track(j).endFrame \+ maxFrameInterval, 1, 'first');
 
 firstValid \= j \+ find(sf((j\+1\):lastValid) \> expt.track(j).endFrame, 1, 'first');
 
 for k \= setdiff(firstValid:lastValid, alreadyMerged);
 
 if (expt.track(j).precedes(expt.track(k), maxFrameInterval, maxDist) \&\& ...
 (stitchcollisions \|\| \~expt.track(k).iscollision(1\))) %don't stitch tracks that begin in collision
 
 if (\~interactive \|\| getApproval(expt, j, k, rectSize)) 
 alreadyMerged \= mergeTracks (expt, j, k, alreadyMerged);
 end
 break; %only merge one track
 end
 
 end
 
 if (mod(j,100\) \=\= 0\) 
 disp (\[num2str(j /(length(expt.track) \- j) \* toc(ts)) ' s remaining']);
 end
 end
 inds \= setdiff(1:length(expt.track), alreadyMerged);
 disp(\['merged ' num2str(length(alreadyMerged)) ' tracks']);
 delete(expt.track(alreadyMerged));
 expt.track \= expt.track(inds);
 
 
end %stitchTracks

function alreadyMerged \= mergeTracks (expt, j, k, alreadyMerged)
 %disp('merging');
 expt.track(j).merge(expt.track(k));
 alreadyMerged \= \[alreadyMerged k];
end

function approved \= getApproval (expt, j, k, rectSize, ptbuffer)
 ts \= tic;
 existsAndDefault('rectSize', 20\);
 existsAndDefault('ptbuffer', 10\);
 figure(1\); clf(1\); hold on
 t1 \= expt.track(j);
 t2 \= expt.track(k);
 pt1 \= expt.track(j).pt(end);
 pt2 \= expt.track(k).pt(1\);
 indsExpression \= \['find(abs(track.getDerivedQuantity(''eti'') \- ' num2str(pt1\.et) ') \< 5\)'];
 expt.track.plotPath('iloc', 'k\-', 'LineWidth', 0\.2, 'Color', \[0\.7 0\.7 0\.7]);
 expt.track.plotPath('iloc', 'k\-\-', 'indsExpression', indsExpression, 'LineWidth', 2\);
 
 expt.executeTrackFunction('plotPath', 'loc', 'k\-', 'LineWidth', 0\.2, 'Color', \[0\.7 0\.7 0\.7]);
 expt.track(j).plotPath('loc', 'r\-','LineWidth', 2\);
 expt.track(k).plotPath('loc', 'g\-','LineWidth', 2\);
 loc \= pt1\.loc;
 axis(\[loc(1\)\-rectSize, loc(1\) \+ rectSize, loc(2\)\-rectSize, loc(2\)\+rectSize]); 
 axis equal
 axis(\[loc(1\)\-rectSize, loc(1\) \+ rectSize, loc(2\)\-rectSize, loc(2\)\+rectSize]); 
 
 fd \= pt2\.ind \- pt1\.ind;
 pd \= pt1\.distance(pt2\);
 
 title({\[expt.fname ' tracks ' num2str(j) ' \& ' num2str(k) ],\['frame diff \= ' num2str(fd) ' point dist \= ' num2str(pd)]},...
 'Interpreter','none');
 
 
 expt.openDataFile;
 figure(2\); clf(2\);
 ind1 \= max(1,length(\[expt.track(j).pt]) \- 10\);
 
 ind2 \= min(length(expt.track(k).pt),10\);

 pt1 \= expt.track(j).pt(ind1:end);
 pt2 \= expt.track(k).pt(1:ind2\);
 
 %find all points that are in target rectangle in time range
 disprect \= \[loc(1\) \- rectSize, loc(1\) \+ rectSize, loc(2\) \- rectSize, loc(2\) \+ rectSize];
 tinds \= expt.track.passesThroughBox(disprect,...
 \[pt1(1\).et pt2(end).et]);
 t \= expt.track(tinds);
 pt \= \[t.pt];
 ploc \= \[pt.loc];
 pin \= \[pt.ind];
 pinds \= find(abs(ploc(1,:) \- loc(1\)) \< rectSize \& abs(ploc(2,:) \- loc(2\)) \< rectSize ...
 \& pin \>\= expt.track(j).pt(end).ind \- ptbuffer \& pin \<\= expt.track(k).pt(1\).ind \+ ptbuffer);
 pt \= expt.reloadPoint(pt(pinds));
 ploc \= ploc(:,pinds);
 pin \= pin(pinds);
 
 % disp(\['getApproval setup took ' num2str(toc(ts)) ' s']);
 %rectSize
 while(1\)
 figure(2\);
 %{
 for j \= 1:length(pt1\)
 pt1(j).drawTrackImage(\[],'fid', expt.fid);
 title ('end of track 1');
 pause(0\.1\);
 end
 for j \= 1:length(pt2\)
 pt2(j).drawTrackImage(\[],'fid', expt.fid);
 title ('start of track 2');
 pause(0\.1\);
 end
 %}
 % min(pin)
 % max(pin)
 for j \= min(pin):max(pin)
 cla();
 for k \= find(pin \=\= j)
 pt(k).drawTrackImage();
 hold on;
 end 
 indsExpression \= \['find(track.getDerivedQuantity(''eti'') \<\= ' num2str(expt.elapsedTime(max(pin)) \+ 10\) ' \& track.getDerivedQuantity(''eti'') \>\= ' num2str(expt.elapsedTime(min(pin))\-10\) ')' ];
 tactive \= \[t.endFrame] \>\= j;
 t1\.plotPath('iloc', 'y\-', 'indsExpression', indsExpression, 'LineWidth', 4\);
 t2\.plotPath('iloc', 'y\-', 'indsExpression', indsExpression, 'LineWidth', 4\);
 indsExpression \= \['find(track.getDerivedQuantity(''eti'') \<\= ' num2str(expt.elapsedTime(j)) ' \& track.getDerivedQuantity(''eti'') \>\= ' num2str(expt.elapsedTime(min(pin))) ')' ];
 
 if (any(tactive))
 t(tactive).plotPath('iloc', 'c\-', 'indsExpression', indsExpression, 'LineWidth', 2\);
 end
 if (any(\~tactive))
 t(\~tactive).plotPath('iloc', 'r\-', 'indsExpression', indsExpression, 'LineWidth', 2\);
 end
 axis (disprect);
% title (\[num2str(sum(pin \=\= j)) ' points should be displayed']);
 pause(0\.1\);
 end
 
 key \= input ('stitch tracks? : y/n/a(ll remaining without asking)', 's');
 if (isempty(key))
 continue;
 end
 switch(lower(key(1\)))
 case 'y'
 approved \= true;
 return;
 case 'n'
 approved \= false;
 return;
 case 'a'
 approved \= true;
 evalin('caller', 'interactive \= false;');
 return;
 end
 end
end
\-\-\-

\#\#\# File: findNearestPoint.m (ID: @Experiment.15\)

function \[pt, track, trackind, ptind] \= findNearestPoint (expt, loc, varargin)
%searches through all points in tracks in expt to find point(s) nearest loc
%function \[pt, track, trackind, ptind] \= findNearestPoint (expt, loc)
%
%outputs:
%PT: an array of point objects that duplicates the point(s) in expt nearest
% loc(s)
%TRACK: an array of track (handle) object(s) containing the nearest
% point(s)
%TRACKIND: the indices of the track(s) containing the nearest point(s)
%PTIND: the indices of the nearest point(s) within track(s)
% i.e. EXPT.track(TRACKIND) \= TRACK
% EXPT.track(TRACKIND(j)).pt(PTIND(j)) is the same as PT(j)
%inputs:
%EXPT: a member of the experiment class
%LOC: a 2xN list of points
useTime \= false;
atTime \= \-1;
varargin \= assignApplicable(varargin);

if useTime
 \[pt, track, trackind, ptind] \= findNearestPointAtTime(expt, loc, atTime, varargin);
 return;
end


if (\~exist ('loc', 'var') \|\| isempty (loc))
 \[x,y] \= getpts(); 
 %use last point selected
 x \= x(end);
 y \= y(end);
else
 x \= loc(1,end);
 y \= loc(2,end);
end

pts \= expt.gatherField('loc');
if (atTime\>0\)
 times \= expt.gatherField('et');
 pts \= pts(:,logical((atTime\-withinTime)\= I, 1, 'first');
if (trackind \> 1\)
 ptind \= I \- n(trackind\-1\);
else
 ptind \= I;
end
track \= expt.track(trackind);
pt \= track.pt(ptind);
\-\-\-

\#\#\# File: setTimingByFrameDifference.m (ID: @Experiment.16\)

function setTimingByFrameDifference(expt, deltaT, overrideExisting) 
%function setTimingByFrameDifference(expt, deltaT, overrideExisting) 
%
%sets the elapsedTime to be 0:1:numFrames \* deltaT
%if there is already an existing elapsedTime, then does not overwrite it,
%unless overrideExisting is true

existsAndDefault('overrideExisting', false);
existsAndDefault('deltaT', 1\);
if (\~isempty(expt.elapsedTime) \&\& \~overrideExisting)
 return;
end
tr \= expt.track;
maxFrame \= max(\[tr.endFrame]);

expt.dr.interpTime \= deltaT;
\[tr.dr] \= deal(expt.dr);

t \= double(0:1:maxFrame)\*deltaT;
expt.elapsedTime \= double(t');
indx \= (1:length(t)) \- 1;
for j \= 1:length(expt.track)
 expt.track(j).addTime (indx, expt.elapsedTime);
end

expt.timfname \= 'asserted timing from inter\-frame interval';

\-\-\-

\#\#\# File: executeTrackFunction.m (ID: @Experiment.17\)

function varargout \= executeTrackFunction(expt, func, varargin)
%loops through all tracks and executes func(expt.track(j), varargin)
%function varargout \= executeTrackFunction(expt, func, varargin)
%
%inputs:
%EXPT: a member of the Experiment class
%FUNC: the function to execute
% if func is a string, calls
% expt.track(j).(func)(varargin{:})
% if func is not a string, it is assumed to be a function handle; call is
% func(expt.track(j),varargin{:})
%VARARGIN: additional arguments passed to func
%outputs: varargout
% varargout is a cell array of cells. 
% varargout{1} is a compilation of the first return output, etc.
% in pseduo\-code 
% \[varargout{1}{j}, varargout{2}{j},...] \= expt.track(j).(func)(varargin{:})

if ischar(func)
 if (nargout \> 0 \&\& \~isempty(expt.track) \&\& objNargout (expt.track(1\), func) \~\= 0\)
 for j \= 1:length(expt.track)
 \[result{1:nargout}] \= expt.track(j).(func)(varargin{:});
 allresult{j} \= result;
 end
 for k \= 1:nargout
 clear temp;
 for j \= 1:length(allresult)
 temp(j) \= allresult{j}{k};
 end
 varargout{k} \= temp;
 end
 else
 for j \= 1:length(expt.track)
 expt.track(j).(func)(varargin{:});
 end
 end
else
 if (nargout \> 0 \&\& nargout(func) \~\= 0\)
 for j \= 1:length(expt.track)
 \[result{1:nargout}] \= func(expt.track(j),varargin{:});
 allresult{j} \= result;
 end
 for k \= 1:nargout
 clear temp;
 for j \= 1:length(allresult)
 temp(j) \= allresult{j}{k};
 end
 varargout{k} \= temp;
 end
 else
 for j \= 1:length(expt.track)
 func(expt.track(j),varargin{:});
 end
 end
end
 
\-\-\-

\#\#\# File: gatherSubField.m (ID: @Experiment.18\)

function qvec \= gatherSubField (expt, field, subfield, varargin)
%gets all track.(field).(subfield)
%function qvec \= gatherSubField (expt, field, subfield, varargin)
%
%outputs:
%QVEC: a kxN array where k is the dimension of field.subfield and N is the
% number of points
%
%inputs:
%EXPT: a member of the experiment class
%FIELD: a property of EXPT.track
% if field is 'firsths', gathers the first headsweep from every
% reorientation only
% if field is 'lasths', gathers the last headsweep from every reo
%SUBFIELD: a property of EXPT.track.FIELD
% i.e. if FIELD is 'run', subfield might be 'startTheta', in which case
% the starting angle of every run is returned
%optional inputs:
%'expandToInds', true/false
%if you pass 'expandToInds',true the subfield is expanded so that
%the return vector is the same length as gatherFromSubField would return
%field must have a subfield inds
%
%for example say a field has a subfield "fieldnumber" \= 1 for first field, 2
%for second and so on
%and field(1\).inds \= \[1 2 3], field(2\).inds \= \[1 2 3 4 5], field(3\).inds \=
%\[187]
%
%then gatherSubField(field, fieldnumber, 'expandToInds', true) would yield
%\[1 1 1 2 2 2 2 2 3]

expandToInds \= false;
varargin \= assignApplicable(varargin);

if (isempty(expt) \|\| isempty(expt.track))
 qvec \= \[];
 return;
end


if (strcmpi (field, 'firsths'))
 r \= \[expt.track.reorientation];
 r \= r(\[r.numHS] \> 0\);
 f \= repmat(HeadSwing, size(r));
 for k \= 1:length(r)
 f(k) \= r(k).headSwing(1\);
 end
else
 if (strcmpi (field, 'lasths'))
 r \= \[expt.track.reorientation];
 r \= r(\[r.numHS] \> 0\);
 f \= repmat(HeadSwing, size(r));
 for k \= 1:length(r)
 f(k) \= r(k).headSwing(end);
 end
 else
 f \= \[expt.track.(field)];
 end
end
if (isempty(f))
 qvec \= \[];
 return;
end
qvec \= \[f.(subfield)];

if (expandToInds)
 inds \= \[f.inds];
 k \= 0;
 for j \= 1:length(f)
 n \= length(f(j).inds);
 inds(k \+ (1:n)) \= j;
 k \= k\+n;
 end
 qvec \= qvec(:,inds);
end
\-\-\-

\#\#\# File: updateDerivationRules.m (ID: @Experiment.19\)

function updateDerivationRules(expt, varargin)
% changes all derivation rules be the same as experiment's
% does not recalculate derived quantities
% function updateDerivationRules(expt)
% function updateDerivationRules(expt, dr)
% EXPT \< experiment
% DR \< DerivationRules (optional) \- sets expt.dr \= dr

if (length(expt) \> 1\)
 for j \= 1:length(expt)
 expt(j).updateDerivationRules(varargin{:});
 end
 return;
end
if (length(varargin) \>\= 1\)
 dr \= varargin{1};
 if (isa(dr, 'DerivationRules'))
 expt.dr \= dr;
 end
end
\[expt.track.dr] \= deal(expt.dr);
\-\-\-

\#\#\# File: fromMWTFile.m (ID: @Experiment.20\)

function expt \= fromMWTFile (inputname, camcalinfo, varargin)
%loads an experiment from a bin file
%function expt \= fromMWTFile (inputname, camcalinfo, varargin)
%this is a static method of the Experiment class (Experiment.fromMWTFile)
%
%outputs: 
%EXPT, a member of the experiment class
%inputs:
%INPUTFNAME: directory containing something choreography can read
%CAMCALINFO: camera calibration struct (ask Marc); pass empty (\[]) to ignore
% default: \[]
%optional args \- 'choreography\_command', 'pluginArray' \-\- ask Marc
%interpTime, (interpolation time in seconds) \-\- override default selection
%of interp time

if (\~exist ('camcalinfo', 'var')) 
 camcalinfo \= \[];
end

choreography\_command \= '\-t 30 \-s 0\.1 \-M 1 \-\-shadowless \-\-plugin Reoutline::exp \-\-plugin Respine::0\.23::tapered\=0\.28,1,2 \-\-plugin SpinesForward::rebias \-\-minimum\-biased 3mm \-S \-\-nanless';
pluginArray \= javaArray('CustomComputation',3\); pluginArray(1\) \= Reoutline(); pluginArray(2\) \= Respine(); pluginArray(3\) \= SpinesForward(); 
interpTime \= \[];
varargin \= assignApplicable(varargin);
jsa \= commandLineToJavaStringArray(choreography\_command);
jsa(length(jsa)\+1\) \= java.lang.String(inputname);
try
 chore \= javaMethod('doEverything','Choreography',jsa,pluginArray,true);
 dances \= chore.extractReasonableDancers();
catch me
 disp ('choreography error:');
 disp (me.getReport());
 expt \= repmat(Experiment(), 0\);
 return;
end

ts1 \= tic();
expt \= Experiment();

expt.fname \= inputname;
expt.camcalinfo \= camcalinfo;
expt.elapsedTime \= double(chore.extractTimes())';
if (isempty(interpTime))
 interpTime \= percentile(diff(expt.elapsedTime), 0\.1\);
end
for j \= 1:length(dances)
 track(j) \= MWTTrack.fromDance(dances(j), camcalinfo);
 track(j).dr.interpTime \= interpTime;
 if (\~isempty(camcalinfo)) %real points instead of camera points
 track(j).so.stop\_speed\_cut \= 0\.01;
 track(j).so.start\_speed\_cut \= 0\.015;
 track(j).so.curv\_cut \= 50;
 end
end
expt.track \= track;
\[expt.track.expt] \= deal(expt);
disp(\['conversion to matlab struct took: ' num2str(toc(ts1\),2\) ' s']);
\-\-\-

\#\#\# File: addMetaDataFields.m (ID: @Experiment.21\)

function addMetaDataFields(expt, varargin)
%parses the metadata file (.mdat) for global quantities

if (length(expt) \> 1\) 
 for j \= 1:length(expt)
 expt(j).addMetaDataFields(varargin{:});
 end
 return;
end
 
if (\~isempty(varargin) \&\& exist(varargin{1},'file'))
 expt.timfname \= varargin{1};
end

% header \= {'GAS\_CH1\_SP', 'co2filt\_0', 'co2filt\_1', 'PID\_PPM', 'LED\_ON', 'LUM\_PWM\_AMP'};
% timheader \= {'GAS\_CH1\_SP\_time', 'co2fast\_0\_time', 'co2fast\_1\_time', 'PID\_PPM\_time', 'LED\_ON\_time', 'LUM\_PWM\_AMP\_time'};
% gname \= {'gassp', 'co2ppm0', 'co2ppm1', 'vocppm', 'ledOn', 'ledAmp'};
% smoothTime \= \[0, 2, 2, 7, 0, 0];
% derivTime \= \[0\.1, 1, 1, 1, 0, 0];
% isgas \= \[true, true, true, true, false, false];
header \= {'GAS\_CH1\_SP', 'co2filt\_0', 'co2filt\_1', 'PID\_PPM', 'LED\_ON', 'LUM\_PWM\_AMP', 'Temp\_C\_WS'};
timheader \= {'GAS\_CH1\_SP\_time', 'co2fast\_0\_time', 'co2fast\_1\_time', 'PID\_PPM\_time', 'LED\_ON\_time', 'LUM\_PWM\_AMP\_time','Temp\_C\_WS\_time'};
gname \= {'gassp', 'co2ppm0', 'co2ppm1', 'vocppm', 'ledOn', 'ledAmp','temperature'};
smoothTime \= \[0, 2, 2, 7, 0, 0,1];
derivTime \= \[0\.1, 1, 1, 1, 0, 0,1];
isgas \= \[true, true, true, true, false, false,false];

gasvel \= 2\.5; %changed to 2\.5 for 4L/min flow in new flow chamber 6/12/2016
gasdir \= \[\-1;0]; %new flow chamber, flow is from the right 
gasorigin\_cell \= {\[27;0],\[27;0],\[27;0],\[27;0],\[],\[],\[]}; %changed to \+27 cm for new flow chamber 6/12/2016
fnum \= 1:length(expt.elapsedTime);
et \= expt.elapsedTime;

if (isempty(expt.metadata))
 expt.metadata \= importdata2(fixFileNameWin(expt.timfname));
end

datastruct \= expt.metadata;

%{
try
 datastruct \= importdata(timfname);
catch me
 disp(me);
 return;
end
%}

for j \= 1:length(header)
 col \= find(strcmpi(datastruct.colheaders, header{j}), 1\);
 if (\~isempty(col))
 try
 ydata \= datastruct.data(:,col);
 col \= find(strcmpi(datastruct.colheaders, timheader{j}), 1\);
 if (\~isempty(col))
 timdata \= datastruct.data(:,col)/1000;
 else
 timdata \= et;
 end
 inds \= find(isfinite(ydata)\&isfinite(timdata));
 ydat \= ydata(inds);
 timdata \= timdata(inds);
 \[\~,I] \= min(timdata);
 ydat \= ydat(I:end); %get rid of any early bad time values before reset
 timdata \= timdata(I:end);
 \[timdata,I] \= unique(timdata);
 ydat \= ydat(I);
 p \= polyfit(timdata, et(inds(I)),1\);
 et2 \= p(1\)\*timdata \+ p(2\);
 eti \= linspace(min(et2\), max(et2\), (max(et2\)\-min(et2\))/expt.dr.interpTime);
 xdat \= eti;
 ydat \= interp1(et2, ydat, eti, 'linear');
 inds \= isfinite(xdat) \& isfinite(ydat);
 xdat \= xdat(inds); ydat \= ydat(inds);
 if (smoothTime(j) \> 0\)
 ydat \= lowpass1D(ydat, smoothTime(j)/expt.dr.interpTime, 'padType', 'linear');
 end
 gq \= GlobalQuantity();
 gq.yData \= ydat;
 gq.fieldname \= gname{j};
 if (isgas(j))
 gasorigin \= gasorigin\_cell{j};
 gq.xField \= {'eti', 'sloc'};
 xData.et \= xdat;
 xData.origin \= gasorigin;
 xData.flowspeed \= gasvel;
 xData.flowdir \= gasdir;
 gq.xData \= xData;
 gq.derivationMethod \= @GlobalQuantity.timeVaryingGasDerivation;
 else
 gq.xField \= 'eti';
 gq.xData \= \[min(expt.elapsedTime)\-1 xdat max(expt.elapsedTime)\+1];
 gq.yData \= gq.yData(\[1 1:end end]);
 end
 
 
 
 expt.addGlobalQuantity(gq);
 if (derivTime(j) \> 0\)
 gq.xData \= \[];
 gq.yData \= \[];
 gq.xField \= gname{j};
 gq.fieldname \= \['d' gname{j}];
 gq.derivationMethod \= @(xin, xData, yData) deriv(xin, derivTime(j)/expt.dr.interpTime);
 expt.addGlobalQuantity(gq);
 end
 catch me
 disp (\['problem adding metadata field ' gname{j}]);
 disp (me.getReport);
 end
 
 end
end

ind \= find(strcmpi('LAST\_STROBE\_MS', datastruct.colheaders));
if (\~isempty(ind))
 strobeind \= find(isfinite(datastruct.data(:,ind)));
 strobeind \= strobeind(strobeind \> 0\);
 xdata \= et;
 ydata \= false(size(xdata));
 ydata(strobeind) \= true;
 
 gq \= GlobalQuantity();
 gq.yData \= ydata;
 gq.fieldname \= 'strobe';
 gq.xField \= 'eti';
 gq.xData \= xdata;
 
 expt.addGlobalQuantity(gq);
 gq.fieldname \= 'strobe\_high';
 expt.addGlobalQuantity(gq);
 gq.fieldname \= 'strobe\_low';
 gq.yData \= \~ydata;
 expt.addGlobalQuantity(gq);
 
 
 strobetime \= et(strobeind);
 ydata \= \-100\*ones(size(xdata));
 for j \= 1:length(et)
 if (any(strobetime \<\= et(j)))
 ydata(j) \= et(j) \- max(strobetime(strobetime \<\= et(j)));
 end
 end
 xdata \= et;
 gq.yData \= ydata;
 gq.fieldname \= 'strobe\_ton';
 gq.xField \= 'eti';
 gq.xData \= xdata;
 expt.addGlobalQuantity(gq);
 gq.fieldname \= 'strobe\_toff';
 expt.addGlobalQuantity(gq);
end

if (isfield(expt.metadata, 'ledNBitsOut') \|\| isfield(expt.metadata, 'ledNBytesOut'))
 \[p,f] \= fileparts(expt.fname);
 if (isfield(expt.metadata, 'ledNBitsOut'))
 nb \= expt.metadata.ledNBitsOut;
 fp \= expt.metadata.ledFP;
 ii \= fp \> 0 \& isfinite(nb ./ fp); 
 if (median(nb(ii)./fp(ii)) \< 4\) %byte output, not bit output
 expt.metadata.ledNBytesOut \= expt.metadata.ledNBitsOut;
 expt.metadata \= rmfield(expt.metadata, 'ledNBitsOut');
 end 
 end
 
 try
 createLedTablesFromBinFiles(expt);
% fname \= fullfile (p, \[f ' led values.bin']);
% if (exist(fname, 'file'))
% \[glt,gq] \= GlobalLookupTable.createLedTableFromBitFile(expt, fname, true); %true means add global quantities to experiment
% else
% fname \= fullfile (p, \[f ' sup data dir'], \[f ' led values.bin']);
% if (exist(fname, 'file'))
% \[glt,gq] \= GlobalLookupTable.createLedTableFromBitFile(expt, fname, true);
% else
% glt \= \[];
% end
% end
 catch me
 glt \= \[];
 disp (me.getReport());
 end
 %gqs already added
 %{
 if (\~isempty(glt))
 expt.addGlobalQuantity(glt);
 expt.addGlobalQuantity(gq);
 end
 %} 
end
 
end

function createLedTablesFromBinFiles(expt)
 \[p,f] \= fileparts(expt.fname);
 fend \= {' led values.bin', ' led1 values.bin', ' led2 values.bin', '@led1\.bin', '@led2\.bin'};
 gqname \= {'ledVal', 'led1Val','led2Val', 'led1Val','led2Val'};
 found \= false(size(gqname));
 for j \= 1:length(fend)
 fname \= fullfile (p, \[f fend{j}]);

 if (exist(fixFileNameWin(fname), 'file'))
 \[glt,gq] \= GlobalLookupTable.createLedTableFromBitFile(expt, fname, false); %true means add global quantities to experiment
 else
 sdd \= Experiment.findSuppDataDir(expt.fname);
 fname \= fullfile (sdd, \[f fend{j}]);
 if (\~isempty(sdd) \&\& exist(fixFileNameWin(fname), 'file'))
 \[glt,gq] \= GlobalLookupTable.createLedTableFromBitFile(expt, fname, false);
 else
 glt \= \[];
 end
 end
 if (\~isempty(glt))
 found(j) \= true;
 glt(1\).fieldname \= gqname{j};
 glt(2\).fieldname \= \[gqname{j} 'Deriv'];
 glt(3\).fieldname \= \[gqname{j} 'Diff'];
 gq(1\).fieldname \= gqname{j};
 gq(2\).fieldname \= \[gqname{j} 'Deriv'];
 gq(3\).fieldname \= \[gqname{j} 'Diff'];
 expt.addGlobalQuantity(glt);
 expt.addGlobalQuantity(gq);
 end
 end
 if (\~any(found))
 for j \= 1:length(fend)
 %relax rules for matching; see if there is anything with the right
 %ending in sup data dir
 sdd \= Experiment.findSuppDataDir(expt.fname);
 if (isempty(sdd))
 continue;
 end
 dd \= dir(fullfile(sdd, \['\*' fend{j}]));
 if (isempty(dd))
 continue;
 end
 if (length(dd) \=\= 1\)
 fname \= fullfile(sdd, dd.name);
 else
 names \= {dd.name};
 for n \= 1:length(f)
 match \= strncmpi(f, names, n);
 if (nnz(match) \=\= 1\)
 fname \= fullfile(sdd, dd(match).name);
 break;
 end
 if (nnz(match) \=\= 0\)
 warning ('expt:amd', \['multiple equally good/poor choices for ' fend{j} ' for: ' f]);
 continue;
 end
 end
 end
 \[glt,gq] \= GlobalLookupTable.createLedTableFromBitFile(expt, fname, false);
 if (\~isempty(glt))
 found(j) \= true;
 glt(1\).fieldname \= gqname{j};
 glt(2\).fieldname \= \[gqname{j} 'Deriv'];
 glt(3\).fieldname \= \[gqname{j} 'Diff'];
 gq(1\).fieldname \= gqname{j};
 gq(2\).fieldname \= \[gqname{j} 'Deriv'];
 gq(3\).fieldname \= \[gqname{j} 'Diff'];
 expt.addGlobalQuantity(glt);
 expt.addGlobalQuantity(gq);
 end
 
 end
 end
 if (\~any(found))
 warning('expt:amd', \[' can not find led value file for ' f]);
 end
 
 

end 
 

\-\-\-

\#\#\# File: Experiment.m (ID: @Experiment.22\)

%Experiment
%A set of tracks extracted from the same experiment
%Each experiment is loaded from a single .bin file created by the
%track extraction software


classdef Experiment \< handle
 %Experiment
 %A set of tracks extracted from the same experiment
 %Each experiment is loaded from a single .bin file created by the
 %track extraction software

 properties
 fname \= ''; %the name of the .bin file representing the experiment
 timfname \= ''; %the name of the timing file that tells when each frame happened
 camcalinfo \= \[]; %camera calibration information; not tested at the moment
 elapsedTime \= \[]; %the elapsed time from the start of the experiment for each frame
 %temperature \= \[]; %??? nix
 
 dr \= DerivationRules(); %rules for interpolating, smoothing, and differentiating
 so \= WormSegmentOptions(); %rules for segmenting tracks into runs \& reorientations
 globalQuantity \= \[]; %used to add extra information (e.g. light, temperature) to the tracks
 metadata \= \[]; %all fields loaded from mdat file
 globalLookupTable \= \[]; %like globalQuantity, but has a high resolution component as well
 
 savedTrackDir \= ''; %if tracks are saved to disk separately (for memory reasons), the absolute path of the directory containing those tracks
 savedTrackRelDir \= '';%if tracks are saved to disk separately (for memory reasons), the relative path from the directory where the expt file is found
 end
 properties (AbortSet \= true)
 track; %the set of tracks contained in the experiment; see Track, MaggotTrack
 end
 
 properties (Transient \= true)
 fid \= 0;
 end
 
 methods
 addtime (expt, timfname) %adds timing information to map frame number to seconds; should be done automatically on loading
 addJavaTime(expt, timfname);
 addGlobalQuantity(expt,varargin); %adds a global quantity (maps derived quantity, e.g. elapsed time) to another quantity (e.g. odor level)
 assignGlobalQuantities(expt,varargin); %assigns all global quantities to tracks; automatically called when quantity is added
 addStandardizedField(expt, fieldname, varargin); %standardized\_field \= (field \- mean(field))/std(field) on a track by track basis
 addTemperatureAdjustedSpeed (expt, varargin); %calculates mean speed vs. temp, then creates adjusted speed to take out linear contribution
 addAdjustedField(expt, field1, adjfield,varargin) %calculates mean adjfield vs. field1, then creates adjusted field to take out linear contribution
 addMetaDataFields(expt, timfname, varargin); %adds global quantities from meta data file (.mdat) 
 stitchTracks (expt, maxFrameInterval, maxDist, varargin); %stitches tracks together if they come from the same animal
 cleanTracks (expt, minFrames, minDist); %deprecated \- use ESetCleaner
 qvec \= gatherField(expt, fieldname, varargin); %gets all values of a fieldname
 qvec \= gatherFieldInTracks(expt, fieldname, tracknums, varargin)%gets all values of 'fieldname' for a subset of tracks in expt
 qvec \= gatherFromSubField(expt, subfield, fieldname, varargin); %gets all values of 'fieldname' from track parts (e.g. runs, reorientations)
 \[qv, datamatrix] \= averageFromSubField(expt, subfield, fieldname, centerpos, offsetinds, varargin); 
 
 qvec \= gatherSubField (expt, field, subfield, varargin); %gathers from a subfield of track; all track.(field).(subfield)
 \[pt, track, trackind, ptind] \= findNearestPoint (expt, x, y, varargin); %finds nearest point in the experiment to given point
 \[pt, track, trackind, ptind] \= findNearestPointAtTime(expt, loc, atTime, varargin) %finds nearest point in the experiment to given point within a small time and distance
 pt \= reloadPoint (expt, pt, varargin); %reloads a point from disk, including image, if any
 track2 \= reloadTrack(expt, track, varargin); %reloads a track from disk, including images, if any
 
 openDataFile(expt); %opens the data file the experiment was originally loaded from, for reading
 closeDataFile(expt); %closes the data file, if open
 calculateDerivedQuantity(expt, quantityNames, recalculate); %assigns experiments derivation rules to all tracks, then calculates derived quantity
 
 segmentTracks(expt, segmentOptions); %segments all tracks in experiment; rarely used (eset.executeTrackFunction('segmentTrack') is more typical call)
 varargout \= executeTrackFunction(expt, func, varargin); %executes the function func for all tracks in expt
 result \= evaluateTrackExpression(expt, expression); %evaluates the expression for all tracks in expt
 detectCollisions(expt, maxdist); %marks the iscollision field of each track if it comes too close to another track
 \[inds,why] \= detectPossibleSegmentationProblems(expt); %detects possible segmentation problems with maggot tracks (rarely used)
 im \= makeWholeFrameImage (expt, ind, varargin); %creates a mosaic image of all the individual point images for a frame
 
 %trimTracks cuts out any part of the track outside
 %min(timerange),max(timerange) and removes any part of the track
 %from the point the track leaves validrect until the end of the
 %track; leave timerange or validrect empty to disable
 trimTracks(expt, timerange, validrect); %removes parts of tracks
 
 %pruneTracks removes completely any track that starts outside
 %starttimerange in elapsedTime, as well as any track that starts
 %outside startrect; leave startttimerange or startrect empty to disable
 pruneTracks(expt, starttimerange, startrect); %removes entire tracks
 
 \[ps, f] \= powerSpectrum(expt, quantityName, timeInterval, varargin); %produces the power spectrum for a qiven measured/derived quantity
 \[xc, np, tx, nt] \= crosscorrelate (expt, fieldname1, fieldname2, varargin);%cross correlates fieldname1 and fieldname2
 \[ac, np, tx, nt] \= autocorrelate (expt, fieldname, varargin);%autocorrelates fieldname
 updateDerivationRules(expt, varargin);
 updateTrackSegmentationOptions(expt, varargin); % changes all tracks segmentation options to be the same as experiment's
 setTimingByFrameDifference(expt, deltaT, overrideExisting); %sets the elapsedTime to be 0:1:numFrames \* deltaT; another butt\-saver that shouldn't need to be used
 
 addTonToff(expt, fieldname, ramptype, varargin); %adds \_ton and \_toff global quantities for a given temporal global quantity
 
 toMWTFiles(expt, prefix, makeMultipleBlobsFile, varargin); %outputs files to be used in mwt choreography analysis
 makeMWTSummaryFile(expt, prefix, filenum, locInFile, varargin);
 
 es \= getExperimentStatistics(expt, varargin);
 im \= diagnosticImage (expt, foregroundIm, varargin);
 
 toMatFile(expt, varargin);
 
 loadTracksFromDir(expt, basedir, varargin);
 
 
 end
 
 methods %set methods
 function set.track(obj, value)
 if (\~isempty(value) \&\& isa (value, 'Track'))
 \[value.expt] \= deal(obj);
 end
 obj.track \= value;
 end
 
 end
 
 methods %constructor
 function expt \= Experiment(varargin)
 if (\~isempty(varargin) \&\& isa(varargin{1}, 'Experiment'))
 fn \= intersect(fieldnames(varargin{1}), fieldnames(expt));
 for j \= 1:length(fn)
 expt.(fn{j}) \= varargin{1}.(fn{j});
 end
 end
 end
 end
 
 
 
 methods(Static)
 function expt \= loadobj(expt) 
 expt.loadTracksFromDir();
 end
 function expt \= fromMatFile(fname)
 expt \= loadObjectTypeFromMatFile(fname, 'Experiment');
 expt.loadTracksFromDir(fileparts(fname));
 end
 \[expt, valid] \= fromFile (fname, timfname, loadContour, camcalinfo, minTrackLength)
 expt \= fromMWTFile (inputname, camcalinfo, varargin)
 \[ptType, valid] \= getPtType (fname)
 \[expt, valid] \= fromJava(jEx, fname, timfname, loadContour, camcalinfo, minTrackLength)
 \[type, valid] \= getJavaPtType(jEx,fname)
 sdd \= findSuppDataDir(exp\_fname)
 end
end


\-\-\-

\#\#\# File: addtime.m (ID: @Experiment.23\)

function addtime(expt, timfname, varargin)
%loads timing information to the file and adds it to all tracks
%function addtime(expt, timfname)
%experiment.addtime(timfname)
%
%outputs: none
%inputs:
%EXPT: a member of the Experiment class
%TIMFNAME: the filename of a .tim file
%
%each .tim file has 3 columns; only the first is used here
%column 1: elapsed time in ms. If the time wraps to 0, a jump of 65536 ms
%is assumed to have occurred (this is what mightex cameras do)
%column 2: number of triggers sent to the camera by this frame (ignored)
%column 3: time in seconds as recorded by the system at the time the pic
%was taken (ignored)
%
%alternately, a .mdat file with the header Mightex

fixedInterpTime \= \[];
varargin \= assignApplicable(varargin);

\[ps, fn] \= fileparts(expt.fname);
existsAndDefault('timfname', fullfile(ps, \[fn '.mdat']));
try 
 \[pathstr,name,ext] \= fileparts(timfname);
catch me
 disp(me.getReport);
 return;
end

if (strcmp(timfname, 'doNOTloadTIME'))
 return;
end
t \= \[];
ismdat \= false;
if (strcmpi (ext, '.mdat'))
 try 
 expt.metadata \= importdata2(timfname);
 col \= find(strcmpi(expt.metadata.colheaders, 'Mightex\_TimeStamp'), 1\);
 if (\~isempty(col))
 t \= expt.metadata.data(:,col);
 ismdat \= true;
 else
 try
 bufnum \= expt.metadata.bufnum;
 bufnum\_time \= expt.metadata.bufnum\_time;
 %col \= find(strcmpi(tempstruct.colheaders, 'bufnum'), 1\);
 %col2 \= find(strcmpi(tempstruct.colheaders, 'bufnum\_time'), 1\);
 tpf \= diff(bufnum\_time)./diff(bufnum); %time per frame
 tpm \= median(tpf(isfinite(tpf))); %median time per frame
 
 tvalid \= isfinite(tpf) \& tpf \> 0\.8 \* tpm \& tpf \< 1\.2 \* tpm; %reasonable times
 bn \= bufnum(tvalid);
 bnt \= bufnum\_time(tvalid);
 p \= polyfit(bn \- bn(1\), bnt\-bnt(1\) , 1\);
 tpm \= p(1\);
 
% tpm \= mean(tpf(isfinite(tpf) \& tpf \> 0\.8 \* tpm \& tpf \< 1\.2 \* tpm)); %mean of resonable time per frames
 t \= (bufnum \- bufnum(1\)) \* tpm;
 ismdat \= true;
 catch %\#ok
 t \= NaN;
 end
 
 if (nnz(\~isfinite(t)) \> 0\.01\*length(t))
 warning ('mdat file is corrupted \- check dat file; trying to use frame added time stamp');
 disp ('disabling advanced mdat features');
 ismdat \= false;
 t \= expt.metadata.frameAddedTimeStamp;
% col \= find(strcmpi(tempstruct.colheaders, 'FrameNumber'), 1\);
 % col2 \= find(strcmpi(tempstruct.colheaders, 'frameAddedTimeStamp'), 1\);
 % t \= tempstruct.data(:,col2\);
 
 if (nnz(\~isfinite(t)) \> 0\.01\*length(t))
 error ('mdat file is hopelessly corrupt \- use dat file');
 end
 t \= t \- t(find(isfinite(t), 1, 'first'));
 end
 
 end
 catch %\#ok
 timfname \= fullfile(pathstr, \[name '.tim']);
 ismdat \= false;
 t \= \[];
 end
 if (isempty(t)) 
 timfname \= fullfile(pathstr, \[name '.tim']);
 t \= \[];
 ismdat \= false;
 end
end



if (isempty(t))
 try 
 data \= load(timfname);
 if (isempty(data))
 disp (\['failed to load timing info from ' timfname]);
 return;
 end
 t \= data(:,1\);
 catch me
 disp(me.getReport());
 disp ('failed to load timing info \-\- use add time yourself before running any functions');
 return
 end
end

expt.timfname \= timfname;


ind \= find(diff(t) \< 0, 1, 'first');
while (\~isempty(ind))
 t((ind\+1\):end) \= t((ind\+1\):end) \+ 65536;
 ind \= find(diff(t) \< 0, 1, 'first');
end

inds \= find(diff(t) \< 1\);
if \~isempty(inds)
 t(inds\+1\) \= t(inds\+1\)\+1;
end

expt.elapsedTime \= (t \- t(1\)) / 1000;
if (isempty(fixedInterpTime))
 dt \= round(median(diff(t)))/1000; %take interpolation time to nearest ms
else
 dt \= fixedInterpTime;
end
expt.dr.interpTime \= dt;
\[expt.track.dr] \= deal(expt.dr);
indx \= (1:length(t)) \- 1;
for j \= 1:length(expt.track)
 expt.track(j).addTime (indx, expt.elapsedTime);
end
%{
% only for very old data; will be removed soon

if (exist('data', 'var') \&\& size(data,2\) \> 4\)
 et2 \= (data(:,5\) \- data(2,5\))/1000;
 \[et2,I] \= unique(et2\);
 et1 \= expt.elapsedTime;
 p \= polyfit(et2(100:end), et1(I(100:end)), 1\);
 et2 \= p(1\)\*et2 \+ p(2\);
 gq \= GlobalQuantity();
 gq.xField \= 'eti';
 gq.fieldname \= 'lightTarget';
 gq.xData \= et2';
 gq.yData \= data(I,4\)';
 expt.addGlobalQuantity(gq);
 dll \= deriv(gq.yData, 10\) ./ deriv(gq.xData, 10\);
 gq.yData \= dll;
 gq.fieldname \= 'dlightTarget';
 expt.addGlobalQuantity(gq);
 if (size(data,2\) \> 5\)
 gq.fieldname \= 'projOutput';
 gq.yData \= data(I,6\)';
 expt.addGlobalQuantity(gq);
 end
end

%}

if (ismdat)
 addMetaDataFields(expt);
% addMDatFields(expt, tempstruct, expt.elapsedTime);
end

%this function handled metadata from projector experiments \-\- should be
%moved in to addMetaDataFields, if anyone cares
function addMDatFields(expt, datastruct, timestampbyrow)

header \= {'CamTargetLightLevel', 'ProjOutputValue'};
gqname \= {'lightTarget', 'projOutput'};
derivPts \= \[4, 0];
for j \= 1:length(header)
 col \= find(strcmpi(datastruct.colheaders, header{j}), 1\);
 if (\~isempty(col))
 ydat \= datastruct.data(:,col);
 xdat \= timestampbyrow(isfinite(ydat));
 ydat \= ydat(isfinite(ydat));
 gq \= GlobalQuantity;
 gq.xField \= 'eti';
 gq.xData \= xdat;
 gq.yData \= ydat;
 gq.fieldname \= gqname{j};
 gq.derivationMethod \= @GlobalQuantity.oneDinterpolation;
 expt.addGlobalQuantity(gq);
 if (derivPts(j) \> 0\)
 gq.yData \= deriv(ydat, derivPts(j))./deriv(xdat, derivPts(j));
 gq.fieldname \= \['d' gqname{j}];
 expt.addGlobalQuantity(gq);
 end
 end
end

addMetaDataFields(expt);
 
\-\-\-

\#\#\# File: getPtType.m (ID: @Experiment.24\)

function \[ptType, valid] \= getPtType (fname)
%loads an experiment from a bin file
%\[expt, valid] \= fromFile (fname, timfname, loadContour, camcalinfo, minTrackLength)
%this is a static method of the Experiment class (Experiment.fromFile)
%
%outputs: 
%EXPT, a member of the experiment class
%VALID, whether the experiment loaded without errors
%inputs:
%FNAME: name of .bin file to load
%TIMFNAME: timining information file (.tim);
% default: change extension of fname to .tim
%LOADCONTOUR: whether to load the contour if this is a maggot track:
% default TRUE
%CAMCALINFO: camera calibration struct (ask Marc); pass empty (\[]) to ignore
% default: \[]
%MINTRACKLENGTH: minimum length of a track (in points) to load from disk
% default: 1
tic
try 
 
 valid \= true;
 
 
 
 fid \= fopen(fname, 'r');
 code \= fread(fid, 1, 'int32');
 fclose(fid);
 
 switch (bitshift(code, \-16\))
 case 1
 ptType \= TrackPoint();
 case 2
 ptType \= ImTrackPoint();
 case 3
 ptType \= OldMaggotTrackPoint();
 
 case 4
 ptType \= MaggotTrackPoint();
 
 otherwise
 disp('invalid code: I don''t know what kind of point I''m loading');
 ptType \= \[];
 valid \= false;
 
 end
catch me
 
 disp(me.getReport());
 valid \= false;
 ptType \= \[];
 if (exist('fid', 'var'))
 fclose(fid);
 end
end
 
\-\-\-

\#\#\# File: pruneTracks.m (ID: @Experiment.25\)

function pruneTracks(expt, starttimerange, startrect)
%delete tracks that start outside designated ranges
%function pruneTracks(expt, starttimerange, startrect)
%
%outputs: none
%inputs:
%EXPT: a member of the Experiment class
%STARTTIMERANGE: \[t0 t1], the range of valid start times
%STARTRECT: \[x0 y0 x1 y1], the space of valid start positions
%pruneTracks removes completely any track that starts outside
%STARTTIMERANGE in elapsedTime, as well as any track that starts
%outside STARTRECT; leave STARTTIMERANGE or STARTRECT empty to disable
 
if (length(expt) \> 1\)
 for j \= 1:length(expt)
 expt(j).pruneTracks(starttimerange, startrect);
 end
 
return;
end
starttime \= transpose(expt.elapsedTime(\[expt.track.startFrame]\+1\));

startloc \= zeros(\[2 length(expt.track)]);
for j \= 1:length(expt.track)
 startloc(:,j) \= expt.track(j).pt(1\).loc;
end

valid \= true(size(expt.track));
if (exist('starttimerange','var') \&\& \~isempty(starttimerange))
 valid \= starttime \>\= min(starttimerange) \& starttime \<\= max(starttimerange);
end

if (exist('startrect', 'var') \&\& \~isempty(startrect))
 valid \= valid \& startloc(1,:) \>\= startrect(1\) \& startloc(1,:) \<\= startrect(3\) \& ...
 startloc(2,:) \>\= startrect(2\) \& startloc(2,:) \<\= startrect(4\);
end

expt.track \= expt.track(valid);

 
\-\-\-

\#\#\# File: getExperimentStatistics.m (ID: @Experiment.26\)

function es \= getExperimentStatistics(expt, varargin)
if (length(expt) \> 1\)
 for j \= 1:length(eset)
 es(j) \= getExperimentStatistics(expt(j), varargin{:}); %\#ok
 end
 return;
end


eti \= expt.gatherField('eti');
timerange \= \[min(eti)\-1 max(eti)\+1];
es.timerange \= timerange;

it \= expt.gatherSubField('dr','interpTime');
dt \= median(it);
if (any(it \~\= dt))
 disp (\['warning: eset does not have homogenous interpolation times, instead range from ' num2str(min(it)) ' to ' num2str(max(it))]);
end


eet \= expt.gatherField('eti');

es.numAnimals \= max(histc(eet, min(eet):(100\*dt):max(eet)))/100;
tx \= min(eet):30:max(eet);
h \= hist(eet, tx);
\[\~,I] \= max(h);


sl \= expt.gatherField('spineLength', 'mean');
st \= expt.evaluateTrackExpression('min(track.getDerivedQuantity(''eti''))');
et \= expt.evaluateTrackExpression('max(track.getDerivedQuantity(''eti''))');
es.spineLength \= sl(st \<\= tx(I) \& et \> tx(I) \& et\-st \> 30\);



es.animalTime \= length(expt.gatherField('eti'))\*dt;

es.numruns \= length(\[expt.track.run]);
es.numturns \= nnz(expt.gatherSubField('reorientation', 'numHS') \> 0\);
es.numpauses \= nnz(expt.gatherSubField('reorientation', 'numHS') \=\= 0\);

\-\-\-

\#\#\# File: addGlobalQuantity.m (ID: @Experiment.27\)

function addGlobalQuantity(expt,varargin)
%adds globalQuantity to list of quantities experiment is keeping track of
%function addGlobalQuantity(expt,varargin)
%
%expt.addGlobalQuantity(globalQuantity)
%expt.addGlobalQuantity(xfieldname, newfieldname, xdata, ydata)
%expt.addGlobalQuantity(xfieldname, newfieldname, xdata, ydata, method)
%
%adds globalQuantity to list of quantities experiment is keeping track of
%(or creates a new global quantity from input params), then assigns values
%to tracks
%
%outputs: none
%inputs:
%EXPT: a member of the Experiment class 
%GLOBALQUANTITY: a GlobalQuantity created and defined elsewhere (see
%GlobalQuantity)
%or
%XFIELDNAME: the name of the field on which the global quantity depends
% for instance, if the temperature is varying with time, xfieldname would
% be 'eti'
% if light intensity is a function of space, xfieldname might be 'sloc'
%NEWFIELDNAME: the name of the new field created, e.g. 'lightIntensity'
%XDATA: the values of xfieldname over which the new field function is
% defined.
% for instance if the temperature was measured every second, xdata
% would be 0:1:lastTime
%YDATA: the values of the new field at each point specified by xdata
%METHOD: a function of the form
% yfield \= METHOD (xfield, xData, yData); see GlobalQuanity for
% details
if isempty(varargin)
 warning('GERSHOW:AGC01', 'You have to pass something to addGlobalQuantity');
 return;
end

if (length(expt) \> 1\)
 for j \= 1:length(expt)
 expt(j).addGlobalQuantity(varargin{:});
 end
 return;
end

if isa(varargin{1}, 'GlobalQuantity')
 gq \= varargin{1};
else
 gq \= GlobalQuantity;
 fieldlist \= {'xField','fieldname','xData','yData','derivationMethod'};
 n \= min(length(fieldlist), length(varargin));
 if (n \< 4\)
 warning('GERSHOW:AGC01', 'I need at least 4 arguments to create a new GQ');
 return;
 end
 for j \= 1:n
 gq.(fieldlist{j}) \= varargin{j};
 end
end

if (length(gq) \> 1\)
 for j \= 1:length(gq)
 expt.addGlobalQuantity(gq(j));
 end
 return;
end

if (isa(gq, 'GlobalLookupTable'))
 if (isempty(expt.globalLookupTable))
 expt.globalLookupTable \= gq;
 else
 ind \= find(strcmpi(gq.fieldname, {expt.globalLookupTable.fieldname}));
 if (isempty(ind)) 
 expt.globalLookupTable \= \[expt.globalLookupTable gq];
 else
 expt.globalLookupTable(ind) \= gq;
 end
 end
 % gq.addQuantityToTrack(expt.track);
 return;
end

if (isempty(expt.globalQuantity))
 expt.globalQuantity \= gq;
else
 ind \= find(strcmpi(gq.fieldname, {expt.globalQuantity.fieldname}));
 if (isempty(ind)) 
 expt.globalQuantity \= \[expt.globalQuantity gq];
 else
 expt.globalQuantity(ind) \= gq;
 end
end

for j \= 1:length(expt.track)
 gq.addQuantityToTrack(expt.track(j));
end

\-\-\-

\#\#\# File: assignGlobalQuantities.m (ID: @Experiment.28\)

function assignGlobalQuantities(expt,varargin)
%reassigns all tracked global quantities to all tracks
%function assignGlobalQuantities(expt,varargin)
%expt.assignGlobalQuantities
%
%reassigns all tracked global quantities (see expt.globalQuantity)
%to all tracks
if (length(expt) \> 1\)
 for k \= 1:length(expt)
 expt(k).assignGlobalQuantities;
 end
 return;
end

for k \= 1:length(expt.globalQuantity);
 gq \= expt.globalQuantity(k);
 for j \= 1:length(expt.track)
 gq.addQuantityToTrack(expt.track(j));
 end
end

%{
for k \= 1:length(expt.globalLookupTable);
 gq \= expt.globalLookupTable(k);
 for j \= 1:length(expt.track)
 gq.addQuantityToTrack(expt.track(j));
 end
end
%}
\-\-\-

\#\#\# File: detectPossibleSegmentationProblems.m (ID: @Experiment.29\)

function \[inds,why] \= detectPossibleSegmentationProblems(expt)
%look for possible problems with the segmentation of various tracks
%function \[inds,why] \= detectPossibleSegmentationProblems(expt)
%
%we look for possible problems with the segmentation of various tracks
%signs of problems
%mean(speed) \< start\_speed\_cut
%less than 50% of points are in runs
%mean run time is less than 50% of mean run time for experiment as a whole
%
%outputs:
%INDS: the indices of problem tracks
%WHY: a string indicating the problem found for each problem track
%inputs:
%EXPT: a member of the experiment class

k \= 1;
mrt \= mean(expt.gatherSubField('run', 'runTime'));
inds \= \[];
for j \= 1:length(expt.track)
 if (mean(expt.track(j).getDerivedQuantity(expt.track(j).so.speed\_field)) \< expt.track(j).so.start\_speed\_cut)
 inds(k) \= j;
 why{k} \= 'slow';
 k \= k\+1;
 continue;
 end
 if (sum(expt.track(j).isrun \~\= 0\) \< 0\.5 \* length(expt.track(j).isrun))
 inds(k) \= j;
 why{k} \= 'few points in run';
 k \= k\+1;
 continue% semicolon here?
 end
 if (mean(\[expt.track(j).run.runTime]) \< 0\.5 \* mrt)
 inds(k) \= j;
 why{k} \= 'runs are short';
 continue;
 end
end
if (\~exist('why','var'))
 why \= 'you are so damn sexy, you don''t have any problems';
end


\-\-\-

\#\#\# File: loadTracksFromDir.m (ID: @Experiment.30\)

function loadTracksFromDir(expt, basedir, varargin)
% function loadTracksFromDir(expt, basedir, varargin)
%
% loads tracks that were saved separately, only if expt.track is empty or 
% optional arg 'overwrite',true or 'append',true is passed
%
% basedir is used only if expt.savedTrackDir does not exist
overwrite \= false;
append \= false;
existsAndDefault('basedir', '');
varargin \= assignApplicable(varargin);

if (\~isempty(expt.track) \&\& \~(append \|\| overwrite))
 return;
end

if isdir(fixFileNameWin(expt.savedTrackDir))
 trackdir \= expt.savedTrackDir;
else
 if \~isempty(basedir)
 trackdir \= fullfile(basedir, expt.savedTrackRelDir);
 else
 return;
 end
end

dd \= dir(fullfile(fixFileNameWin(trackdir), '\*.mat'));

if (isempty(dd))
 return;
end

for j \= 1:length(dd)
 temp \= Track.fromMatFile(fixFileNameWin(fullfile(trackdir, dd(j).name)));
 if (isempty(temp))
 continue;
 end
 if (\~exist('track', 'var'))
 track \= temp;
 else
 try
 track \= \[track temp]; %\#ok
 catch me
 disp (me.getReport());
 error ('track concatenation failed \- incompatible types?');
 end
 end
end

if (\~exist('track', 'var'))
 return;
end

if (append)
 try %\#ok
 expt.track \= \[expt.track track];
 catch me
 disp (me.getReport());
 error ('track concatenation failed \- incompatible types?');
 end
else
 expt.track \= track;
end
\-\-\-

\#\#\# File: addStandardizedField.m (ID: @Experiment.31\)

function addStandardizedField(expt, fieldname, varargin)
% creates a standardized field for a given quantity
% function addStandardizedField(expt, fieldname, varargin)
%
% if x(j) is the value of the field then 
% standardized\_x(j) \= (x(j) \- ) / std(x), where the mean and standard
% deviation are taken across the whole experiment
if (length(expt) \> 1\)
 for j \= 1:length(expt)
 expt(j).addStandardizedField(fieldname, varargin{:});
 end
 return;
end

if (iscell(fieldname))
 for j \= 1:length(fieldname)
 expt.addStandardizedField(fieldname{j}, varargin{:});
 end
 return;
end

newfieldname \= \['standardized\_' fieldname];
qv \= (expt.gatherField(fieldname));
meanf \= mean(qv);
stdf \= std(qv);

gq \= GlobalQuantity();
gq.xField \= fieldname;
gq.fieldname \= newfieldname;
gq.xData \= meanf;
gq.yData \= stdf;
gq.derivationMethod \= @(xin, xData, yData) (xin \- xData)./yData;

expt.addGlobalQuantity(gq);

end


\-\-\-

\#\#\# File: makeMWTSummaryFile.m (ID: @Experiment.32\)

Could not read file: 'utf\-8' codec can't decode byte 0x93 in position 1679: invalid start byte

\-\-\-

\#\#\# File: addTonToff.m (ID: @Experiment.33\)

function addTonToff(expt, fieldname, ramptype, varargin)
% takes a cyclic quantity and derives a cyclic time that defines time since
% quantity onset/offset
% addTonToff(expt, fieldname, ramptype, varargin);
% 
% outputs: none
% inputs:
% EXPT \< Experiment
% FIELDNAME \- name of cyclic field
% RAMPTYPE \- type of waveform (square, triangle, etc.)
% see globalQuantity/timeOnOffGQs
% optional args: see globalQuantity/timeOnOffGQs


if (length(expt) \> 1\)
 for j \= 1:length(expt)
 expt(j).addTonToff(fieldname, ramptype, varargin{:});
 end
 return
end

ind \= find(strcmpi(fieldname, {expt.globalQuantity.fieldname}));
if (isempty(ind))
 disp (\['could not find global quantity named ' fieldname]);
 return;
end

if (length(ind) \> 1\)
 ind \= find(strcmp(fieldname, {expt.globalQuantity.fieldname}));
end

if (isempty(ind))
 disp (\['found more than one case\-insensitive match, but no exact matches for fieldname ' fieldname]);
 return;
end

if (length(ind) \> 1\)
 disp (\['found two global quantities with same name: ', fieldname]);
 return;
end

gqs \= expt.globalQuantity(ind).timeOnOffGQs(ramptype, varargin);

for j \= 1:length(gqs)
 expt.addGlobalQuantity(gqs(j));
end

\-\-\-

\#\#\# File: gatherFieldInTracks.m (ID: @Experiment.34\)

function qvec \= gatherFieldInTracks(expt, fieldname, tracknums, varargin)
%gets all values of 'fieldname' for a subset of tracks in expt
%function qvec \= gatherFieldInTracks(expt, fieldname, tracknums, varargin)
%outputs: 
%QVEC: a kxN array of values, where N is the total number of points
% and k is the dimension of the values of fieldname
%
%inputs: 
%EXPT: a member of the Experiment class
%FIELDNAME: either a property of the Track/MaggotTrack/etc. in EXPT or
% a fieldname that can be passed to Track/getDerivedQuantity
%TRACKNUMS: the indices of tracks from which to gather field
%VARARGIN: if fieldname is passed to getDerivedQuantity, VARARGIN{:}
% is also passed, so any valid arguments to getDerivedQuantity can be
% appended here
% e.g. add 'runs', 'reorientations', 'headswings' to get field just in
% runs/reos/hs

if (any(strcmp(fieldname, fieldnames(expt.track(1\)))))
 qvec \= \[expt.track(tracknums).(fieldname)];
else 
 qvec \= \[];
 for j \= tracknums;
 qvec \= \[qvec expt.track(j).getDerivedQuantity(fieldname, false, varargin{:})];
 if (isempty(qvec))
 break;
 end
 end
end
\-\-\-

\#\#\# File: gatherFromSubField.m (ID: @Experiment.35\)

function qvec \= gatherFromSubField(expt, subfield, fieldname, varargin)
%gathers fieldname from sections of track that are part of subfield
%function qvec \= gatherFromSubField(expt, subfield, fieldname, varargin)
%
%gets derived quantity fieldname from subfield by calling
%track.getSubFieldDQ(subfield, fieldname, varargin)
%
%see Track.getSubFieldDQ and 
% TrackPart.getDerivedQuantity for optional params

 qvec \= \[];
 for j \= 1:length(expt.track)
 qvec \= \[qvec expt.track(j).getSubFieldDQ(subfield, fieldname, varargin{:})]; %removed false between fieldname and varargin
 %{
 if (isempty(qvec))
 break;
 end
 %} 
 %removed by MHG 8/23/2010 \- don't know what purpose this served
 end
 
 
\-\-\-

\#\#\# File: trimTracks.m (ID: @Experiment.36\)

function trimTracks(expt, timerange, validrect)
%removes bad parts of tracks
%function trimTracks(expt, timerange, validrect)
%
%inputs:
%EXPT: a member of the Experiment class
%TIMERANGE: \[t0 t1], the range of times (seconds)
%VALIDRECT: \[x0 y0 x1 y1], the space of valid positions
%
%trimTracks cuts out any part of the track outside
%min(timerange),max(timerange) and removes any part of the track
%from the point the track leaves validrect until the end of the
%track; leave timerange or validrect empty to disable
if (isempty(timerange) \&\& isempty(validrect))
 return;
end
rval \= expt.executeTrackFunction('trim', timerange, validrect);
if (iscell(rval))
 todelete \= cell2mat(rval);
else
 todelete \= rval;
end

expt.track \= expt.track(\~todelete);

if (all(todelete))
 warning ('trim tracks deleted all tracks')
 disp (\['fname \= ' expt.fname]);
 timerange
 validrect
 return;
end
 
minpts \= (expt.track(1\).dr.derivTime \+ expt.track(1\).dr.smoothTime) / expt.track(1\).dr.interpTime \+ 1;
expt.track \= expt.track(\[expt.track.npts] \> minpts);

expt.executeTrackFunction('recalculateDerivedQuantities');
expt.assignGlobalQuantities();
\-\-\-

\#\#\# File: segmentTracks.m (ID: @Experiment.37\)

function segmentTracks(expt, segmentOptions)
%segments tracks into runs and reorientation by calling Track.segmentTrack
%function segmentTracks(expt, segmentOptions)
%
%ouputs: none
%inputs: 
%EXPT: a member of the Experiment class
%SEGMENTOPTIONS: (optional), the segment options to be applied to every
% track. If empty, the track's segmentation options (not the
% experiment's) are used. Thus, to use the experiment's default
% segmentation options, expt.segmentTracks(expt.so)

if (existsAndDefault('segmentOptions', \[]))
 expt.so \= segmentOptions;
end

expt.executeTrackFunction('segmentTrack', segmentOptions);
\-\-\-

\#\#\# File: fromJava.m (ID: @Experiment.38\)

function \[expt, valid] \= fromJava(jEx, fname, timfname, loadContour, camcalinfo, minTrackLength)
% Replacement for Experiment.fromFile;
% Opens \[JavaTrackExtraction.Experiment jEx]\<\-FILENAME
% Converts jEx to \[Experiment ex] that is consistent with the experiments
% loaded with Ex.fromFile

% NOTE: See C:\\Users\\Natalie\\Documents\\GitHub\\Matlab\-Track\-Analysis\\@Experiment\\fromFile.m
% for processing messages

debug \= true;

try 
 
 % Set flags/parameters for later processing
 if (\~exist ('loadContour', 'var') \|\| isempty ('loadContour'))
 loadContour \= true;
 end
 if (\~exist ('camcalinfo', 'var')) 
 camcalinfo \= \[];
 end
 if (\~exist ('minTrackLength', 'var') \|\| isempty(minTrackLength))
 minTrackLength \= 1;
 end
 
% disp('\~\~\~\~\~\~\~\~\~ Experiment.fromJava \~\~\~\~\~\~\~\~\~');
 
 % Create the experiment
% disp('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');
% disp(\['Processing jav\-\>mat: ' fname]);
% disp('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');
 expt \= Experiment();
 valid \= true;
 % set file name
 expt.fname \= fname;
 % set camcalinfo
 expt.camcalinfo \= camcalinfo;

 %...Not checking whether or not fname is a MWTTrack

 % Determine number of tracks nTracks
 %%%nTracks \= jEx.getNumTracks;
 nTracks \= javaMethod('getNumTracks','TrackExtractionJava.Experiment',fname);
 
 % Determine point type \& allocate track array
 % \~\~ 3 LTP(\=BTP) \~\~ 2 MTP \~\~ 1 ITP \~\~ 0 TP
 %%%typeCode \= jEx.getTypeCode;
 typeCode \= javaMethod('getPointType','TrackExtractionJava.Experiment',fname);
 switch(typeCode)
 case 3
 ptType \= LarvaTrackPoint();
 tracks(nTracks) \= LarvaTrack();
 case 2
 ptType \= MaggotTrackPoint();
 tracks(nTracks) \= MaggotTrack();
 case 1
 ptType \= ImTrackPoint();
 tracks(nTracks) \= Track();
 case 0
 ptType \= TrackPoint;
 tracks(nTracks) \= Track();
 otherwise
 disp('Invalid point type code');
 valid \= false;
 \[ppp, fff] \= fileparts(fname);
 fidd \= fopen(fullfile(ppp, \[fff '.bad']),'wt');
 fprintf(fidd, 'invalid code: I don''t know what kind of point I''m loading\\n');
 fclose(fidd);
 return;
 end

 
% nPts \= 0;
% for i\=0:(nTracks\-1\)
% t \= javaMethod('getTrack', 'TrackExtractionJava.Experiment', i,fname);
% nPts \= nPts \+ t.getNumPoints();
% end
 % Loop over tracks
 disp(\['Loading ' int2str(nTracks) ' tracks...']);% (' int2str(nPts) ' pts)
 ts \= tic; 
 ptsLastLoaded \= 0;
 lastelapsed \= 0;
 reportEvery \= 60;
 for i \= 0:(nTracks\-1\)
 % \~\~ Display processing messages
 elapsed \= toc(ts);
 if (elapsed \- lastelapsed \> reportEvery)
 ptsPerMin \= (60\.0\*ptsLastLoaded)/(elapsed \- lastelapsed);
 lastelapsed \= elapsed;
 disp (\[num2str(elapsed) 's: ' num2str(i) '/' num2str(nTracks) ' tracks (' int2str(ptsPerMin) ' pts/min)']);
 ptsLastLoaded\=0;
 end
 % \~\~ Add track TrackFromJava(jTrack(i))
 disp(\['track ' num2str(i)]);
 jTr \= javaMethod('getTrack', 'TrackExtractionJava.Experiment', i,fname);
 tracks(i\+1\) \= Track.fromJava(jTr, ptType, i, \[], loadContour, camcalinfo, minTrackLength);
 ptsLastLoaded \= ptsLastLoaded \+ jTr.getNumPoints();
 %%%tracks(i\+1\) \= Track.fromJava(jEx.getTrackFromInd(int32(i)), ptType, i, \[], loadContour, camcalinfo, minTrackLength);
 end
 disp(\['...done loading tracks (' int2str(toc(ts)) 'sec)']);
 
 % Show a report (or don't)
 showReport \= false;
 if (showReport)
 semilogy (0:10:max(\[tracks.npts]), hist(\[tracks.npts], 0:10:max(\[tracks.npts])), 'b\-'); hold on;
 title ('distribution of track length in frames');
 end
 
 disp('Tidying \& bookkeeping...');
 
 % Remove short tracks
 expt.track \= tracks(\[tracks.npts] \> minTrackLength);
 % Again, show a report (or don't)
 if (showReport)
 semilogy (0:10:max(\[expt.track.npts]), hist(\[expt.track.npts], 0:10:max(\[expt.track.npts])), 'r\-'); hold off;
 legend ('pre trim', 'post trim');
 end
 
 % Assign ex to all track.ex's
 \[expt.track.expt] \= deal(expt);
 
 disp('...done');
 
 if (debug)
 try
 expt.toMatFile('extradir', 'noTime');
 catch
 disp('error saving expt (pre\-timing info)')
 end
 end
 
 % Add timing info
 try
 disp ('Adding timing info...')
 expt.addtime(timfname);
 %expt.addtime(timfname);
 disp('...done adding timing info')
 catch e
 disp(e.getReport());
 disp('...done adding timing info')
 end

catch me
 valid \= false;
 \[ppp, fff] \= fileparts(fname);
 fidd \= fopen(fullfile(ppp, \[fff '.bad']),'wt');
 fprintf(fidd, me.getReport());
 fclose(fidd);
 rethrow(me);
end
% disp('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');
% disp(\['Done processing jav\-\>mat: ' fname]);
% disp('\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*');
end
\-\-\-

\#\#\# File: evaluateTrackExpression.m (ID: @Experiment.39\)

function result \= evaluateTrackExpression(expt, expression)
%evaluates the expression for each track in experiment
%function result \= evaluateTrackExpression(expt, expression)
%
%evaluates the expression for each track in experiment
%expression should use 'track' as the name of the track
%and 'expt' as the name of the experiment
%
%examples:
%to get the number of runs in each track
%numruns \= expt.evaluateTrackExpression('length(track.run)');
%
%to set all the segmentation options to a default value
%expt.evaluateTrackExpression('track.so \= expt.so');
%
%result is returned as a matrix if possible, otherwise as a cell
%
%outputs:
%RESULT: optional; the result of the expression for each track
% asking for an output from an expression that doesn't produce one
% will result in errors
%inputs:
%EXPT: a member of the experiment class
%EXPRESSION: the expression to evaluate

for j \= 1:length(expt.track)
 track \= expt.track(j); %\#ok
 if (nargout \> 0\)
 mycell{j} \= eval(expression); %\#ok
 else
 eval(expression);
 end
end

if (nargout \> 0\)
 try 
 result \= cell2mat(mycell);
 catch me
 result \= mycell;
 end
end
\-\-\-

\#\#\# File: autocorrelate.m (ID: @Experiment.40\)

function \[ac, np, tx, nt] \= autocorrelate (expt, fieldname, varargin)
%finds the autocorrelation of a field with itself
%function \[ac, np, tx, nt] \= autocorrelate (expt, fieldname, varargin)
%
%
%auto correlates track field (see Track.crosscorrelate)
%
%outputs:
%AC is the unnormalized auto\-correlation (normalized is xc./np)
%TX is the time axis for the cross correlation
%NP is the number of points contributing to a certain bin
%NT is the number of tracks contributing to a certain bin
%
%we define the auto\-correlation to be
%ac(T) \= ; 0 denotes the average
%AC is the return 1xN vector AC(j) \= AC(j\-1\);
%
%inputs:
%EXPT: a member of the Experiment class
%FIELDNAME: the name of the field to auto\-correlate
%VARARGIN: any parameter/value pair passed to Track/crosscorrelate, see
%below
%
%arguments to pass in:
%'row', row number(s)
%if row \= m, just finds the correlation of track.dq.(fieldnames)(m,:)\\
%'inRuns', true/false
%if inRuns is true, we take the autocorrelation over the whole track, but
%first interpolate the fields over only the run indices
%this is useful if the fields are ill\-defined between runs (e.g. velocity
%direction)
%'withinRuns', true/false
%if withinRuns is true, we find the correlation only within each run
%'isangle', true/false
% if isangle is true, then we compute the correlation as cos (theta1 \-
% theta2\) instead of as theta1\*theta2
%'timerange', \[mintime maxtime] \-\- only consider data from this time range


\[xc,np,tx,nt] \= expt.crosscorrelate(fieldname, fieldname, varargin{:});
N \= (length(xc) \+ 1\) / 2;
ac \= xc(N:end);
np \= np(N:end);
tx \= tx(N:end);
nt \= nt(N:end);
\-\-\-

\#\#\# File: fromFile.m (ID: @Experiment.41\)

function \[af, valid] \= fromFile (fname, timfname, loadContour, camcalinfo, minTrackLength)
%loads an experiment from a bin file
%\[expt, valid] \= fromFile (fname, timfname, loadContour, camcalinfo, minTrackLength)
%this is a static method of the Experiment class (Experiment.fromFile)
%
%outputs: 
%EXPT, a member of the experiment class
%VALID, whether the experiment loaded without errors
%inputs:
%FNAME: name of .bin file to load
%TIMFNAME: timining information file (.tim);
% default: change extension of fname to .tim
%LOADCONTOUR: whether to load the contour if this is a maggot track:
% default TRUE
%CAMCALINFO: camera calibration struct (ask Marc); pass empty (\[]) to ignore
% default: \[]
%MINTRACKLENGTH: minimum length of a track (in points) to load from disk
% default: 1
tic

if (\~iscell(fname))
 \[\~,\~,ext] \= fileparts(fname);
 if strcmpi (ext, '.jav')
 \[af, valid] \= fromJava(\[], fname, timfname, loadContour, camcalinfo, minTrackLength);
 return;
 end
end

try 
 
valid \= true;
if (\~exist ('loadContour', 'var') \|\| isempty ('loadContour'))
 loadContour \= true;
end

if (\~exist ('camcalinfo', 'var')) 
 camcalinfo \= \[];
end

if (\~exist ('minTrackLength', 'var') \|\| isempty(minTrackLength))
 minTrackLength \= 1;
end

af \= Experiment();

af.fname \= fname;
af.camcalinfo \= camcalinfo;
if (iscell(fname))
 \[\~,\~,ext] \= fileparts(fname{1});
else
 \[\~,\~,ext] \= fileparts(fname);
end

if (strcmpi (ext, '.blob') \|\| strcmpi (ext, '.blobs'))
 af.track \= MWTTrack.fromFile(fname, camcalinfo);
 
 return;
end
if (iscell(fname))
 error ('multiple file names only supported for MWT blob(s) files');
end


d \= dir(fname);
totalsize \= d.bytes;

fid \= fopen(fname, 'r');
code \= fread(fid, 1, 'int32');
disp (\['code \= ' num2str(code, '%x')]);

switch (bitshift(code, \-16\))
 case 1
 ptType \= TrackPoint();
 case 2
 ptType \= ImTrackPoint();
 case 3
 ptType \= OldMaggotTrackPoint();
 af.so \= MaggotSegmentOptions();
 %af.dr.smoothTime \= 1;
 case 4
 ptType \= MaggotTrackPoint();
 af.so \= MaggotSegmentOptions();
 otherwise
 disp('invalid code: I don''t know what kind of point I''m loading');
 af \= repmat(af, 0\);
 valid \= false;
 \[ppp, fff] \= fileparts(fname);
 fidd \= fopen(fullfile(ppp, \[fff '.bad']),'wt');
 fprintf(fidd, 'invalid code: I don''t know what kind of point I''m loading\\n');
 fclose(fidd);
 return
end 


ntracks \= fread(fid, 1, 'int32');
if (isa(ptType, 'MaggotTrackPoint'))
 bob \= repmat(MaggotTrack(), \[1 ntracks]);
else
 bob \= repmat(WormTrack(), \[1 ntracks]);
end
%af.track \= repmat(Track(), \[1 ntracks]);
ts \= tic;
lastelapsed \= 0;
reportEvery \= 60;
for j \= 1:ntracks
 elapsed \= toc(ts);
 if (elapsed \- lastelapsed \> reportEvery)
 lastelapsed \= elapsed;
 disp (\[num2str(elapsed) 's: ' num2str(ftell(fid)) '/' num2str(totalsize) ' bytes (' num2str(100\*ftell(fid)/totalsize, 2\) '%) loaded' ...
 num2str(elapsed\*(totalsize \- ftell(fid))/ftell(fid)) ' s remain']);
 end
 bob(j) \= Track.fromFile(fid, ptType, \[], loadContour, camcalinfo, minTrackLength);
 if (mod(j,100\) \=\= 0\)
 % toc(ts);
 end
end
%disp('now you have to wait, because matlab is slow and sucks nuts');
%ts \= tic;

%modified by MHG 03/17 to show report
showReport \= false;
if (showReport)
 semilogy (0:10:max(\[bob.npts]), hist(\[bob.npts], 0:10:max(\[bob.npts])), 'b\-'); hold on;
 title ('distribution of track length in frames');
end
af.track \= bob(\[bob.npts] \> minTrackLength);

if (showReport)
 semilogy (0:10:max(\[af.track.npts]), hist(\[af.track.npts], 0:10:max(\[af.track.npts])), 'r\-'); hold off;
 legend ('pre trim', 'post trim');
end
%toc(ts);

\[af.track.expt] \= deal(af);

fclose(fid);

disp('adding timing information'); 

try
 af.addtime(timfname);
catch me
 disp(me.getReport());
end
toc(ts)

catch me
 %af \= repmat(af, 0\);
 valid \= false;
 \[ppp, fff] \= fileparts(fname);
 fidd \= fopen(fullfile(ppp, \[fff '.bad']),'wt');
 fprintf(fidd, me.getReport());
 fclose(fidd);
 rethrow(me);
end
 
\-\-\-

\#\#\# File: diagnosticImage.m (ID: @Experiment.42\)

function diagIm \= diagnosticImage (expt, foregroundIm, varargin)

cc \= expt.camcalinfo;
if \~existsAndDefault('foregroundIm', \[]);
 \[dr, n] \= fileparts(expt.fname);
 d \= dir(fullfile(dr, \[n(1:end\-1\) '\*.bmp']));
 
 if (isempty(d))
 warning( \['Could not find foreground image corresponding to: ' expt.fname]);
 diagIm \= \[];
 return;
 end
 im \= double(imread(fullfile(dr, d(1\).name)));
else
 if (ischar(foregroundIm))
 im \= double(imread(foregroundIm));
 else
 im \= foregroundIm;
 end
end
pts \= expt.gatherField('iloc');
ipts \= round(cc.camPtsFromRealPts(pts));
ipts \= ipts(:, ipts(1,:) \>\= 1 \& ipts(1,:) \<\= size(im,2\) \& ipts(2,:) \>\= 1 \& ipts(2,:) \<\= size(im,1\));
inds \= sub2ind(size(im), ipts(2,:), ipts(1,:));
ispath \= zeros(size(im));
ispath(inds) \= 1;
ispath \= imdilate(ispath, ones(ceil(sqrt(mean(expt.gatherField('iarea'))))));
diagIm \= repmat(im, \[1 1 3]);
diagIm(:,:,2\) \= im.\*double(ispath);
diagIm(:,:,3\) \= im.\*double(ispath);
 
\-\-\-

\#\#\# File: toMWTFiles.m (ID: @Experiment.43\)

Could not read file: 'utf\-8' codec can't decode byte 0x93 in position 1770: invalid start byte

\-\-\-

\#\#\# File: cleanTracks.m (ID: @Experiment.44\)

function cleanTracks (expt, minFrames, minDist)
%deletes short or stubby tracks; consider ESetCleaner instead
%function cleanTracks (expt, minFrames, minDist)
%expt.cleanTracks(minFrames, minDist)
%
%deletes all tracks that have fewer than minFrames pts
%and all tracks that extend less than minDist in any direction
%
%ouputs: none
%inputs:
%EXPT: a member of the experiment class
%MINFRAMES: any track with less than this number of points is deleted
%MINDIST: any track that extends less than minDist is deleted

 for j \= length(expt.track):\-1:1
 d(j) \= maxExcursion(expt.track(j));
 end
 badtracks \= find((d \< minDist) \| (\[expt.track.npts] \< minFrames));
 length(badtracks)
 inds \= setdiff (1:length(expt.track), badtracks);
 length(inds)
 delete (expt.track(badtracks));

 length(expt.track)
 sum(isvalid(expt.track))
 
 expt.track \= expt.track(inds);
 length(expt.track)
 sum(isvalid(expt.track))
 
end %cleanTracks



function d \= maxExcursion(track)
 %function d \= maxExcursion(track)

 loc \= \[track.pt.loc];
 x \= loc(1,:);
 y \= loc(2,:);

 if (length(x) \> 100\)
 n \= floor(length(x)/100\);
 x \= x(1:n:end);
 y \= y(1:n:end);
 end

 x \= repmat(x,fliplr(size(x)));
 y \= repmat(y,fliplr(size(y)));
 ds \= (x\-x').^2 \+ (y\-y').^2;
 d \= sqrt(max(max(ds)));
end
\-\-\-

\#\#\# File: toMatFile.m (ID: @Experiment.45\)

function toMatFile(experiment, varargin)
%function toMatFile(experiment, varargin)
%
%saves an experiment to a .mat file with the same file name as the .bin
%file, but with a different extension
%extradir, 'extra\\directories' \-\- places matfile in a subdirectory 
extradir \= '';
tracksInSubDir \= false;
fname \= '';
varargin \= assignApplicable(varargin);
if (isempty(fname))
 \[p, f] \= fileparts(experiment.fname);
 if (\~isempty(extradir))
 fname \= fullfile(p, extradir, \[f '.mat']);
 % save(fullfile(p, extradir, \[f '.mat']), 'experiment')
 else
 fname \= fullfile(p, \[f '.mat']);
 % save(fullfile(p, \[f '.mat']), 'experiment');
 end
end
if (tracksInSubDir)
 experiment \= Experiment(experiment); %clone to avoid sending changes backwards
 \[p,f] \= fileparts(fname);
 experiment.savedTrackRelDir \= \[shortenFileStub(f) ' \- tracks'];
 experiment.savedTrackDir \= fullfile(p, experiment.savedTrackRelDir);
 if (\~exist(experiment.savedTrackDir, 'dir'))
 mkdir(experiment.savedTrackDir);
 end
 for j \= 1:length(experiment.track)
 experiment.track(j).toMatFile(fullfile(experiment.savedTrackDir, \['track' num2str(j) '.mat']));
 end
 experiment.track \= \[];
end

save(fixFileNameWin(fname), 'experiment');
\-\-\-

\#\#\# File: openDataFile.m (ID: @Experiment.46\)

function openDataFile(expt)
%opens the data file associated with expt for reading
%function openDataFile(expt)
%
%opens the data file associated with expt for reading (e.g. for reloading
%images)
%inputs: EXPT, a member of the Experiment class
if (isa(expt.track(1\), 'MWTTrack'))
 %no data file to read in same way for multi worm tracker
 return;
end

if (expt.fid \~\= 0\)
 try
 fclose(expt.fid);
 catch me
 % do nothing, it was probably already closed
 end
end

expt.fid \= fopen(expt.fname, 'r');
\-\-\-

\#\#\# File: calculateDerivedQuantity.m (ID: @Experiment.47\)

function calculateDerivedQuantity(expt, quantityNames, recalculate)
%calculates the derived quantity for each track using the same derivation rules
%function calculateDerivedQuantity(expt, quantityNames, recalculate)
%expt.calculateDerivedQuantity(quantityNames, recalculate)
%
%Assigns expt.dr to each track (overwriting any existing different
%derivation rules)
%then calls calculateDerivedQuantity on each track
%
%ouputs: none
%inputs:
%EXPT: a member of the experiment class
%QUANTITYNAMES: the names of quantities to calculate
%RECALCULATE: whether to recalculate the quantities if they are already
%calculated (optional, defaults to false)

existsAndDefault('recalculate', false);
\[expt.track.dr] \= deal(expt.dr);
expt.executeTrackFunction('calculateDerivedQuantity', quantityNames, recalculate);
\-\-\-

\#\#\# File: reloadTrack.m (ID: @Experiment.48\)

function track2 \= reloadTrack(expt, track, varargin)
%loads a copy of track from disk, or loads images into an existing track
%function track2 \= reloadTrack(expt, track, varargin)
%
%outputs:
%TRACK2: the track, as loaded from disk
%inputs:
%EXPT: a member of the Experiment class
%TRACK: either a handle to a track, or the index of a track in EXPT.track
% if track is a track handle, then 
% creates a new track handle and reloads track into new handle (with all
% images). NB: you must delete track2 handle when done
%
% if track is an index to a track, then we reload the track into the old
% place in memory
%
% optional parameter: 
% 'usecamcalinfo', \[true]/false
% whether to use camera calibration when reloading file
% use camcalinfo is always true if track is a number (to prevent mixed
% representation in experiment)

usecamcalinfo \= true;
varargin \= assignApplicable(varargin);

if (\~isa (track, 'Track')) 
 trackid \= track;
 track \= expt.track(trackid);
 usecamcalinfo \= true;
else
 trackid \= 0;
end

try 
 invalid \= (expt.fid \=\= 0 \|\| ftell(expt.fid) \< 0\);
catch
 expt.openDataFile();
 invalid \= (expt.fid \=\= 0 \|\| ftell(expt.fid) \< 0\);
end
if invalid
 expt.openDataFile();
end

if (usecamcalinfo)
 cc \= expt.camcalinfo;
else
 cc \= \[];
end

if (isa(track, 'MaggotTrack')) 
 track2 \= repmat(MaggotTrack(), \[1 track.nt]);
else
 track2 \= repmat(Track(), \[1 track.nt]);
end
for j \= 1:track.nt
 fseek(expt.fid, track.locInFile(j), \-1\);
 track2(j) \= Track.fromFile(expt.fid, track.pt(1\), true, true, cc);
end
for j \= (track.nt\-1\):\-1:1
 track2(j).merge(track2(j\+1\));
end
delete (track2(2:end));
track2 \= track2(1\);
track2\.dr \= track.dr;
if (\~isempty(expt.elapsedTime)) 
 indx \= (1:length(expt.elapsedTime)) \- 1;
 track2\.addTime (indx, expt.elapsedTime);
end
track2\.expt \= track.expt;

if (trackid \> 0\)
 %take care of case where track may have been trimmed previously
 startind \= find(\[track2\.pt.ind] \=\= expt.track(trackid).startFrame);
 endind \= find(\[track2\.pt.ind] \=\= expt.track(trackid).endFrame);
 \[expt.track(trackid).pt.imData] \= track2\.pt(startind:endind).imData;
end
\-\-\-

\#\#\# File: getJavaPtType.m (ID: @Experiment.49\)

function \[type, valid] \= getJavaPtType(fname)

% jEx \= javaObjectEDT('TrackExtractionJava.Experiment', fname);
% code \= jEx.getTypeCode();
 
 code \= javaMethod('getPointType','TrackExtractionJava.Experiment', fname);
 
 valid \= true;
 switch (code)
 case 3
 type \= LarvaTrackPoint();
 case 2
 type \= MaggotTrackPoint();
 case 1
 type \= ImTrackPoint();
 case 0
 type \= TrackPoint();
 otherwise
 type \= \-1;
 valid \= false;
 end
 
 
end
\-\-\-

\#\#\# Folder: @MaggotTrack (ID: @MaggotTrack)

\-\-\-

\#\#\# File: segmentTrack.m (ID: @MaggotTrack.1\)

 function track \= segmentTrack (track, mso)
%function track \= segmentTrack (track, mso)
%
% carries out the segmentation algorithm
% requires segmentation options (mso)
% if mso is passed here, these become the track's default segmentation
% options
% if mso is not passed, track's default segmentation options are used
% note: generally speaking, one should use "setSegmentSpeeds" to set proper
% segmentation speeds in the segmentation options, then call segmentTrack
% without mso
%
% outputs: none
% inputs:
% TRACK \< MaggotTrack
% MSO \< MaggotSegmentOptions (see note above, generally not passed
% here)
%
% Track Segmentation Algorithm:
% 1\) Find everywhere not a run (because head is swinging wide, speed
% is low, track has a kink, vel\_dp is low)
% 2\) Find run starts and stops based on (1\) and min run start speed 
% 3\) eliminate very short runs
% 4\) find head swings (head is swinging \& not a run)
% 5\) group head swings into reorientations (turns) and also mark
% turns with no headswings
%
% See MaggotSegmentationOptions for various parameters that interact with
% segmentation
debug \= false;

if (\~exist('mso', 'var') \|\| isempty(mso))
 mso \= track.so;
else
 track.so \= mso;
end
if (mso.autoset\_curv\_cut)
 mso.curv\_cut \= mso.autoset\_curv\_cut\_mult / median(track.getDerivedQuantity('spineLength')); %autoset\_curv\_cut\_mult default is 5
 track.so \= mso;
end

cv \= track.getDerivedQuantity('curv');
%bt \= track.getDerivedQuantity('sbodytheta');
if (mso.smoothBodyFromPeriFreq \|\| \~isempty(mso.smoothBodyTime))
 if (\~isempty(mso.smoothBodyTime))
 st \= mso.smoothBodyTime;
 else
 st \= 0\.2/median(track.getDerivedQuantity('periFreq'));
 end
 bt \= lowpass1D(track.getDerivedQuantity('spineTheta'), st/track.dr.interpTime);
else
 bt \= track.getDerivedQuantity('sspineTheta');
end
vdp \= track.getDerivedQuantity('vel\_dp');
sp \= track.getDerivedQuantity(mso.speed\_field);

if (debug)
 tx \= track.dq.eti;
 figure(1\);
 plot (tx, abs(cv), tx, repmat(mso.curv\_cut, size(tx))); ylim(\[0 mso.curv\_cut]);
 title ('curv')
 figure(2\);
 plot (tx, bt, tx, repmat(mso.theta\_cut, size(tx)));
 title ('body theta');
 figure(3\);
 plot (tx, sp, tx, repmat(mso.stop\_speed\_cut, size(tx)),'r\-', tx, repmat(mso.start\_speed\_cut, size(tx)),'g\-');
 title ('speed');
end

highcurv \= (abs(cv) \> mso.curv\_cut);
head\_swinging \= (abs(bt) \> mso.theta\_cut);
speedlow \= (sp \< mso.stop\_speed\_cut);

%whenever the head swings wide or the path has high 
%curvature or the speed drops too low, we say any existing run
%ends
notarun \= (highcurv \| head\_swinging \| speedlow);
endarun \= find(diff(notarun) \>\= 1\) \+ 1;


%in order to begin a run, we need to (a) not be at a stop point
%(b) be moving fast enough and (c) have the head aligned with the direction
%of motion
speedhigh \= (sp \>\= mso.start\_speed\_cut);
headaligned \= (vdp \>\= mso.aligned\_dp); 
isarun \= (\~notarun \& speedhigh \& headaligned);

startarun \= find(diff(isarun) \>\= 1\) \+ 1;

start \= startarun;
stop \= endarun;
si \= 1;
k \= 0;
%create a list of sequential starts and stops from valid start and stop
%points
while (\~isempty(si) \&\& \~isempty(startarun))
 k \= k\+1;
 start(k) \= startarun(si);
 ei \= find(endarun \> start(k), 1, 'first');
 if (isempty(ei))
 stop(k) \= length(track.dq.eti);
 else
 stop(k) \= endarun(ei);
 end
 si \= find(startarun \> stop(k),1, 'first');
end
start \= start(1:k);
stop \= stop(1:k);

%remove runs that are too short
inds \= find(track.dq.eti(stop) \- track.dq.eti(start) \>\= mso.minRunTime);
start \= start(inds);
stop \= stop(inds);
%{
%clear old runs
if (\~isempty(track.run))
 for j \= 1:length(track.run)
 delete(track.run(j));
 end 
end
%}
run \= repmat(Run(),0\);%changed from 1 to 0 1/19/2014 by MHG (so default is empty run); let's see what this breaks
%record runs in track, and take some basic statistics
for k \= 1:length(start)
 run(k) \= Run(track,start(k),stop(k));
 %{
 if (k \> 1\)
 run(k).previousRun \= run(k\-1\);
 run(k\-1\).nextRun \= run(k);
 end
 %}
end
track.run \= run;
track.isrun \= false(size(track.dq.eti));
track.isrun(\[run.inds]) \= true;
notrun \= \~track.isrun;

%now that we have found runs, we look for head swings
%locate head swings; head swings are anything where the head swings 
buffer \= ceil((track.dr.smoothTime \+ track.dr.derivTime)/track.dr.interpTime);


%eliminate all headswings before the first run \& after the last run
firstrunind \= find(track.isrun, 1, 'first') \+ buffer; %changed to eliminate looking for headswings at the end of the last run or the beginning of the first run 7/31
lastrunind \= find(track.isrun, 1, 'last') \- buffer;
inrange \= false(size(notrun));
inrange(firstrunind:lastrunind) \= true;



notrun \= imdilate(notrun, ones(\[1, buffer])); %allow head sweeps to start right at the end of runs 

head\_swinging \= find (abs(bt) \> mso.headswing\_start \& notrun \& inrange);
%size(track.isrun)
isrun2 \= imerode(track.isrun, ones(\[1, buffer])); %remove the ends of the run (lets head sweeps end inside of runs) \- changed to adapted time by mhg on 7/3 (instead of fixed \# of points)
not\_head\_swing \= find((abs(bt) \< mso.headswing\_stop) \| (\[0 diff(sign(bt))] \~\= 0 \| isrun2\) \& inrange);



%create a list of sequential starts and stops from valid start and stop
%points
si \= 1;
k \= 0;
start \= head\_swinging;
stop \= start;
while (\~isempty(si) \&\&\~isempty(head\_swinging))
 k \= k\+1;
 start(k) \= head\_swinging(si);
 ei \= find(not\_head\_swing \> start(k), 1, 'first');
 if (isempty(ei))
 stop(k) \= length(track.dq.eti);
 else
 stop(k) \= not\_head\_swing(ei);
 end
 si \= find(head\_swinging \> stop(k), 1, 'first');
end
start \= start(1:k);
stop \= stop(1:k);


inds \= start;
j \= 0;
%a headswing is only valid if it includes at least one point that is not
%part of a run
for k \= 1:length(start)
 if (any(notrun(start(k):stop(k))))
 j \= j \+ 1;
 inds(j) \= k;
 end
end
inds \= inds(1:j);

start \= start(inds);
stop \= stop(inds);

headSwing \= repmat(HeadSwing(), 0\);
for k \= 1:length(start)
 headSwing(k) \= HeadSwing(track, start(k), stop(k));
end
track.headSwing \= headSwing;

%group headswings into reorientations
%a reorientation is the period between runs, whether or not that contains
%any headswings;
%a reorientation is a group of 1 or more headswings that fall between the
%same runs
nextrun \= zeros(size(track.headSwing));
for j \= 1:length(track.headSwing)
 ind \= find(\[track.run.startInd] \> track.headSwing(j).startInd, 1, 'first');
 if (isempty(ind))
 nextrun(j) \= length(track.run) \+ 1;
 else
 nextrun(j) \= ind;
 end
end
k \= 0;
reorientation \= repmat(MaggotReorientation(), \[1 length(track.run)\-1]);
for j \= 1:length(reorientation)
 inds \= find(nextrun \=\= j\+1\);
 if (isempty(inds))
 reorientation(j) \= MaggotReorientation(track, \[], track.run(j), track.run(j\+1\)); 
 else
 reorientation(j) \= MaggotReorientation(track, track.headSwing(inds), track.run(j), track.run(j\+1\));
 end
end
track.reorientation \= reorientation;

\-\-\-

\#\#\# File: plotSegmentation.m (ID: @MaggotTrack.2\)

function plotSegmentation (track, varargin)
%function plotSegmentation (track, varargin)
TrackColor \= 'm.\-';
RunColor \= 'b\-';
ReoColors.accepted \= 'g\-';
ReoColors.rejected \= 'r\-';
SegColors \= \[];
varargin \= assignApplicable(varargin);
if (isempty(SegColors))
 SegColors.TrackColor \= TrackColor;
 SegColors.RunColor \= RunColor;
 SegColors.ReoColors \= ReoColors;
end

track.calculateDerivedQuantity({'sloc', 'stail','shead','theta'});
ih \= ishold;
plot (track.dq.sloc(1,:), track.dq.sloc(2,:), SegColors.TrackColor, 'LineWidth', 1\); hold on
if (isempty(track.run))
 return;
end
for j \= 1:length(track.run)
 track.run(j).draw('Color', SegColors.RunColor);
end

for j \= 1:length(track.reorientation)
 track.reorientation(j).draw('Colors', SegColors.ReoColors);
end
if (\~ih)
 hold off
end

axis equal
\-\-\-

\#\#\# File: MaggotTrack.m (ID: @MaggotTrack.3\)

classdef MaggotTrack \< Track
 %MaggotTrack extends Track 
 %MaggotTrack adds the headSwing field (keeps track of when maggot is
 % turning its head to the side)
 %Several Track methods (e.g. segmentTrack) are overwritten or extended
 % here
 %
 %Typical end users will not instantiate their own MaggotTracks but
 % will find them in experiments they have loaded from disk
 
 properties (Transient \= true, AbortSet \= true)
 headSwing;
 end
 
 methods %constructor
 function mt \= MaggotTrack (varargin)
 mt \= mt@Track(varargin);
 mt.dr.smoothTime \= 0\.5; %maggots move faster \& need less smoothing than worms
 mt.so \= MaggotSegmentOptions();
 if ((nargin \>\= 1\) \&\& isa(varargin{1}, 'MaggotTrack'))
 mt.clone(varargin{1});
 end
 end
 end %constructor
 
 methods %access
 function set.headSwing(obj, value)
 if (\~isempty(value) \&\& isa(value, 'TrackPart'))
 \[value.track] \= deal(obj);
 end
 obj.headSwing \= value;
 end
 end
 
 methods(Static)
 varargout \= validDQName (varargin)
 end
 methods 
 recalculateDerivedQuantities(track, varargin); %recalculate already derived quantities
 calculateDerivedQuantity(track, quantityName, recalculate); 
 %setSegmentSpeedsByPercentile (track, maggotSegmentOptions, stopPctl, startPctl); %nix 
 segmentTrack (track, maggotSegmentOptions); %segments the track into runs and turns (with head sweeps)
 setSegmentSpeeds (track, mso);
 plotSegmentation (track, varargin); %plots the segmented tracks run and turns with annotation
 fixHTOrientation(track, varargin); 
 prettyMovie(track, varargin); %play a pretty movie
 
 toMWTTrackFile (track, filestub, varargin); %writes a .blob file for 1 track
 str \= toMWTTrackString (track, varargin); %writes the appropriate string for a .blobs file
 shapeModel \= getTypicalMaggotShape(track, varargin);
 
 playMovie\_BehaviorTriggered(track, fieldName,fieldDescription, displacementAxis, triggeredSum, triggeredInd, figTitle, varargin);
 loadJavaMasks(track, jTr);
 
 end
 
 
 
 
end


\-\-\-

\#\#\# File: toMWTTrackString.m (ID: @MaggotTrack.4\)

function str \= toMWTTrackString (track, varargin) %writes the appropriate string for a .blobs file
%function str \= toMWTTrackString (track, varargin) 
%writes the appropriate string for a .blobs file
%
%track \< MaggotTrack

pt \= track.pt;
valid \= \[pt.area] \>\= 0\.4 \* \[pt.targetArea];
if (mean(valid) \< 0\.8\)
 valid \= \[pt.area] \> 20; %minimum 20 pixels in area
 if (mean(valid) \< 0\.8\)
 warning ('MGT:TOMWTTRACK', \['a large number of points in track ' num2str(track.trackNum) ' fall below threshold area']);
 return;
 end
end
pt \= fillInBlanks(pt(valid));
% if (\~all(valid) \|\| track.nt \> 1\) 
% pt \= pt);
% end

str \= cell(length(track.pt)\+1,1\);
str{1} \= sprintf ('%% %d\\n', track.trackNum);
pt \= track.pt;
if(isempty(track.expt))
 cc \= \[];
else
 cc \= track.expt.camcalinfo;
end
for j \= 1:length(pt)
 str{j\+1} \= sprintf('%s\\n', pt(j).toMWTBlobLine(cc));
end
str \= \[str{:}];


function pt \= fillInBlanks(pt)

while (any (diff(\[pt.ind]) \> 1\))
 \[\~,I] \= find(diff(\[pt.ind]) \> 1, 1, 'first');
 npts \= double(pt(I\+1\).ind\-pt(I).ind \- 1\);
 newpt \= repmat(pt(I), 1, npts);
 for j \= double(1:npts)
 newpt(j).ind \= pt(I).ind \+ j;
 newpt(j).loc \= (pt(I).loc \*(npts\+1\-j)\+pt(I\+1\).loc \*(j))/(npts\+1\);
 end
 pt \= \[pt(1:I) newpt pt((I\+1\):end)];
end

\-\-\-

\#\#\# File: presentationMovie.m (ID: @MaggotTrack.5\)

function varargout \= presentationMovie(track, varargin)
%@MaggotTrack
%playMovie(track, varargin)
%enter options as pairs, caps matter
%options, with defaults
%
%ptbuffer \= 1000;
%delayTime \= 0\.05;
%inds \= 1:length(track.pt);
%startLoc \= \[]; \> if startLoc \& stopLoc are not empty, we run the movie
%between these two points
%stopLoc \= \[]; \>
%pass 'fid', \[] to not load images from disk
%'AxesList', ax \= list of axes to plot to; specified from top left in cc
% order
%'TitleOptions', {'Color', 'k', 'FontSize', 14};
%'DataPlotOptions', {'Color', 'k', 'LineWidth', 3};
%'DataAxesOptions', {}
%'LocPlotOptions', {'field', 'sloc', 'LineWidth', 2, 'AxesOptions', {}}

ptbuffer \= 200;
delayTime \= 0\.05;

inds \= 1:length(track.pt);
track.expt.openDataFile;
fid \= track.expt.fid;
AxesList \= \[];
TitleOptions \= {'Color', 'k', 'FontSize', 14};
DataPlotOptions \= {'Color', 'k', 'LineWidth', 3};
DataAxesOptions \= {};
LocPlotOptions \= {'field', 'sloc', 'LineWidth', 2, 'AxesOptions', {}};
aviobj \= \[];
%vidobj requires matlab 2011 (7\.12\) or later
vidobj \= \[];
avirect \= \[];
varargin \= assignApplicable(varargin);
if (isempty(AxesList))
 order \= \[1 3 4 2];
 for j \= 1:4
 AxesList(j) \= subplot(2,2,order(j)); %\#ok
 end
end
 

pt \= \[track.pt];
%loc \= \[pt.loc];
sloc \= track.getDerivedQuantity('sloc');
sind \= track.getDerivedQuantity('mapptstointerped');
track.calculateDerivedQuantity({'sbodytheta', 'speed', 'vel\_dp'});

sstart \= sind(1\) \- ptbuffer;
send \= sind(end) \+ ptbuffer;
if (sstart \< 1\)
 sstart \= 1;
end
if (send \> length(sloc))
 send \= length(sloc);
end
datafields(track, AxesList(\[4 2]), sstart:send, TitleOptions, DataPlotOptions, DataAxesOptions);
locPlot(track, sstart:send, AxesList(3\), LocPlotOptions{:}, 'TitleOptions', TitleOptions);
handles \= \[];
hloc \= \[];



for j \= inds
 ts1 \= tic();
 axcolor \= get(AxesList(1\), 'Color');
 pt(j).drawTrackImage(track.expt.camcalinfo,'Axes', AxesList(1\), 'fid', fid, varargin{:}); 
 shading(AxesList(1\),'interp');
 xl \= get(AxesList(1\),'XLim');
 yl \= get(AxesList(1\),'YLim');
 
 hold (AxesList(1\),'on');
 sstart \= sind(j) \- ptbuffer;
 send \= sind(j) \+ ptbuffer;
 if (sstart \< 1\)
 sstart \= 1;
 end
 if (send \> length(sloc))
 send \= length(sloc);
 end
 
 plot (AxesList(1\),sloc(1,sstart:sind(j)), sloc(2,sstart:sind(j)), 'b.\-');
 plot (AxesList(1\),sloc(1,sind(j)), sloc(2,sind(j)), 'bo', 'MarkerSize', 5\);
 set(AxesList(1\),'XLim', xl, 'YLim', yl, 'YDir', 'reverse');
 hold (AxesList(1\), 'off');
 set(AxesList(1\), 'XTick', \[], 'YTick', \[],'Color',axcolor);
 if (\~isempty(track.run))
 t \= \[];
 
 if (\~isempty(track.headSwing) \&\& any(\[track.headSwing.inds] \=\= sind(j)))
 t \= 'headsweep ';
 I \= find(\[track.headSwing.startInd] \<\= sind(j) \& \[track.headSwing.endInd] \>\= sind(j));
 if (\~isempty(I))
 if (track.headSwing(I).accepted)
 t \= \[t 'accepted ']; %\#ok
 else
 t \= \[t 'rejected ']; %\#ok
 end
 end
 else
 if (track.isrun(sind(j)))
 t \= 'run '; 
 end
 end
 %{
 if (\~isempty(track.reorientation) \&\& any(\[track.reorientation.inds] \=\= sind(j)))
 t \= \[t 'reorientation '];
 end
 %}
 title (AxesList(1\),t, TitleOptions{:});
 end
 
 handles \= updateCenter(handles, AxesList(\[4 2]),track, sind(j), sstart, send, DataAxesOptions);
 hloc \= locUpdate (track, sind(j), AxesList(3\), hloc, LocPlotOptions{:});
 timeleft \= delayTime \- toc(ts1\);
 if (timeleft \> 0\)
 pause(timeleft);
 else
 pause(0\.001\);
 end
 if (\~isempty(aviobj) \|\| \~isempty(vidobj))
 if (isempty(avirect))
 F \= getframe(gcf);
 else
 F \= getframe(gcf, avirect);
 end 
 if (\~isempty(aviobj))
 aviobj \= addframe(aviobj, F);
 end
 if (\~isempty(vidobj))
 writeVideo(vidobj,F);
 end
 end
end
if (nargout \> 0\)
 varargout{1} \= aviobj;
end
end

function datafields(track, ax, inds, TitleOptions, DataPlotOptions, DataAxesOptions)
 fields \= {'sbodytheta',track.so.speed\_field};
 ttls \= {'Body Bend Angle', 'Speed'};
 % ylb \= {'degrees', 'cm/min'};
 mult \= \[rad2deg(1\), 60, 1];
 yl \= {\[\-120 120], \[0 mult(2\)\*max(track.getDerivedQuantity(fields{2}))]};
 for k \= 1:2
 hold(ax(k), 'off');
 plot (ax(k), track.dq.eti(inds), mult(k)\*track.dq.(fields{k})(inds), DataPlotOptions{:}); hold on
 title(ax(k), ttls{k}, TitleOptions{:});
 set(ax(k), 'YLim', yl{k}, DataAxesOptions{:}); 
 %get(ax(k), 'Xlim')
 % ylabel(ax(k), ylb{k});
 end
 % set (ax(1\), 'YAxisLocation', 'Right');
 if (false)
 ylabel (ax(1\), '$\\leftarrow$ leftward ; rightward $\\rightarrow$', TitleOptions{:}, 'Interpreter', 'Latex');
 ylabel(ax(2\), '$\\leftarrow$ slower ; faster $\\rightarrow$', TitleOptions{:}, 'Interpreter', 'Latex');
 end
end

function handles \= updateCenter(handles, ax, track, cind, start, stop, DataAxesOptions)
 if \~isempty(handles)
 for j \= 1:length(handles)
 delete(handles(j));
 end
 end
 fields \= {'sbodytheta',track.so.speed\_field,'vel\_dp'};
 mult \= \[rad2deg(1\), 60, 1];
 for k \= 1:2
 ih \= ishold(ax(k));
 
 hold (ax(k), 'on');
 handles(k) \= plot (ax(k), track.dq.eti(cind), mult(k)\*track.dq.(fields{k})(cind), 'c.','MarkerSize',30\);
 xlim(ax(k), \[min(track.dq.eti(start)) max(track.dq.eti(stop))]);
 if (\~ih)
 hold (ax(k), 'off');
 end
 if (\~isempty(DataAxesOptions))
 set(ax(k), DataAxesOptions{:});
 end
 end
end 

function locPlot (track, inds, ax, varargin)
 field\= 'sloc';
 AxesOptions \= {};
 imData \= \[];
 TitleOptions \= {};
 varargin \= assignApplicable(varargin);
 hold(ax, 'off');
 if (\~isempty(imData))
 track.plotPath(field, 'b\-', 'inds', inds, 'Axes', ax, varargin{:});
 axis(ax,'equal');
 xl \= get(ax, 'XLim');
 yl \= get(ax, 'YLim');
 
 u \= get(ax, 'Units');
 set(ax,'Units','Pixels');
 pos \= get(ax, 'position');
 pos \= ceil(pos);
 xinds \= find(imData.x \<\= xl(2\) \& imData.x \>\= xl(1\));
 yinds \= find(imData.y \<\= yl(2\) \& imData.y \>\= yl(1\));
 
 if (pos(3\) \< length(xinds))
 xinds \= interp1(xinds, (0:(pos(3\)\-1\)) \* length(xinds)/pos(3\) \+ 1, 'nearest');
 end
 if (pos(4\) \< length(yinds))
 yinds \= interp1(yinds, (0:(pos(4\)\-1\)) \* length(yinds)/pos(4\) \+ 1, 'nearest');
 end
 set(ax, 'Units', u);
 min(imData.x(xinds))
 max(imData.x(xinds))
 pcolor(ax, imData.x(xinds), imData.y(yinds), imData.im(yinds,xinds)); shading(ax, 'flat'); colormap(ax, 'gray');
 hold(ax, 'on');
 end
 track.plotPath(field, 'b\-', 'inds', inds, 'Axes', ax, varargin{:});
 if (exist('xl', 'var'))
 set(ax, 'XLim', xl, 'YLim', yl);
 end
 axis(ax, 'equal');
 title (ax, 'Position', TitleOptions{:});
 hold (ax, 'off');
 
 set(ax,'YDir', 'reverse', AxesOptions{:});
end

function h \= locUpdate (track, ind, ax, h, varargin)
 field\= 'sloc';
 AxesOptions \= {};
 varargin \= assignApplicable(varargin);
 existsAndDefault('h', \[]);
 if (\~isempty(h))
 delete(h);
 end
 xl \= get(ax, 'XLim');
 yl \= get(ax, 'YLim');
 ih \= ishold(ax);
 hold(ax, 'on');
 
 loc \= track.getDerivedQuantity(field, \[], 'inds', ind);
 h \= plot(ax, loc(1\), loc(2\), 'c.', 'MarkerSize', 30\);
 if (\~ih)
 hold(ax, 'off');
 end
 set(ax, 'XLim', xl, 'YLim', yl, AxesOptions{:});
end




\-\-\-

\#\#\# File: playMovie.m (ID: @MaggotTrack.6\)

function playMovie(track, varargin)
%@MaggotTrack
%playMovie(track, varargin)
%enter options as pairs, caps matter
%options, with defaults
%
%frameRate \= \[];
%ptbuffer \= 1000;
%delayTime \= 0\.05;
%axisSize (3 \* length of larva)
%inds \= 1:length(track.pt);
%startLoc \= \[]; \> if startLoc \& stopLoc are not empty, we run the movie
%between these two points
%stopLoc \= \[]; \>
%startTime \= \[]; if startTime and stopTime are not empty, re run the movie
%between these two times
%stopTime \= \[];
%vidObj \= \[];
%aviobj \= \[];
%avirect \= \[];
%resizefig \= true;
%figcolor \= 'w';
%fontcolor \= 'k';
%underlayTemporalField \= ''; boolean true if on
%underlayTemporalOnColor \= \[0 0\.8 0\.8];
%underlayTemporalOffColor \= \[0 0 0];
%underlayTemporalOnMessage \= 'Light on';
%underlayTemporalOffMessage \= 'Light off';
%rect \= \[];
% displayTimeCoordinate \= 'eti';
%pass 'fid', \[] to not load images from disk
%ptskip, \[] \-\- if not empty we sample pts at this interval 
if (length(track) \> 1\)
 for j \= 1:length(track)
 track(j).playMovie(varargin{:});
 end
 return;
end
frameRate \= \[]; %override frameRate to set a target frame rate
stretchReos \= false; %if skipping frames due to frame rate, then don't skip reorientation frames

ptbuffer \= ceil(40/track.dr.interpTime);
delayTime \= max(track.dr.interpTime/4\-0\.1, 0\.01\);
%set(0,'DefaultTextInterpreter', 'Latex');
if (isempty(track.expt) \|\| isempty(track.expt.camcalinfo))
 mf \= 1;
else
 mf \= track.expt.camcalinfo.realUnitsPerPixel;
end
%axisSize \= mf\*max(size(track.pt(1\).imData));
sl \= track.getDerivedQuantity('spineLength');
axisSize \= 3\*median(sl(:,track.getDerivedQuantity('ihtValid')));
if (axisSize \<\= 0\)
 try 
 track.expt.openDataFile();
 pttemp \= track.expt.reloadPoint(track.pt(1\));
 axisSize \= mf\*max(size(pttemp.imData));
 catch
 end
end
displayTimeCoordinate \= 'eti';

if (axisSize \<\= 0 \|\| \~isfinite(axisSize))
 %axisSize \= 50;
 axisSize \= 8 \* mean(track.getDerivedQuantity('speed'));
 
end
ptskip \= \[];
iinds \= \[];
inds \= 1:length(track.pt);
startLoc \= \[];
stopLoc \= \[];
startTime \= \[];
stopTime \= \[];
vidObj \= \[];
aviobj \= \[];
avirect \= \[];
resizefig \= true;
figcolor \= 'w';
fontcolor \= 'k';
scalebar \= false;

if (\~isempty(track.expt))
 track.expt.openDataFile;
 fid \= track.expt.fid;
else
 fid \= \[];
end
if (isa(track.pt(1\), 'MWTTrackPoint'))
 imOptions \= {'pretty', true, 'drawHeadArrow', true, 'spineColor', 'r.','contourColor', 'm\-', 'contourWidth', 1, 'scale', 1, 'drawContour', true, 'drawSpine', true};%'drawContour', true, 'scale', 1,'contourColor', 'r\-', 'LineWidth', 1, 'mhWidth', 1};
else
 imOptions \= {'pretty', true, 'drawHeadArrow', true, 'spineColor', 'r.','contourColor', 'c.', 'contourWidth', 1, 'scale', 1, 'drawContour', (isempty(fid) \|\| fid \<\= 0\), 'drawSpine', true};%'drawContour', true, 'scale', 1,'contourColor', 'r\-', 'LineWidth', 1, 'mhWidth', 1};
end

underlayImData \= \[];
overlayImData \= \[];
underlayTemporalField \= '';
underlayTemporalOnColor \= \[0 1 1];
underlayTemporalOffColor \= \[0 0 0];
underlayTemporalOnMessage \= 'Light on';
underlayTemporalOffMessage \= 'Light off';
rect \= \[];
fixedrect \= false;
varargin \= assignApplicable(varargin);
if (\~isempty(iinds))
 inds \= track.getDerivedQuantity('mapinterpedtopts', false,iinds);
end
if (\~isempty(ptskip))
 inds \= inds(1\):ptskip:inds(end);
end
if (\~isempty(startLoc) \&\& \~isempty(stopLoc))
 \[\~,s] \= track.nearestPoint (startLoc);
 \[\~,e] \= track.nearestPoint (stopLoc);
 if (s \> e)
 inds \= e:s;
 else
 inds \= s:e;
 end
end
if (\~isempty(startTime) \&\& \~isempty(stopTime))
 pt \= \[track.pt];
 inds \= find(\[pt.et] \>\= startTime, 1, 'first'):find(\[pt.et] \<\= stopTime, 1, 'last');
end
pt \= \[track.pt];
loc \= \[pt.loc];
sloc \= track.getDerivedQuantity('sloc');
sind \= track.getDerivedQuantity('mapptstointerped');
track.calculateDerivedQuantity({'sbodytheta', 'speed', 'vel\_dp', 'dsbodytheta', 'spheadperp', 'sspineTheta'});


 
%pt \= \[track.pt];
sstart \= sind(1\) \- ptbuffer;
send \= sind(end) \+ ptbuffer;
if (sstart \< 1\)
 sstart \= 1;
end
if (send \> length(sloc))
 send \= length(sloc);
end

%dounderlay \= \~isempty(underlayImData);
dounderlay \= false;
\[imax, dataaxes, underlayax] \= setupFigure(gcf, resizefig,dounderlay);

u \= get(imax, 'units');
set(imax, 'units', 'pixels');
imh \= get(imax, 'position');
imh \= imh(4\);
fontsize \= .04 \* imh;
set(imax, 'units', u);
%set(gcf, 'DefaultAxesColor', 'w', 'DefaultTextColor', 'k');
set(gcf, 'Color', figcolor);
%set(imax, 'Color', 'k');
set(dataaxes, 'XColor', fontcolor, 'YColor', fontcolor, 'FontSize', fontsize\-2\)
datafields(track, sstart:send, dataaxes, fontsize);

% if (dounderlay)
% % set(pcolor (underlayax, underlayImData.x, underlayImData.y, underlayImData.im), 'FaceAlpha', 0\.4, 'EdgeColor', 'none');
% imagesc(underlayImData.x, underlayImData.y, double(underlayImData.im), 'Parent', underlayax);
% imOptions \= \[imOptions {'patchOptions', {'AlphaData', 0\.4}}];
% axis(underlayax, 'equal'); axis(underlayax, 'xy'); axis(underlayax, 'off');
% else
% overlayax \= \[];
% end

handles \= \[];
if (isempty(track.expt))
 ccinfo \= \[];
else
 ccinfo \= track.expt.camcalinfo;
end
eti \= track.getDerivedQuantity('eti');
temporalunderlay \= false;
if (\~isempty(underlayTemporalField))
 temporalFieldData \= logical(setNonFiniteToZero(track.getDerivedQuantity(underlayTemporalField)));
 temporalunderlay \= true;
end

if (fixedrect \&\& isempty(rect))
 plot (imax, loc(1,inds) \- axisSize/2, loc(2,inds) \- axisSize/2, loc(1,inds) \+ axisSize/2, loc(2,inds) \+ axisSize/2\);
 axis(imax, 'equal');
 rect \= \[get(imax, 'xlim') get(imax, 'ylim')];
 ll \= min(loc(:,inds),\[],2\);% \- axisSize/2;
 ur \= max(loc(:,inds),\[],2\);% \+ axisSize/2;
 
 if (ll(1\) \< rect(1\) \|\| ur(1\) \> rect(2\))
 rect(1:2\) \= rect(1:2\) \+ mean(\[ll(1\) ur(1\)]) \- mean(rect(1:2\));
 end
 if (ll(2\) \< rect(3\) \|\| ur(2\) \> rect(4\))
 rect(3:4\) \= rect(3:4\) \+ mean(\[ll(2\) ur(2\)]) \- mean(rect(3:4\));
 end
 cla(imax);
 
end

if (\~isempty(underlayImData))
 if (isempty(rect))
 ll \= min(loc(:,inds),\[],2\);% \- axisSize/4;
 ur \= max(loc(:,inds),\[],2\);% \+ axisSize/4;
 else
 ll \= \[rect(1\) rect(3\)];
 ur \= \[rect(2\) rect(4\)];
 end
 xv \= find(underlayImData.x \>\= ll(1\) \& underlayImData.x \<\= ur(1\));
 yv \= find(underlayImData.y \>\= ll(2\) \& underlayImData.y \<\= ur(2\));
 % \[xx,yy] \= meshgrid(xv,yv);
 underlayImData.x \= underlayImData.x(xv);
 underlayImData.y \= underlayImData.y(yv);
 underlayImData.im \= underlayImData.im(yv,xv,:);
 imOptions \= \[imOptions, {'underlayImData', underlayImData}];
 size(underlayImData.im)
end

ts0 \= tic();
nframes \= 0;
skipCount \= 1;
%if (\~isempty(frameRate) \&\& stretchReos)
 % disp ('stretching reorientations out to slow speed; runs will animate faster');
%end

timeToDisplay \= track.getDerivedQuantity(displayTimeCoordinate);
for j \= inds
 nframes \= nframes \+ 1;
 I \= find(\[track.reorientation.startInd] \<\= sind(j) \& \[track.reorientation.endInd] \>\= sind(j), 1, 'first');
 if ((mod(nframes, skipCount) \>\= 1\) \&\& \~(stretchReos \&\& \~isempty(I)))
 continue;
 end
 ts1 \= tic();
 hold (imax,'off'); 
 cla(imax); 
 % set(imax, 'Color', 'k');
 if (isempty(rect))
 imrect \= \[loc(1,j) \+ \[\-axisSize/2 axisSize/2], loc(2,j) \+ \[\-axisSize/2 axisSize/2]];
 else
 imrect \= rect;
 end
 if (temporalunderlay)
 if (\~isempty(ccinfo))
 uid.x \= imrect(1\):ccinfo.realUnitsPerPixel:imrect(2\);
 uid.y \= imrect(3\):ccinfo.realUnitsPerPixel:imrect(4\); 
 else
 uid.x \= round(imrect(1\)):round(imrect(2\));
 uid.y \= round(imrect(3\)):round(imrect(4\));
 end
 uid.im \= ones(\[length(uid.y) length(uid.x) 3]);
 for k \= 1:3
 if (temporalFieldData(sind(j)))
 uid.im(:,:,k) \= underlayTemporalOnColor(k);
 else
 uid.im(:,:,k) \= underlayTemporalOffColor(k);
 end
 end
 pt(j).drawTrackImage(ccinfo,'fid', fid, 'Axes', imax, imOptions{:}, 'underlayImData', uid, 'underlayScale', 0\.6\);
 else
 pt(j).drawTrackImage(ccinfo,'fid', fid, 'Axes', imax, imOptions{:}); 
 end
 hold (imax, 'on');
 
 sstart \= sind(j) \- ptbuffer;
 send \= sind(j) \+ ptbuffer;
 if (sstart \< 1\)
 sstart \= 1;
 end
 if (send \> length(sloc))
 send \= length(sloc);
 end
 
 
 
 
 plot (imax,sloc(1,sstart:send), sloc(2,sstart:send), 'w.\-', 'MarkerSize', 5\);
% plot (imax, sloc(1, sstart:(1/track.dr.interpTime):send), sloc(2, sstart:(1/track.dr.interpTime):send), 'w.');
 plot (imax,sloc(1,sind(j)), sloc(2,sind(j)), 'wo', 'MarkerSize', 5\);
 
 axis (imax,imrect);
 axis (imax,'equal'); 
 axis (imax,imrect);
 
 set(imax, 'XTick', \[], 'YTick', \[]);%, 'Color', 'k');
 if (scalebar \&\& \~isempty(ccinfo))
 sbsize \= double(ceil(axisSize \* 2\.5\));
 xl \= get(imax, 'XLim');
 yl \= get(imax, 'YLim');
 sbx \= xl(2\) \+ \[\-1\.1 \-0\.1]\*sbsize/10;
 sby \= yl(1\)\*0\.95 \+ yl(2\)\*0\.05;
 plot (imax, sbx, \[sby sby], 'w\-', 'LineWidth', 4\);
 text (mean(sbx), yl(1\)\*0\.94 \+ yl(2\)\*0\.06, \[num2str(sbsize) ' mm'], 'Color', 'w',...
 'Interpreter', 'Tex', 'Parent', imax, 'FontName', 'Arial', 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'bottom',...
 'BackgroundColor', 'k');
 end
 hold (imax,'off');
 xl \= get(imax, 'XLim');
 xl \= xl(1\)\*0\.99 \+ xl(2\)\*0\.01;
 yl \= get(imax, 'YLim');
 yl \= yl(1\)\*0\.01 \+ yl(2\)\*0\.99;
 t \= {\['\\color{orange}' displayTimeCoordinate ' \= ' num2str(timeToDisplay(sind(j)), '%.1f')]};
 if (temporalunderlay)
 if (temporalFieldData(sind(j)))
 t \= \[t '\\color{white}' underlayTemporalOnMessage];
 else
 t \= \[t '\\color{white}' underlayTemporalOffMessage];
 end
 end
 if (\~isempty(track.run))
 
 
 I \= find(\[track.run.startInd] \<\= sind(j) \& \[track.run.endInd] \>\= sind(j), 1, 'first');
 %col \= {\[0\.6 0\.6 .9], \[1 1 1], \[0\.7 1 0\.7],\[1 0\.7 0\.7]};
 
 if (\~isempty(I))
 t \= \[t \['\\color\[rgb]{0\.6 0\.6 0\.9}run, \\tau \= ' num2str(track.run(I).runTime,'%.1f') ' s, L \= ' num2str(track.run(I).pathLength, '%.1f') ' cm']];
 end
 
 I \= find(\[track.reorientation.startInd] \<\= sind(j) \& \[track.reorientation.endInd] \>\= sind(j), 1, 'first');
 if (\~isempty(I))
 if (track.reorientation(I).numHS \=\= 0\)
 t \= \[t \['\\color{white}pause, \\Delta\\theta \= ' num2str(rad2deg(diff(unwrap(\[track.reorientation(I).prevDir;track.reorientation(I).nextDir]))), '%.1f')]];
 else
 t \= \[t \['\\color{white}turn, \\Delta\\theta \= ' num2str(rad2deg(diff(unwrap(\[track.reorientation(I).prevDir;track.reorientation(I).nextDir]))), '%.1f')]];
 end
 end
 
 I \= find(\[track.headSwing.startInd] \<\= sind(j) \& \[track.headSwing.endInd] \>\= sind(j), 1, 'first');
 if (\~isempty(I))
 if (\~track.headSwing(I).valid)
 inv \= ' \*invalid';
 else
 inv \= '';
 end
 if (track.headSwing(I).accepted)
 t \= \[t '\\color\[rgb]{0\.7 1 0\.7}accepted head sweep' inv];
 else
 t \= \[t '\\color\[rgb]{1 0\.7 0\.7}rejected head sweep' inv];
 end
 end
 end
 if (\~isempty(t))
 text(double(xl), double(yl), t, 'Interpreter', 'Tex', 'Parent', imax, 'FontName', 'Arial', 'FontSize', fontsize, 'HorizontalAlignment', 'Left', 'VerticalAlignment', 'Top', 'BackgroundColor', 'k');
 end
 
 handles \= updateCenter(handles, track, sind(j), sstart, send, dataaxes);
 if (\~isempty(underlayax))
 set(underlayax, 'Position', get(imax, 'position'), 'XLim', get(imax, 'XLim'), 'YLim', get(imax, 'YLim')); 
 end
 
 if (dounderlay)
 set(imax, 'Color', 'none');
 else
 set(imax, 'Color', 'k');
 end
 
 if (\~isempty(aviobj) \|\| \~isempty(vidObj))
 if (isempty(avirect))
 F \= getframe(gcf);
 else
 F \= getframe(gcf, avirect);
 end 
 if (\~isempty(aviobj))
 aviobj \= addframe(aviobj, F);
 end
 if (\~isempty(vidObj))
 writeVideo(vidObj,F);
 end
 else
 
 timeleft \= delayTime \- toc(ts1\);
 if (timeleft \> 0\)
 pause(timeleft);
 else
 pause(0\.001\);
 end
 if (\~isempty(frameRate))
 vidTime \= toc(ts0\);
 if (vidTime \> 2\) %update frame rate every 2 seconds
 fr \= nframes/vidTime;
 nframes \= 0;
 ts0 \= tic();
 if (fr \< frameRate)
 delayTime \= 0\.001;
 skipCount \= skipCount \* min(2,frameRate/fr);
 else
 skipCount \= max(1,skipCount \* frameRate/fr);
 if (skipCount \=\= 1\)
 delayTime \= 1/frameRate;
 end
 end
 end
 end
 end
 
end
%{
drawtime
tracktime
otherplotstime
%}
end

function datafields(track, inds, dataaxes, fontsize)
 thetafield \= 'sspineTheta';
% if (false \&\& strcmpi (track.so.method,'new'))
% fields \= {thetafield,track.so.speed\_field,'spheadperp'};
% ftitles \= {'Bondy Bend Angle', track.so.speed\_field, 'vhead perp'};
% mult \= \[rad2deg(1\), 1, 1];
% else
% fields \= {thetafield,track.so.speed\_field,'vel\_dp'};
% ftitles \= {'Bondy Bend Angle', track.so.speed\_field, 'Velocity Dot Product'};
% mult \= \[rad2deg(1\), 1, 1];
% end

 fields \= {thetafield, 'vel\_dp', track.so.speed\_field };
 ftitles \= {'$\\theta body $', '$\\hat{v}{\\cdot}\\hat{h}$',{'speed', 'cm/min'}};
 mult \= \[180/pi 1 60];
 
 
 if (isempty(track.run) \|\| isempty(track.reorientation) \|\| isempty(track.headSwing))
 start \= {\[],\[],\[],\[]};
 stop \= {\[],\[],\[],\[]};
 else

 start{1} \= \[track.run.startInd];
 stop{1} \= \[track.run.endInd];
 start{2} \= \[track.reorientation(\[track.reorientation.numHS] \>\= 0\).startInd];
 stop{2} \= \[track.reorientation(\[track.reorientation.numHS] \>\= 0\).endInd];
 start{3} \= \[track.headSwing(\[track.headSwing.accepted]).startInd];
 stop{3} \= \[track.headSwing(\[track.headSwing.accepted]).endInd];
 start{4} \= \[track.headSwing(\~\[track.headSwing.accepted]).startInd];
 stop{4} \= \[track.headSwing(\~\[track.headSwing.accepted]).endInd];
 end

 %fn \= {'run', 'turn', 'ahs', 'rhs'};
 col \= {\[0\.6 0\.6 .9], \[1 1 1], \[0\.7 1 0\.7],\[1 0\.7 0\.7]};
 
 for j \= 1:length(start)
 if (isempty(start{j}) \|\| isempty(stop{j}))
 continue;
 end
 start{j} \= start{j}(start{j} \> inds(1\));
 stop{j} \= stop{j}(stop{j} \> start{j}(1\) \& stop{j} \< inds(end));
 start{j} \= start{j}(start{j} \< stop{j}(end));
 end
 
 eti \= track.getDerivedQuantity('eti');
 for k \= 1:3
 for m \= 1:length(start)
 yl \= \[min(mult(k)\*track.dq.(fields{k})(inds)) max(mult(k)\*track.dq.(fields{k})(inds))];
 dy \= diff(yl)/25;
 
 si \= eti(start{m});
 ei \= eti(stop{m});
 c \= col{m};
 for j \= 1:length(si)
 patch(\[si(j) ei(j) ei(j) si(j) si(j)], \[yl(1\) yl(1\) yl(2\) yl(2\) yl(1\)], c, 'EdgeColor', 'none', 'Parent', dataaxes(k)); hold(dataaxes(k), 'on');
 end
 end

 
 plot (dataaxes(k), track.dq.eti(inds), mult(k)\*track.dq.(fields{k})(inds), 'k\-', 'LineWidth', 2\); hold(dataaxes(k), 'on');
 
 ylabel(dataaxes(k), ftitles{k}, 'Interpreter', 'Latex', 'FontSize', fontsize, 'FontName', 'Arial');
 end
 
 spfields \= {{'theta\_cut', 'headswing\_start', 'headswing\_stop'}, {'aligned\_dp'},{'stop\_speed\_cut', 'start\_speed\_cut'}};
 spcolors \= {{'m\-','g\-','r\-'}, {'m\-'},{'r\-', 'g\-'}};
 spmirror \= \[1 0 0];
 
 for k \= 1:3
 
 x \= track.dq.eti(inds);
 for j \= 1:length(spfields{k})
 f \= spfields{k}{j};
 c \= spcolors{k}{j};
 y \= repmat (mult(k)\*track.so.(f), size(x));
 plot (dataaxes(k), x,y,c);
 if (spmirror(k));
 plot (dataaxes(k), x,\-y,c);
 end
 yl \= \[min(mult(k)\*track.dq.(fields{k})(inds)) max(mult(k)\*track.dq.(fields{k})(inds))];
 dy \= diff(yl)/25;
 ylim(dataaxes(k), yl \+ dy\*\[\-1 1]);
 set(dataaxes(k), 'box', 'on');
 end
 end
 p \= get(dataaxes(1\), 'position');
 py \= \-0\.95\*p(2\)/p(4\);
 hx \= xlabel(dataaxes(1\), 'time (s)');
 set(hx, 'Units', 'normalized');
 p \= get(hx, 'position');
 p(2\) \= py;
 set (hx, 'position', p, 'VerticalAlignment', 'bottom');
end

function handles \= updateCenter(handles, track, cind, start, stop, dataaxes)
 thetafield \= 'sspineTheta';
 if \~isempty(handles)
 for j \= 1:length(handles)
 delete(handles(j));
 end
 end
 fields \= {thetafield, 'vel\_dp', track.so.speed\_field };
 % ftitles \= {'$\\theta\_{body}$', '$\\hat{v}\\cdot\\hat{h}$','speed (cm/min)' };
 mult \= \[180/pi 1 60];
 
 for k \= 1:3
 %subplot(2,2,k\+1\); hold on
 hold(dataaxes(k), 'on');
 handles(k) \= plot (dataaxes(k), track.dq.eti(cind), mult(k)\*track.dq.(fields{k})(cind), 'c.','MarkerSize',25\);
 xlim(dataaxes(k), \[min(track.dq.eti(start)) max(track.dq.eti(stop))]); 
 end
end 

function \[imax, dataaxes, underlayax] \= setupFigure(fignum, resizefig, makeunderlay)
 existsAndDefault('fignum', gcf);
 existsAndDefault('makeunderlay', false);
 existsAndDefault('resizefig', true);
 clf(fignum);
 if (resizefig)
 p \= get(fignum, 'position');
 pold \= p;
 p(3\) \= p(4\) \* 8/3;
 p(1\) \= max(1/2\*(pold(3\)\-p(3\)) \+ p(1\), 0\);
 set(fignum, 'position', p);
 end
 h \= 0\.8;
 w \= h \* 3/8;
 if (makeunderlay)
 underlayax \= axes('position', \[(.5\-w)/2 (1\-h)/2 w h], 'Parent', fignum, 'XTick', \[], 'YTick', \[], 'Color', 'k');
 imax \= axes('position', \[(.5\-w)/2 (1\-h)/2 w h], 'Parent', fignum, 'Color', 'none', 'XTick', \[], 'YTick', \[]);
 else
 imax \= axes('position', \[(.5\-w)/2 (1\-h)/2 w h], 'Parent', fignum, 'XTick', \[], 'YTick', \[], 'Color', 'k');
 underlayax \= \[];
 end
 h \= 0\.9;
 w \= 0\.45;
 for j \= 1:3
 dataaxes(j) \= axes('position', \[.5\+(.5\-w)/2 0\.9\*(1\-h)\+(j\-1\)\*h/3 w h/3\.1], 'Parent', fignum); %\#ok
 end
 for j \= 2:3
 set(dataaxes(j), 'XTickLabel', \[]);
 end
end




\-\-\-

\#\#\# File: toMWTTrackFile.m (ID: @MaggotTrack.7\)

function toMWTTrackFile (track, filestub, varargin) %writes a .blob file for 1 track
%function toMWTTrackFile (track, filestub, varargin) %writes a .blob file for 1 track
%
%writes track to an MWT blob file
%track \< MaggotTrack
%filestub \- everything before the \_NNNNN.blob in the blob file name (incl.
% directory)
%

if (length(track) \> 1\)
 for j \= 1:length(track)
 track(j).toMWTTrackFile(filestub, varargin{:});
 end
 return;
end

% if (track.nt \> 1\) 
% pt \= fillInBlanks(track.pt);
% else
% pt \= track.pt;
% end
pt \= track.pt;
valid \= \[pt.area] \>\= 0\.4 \* \[pt.targetArea];
if (mean(valid) \< 0\.8\)
 valid \= \[pt.area] \> 20; %minimum 20 pixels in area
 if (mean(valid) \< 0\.8\)
 warning ('MGT:TOMWTTRACK', \['a large number of points in track ' num2str(track.trackNum) ' fall below threshold area']);
 return;
 end
end
pt \= fillInBlanks(pt(valid));
fid \= fopen (\[filestub sprintf('\_%05d.blob', track.trackNum)], 'wt');
if(isempty(track.expt))
 cc \= \[];
else
 cc \= track.expt.camcalinfo;
end
for j \= 1:length(pt)
 fprintf(fid, '%s\\n', pt(j).toMWTBlobLine(cc));
end
fclose(fid);

function pt \= fillInBlanks(pt)

while (any (diff(\[pt.ind]) \> 1\))
 \[\~,I] \= find(diff(\[pt.ind]) \> 1, 1, 'first');
 npts \= double(pt(I\+1\).ind\-pt(I).ind \- 1\);
 newpt \= repmat(pt(I), 1, npts);
 for j \= double(1:npts)
 newpt(j).ind \= pt(I).ind \+ j;
 newpt(j).loc \= (pt(I).loc \*(npts\+1\-j)\+pt(I\+1\).loc \*(j))/(npts\+1\);
 end
 pt \= \[pt(1:I) newpt pt((I\+1\):end)];
end

\-\-\-

\#\#\# File: playMovie\_BehaviorTriggered.m (ID: @MaggotTrack.8\)

function playMovie\_BehaviorTriggered(track, fieldName,fieldDescription, displacementAxis, triggeredSum, triggeredInd, figTitle, varargin)
%@MaggotTrack
%playMovie(track, varargin)
%enter options as pairs, caps matter
%options, with defaults
%
%frameRate \= \[];
%ptbuffer \= 1000;
%delayTime \= 0\.05;
%axisSize (3 \* length of larva)
%inds \= 1:length(track.pt);
%startLoc \= \[]; \> if startLoc \& stopLoc are not empty, we run the movie
%between these two points
%stopLoc \= \[]; \>
%startTime \= \[]; if startTime and stopTime are not empty, re run the movie
%between these two times
%stopTime \= \[];
%vidObj \= \[];
%aviobj \= \[];
%avirect \= \[];
%resizefig \= true;
%figcolor \= 'w';
%fontcolor \= 'k';
%underlayTemporalField \= ''; boolean true if on
%underlayTemporalOnColor \= \[0 0\.8 0\.8];
%underlayTemporalOffColor \= \[0 0 0];
%underlayTemporalOnMessage \= 'Light on';
%underlayTemporalOffMessage \= 'Light off';
%rect \= \[];
%mark\_size \= 5

%pass 'fid', \[] to not load images from disk
%ptskip, \[] \-\- if not empty we sample pts at this interval 
if (length(track) \> 1\)
 for j \= 1:length(track)
 track(j).playMovie(varargin{:});
 end
 return;
end
frameRate \= \[]; %override frameRate to set a target frame rate
stretchReos \= false; %if skipping frames due to frame rate, then don't skip reorientation frames

ptbuffer \= ceil(40/track.dr.interpTime);
delayTime \= max(track.dr.interpTime/4\-0\.1, 0\.01\);
%set(0,'DefaultTextInterpreter', 'Latex');
if (isempty(track.expt) \|\| isempty(track.expt.camcalinfo))
 mf \= 1;
else
 mf \= track.expt.camcalinfo.realUnitsPerPixel;
end
%axisSize \= mf\*max(size(track.pt(1\).imData));
sl \= track.getDerivedQuantity('spineLength');
axisSize \= 3\*median(sl(:,track.getDerivedQuantity('ihtValid')));
if (axisSize \<\= 0\)
 try 
 track.expt.openDataFile();
 pttemp \= track.expt.reloadPoint(track.pt(1\));
 axisSize \= mf\*max(size(pttemp.imData));
 catch
 end
end


if (axisSize \<\= 0 \|\| \~isfinite(axisSize))
 %axisSize \= 50;
 axisSize \= 8 \* mean(track.getDerivedQuantity('speed'));
 
end
ptskip \= \[];
iinds \= \[];
inds \= 1:length(track.pt);
startLoc \= \[];
stopLoc \= \[];
startTime \= \[];
stopTime \= \[];
vidObj \= \[];
aviobj \= \[];
avirect \= \[];
resizefig \= true;
figcolor \= 'w';
fontcolor \= 'k';
scalebar \= false;
mark\_size \= 5;

if (\~isempty(track.expt))
 track.expt.openDataFile;
 fid \= track.expt.fid;
else
 fid \= \[];
end
if (isa(track.pt(1\), 'MWTTrackPoint'))
 imOptions \= {'pretty', true, 'drawHeadArrow', true, 'spineColor', 'y.','contourColor', 'm\-', 'contourWidth', 1, 'scale', 1, 'drawContour', true, 'drawSpine', true};%'drawContour', true, 'scale', 1,'contourColor', 'r\-', 'LineWidth', 1, 'mhWidth', 1};
else
 imOptions \= {'pretty', true, 'drawHeadArrow', false, 'spineColor', 'y.','contourColor', 'c.', 'contourWidth', 1, 'scale', 1, 'drawContour', false, 'drawSpine', true};%'drawContour', true, 'scale', 1,'contourColor', 'r\-', 'LineWidth', 1, 'mhWidth', 1};
end

underlayImData \= \[];
overlayImData \= \[];
underlayTemporalField \= '';
underlayTemporalOnColor \= \[0 1 1];
underlayTemporalOffColor \= \[0 0 0];
underlayTemporalOnMessage \= 'Light on';
underlayTemporalOffMessage \= 'Light off';
rect \= \[];
fixedrect \= false;
varargin \= assignApplicable(varargin);
if (\~isempty(iinds))
 inds \= track.getDerivedQuantity('mapinterpedtopts', false,iinds);
end
if (\~isempty(ptskip))
 inds \= inds(1\):ptskip:inds(end);
end
if (\~isempty(startLoc) \&\& \~isempty(stopLoc))
 \[\~,s] \= track.nearestPoint (startLoc);
 \[\~,e] \= track.nearestPoint (stopLoc);
 if (s \> e)
 inds \= e:s;
 else
 inds \= s:e;
 end
end
if (\~isempty(startTime) \&\& \~isempty(stopTime))
 pt \= \[track.pt];
 inds \= find(\[pt.et] \>\= startTime, 1, 'first'):find(\[pt.et] \<\= stopTime, 1, 'last');
end
pt \= \[track.pt];
loc \= \[pt.loc];
sloc \= track.getDerivedQuantity('sloc');
sind \= track.getDerivedQuantity('mapptstointerped');
track.calculateDerivedQuantity({'sbodytheta', 'speed', 'vel\_dp', 'dsbodytheta', 'spheadperp', 'sspineTheta'});

 
%pt \= \[track.pt];
sstart \= sind(1\) \- ptbuffer;
send \= sind(end) \+ ptbuffer;
if (sstart \< 1\)
 sstart \= 1;
end
if (send \> length(sloc))
 send \= length(sloc);
end

%dounderlay \= \~isempty(underlayImData);
dounderlay \= false;
\[imax, dataaxes, underlayax] \= setupFigure(gcf, resizefig,dounderlay);

u \= get(imax, 'units');
set(imax, 'units', 'pixels');
imh \= get(imax, 'position');
imh \= imh(4\);
fontsize \= .04 \* imh;
set(imax, 'units', u);
%set(gcf, 'DefaultAxesColor', 'w', 'DefaultTextColor', 'k');
set(gcf, 'Color', figcolor);
%set(imax, 'Color', 'k');
set(dataaxes, 'XColor', fontcolor, 'YColor', fontcolor, 'FontSize', fontsize\-2\)
datafields(track, sstart:send, dataaxes, fontsize, fieldName, fieldDescription, displacementAxis, triggeredSum);

% if (dounderlay)
% % set(pcolor (underlayax, underlayImData.x, underlayImData.y, underlayImData.im), 'FaceAlpha', 0\.4, 'EdgeColor', 'none');
% imagesc(underlayImData.x, underlayImData.y, double(underlayImData.im), 'Parent', underlayax);
% imOptions \= \[imOptions {'patchOptions', {'AlphaData', 0\.4}}];
% axis(underlayax, 'equal'); axis(underlayax, 'xy'); axis(underlayax, 'off');
% else
% overlayax \= \[];
% end

handles \= \[];
if (isempty(track.expt))
 ccinfo \= \[];
else
 ccinfo \= track.expt.camcalinfo;
end
eti \= track.getDerivedQuantity('eti');
temporalunderlay \= false;
if (\~isempty(underlayTemporalField))
 temporalFieldData \= logical(setNonFiniteToZero(track.getDerivedQuantity(underlayTemporalField)));
 temporalunderlay \= true;
end

if (fixedrect \&\& isempty(rect))
 plot (imax, loc(1,inds) \- axisSize/2, loc(2,inds) \- axisSize/2, loc(1,inds) \+ axisSize/2, loc(2,inds) \+ axisSize/2\);
 axis(imax, 'equal');
 rect \= \[get(imax, 'xlim') get(imax, 'ylim')];
 ll \= min(loc(:,inds),\[],2\);% \- axisSize/2;
 ur \= max(loc(:,inds),\[],2\);% \+ axisSize/2;
 
 if (ll(1\) \< rect(1\) \|\| ur(1\) \> rect(2\))
 rect(1:2\) \= rect(1:2\) \+ mean(\[ll(1\) ur(1\)]) \- mean(rect(1:2\));
 end
 if (ll(2\) \< rect(3\) \|\| ur(2\) \> rect(4\))
 rect(3:4\) \= rect(3:4\) \+ mean(\[ll(2\) ur(2\)]) \- mean(rect(3:4\));
 end
 cla(imax);
 
end

if (\~isempty(underlayImData))
 if (isempty(rect))
 ll \= min(loc(:,inds),\[],2\);% \- axisSize/4;
 ur \= max(loc(:,inds),\[],2\);% \+ axisSize/4;
 else
 ll \= \[rect(1\) rect(3\)];
 ur \= \[rect(2\) rect(4\)];
 end
 xv \= find(underlayImData.x \>\= ll(1\) \& underlayImData.x \<\= ur(1\));
 yv \= find(underlayImData.y \>\= ll(2\) \& underlayImData.y \<\= ur(2\));
 % \[xx,yy] \= meshgrid(xv,yv);
 underlayImData.x \= underlayImData.x(xv);
 underlayImData.y \= underlayImData.y(yv);
 underlayImData.im \= underlayImData.im(yv,xv,:);
 imOptions \= \[imOptions, {'underlayImData', underlayImData}];
 size(underlayImData.im)
end

ts0 \= tic();
nframes \= 0;
skipCount \= 1;
%if (\~isempty(frameRate) \&\& stretchReos)
 % disp ('stretching reorientations out to slow speed; runs will animate faster');
%end
axes(imax); axis xy;
triggeredInd \= track.getDerivedQuantity('mapinterpedtopts', false, triggeredInd);
triggeredInd \= sort(triggeredInd, 'ascend');
triggeredInd \= triggeredInd(triggeredInd \> inds(1\));
for j \= inds
 nframes \= nframes \+ 1;
 I \= find(\[track.reorientation.startInd] \<\= sind(j) \& \[track.reorientation.endInd] \>\= sind(j), 1, 'first');
 if ((mod(nframes, skipCount) \>\= 1\) \&\& \~(stretchReos \&\& \~isempty(I)))
 continue;
 end
 ts1 \= tic();
 hold (imax,'off'); 
 cla(imax); 
 % set(imax, 'Color', 'k');
 if (isempty(rect))
 imrect \= \[loc(1,j) \+ \[\-axisSize/2 axisSize/2], loc(2,j) \+ \[\-axisSize/2 axisSize/2]];
 else
 imrect \= rect;
 end
 if (temporalunderlay)
 if (\~isempty(ccinfo))
 uid.x \= imrect(1\):ccinfo.realUnitsPerPixel:imrect(2\);
 uid.y \= imrect(3\):ccinfo.realUnitsPerPixel:imrect(4\); 
 else
 uid.x \= round(imrect(1\)):round(imrect(2\));
 uid.y \= round(imrect(3\)):round(imrect(4\));
 end
 uid.im \= ones(\[length(uid.y) length(uid.x) 3]);
 for k \= 1:3
 if (temporalFieldData(sind(j)))
 uid.im(:,:,k) \= underlayTemporalOnColor(k);
 else
 uid.im(:,:,k) \= underlayTemporalOffColor(k);
 end
 end
 pt(j).drawTrackImage(ccinfo,'fid', fid, 'Axes', imax, imOptions{:}, 'underlayImData', uid, 'underlayScale', 0\.6\);
 else
 pt(j).drawTrackImage(ccinfo,'fid', fid, 'Axes', imax, imOptions{:}); 
 set(imax, 'YDir', 'normal');
 end
 hold (imax, 'on');
 
 sstart \= sind(j) \- ptbuffer;
 send \= sind(j) \+ ptbuffer;
 if (sstart \< 1\)
 sstart \= 1;
 end
 if (send \> length(sloc))
 send \= length(sloc);
 end
 
 
 
 
 plot (imax,sloc(1,sstart:send), sloc(2,sstart:send), 'w.\-', 'MarkerSize', mark\_size);
% plot (imax, sloc(1, sstart:(1/track.dr.interpTime):send), sloc(2, sstart:(1/track.dr.interpTime):send), 'w.');
 plot (imax,sloc(1,sind(j)), sloc(2,sind(j)), 'wo', 'MarkerSize', mark\_size);
 
 axis (imax,imrect);
 axis (imax,'equal'); 
 axis (imax,imrect);
 
 set(imax, 'XTick', \[], 'YTick', \[]);%, 'Color', 'k');
 if (scalebar \&\& \~isempty(ccinfo))
 sbsize \= double(ceil(axisSize \* 2\.5\));
 xl \= get(imax, 'XLim');
 yl \= get(imax, 'YLim');
 sbx \= xl(2\) \+ \[\-1\.1 \-0\.1]\*sbsize/10;
 sby \= yl(1\)\*0\.95 \+ yl(2\)\*0\.05;
 plot (imax, sbx, \[sby sby], 'w\-', 'LineWidth', 4\);
 text (mean(sbx), yl(1\)\*0\.94 \+ yl(2\)\*0\.06, \[num2str(sbsize) ' mm'], 'Color', 'w',...
 'Interpreter', 'Tex', 'Parent', imax, 'FontName', 'Arial', 'FontSize', fontsize, 'HorizontalAlignment', 'center', 'VerticalAlignment', 'bottom',...
 'BackgroundColor', 'k');
 end
 hold (imax,'off');
 xl \= get(imax, 'XLim');
 xl \= xl(1\)\*0\.99 \+ xl(2\)\*0\.01;
 yl \= get(imax, 'YLim');
 yl \= yl(1\)\*0\.01 \+ yl(2\)\*0\.99;
 t \= {\['\\color{orange}time \= ' num2str(eti(sind(j)), '%.1f')]};
 if (temporalunderlay)
 if (temporalFieldData(sind(j)))
 t \= \[t '\\color{white}' underlayTemporalOnMessage];
 else
 t \= \[t '\\color{white}' underlayTemporalOffMessage];
 end
 end
 if (\~isempty(track.run))
 
 
 I \= find(\[track.run.startInd] \<\= sind(j) \& \[track.run.endInd] \>\= sind(j), 1, 'first');
 %col \= {\[0\.6 0\.6 .9], \[1 1 1], \[0\.7 1 0\.7],\[1 0\.7 0\.7]};
 
 if (\~isempty(I))
 t \= \[t \['\\color\[rgb]{0\.6 0\.6 0\.9}run, \\tau \= ' num2str(track.run(I).runTime,'%.1f') ' s, L \= ' num2str(track.run(I).pathLength, '%.1f') ' cm']];
 end
 
 I \= find(\[track.reorientation.startInd] \<\= sind(j) \& \[track.reorientation.endInd] \>\= sind(j), 1, 'first');
 if (\~isempty(I))
 if (track.reorientation(I).numHS \=\= 0\)
 t \= \[t \['\\color{white}pause, \\Delta\\theta \= ' num2str(rad2deg(diff(unwrap(\[track.reorientation(I).prevDir;track.reorientation(I).nextDir]))), '%.1f')]];
 else
 t \= \[t \['\\color{white}turn, \\Delta\\theta \= ' num2str(rad2deg(diff(unwrap(\[track.reorientation(I).prevDir;track.reorientation(I).nextDir]))), '%.1f')]];
 end
 end
 
 I \= find(\[track.headSwing.startInd] \<\= sind(j) \& \[track.headSwing.endInd] \>\= sind(j), 1, 'first');
 if (\~isempty(I))
 if (\~track.headSwing(I).valid)
 inv \= ' \*invalid';
 else
 inv \= '';
 end
 if (track.headSwing(I).accepted)
 t \= \[t '\\color\[rgb]{0\.7 1 0\.7}accepted head sweep' inv];
 else
 t \= \[t '\\color\[rgb]{1 0\.7 0\.7}rejected head sweep' inv];
 end
 end
 end
 if (\~isempty(t))
 text(xl, yl, t, 'Interpreter', 'Tex', 'Parent', imax, 'FontName', 'Arial', 'FontSize', fontsize, 'HorizontalAlignment', 'Left', 'VerticalAlignment', 'Top', 'BackgroundColor', 'k');
 end
 
 handles \= updateCenter(handles, track, sind(j), find(track.dq.eti \< track.dq.eti(sind(j)) \+ displacementAxis(1\), 1, 'last'), find(track.dq.eti \> track.dq.eti(sind(j)) \+ displacementAxis(end), 1, 'first'), dataaxes);
 if (\~isempty(underlayax))
 set(underlayax, 'Position', get(imax, 'position'), 'XLim', get(imax, 'XLim'), 'YLim', get(imax, 'YLim')); 
 end
 
 if (dounderlay)
 set(imax, 'Color', 'none');
 else
 set(imax, 'Color', 'k');
 end
 if (\~isempty(figTitle))
 title(imax, figTitle,'FontName', 'Arial', 'FontSize', fontsize);
 end
 triggeredInd \= triggeredAnimation(track, triggeredInd, j, dataaxes, fieldName, displacementAxis, triggeredSum, aviobj, vidObj);
 
 
 if (\~isempty(aviobj) \|\| \~isempty(vidObj))
 if (isempty(avirect))
 F \= getframe(gcf);
 else
 F \= getframe(gcf, avirect);
 end 
 if (\~isempty(aviobj))
 aviobj \= addframe(aviobj, F);
 end
 if (\~isempty(vidObj))
 writeVideo(vidObj,F);
 end
 else
 
 timeleft \= delayTime \- toc(ts1\);
 if (timeleft \> 0\)
 pause(timeleft);
 else
 pause(0\.001\);
 end
 if (\~isempty(frameRate))
 vidTime \= toc(ts0\);
 if (vidTime \> 2\) %update frame rate every 2 seconds
 fr \= nframes/vidTime;
 nframes \= 0;
 ts0 \= tic();
 if (fr \< frameRate)
 delayTime \= 0\.001;
 skipCount \= skipCount \* min(2,frameRate/fr);
 else
 skipCount \= max(1,skipCount \* frameRate/fr);
 if (skipCount \=\= 1\)
 delayTime \= 1/frameRate;
 end
 end
 end
 end
 end
 
 
 
end
%{
drawtime
tracktime
otherplotstime
%}
end

function datafields(track, inds, dataaxes, fontsize, fieldName, fieldDescription, displacementAxis, triggeredSum)
 thetafield \= 'sspineTheta';
% if (false \&\& strcmpi (track.so.method,'new'))
% fields \= {thetafield,track.so.speed\_field,'spheadperp'};
% ftitles \= {'Bondy Bend Angle', track.so.speed\_field, 'vhead perp'};
% mult \= \[rad2deg(1\), 1, 1];
% else
% fields \= {thetafield,track.so.speed\_field,'vel\_dp'};
% ftitles \= {'Bondy Bend Angle', track.so.speed\_field, 'Velocity Dot Product'};
% mult \= \[rad2deg(1\), 1, 1];
% end

 fields \= {thetafield, track.so.speed\_field, fieldName};
 ftitles \= {'$\\theta body $',{'speed', 'cm/min'}, fieldDescription};
 mult \= \[180/pi 60 1];
 
 
 if (isempty(track.run) \|\| isempty(track.reorientation) \|\| isempty(track.headSwing))
 start \= {\[],\[],\[],\[]};
 stop \= {\[],\[],\[],\[]};
 else

 start{1} \= \[track.run.startInd];
 stop{1} \= \[track.run.endInd];
 start{2} \= \[track.reorientation(\[track.reorientation.numHS] \>\= 0\).startInd];
 stop{2} \= \[track.reorientation(\[track.reorientation.numHS] \>\= 0\).endInd];
 start{3} \= \[track.headSwing(\[track.headSwing.accepted]).startInd];
 stop{3} \= \[track.headSwing(\[track.headSwing.accepted]).endInd];
 start{4} \= \[track.headSwing(\~\[track.headSwing.accepted]).startInd];
 stop{4} \= \[track.headSwing(\~\[track.headSwing.accepted]).endInd];
 end

 %fn \= {'run', 'turn', 'ahs', 'rhs'};
 col \= {\[0\.6 0\.6 .9], \[1 1 1], \[0\.7 1 0\.7],\[1 0\.7 0\.7]};
 
 for j \= 1:length(start)
 if (isempty(start{j}) \|\| isempty(stop{j}))
 continue;
 end
 start{j} \= start{j}(start{j} \> inds(1\));
 stop{j} \= stop{j}(stop{j} \> start{j}(1\) \& stop{j} \< inds(end));
 start{j} \= start{j}(start{j} \< stop{j}(end));
 end
 
 eti \= track.getDerivedQuantity('eti');
 
 plot (dataaxes(1\), displacementAxis, triggeredSum, 'k\-', 'LineWidth', 2\);
 set (dataaxes(1\), 'YTick', \[]);
 ylabel(dataaxes(1\), \['$\\langle$' fieldDescription '$\\rangle$'], 'Interpreter', 'Latex', 'FontSize', fontsize, 'FontName', 'Arial');
 yl \= get(dataaxes(1\), 'YLim'); ylim(dataaxes(1\), \[\-1 1] \* max(abs(yl)));
 for k \= 1:2
 for m \= 1:length(start)
 yl \= \[min(mult(k)\*track.dq.(fields{k})(inds)) max(mult(k)\*track.dq.(fields{k})(inds))];
 
 
 si \= eti(start{m});
 ei \= eti(stop{m});
 c \= col{m};
 for j \= 1:length(si)
 patch(\[si(j) ei(j) ei(j) si(j) si(j)], \[yl(1\) yl(1\) yl(2\) yl(2\) yl(1\)], c, 'EdgeColor', 'none', 'Parent', dataaxes(k\+1\)); hold(dataaxes(k\+1\), 'on');
 end
 end

 
 plot (dataaxes(k\+1\), track.dq.eti(inds), mult(k)\*track.dq.(fields{k})(inds), 'k\-', 'LineWidth', 2\); hold(dataaxes(k), 'on');
 
 ylabel(dataaxes(k\+1\), ftitles{k}, 'Interpreter', 'Latex', 'FontSize', fontsize, 'FontName', 'Arial');
 end
 
 k \= 3;
 plot (dataaxes(k\+1\), track.dq.eti(inds), mult(k)\*track.dq.(fields{k})(inds), 'k\-', 'LineWidth', 2\); hold(dataaxes(k), 'on');
 
 ylabel(dataaxes(k\+1\), ftitles{k}, 'Interpreter', 'Latex', 'FontSize', fontsize, 'FontName', 'Arial');
 
 set(dataaxes(4\), 'YTick', \[], 'XTickLabel', \[]);
 
 spfields \= {{'theta\_cut', 'headswing\_start', 'headswing\_stop'},{'stop\_speed\_cut', 'start\_speed\_cut'}, {}};
 spcolors \= {{'m\-','g\-','r\-'},{'r\-', 'g\-'}, {}};
 spmirror \= \[1 0 0];
 
 for k \= 1:3
 
 x \= track.dq.eti(inds);
 for j \= 1:length(spfields{k})
 f \= spfields{k}{j};
 c \= spcolors{k}{j};
 y \= repmat (mult(k)\*track.so.(f), size(x));
 plot (dataaxes(k\+1\), x,y,c);
 if (spmirror(k));
 plot (dataaxes(k\+1\), x,\-y,c);
 end
 yl \= \[min(mult(k)\*track.dq.(fields{k})(inds)) max(mult(k)\*track.dq.(fields{k})(inds))];
 dy \= diff(yl)/25;
 ylim(dataaxes(k\+1\), yl \+ dy\*\[\-1 1]);
 set(dataaxes(k\+1\), 'box', 'on');
 end
 if (k \=\= 3\)
 ylim(dataaxes(k\+1\), \[\-1 1]\*percentile(abs(track.dq.(fields{k})), .99\));
 end
 end
 p \= get(dataaxes(2\), 'position');
 py \= \-0\.95\*p(2\)/p(4\);
 hx \= xlabel(dataaxes(1\), 'time (s)');
 set(hx, 'Units', 'normalized');
 p \= get(hx, 'position');
 p(2\) \= py;
 set (hx, 'position', p, 'VerticalAlignment', 'bottom');
end

function handles \= updateCenter(handles, track, cind, start, stop, dataaxes)
 thetafield \= 'sspineTheta';
 if \~isempty(handles)
 for j \= 1:length(handles)
 delete(handles(j));
 end
 end
 
 fields \= {thetafield, track.so.speed\_field};
 mult \= \[180/pi 60];
 
 for k \= 1:3
 %subplot(2,2,k\+1\); hold on
 hold(dataaxes(k\+1\), 'on');
 if (k \=\= 3\)
 handles(k) \= plot (dataaxes(k\+1\), track.dq.eti(cind)\*\[1 1], get(dataaxes(k\+1\), 'YLim'), 'c\-\-','LineWidth',4\);
 else
 handles(k) \= plot (dataaxes(k\+1\), track.dq.eti(cind), mult(k)\*track.dq.(fields{k})(cind), 'c.','MarkerSize',25\);
 end
 if (isempty(start))
 start \= 1;
 end
 if (isempty(stop))
 stop \= length(track.dq.eti);
 end
 xlim(dataaxes(k\+1\), \[min(track.dq.eti(start)) max(track.dq.eti(stop))]); 
 end
 
end 

function \[imax, dataaxes, underlayax] \= setupFigure(fignum, resizefig, makeunderlay)
 existsAndDefault('fignum', gcf);
 existsAndDefault('makeunderlay', false);
 existsAndDefault('resizefig', true);
 clf(fignum);
 if (resizefig)
 p \= get(fignum, 'position');
 pold \= p;
 p(3\) \= p(4\) \* 8/3;
 p(1\) \= max(1/2\*(pold(3\)\-p(3\)) \+ p(1\), 0\);
 set(fignum, 'position', p);
 end
 h \= 0\.8;
 w \= h \* 3/8;
 if (makeunderlay)
 underlayax \= axes('position', \[(.5\-w)/2 (1\-h)/2 w h], 'Parent', fignum, 'XTick', \[], 'YTick', \[], 'Color', 'k');
 imax \= axes('position', \[(.5\-w)/2 (1\-h)/2 w h], 'Parent', fignum, 'Color', 'none', 'XTick', \[], 'YTick', \[]);
 else
 imax \= axes('position', \[(.5\-w)/2 (1\-h)/2 w h], 'Parent', fignum, 'XTick', \[], 'YTick', \[], 'Color', 'k');
 underlayax \= \[];
 end
 h \= 0\.9;
 w \= 0\.45;
 for j \= 1:4
 dataaxes(j) \= axes('position', \[.5\+(.5\-w)/2 0\.9\*(1\-h)\+(j\-1\)\*h/4 w h/4\.1], 'Parent', fignum); %\#ok
 end
 for j \= 2:4
 set(dataaxes(j), 'XTickLabel', \[]);
 end
end

function triggeredInd \= triggeredAnimation(track, triggeredInd, cind, dataaxes, fieldName, displacementAxis, triggeredSum, aviobj, vidObj)
 persistent triggered bc1 c0 p0 xl0 xd0;
 maxcount \= 30;
 
 if (isempty(triggeredInd) \|\| cind \< min(triggeredInd))
 triggered \= false;
 return;
 end
 
 count \= cind \- min(triggeredInd);
 if (count \> maxcount)
 c \= get(dataaxes(end), 'Children'); 
 set(dataaxes(end), 'Position', p0, 'Color', bc1\);
 set(c(end), 'Color', c0\);
 triggeredInd \= triggeredInd(triggeredInd \> cind);
 triggered \= false;
 return;
 end
 
 
 
 transitioncount \= 20;
 c \= get(dataaxes(end), 'Children'); 
 if (\~triggered)
 bc1 \= get(dataaxes(end), 'Color'); 
 c0 \= get(c(end), 'Color');
 xd0 \= get(c(1\), 'XData');
 p0 \= get(dataaxes(end), 'position');
 xl0 \= get(dataaxes(end), 'XLim');
 triggered \= true;
 end
 set(c(1\), 'XData', xd0\);
 set(dataaxes(end), 'Color', 'none','XTickLabel', \[]);
 set(c(end), 'Color', 'r');
 pf \= get(dataaxes(1\), 'position');
 cc \= min(count, transitioncount);
 ind0 \= find(track.getDerivedQuantity('eti') \>\= track.pt(cind\-count).et,1,'first');%track.getDerivedQuantity('mapptstointerped', false, cind\-count);
 
 set(dataaxes(end), 'Position', (cc\*pf \+ (transitioncount \- cc)\*p0\)/transitioncount, 'XLim', track.dq.eti(ind0\) \+ \[min(displacementAxis) max(displacementAxis)]);%, 'YLim', (j\*ylf \+ (nsteps \- j)\*yl0\)/nsteps);
 if (transitioncount \=\= count) 
 set(get(dataaxes(1\), 'Children'), 'YData', triggeredSum \+ interp1(track.dq.eti \- track.dq.eti(ind0\), track.dq.(fieldName), displacementAxis, 'linear', 0\));
 end
 %{
 else
 set(dataaxes(end), 'Position', p0, 'Color', bc1, 'YLim', yl0\);
 set(c(end), 'Color', c0\);
 set(get(dataaxes(1\), 'Children'), 'YData', triggeredSum \+ interp1(track.dq.eti \- track.dq.eti(cind), track.dq.(fieldName), displacementAxis, 'linear', 0\));
 end
%}
 %{
 for kk \= 1:nreps
 if (\~isempty(aviobj) \|\| \~isempty(vidObj))
 if (isempty(avirect))
 F \= getframe(gcf);
 else
 F \= getframe(gcf, avirect);
 end 
 if (\~isempty(aviobj))
 aviobj \= addframe(aviobj, F);
 end
 if (\~isempty(vidObj))
 writeVideo(vidObj,F);
 end
 else
 pause(1/30\);
 end
 end
 %}
 % end

end
\-\-\-

\#\#\# File: recalculateDerivedQuantities.m (ID: @MaggotTrack.9\)

function recalculateDerivedQuantities(track, varargin)
% clears and recalculates all derived quantities
% function recalculateDerivedQuantities(track, varargin)
% outputs: none
% inputs:
% TRACK \< MaggotTrack
% VARARGIN: if a list of field names is passed, only those fields are cleared
% and recalculated

recalculateDerivedQuantities@Track(track,varargin{:});
\-\-\-

\#\#\# File: playMovie\_old.m (ID: @MaggotTrack.10\)

function playMovie(track, varargin)
% one of several routines to play back track movies
%@MaggotTrack
%playMovie(track, varargin)
%enter options as pairs, caps matter
%options, with defaults
%
%ptbuffer \= 1000;
%delayTime \= 0\.05;
%axisSize (size of image or 120 \* mean speed)
%inds \= 1:length(track.pt);
%startLoc \= \[]; \> if startLoc \& stopLoc are not empty, we run the movie
%between these two points
%stopLoc \= \[]; \>
%startTime \= \[]; if startTime and stopTime are not empty, re run the movie
%between these two times
%stopTime \= \[];
%pass 'fid', \[] to not load images from disk


ptbuffer \= 200;
delayTime \= 0\.1;
set(0,'DefaultTextInterpreter', 'Latex');
if (isempty(track.expt.camcalinfo))
 mf \= 1;
else
 mf \= track.expt.camcalinfo.realUnitsPerPixel;
end
axisSize \= mf\*max(size(track.pt(1\).imData));
if (axisSize \<\= 0\)
 try 
 track.expt.openDataFile();
 pttemp \= track.expt.reloadPoint(track.pt(1\));
 axisSize \= mf\*max(size(pttemp.imData));
 catch
 end
end


if (axisSize \<\= 0\)
 %axisSize \= 50;
 axisSize \= 8 \* mean(track.getDerivedQuantity('speed'));
end
iinds \= \[];
inds \= 1:length(track.pt);
startLoc \= \[];
stopLoc \= \[];
startTime \= \[];
stopTime \= \[];
if (\~isempty(track.expt))
 track.expt.openDataFile;
 fid \= track.expt.fid;
else
 fid \= \[];
end
varargin \= assignApplicable(varargin);
if (\~isempty(iinds))
 inds \= track.getDerivedQuantity('mapinterpedtopts', false,iinds);
end
if (\~isempty(startLoc) \&\& \~isempty(stopLoc))
 \[\~,s] \= track.nearestPoint (startLoc);
 \[\~,e] \= track.nearestPoint (stopLoc);
 if (s \> e)
 inds \= e:s;
 else
 inds \= s:e;
 end
end
if (\~isempty(startTime) \&\& \~isempty(stopTime))
 pt \= \[track.pt];
 inds \= find(\[pt.et] \>\= startTime, 1, 'first'):find(\[pt.et] \<\= stopTime, 1, 'last');
end
pt \= \[track.pt];
loc \= \[pt.loc];
sloc \= track.getDerivedQuantity('sloc');
sind \= track.getDerivedQuantity('mapptstointerped');
track.calculateDerivedQuantity({'sbodytheta', 'speed', 'vel\_dp', 'dsbodytheta', 'spheadperp', 'sspineTheta'});

pt \= \[track.pt];
sstart \= sind(1\) \- ptbuffer;
send \= sind(end) \+ ptbuffer;
if (sstart \< 1\)
 sstart \= 1;
end
if (send \> length(sloc))
 send \= length(sloc);
end
datafields(track, sstart:send);
handles \= \[];
ccinfo \= track.expt.camcalinfo;
for j \= inds
 ts1 \= tic();
 subplot(2,2,1\); hold off; cla
 pt(j).drawTrackImage(ccinfo,'fid', fid, varargin{:}); hold on
 sstart \= sind(j) \- ptbuffer;
 send \= sind(j) \+ ptbuffer;
 if (sstart \< 1\)
 sstart \= 1;
 end
 if (send \> length(sloc))
 send \= length(sloc);
 end
 
 plot (sloc(1,sstart:send), sloc(2,sstart:send), 'b.\-');
 plot (sloc(1,sind(j)), sloc(2,sind(j)), 'bo', 'MarkerSize', 5\);
 axis (\[loc(1,j) \+ \[\-axisSize/2 axisSize/2], loc(2,j) \+ \[\-axisSize/2 axisSize/2]]);
 axis equal; 
 axis (\[loc(1,j) \+ \[\-axisSize/2 axisSize/2], loc(2,j) \+ \[\-axisSize/2 axisSize/2]]);
 hold off
 set(gca, 'XTick', \[], 'YTick', \[]);
 if (\~isempty(track.run))
 t \= \[];
 if (track.isrun(sind(j)))
 t \= \[t 'run '];
 end
 if (\~isempty(track.headSwing) \&\& any(\[track.headSwing.inds] \=\= sind(j)))
 t \= \[t 'headsweep '];
 I \= find(\[track.headSwing.startInd] \<\= sind(j) \& \[track.headSwing.endInd] \>\= sind(j));
 if (\~isempty(I))
 if (track.headSwing(I).accepted)
 t \= \[t 'accepted '];
 else
 t \= \[t 'rejected '];
 end
 end
 end
 if (\~isempty(track.reorientation) \&\& any(\[track.reorientation.inds] \=\= sind(j)))
 t \= \[t 'reorientation '];
 end
 title (t);
 end
 
 handles \= updateCenter(handles, track, sind(j), sstart, send);
 
 timeleft \= delayTime \- toc(ts1\);
 if (timeleft \> 0\)
 pause(timeleft);
 else
 pause(0\.001\);
 end
 
end
%{
drawtime
tracktime
otherplotstime
%}
end

function datafields(track, inds)
 thetafield \= 'sspineTheta';
 if (strcmpi (false \&\& track.so.method,'new'))
 fields \= {thetafield,track.so.speed\_field,'spheadperp'};
 ftitles \= {'Bondy Bend Angle', track.so.speed\_field, 'vhead perp'};
 mult \= \[rad2deg(1\), 1, 1];
 else
 fields \= {thetafield,track.so.speed\_field,'vel\_dp'};
 ftitles \= {'Bondy Bend Angle', track.so.speed\_field, 'Velocity Dot Product'};
 mult \= \[rad2deg(1\), 1, 1];
 end
 for k \= 1:3
 subplot(2,2,k\+1\); hold off
 plot (track.dq.eti(inds), mult(k)\*track.dq.(fields{k})(inds), 'k.', 'MarkerSize', 5\); hold on
 if (\~isempty(track.headSwing))
 hsinds \= find(\[track.headSwing.endInd] \> inds(1\) \& \[track.headSwing.startInd] \< inds(end));
 else
 hsinds \= \[];
 end
 for j \= hsinds;
 if (track.headSwing(j).accepted)
 c \= 'g\-';
 else
 c \= 'r\-';
 end
 plot (track.dq.eti(track.headSwing(j).inds), mult(k)\*track.dq.(fields{k})(track.headSwing(j).inds), c, 'LineWidth', 2\);
 end
 
 if (\~isempty(track.run))
 runinds \= find(\[track.run.endInd] \> inds(1\) \& \[track.run.startInd] \< inds(end));
 else
 runinds \= \[];
 end
 for j \= runinds;
 plot (track.dq.eti(track.run(j).inds), mult(k)\*track.dq.(fields{k})(track.run(j).inds), 'm\-','LineWidth',2\);
 end
 title(ftitles{k});
 end
 if (false \&\& strcmpi (track.so.method,'new'))
 spfields \= {{'theta\_cut', 'headswing\_start', 'headswing\_stop'},{'stop\_speed\_cut', 'start\_speed\_cut'}, {}};
 spcolors \= {{'m\-','g\-','r\-'},{'r\-', 'g\-'}, {'m\-'}};
 spmirror \= \[1 0 1];
 else
 spfields \= {{'theta\_cut', 'headswing\_start', 'headswing\_stop'},{'stop\_speed\_cut', 'start\_speed\_cut'}, {'aligned\_dp'}};
 spcolors \= {{'m\-','g\-','r\-'},{'r\-', 'g\-'}, {'m\-'}};
 spmirror \= \[1 0 0];
 end
 for k \= 1:3
 subplot(2,2,k\+1\);
 x \= track.dq.eti(inds);
 for j \= 1:length(spfields{k})
 f \= spfields{k}{j};
 c \= spcolors{k}{j};
 y \= repmat (mult(k)\*track.so.(f), size(x));
 plot (x,y,c);
 if (spmirror(k));
 plot (x,\-y,c);
 end
 end
 end
end

function handles \= updateCenter(handles, track, cind, start, stop)
 thetafield \= 'sspineTheta';
 if \~isempty(handles)
 for j \= 1:length(handles)
 delete(handles(j));
 end
 end
 if (false \&\& strcmpi (track.so.method,'new'))
 fields \= {thetafield,track.so.speed\_field,'spheadperp'};
 mult \= \[rad2deg(1\), 1, 1];
 else
 fields \= {thetafield,track.so.speed\_field,'vel\_dp'};
 mult \= \[rad2deg(1\), 1, 1];
 end
 
 for k \= 1:3
 subplot(2,2,k\+1\); hold on
 ih \= ishold;
 handles(k) \= plot (track.dq.eti(cind), mult(k)\*track.dq.(fields{k})(cind), 'c.','MarkerSize',25\);
 xlim(\[min(track.dq.eti(start)) max(track.dq.eti(stop))]);
 if (\~ih)
 hold off
 end
 end
end 


function markHS(track, ind)
 hsind \= find(\[track.headSwing.startInd] \< ind \& \[track.headSwing.endInd] \> ind);
 if (\~isempty(hsind))
 subplot(2,2,1\); hold on
 if (track.headSwing(hsind).accepted);
 c \= 'g\-';
 t \= 'accepted headswing';
 else
 c \= 'r\-';
 t \= 'rejected headswing';
 end
 plot (track.dq.shead(1, track.headSwing(hsind).inds), track.dq.shead(2, track.headSwing(hsind).inds), c);
 title (t);
 subplot(2,2,4\); hold off
 x \= track.dq.speed(track.headSwing(hsind).inds);
 y \= rad2deg(track.dq.sbodytheta(track.headSwing(hsind).inds));
 plot (x, y, c, 'LineWidth', 2\); hold on
 plot (repmat(track.so.start\_speed\_cut,size(y)),y, 'g\-\-');
 plot (x,rad2deg(repmat(track.so.headswing\_start, size(x))), 'g\-\-');
 plot (x,rad2deg(repmat(track.so.headswing\_stop, size(x))), 'r\-\-');
 plot (x,\-rad2deg(repmat(track.so.headswing\_start, size(x))), 'g\-\-');
 plot (x,\-rad2deg(repmat(track.so.headswing\_stop, size(x))), 'r\-\-');
 
 title(t);
 xlabel ('speed');
 ylabel('theta');
 else
 runind \= find(\[track.run.startInd] \< ind \& \[track.run.endInd] \> ind);
 if (\~isempty(runind))
 subplot(2,2,1\); title ('running');
 subplot(2,2,4\); hold off; title ('running');
 x \= track.dq.speed(track.run(runind).inds);
 y \= rad2deg(track.dq.sbodytheta(track.run(runind).inds));
 plot (x, y, 'b\-', 'LineWidth', 2\); hold on
 plot (repmat(track.so.start\_speed\_cut,size(y)),y, 'g\-\-');
 plot (repmat(track.so.stop\_speed\_cut,size(y)),y, 'r\-\-');
 plot (x,rad2deg(repmat(track.so.headswing\_start, size(x))), 'g\-\-');
 plot (x,rad2deg(repmat(track.so.headswing\_stop, size(x))), 'r\-\-');
 plot (x,rad2deg(repmat(track.so.theta\_cut, size(x))), 'm\-\-');
 plot (x,rad2deg(\-repmat(track.so.headswing\_start, size(x))), 'g\-\-');
 plot (x,rad2deg(\-repmat(track.so.headswing\_stop, size(x))), 'r\-\-');
 plot (x,rad2deg(\-repmat(track.so.theta\_cut, size(x))), 'm\-\-');
 xlabel ('speed');
 ylabel('theta');
 end
 end
 
end




\-\-\-

\#\#\# File: fixHTOrientation.m (ID: @MaggotTrack.11\)

function fixHTOrientation(track, varargin)
% legacy code; fixes extraction mistakes that swap head \& tail
% @MaggotTrack/fixHTOrientation(track, varargin)
% maggotTrack.fixHTOrientation(varargin)
%
% fixes head/tail orientations;
% the following parameter/value pairs can be passed in to modify shown
% defaults
%
% outputs: none
% inputs: TRACK \< MaggotTrack
% optional arguments (pass as parameter/value pairs)
% mintime \= 10 (seconds running backwards that signals a problem)
% speedthresh \= 33rd percentile of speed \-\- if it's going slower than this, 
% we don't worry that it's going backwards
% dpthresh \= \-0\.5 if the norm of the mid\-head vector dot the norm of the velocity
% is below this threshold, it's going the wrong way
if (\~isempty(track.dq))
 existingFields \= fieldnames(track.dq);
else
 existingFields \= {};
end

mintime \= 10; %seconds minimum time for something to be bad before it needs to be fixed
pt \= \[track.pt];
if (sum(\[pt.htValid]) \< 4 \|\| sum(\[pt.htValid]) \< 4\*mintime/track.dr.interpTime)
 return; %track is too short
end
track.calculateDerivedQuantity({'eti', 'vel\_dp', 'speed'});

sp \= track.getDerivedQuantity('speed');
sp2 \= sort(sp);
speedthresh \= sp2(round(length(sp2\)/3\));
dpthresh \= \-0\.5;

assignApplicable(varargin);
minpts \= ceil(mintime/track.dr.interpTime);
dp \= track.getDerivedQuantity('vel\_dp');

inds \= find(sp \> speedthresh \& isfinite(dp));

if (length(inds) \< 2\)
 disp ('no points above speed cut in fixHTOrientation');
 return;
end
dp \= double(interp1(inds,dp(inds), 0:(length(dp)\+1\), 'nearest', 'extrap'));
dpfilt \= medfilt1(dp, minpts);
badinds \= dpfilt \< dpthresh;
badinds \= find(imdilate(badinds, ones(\[1 3])));
badinds \= badinds((badinds \>\= 1\) \& (badinds \<\= length(track.dq.eti))); 
badtimes \= track.dq.eti((badinds)); %time when it's going backwards

%find the original points that are in that time range
%note we are assuming that the interpolation time \<\= sampling time, which
%should be valid; we space out by thirds to make sure we cover all points
%note unique sorts, so there is no need to do that here
badtimes \= unique(\[badtimes, badtimes\-track.dr.interpTime/3, badtimes\+track.dr.interpTime/3]);
badinds \= unique(interp1(\[pt.et], 1:track.npts, badtimes,'nearest', 'extrap'));

%swap head and tail in bad time range
if (\~isempty(badinds))
 allpts \= track.pt;
 for j \= badinds
 temp \= allpts(j).head;
 allpts(j).head \= allpts(j).tail;
 allpts(j).tail \= temp;
 if (isfield(allpts(j), 'spine') \&\& \~isempty(allpts(j).spine))
 allpts(j).spine \= allpts(j).spine(end:\-1:1,:);
 end
 end
 track.pt \= allpts;
end

%only recalculate maggot track params (track params don't involve head or
%tail, so won't change)
fnames \= setdiff(MaggotTrack.validDQName, Track.validDQName);
track.recalculateDerivedQuantities(fnames{:});

%{
%clear all fields from dq, then rederive any that existed before
track.dq \= \[];
if \~isempty(existingFields) 
 track.calculateDerivedQuantity(existingFields);
end
%}
\-\-\-

\#\#\# File: segmentTrackOld.m (ID: @MaggotTrack.12\)

function track \= segmentTrack (track, mso)
%function track \= segmentTrack (track, mso)
%

debug \= false;

if (\~exist('mso', 'var') \|\| isempty(mso))
 mso \= track.so;
else
 track.so \= mso;
end

cv \= track.getDerivedQuantity('curv');
bt \= track.getDerivedQuantity('sbodytheta');
vdp \= track.getDerivedQuantity('vel\_dp');
sp \= track.getDerivedQuantity(mso.speed\_field);

if (debug)
 tx \= track.dq.eti;
 figure(1\);
 plot (tx, abs(cv), tx, repmat(mso.curv\_cut, size(tx))); ylim(\[0 mso.curv\_cut]);
 title ('curv')
 figure(2\);
 plot (tx, bt, tx, repmat(mso.theta\_cut, size(tx)));
 title ('body theta');
 figure(3\);
 plot (tx, sp, tx, repmat(mso.stop\_speed\_cut, size(tx)),'r\-', tx, repmat(mso.start\_speed\_cut, size(tx)),'g\-');
 title ('speed');
end

highcurv \= (abs(cv) \> mso.curv\_cut);
head\_swinging \= (abs(bt) \> mso.theta\_cut);
speedlow \= (sp \< mso.stop\_speed\_cut);

%whenever the head swings wide or the path has high 
%curvature or the speed drops too low, we say any existing run
%ends
notarun \= (highcurv \| head\_swinging \| speedlow);
endarun \= find(diff(notarun) \>\= 1\) \+ 1;


%in order to begin a run, we need to (a) not be at a stop point
%(b) be moving fast enough and (c) have the head aligned with the direction
%of motion
speedhigh \= (sp \>\= mso.start\_speed\_cut);
headaligned \= (vdp \>\= mso.aligned\_dp); 
isarun \= (\~notarun \& speedhigh \& headaligned);

startarun \= find(diff(isarun) \>\= 1\) \+ 1;

start \= startarun;
stop \= endarun;
si \= 1;
k \= 0;
%create a list of sequential starts and stops from valid start and stop
%points
while (\~isempty(si) \&\& \~isempty(startarun))
 k \= k\+1;
 start(k) \= startarun(si);
 ei \= find(endarun \> start(k), 1, 'first');
 if (isempty(ei))
 stop(k) \= length(track.dq.eti);
 else
 stop(k) \= endarun(ei);
 end
 si \= find(startarun \> stop(k),1, 'first');
end
start \= start(1:k);
stop \= stop(1:k);

%remove runs that are too short
inds \= find(track.dq.eti(stop) \- track.dq.eti(start) \>\= mso.minRunTime);
start \= start(inds);
stop \= stop(inds);
%{
%clear old runs
if (\~isempty(track.run))
 for j \= 1:length(track.run)
 delete(track.run(j));
 end 
end
%}
run \= repmat(Run(),1\);
%record runs in track, and take some basic statistics
for k \= 1:length(start)
 run(k) \= Run(track,start(k),stop(k));
 %{
 if (k \> 1\)
 run(k).previousRun \= run(k\-1\);
 run(k\-1\).nextRun \= run(k);
 end
 %}
end
track.run \= run;
track.isrun \= false(size(track.dq.eti));
track.isrun(\[run.inds]) \= true;
notrun \= \~track.isrun;

%eliminate all headswings before the first run \& after the last run
firstrunind \= find(track.isrun, 1, 'first');
lastrunind \= find(track.isrun, 1, 'last');
inrange \= false(size(notrun));
inrange(firstrunind:lastrunind) \= true;

%now that we have found runs, we look for head swings
%locate head swings; head swings are anything where the head swings 
head\_swinging \= find (abs(bt) \> mso.headswing\_start \& notrun \& inrange);
not\_head\_swing \= find((abs(bt) \< mso.headswing\_stop) \| (\[0 diff(sign(bt))] \~\= 0\) \& inrange);



%create a list of sequential starts and stops from valid start and stop
%points
si \= 1;
k \= 0;
start \= head\_swinging;
stop \= start;
while (\~isempty(si) \&\&\~isempty(head\_swinging))
 k \= k\+1;
 start(k) \= head\_swinging(si);
 ei \= find(not\_head\_swing \> start(k), 1, 'first');
 if (isempty(ei))
 stop(k) \= length(track.dq.eti);
 else
 stop(k) \= not\_head\_swing(ei);
 end
 si \= find(head\_swinging \> stop(k), 1, 'first');
end
start \= start(1:k);
stop \= stop(1:k);


inds \= start;
j \= 0;
%a headswing is only valid if it includes at least one point that is not
%part of a run
for k \= 1:length(start)
 if (any(notrun(start(k):stop(k))))
 j \= j \+ 1;
 inds(j) \= k;
 end
end
inds \= inds(1:j);

start \= start(inds);
stop \= stop(inds);

headSwing \= repmat(HeadSwing(), 0\);
for k \= 1:length(start)
 headSwing(k) \= HeadSwing(track, start(k), stop(k));
end
track.headSwing \= headSwing;

%group headswings into reorientations
%a reorientation is the period between runs, whether or not that contains
%any headswings;
%a reorientation is a group of 1 or more headswings that fall between the
%same runs
nextrun \= zeros(size(track.headSwing));
for j \= 1:length(track.headSwing)
 ind \= find(\[track.run.startInd] \> track.headSwing(j).startInd, 1, 'first');
 if (isempty(ind))
 nextrun(j) \= length(track.run) \+ 1;
 else
 nextrun(j) \= ind;
 end
end
k \= 0;
reorientation \= repmat(MaggotReorientation(), \[1 length(track.run)\-1]);
for j \= 1:length(reorientation)
 inds \= find(nextrun \=\= j\+1\);
 if (isempty(inds))
 reorientation(j) \= MaggotReorientation(track, \[], track.run(j), track.run(j\+1\)); 
 else
 reorientation(j) \= MaggotReorientation(track, track.headSwing(inds));
 end
end
track.reorientation \= reorientation;

\-\-\-

\#\#\# File: loadJavaMasks.m (ID: @MaggotTrack.13\)

function loadJavaMasks( track, jTr )
%LOADJAVAMASKS Summary of this function goes here
% Detailed explanation goes here

 for i\=1:length(track.pt)
 %This just adds a field which may or may not be accessible by other
 %functions, since it's not currently in the header
 track.pt(i).mask \= jTr.getPoint(i\-1\).getMask().getIntArray()';%This may throw an error bc getPoint returns a point, not a mtp
 end
 
end


\-\-\-

\#\#\# File: getTypicalMaggotShape.m (ID: @MaggotTrack.14\)

function shapeModel \= getTypicalMaggotShape(track)%, varargin)
%function \[spineim, rel\_width\_vs\_length, shapex, shapey] \= getTypicalMaggotShape(track)

maxpts \= 500;
usecamcalinfo \= false;
%varargin \= assignApplicable(varargin);


if (isempty(track.pt(1\).imData))
 disp ('reloading track to get images');
 track.expt.reloadTrack(track.trackNum, 'usecamcalinfo', usecamcalinfo);
 disp ('done');
end

%find maggot track points where body bend angle is small (\< 7 deg)
iinds \= find(logical(track.getDerivedQuantity('ihtValid')) \& abs(track.getDerivedQuantity('spineTheta')) \< deg2rad(7\));
inds \= track.getDerivedQuantity('mapinterpedtopts', false,iinds);
inds \= unique(inds);

%if there are too many such points, select randomly from them
if (length(inds) \> maxpts)
 inds \= inds(randperm(length(inds)) \< maxpts);
end


thresh \= mean(\[track.pt(inds).threshold]);
nsp \= 100; %number of points along spine for sampling
nwp \= 51; %number of points across body for sampling \-\- changed from 31 to 51 by mhg on 6/19

%mean length of spine (in cm, if calibrated) across sample images
meanSpineLength \= mean(track.getDerivedQuantity('spineLength',false,iinds));

%area in pixels / length (in cm, if calibrated)
width\_in\_pixels \= 5\*mean(track.getDerivedQuantity('iarea',false,iinds))./meanSpineLength; %changed from 2 to 5 by mhg on 6/25
if (\~isempty(track.expt) \&\& usecamcalinfo)
 cc \= track.expt.camcalinfo;
else
 cc \= \[];
end

%if calibrated, correct width pixels^2/cm \* cm/pixels
%correct length cm \* pixels/cm
if(\~isempty(cc))
 width\_in\_pixels \= width\_in\_pixels/cc.pixelsPerRealUnit;
 meanSpineLength \= meanSpineLength\*cc.pixelsPerRealUnit;
end



sl \= mean(track.getDerivedQuantity('spineLength',false,iinds));
shapey \= linspace(\-.25\*sl, .25\*sl,nsp); %change from \-0\.1,1\.1 to \-0\.25,1\.25 by mhg on 6/25, also updated imSpineSampled
pixLen \= shapey(end);

%possible bug \-\- shapey doesn't make a whole lot of sense here
%Spine length ought to be in the proper units already
%if(\~isempty(cc))
% shapey \= shapey/cc.pixelsPerRealUnit;
%end

shapex \= linspace(\-width\_in\_pixels/2, width\_in\_pixels/2, nwp);

%sample first track point image along spine
spineim \= imSpineSampled (track.pt(inds(1\)), nsp, nwp, width\_in\_pixels,cc);

%timer stuff
ts1 \= tic;
etold \= 0;

for j \= inds(2:end)
 %accumulate spine image by adding on sampled points
 spineim \= spineim \+ imSpineSampled (track.pt(j), nsp, nwp, width\_in\_pixels,cc);
 
 %timer stuff
 et \= toc(ts1\);
 if (et \- etold \> 60\)
 etold \= et;
 disp (\[num2str(et, 2\) ' s elapsed. ' num2str(find(inds \=\= j,1\)) ' / ' num2str(length(inds))]);
 end
end

%normalize by number of images
spineim \= spineim/length(inds);

%eliminate left right assymmetry
ssifull \= 0\.5\*(spineim \+ spineim(:,end:\-1:1\)); %symmetrized image
ssifull \= blurim(ssifull, 1\);
ssi \= ssifull(:,ceil((size(ssifull,2\)\+1\)/2\):end);

%find first and last y\-index (along spine) where there is at least one
%pixel above threshold
ind1 \= find(any(ssi \>\= thresh, 2\), 1, 'first');
ind2 \= find(any(ssi \>\= thresh, 2\), 1, 'last');

inds \= ind1:ind2;
L \= diff(shapey(\[ind1 ind2]));
rel\_width\_vs\_length \= zeros(size(inds));

%find width vs. length (outline)
for j \= 1:length(inds)
 ind \= find(ssi(inds(j),:) \>\= thresh, 1, 'last');
 if (isempty(ind))
 continue;
 end
 i1 \= find(ssi(inds(j),:) \< ssi(inds(j),ind), 1, 'first');
 if (isempty(i1\) \|\| i1 \> inds(j))
 i1 \= 1;
 end
 i2 \= find(ssi(inds(j),(ind\+1\):end) \> ssi(inds(j),ind), 1, 'first');
 if (isempty(i2\))
 i2 \= size(ssi,2\);
 else
 i2 \= ind \+ i2;
 end
 if (i1 \=\= i2\)
 i1 \= max(i1 \-1, 1\);
 i2 \= i1\+1;
 end
 xdat \= ssi(inds(j),i1:i2\);
 ydat \= i1:i2;
 \[xdat,I] \= unique(xdat); ydat \= ydat(I);
 rel\_width\_vs\_length(j) \= interp1(xdat, ydat, thresh, 'spline', 'extrap');
end
%shapey \= shapey\-shapey(max(ind1\-1, 1\));
%rel\_width\_vs\_length \= double(\[0 rel\_width\_vs\_length\*width\_in\_pixels/nwp/L 0]);
wvl \= zeros(size(shapey));
wvl(inds) \= double(rel\_width\_vs\_length\*width\_in\_pixels/nwp);
inds \= max((inds(1\)\-1\),1\):min(inds(end)\+1, length(wvl));
shapey \= double(shapey\-shapey(inds(1\)));

%check math \-\- some of this is wrong!
shapeModel.image \= double(spineim); %not symmetrized!
shapeModel.symmetrizedImage \= double(ssifull); %double(\[fliplr(ssi) ssi]);
shapeModel.spine\_coord \= shapey;
shapeModel.rel\_spine\_coord \= shapey/shapey(inds(end));
shapeModel.width\_coord \= double(shapex);

shapeModel.length \= shapey(inds)\-shapey(inds(1\));
shapeModel.pixelLen \= pixLen;
shapeModel.widthVsLength \= wvl(inds);
 
shapeModel.pixelx \= double(shapeModel.width\_coord);
shapeModel.pixely \= double(shapeModel.rel\_spine\_coord \* meanSpineLength);

function spineim \= imSpineSampled (mtp, nsp, nwp, widthInPixels, camcalinfo)
%function imSpineSampled (mtp, nsp, nwp, widthInPixels, camcalinfo)

debug \= false;

%spline fit to spine
pp \= cscvn(double(\[mtp.tail mtp.spine mtp.head]));
sp \= fnval(pp, linspace(pp.breaks(1\), pp.breaks(end), nsp));
l \= \[0 cumsum(sqrt(sum(diff(sp,\[],2\).^2\)))];
sp \= interp1(l,sp',linspace(0,l(end),nsp))';

%extend by 25%
l \= \[0 cumsum(sqrt(sum(diff(sp,\[],2\).^2\)))];
sp \= interp1(l,sp',linspace(\-0\.25\*l(end),1\.25\*l(end),nsp),'linear', 'extrap')'; %change from 5% by MHG 6/25

%re\-regularize
l \= \[0 cumsum(sqrt(sum(diff(sp,\[],2\).^2\)))];
sp \= interp1(l,sp',linspace(0,l(end),nsp))';

if (\~isempty(camcalinfo))
 sp \= camcalinfo.camPtsFromRealPts(sp);
end

%translate spine to align with image; \+1 is because MATLAB is stupid(1\-indexed)
sp(1,:) \= sp(1,:) \- double(mtp.imOffset(1\)) \+ 1;
sp(2,:) \= sp(2,:) \- double(mtp.imOffset(2\)) \+ 1;

%t is tangent, n is normal
t \= diff(sp,\[],2\);
t \= 0\.5\*(t(:,\[1 1:end]) \+ t(:,\[1:end end]));
s \= sqrt(sum(t.^2\));
n \= \[t(2,:)./s;\-t(1,:)./s];

spineim \= zeros(nsp, nwp);

%for each point along spine, interpolate along line locally perpendicular
%to spine at that point
for j \= 1:nsp
 pts \= repmat(sp(:,j), \[1 nwp]) \+ (n(:,j)\*linspace(\-widthInPixels/2, widthInPixels/2, nwp));
 
 spineim(j,:) \= interp2(double(mtp.imData), pts(1,:),pts(2,:),'\*linear', 0\);
 if (debug)
 subplot(2,1,1\); imagesc(double(mtp.imData)); hold on; plot (sp(1,:), sp(2,:), 'y\-', pts(1,:), pts(2,:), 'r\-'); colormap gray; hold off
 subplot(2,1,2\); imagesc(spineim); pause(0\.1\);
 end
end
\-\-\-

\#\#\# File: prettyMovie.m (ID: @MaggotTrack.15\)

function prettyMovie(track, varargin)
%@MaggotTrack
%playMovie(track, varargin)
%enter options as pairs, caps matter
%options, with defaults
%
%ptbuffer \= 1000;
%delayTime \= 0\.05;
%axisSize (size of image or 120 \* mean speed)
%inds \= 1:length(track.pt);
%startLoc \= \[]; \> if startLoc \& stopLoc are not empty, we run the movie
%between these two points
%stopLoc \= \[]; \>
%


ptbuffer \= 400;
delayTime \= 0\.05;
axisSize \= max(size(track.pt(1\).imData));
inds \= 1:length(track.pt);
startLoc \= \[];
stopLoc \= \[];
if (\~isempty(track.expt))
 track.expt.openDataFile;
 fid \= track.expt.fid;
else
 fid \= \[];
end
varargin \= assignApplicable(varargin);
if (axisSize \<\= 0 \&\& \~isempty(fid))
 try
 fseek(fid, track.pt(1\).locInFile, \-1\);
 pt \= track.pt(1\).fromFile(fid, true, true, \[]);
 axisSize \= max(size(pt.imData));
 catch me
 me.getReport
 end
end
if (axisSize \<\= 0\)
 axisSize \= 50;
end
 
if (\~isempty(startLoc) \&\& \~isempty(stopLoc))
 \[blah,s] \= track.nearestPoint (startLoc);
 \[blah,e] \= track.nearestPoint (stopLoc);
 if (s \> e)
 inds \= e:s;
 else
 inds \= s:e;
 end
end
pt \= \[track.pt];
loc \= \[pt.loc];
sloc \= track.getDerivedQuantity('sloc');
sind \= track.getDerivedQuantity('mapptstointerped');
track.calculateDerivedQuantity({'sbodytheta', 'speed', 'vel\_dp'});
stheta \= track.getDerivedQuantity('sbodytheta');
head \= track.getDerivedQuantity('shead');
mhdir \= track.getDerivedQuantity('shead')\-track.getDerivedQuantity('smid');
vnorm \= track.getDerivedQuantity('vel');
so \= track.so;

for j \= inds
 ts \= tic;
 hold off; cla()
 pt(j).drawTrackImage(\[],'fid', fid, varargin{:}); hold on
 set(gca, 'XTick', \[], 'YTick', \[]);
 sstart \= sind(j) \- ptbuffer;
 send \= sind(j) \+ ptbuffer;
 if (sstart \< 1\)
 sstart \= 1;
 end
 if (send \> length(sloc))
 send \= length(sloc);
 end
 
 plot (sloc(1,sstart:send), sloc(2,sstart:send), 'b.\-');
 plot (sloc(1,sind(j)), sloc(2,sind(j)), 'b.', 'MarkerSize', 20\);
 quiver(sloc(1,sind(j)), sloc(2,sind(j)), mhdir(1,sind(j)), mhdir(2,sind(j)), 0,'y','LineWidth',3\);
 quiver(sloc(1,sind(j)), sloc(2,sind(j)), vnorm(1,sind(j)), vnorm(2,sind(j)), 0,'b','LineWidth',3\); 
 axis (\[loc(1,j) \+ \[\-axisSize/2 axisSize/2], loc(2,j) \+ \[\-axisSize/2 axisSize/2]]);
 axis equal; 
 axis (\[loc(1,j) \+ \[\-axisSize/2 axisSize/2], loc(2,j) \+ \[\-axisSize/2 axisSize/2]]);
 if (\~isempty(track.run))
 t \= \[];
 contourColor \= 'm\-';
 if (track.isrun(sind(j)))
 t \= \[t 'run '];
 contourColor \= 'c\-';
 end
 if (any(\[track.reorientation.inds] \=\= sind(j)))
 t \= \[t 'reorientation '];
 end
 if (any(\[track.headSwing.inds] \=\= sind(j)))
 t \= \[t 'headsweep '];
 I \= find(\[track.headSwing.startInd] \<\= sind(j) \& \[track.headSwing.endInd] \>\= sind(j));
 if (\~isempty(I))
 if (track.headSwing(I).accepted)
 t \= \[t 'accepted '];
 contourColor \= 'g\-';
 else
 t \= \[t 'rejected '];
 contourColor \= 'r\-';
 end
 ei \= track.headSwing(I).endInd;
 si \= track.headSwing(I).startInd;
 si \= find(sign(1:si) \~\= sign(stheta(si)) \| abs(stheta(1:si)) \< so.headswing\_stop, 1, 'last');
 if (isempty(si))
 si \= track.headSwing(I).startInd;
 end
 plot (head(1,si:ei), head(2,si:ei), contourColor, 'LineWidth', 2\);
 end
 end
 c \= pt(j).contour;
 c(:,end\+1\) \= c(:,1\);
 plot (c(1,:), c(2,:), contourColor, 'LineWidth', 2\);
 title (t); embiggen()
 end
 hold off
 set(gca, 'XTick', \[], 'YTick', \[]);
 timeleft \= delayTime \- toc(ts);
 if (timeleft \> 0\)
 pause(timeleft);
 else
 pause(0\.001\);
 %refresh(gcf);
 end
 
end




\-\-\-

\#\#\# File: validDQName.m (ID: @MaggotTrack.16\)

function varargout \= validDQName (varargin)
%@Track/validDQName
%static function that tells whether a name is a valid derived quantity
%function varargout \= validDQName (varargin)
%
%tf \= validDQName(name) \- true or false if name is a valid derived
%field for a track
%tflist \= validDQName(namelist) \- array of true or falses, namelist is a cell
%tflist \= validDQName('name1', 'name2') \- nargout \= nargin t/f
%namelist \= validDQName() \- returns a cell containing all valid field names

persistent validfieldlist;
if (isempty(validfieldlist))
 validfieldlist \= {'ihead', 'shead', 'itail', 'stail', 'imid', 'smid', 'ihtValid', 'ibodytheta', 'sbodytheta', ...
 'vtail', 'vhead', 'vmid', 'sptail', 'sphead', 'spmid', 'vel\_dp','imhdir','itmdir','smhdir','stmdir','vheadperp','spheadperp'...
 'ispine','spineLength','spineWidth','periAmp', 'periFreq', 'periPhase', ...%'periTau', 'periMean', ...
 'spineDist','spineCurv', 'spineTheta', 'sspineTheta', 'dspineCurv', 'dspineTheta','dbodytheta', 'dsbodytheta',...
 'fastTailSpeed', 'fastHeadSpeed', 'fastMidSpeed'};
 validfieldlist \= union(validfieldlist, Track.validDQName);
end

varargout{:} \= Track.nameInList(validfieldlist, varargin{:});

 
 

\-\-\-

\#\#\# File: calculateDerivedQuantity.m (ID: @MaggotTrack.17\)

function calculateDerivedQuantity(track, quantityNames, recalculate)
% calculate a quantity based on extracted position and posture
% track.calculateDerivedQuantity(quantityName, recalculate)
% calculateDerivedQuantity(track, quantityName, recalculate)
%
% calculates a derived quantity (for a list of derived quantities, use
% MaggotTrack/validDQName)
% if the quantity has already been calculated (track.dq.(quantityName)
% exists), then the value is not recalculated, unless recalculate is true
% "recalculate" may or may not cause other quantities to also be
% recalculated
%
% outputs: none
% inputs: 
% TRACK \< MaggotTrack
% QUANTITYNAMES: string naming quantity, or cell of strings naming
% quantitites
% RECALCULATE \< bool


 if \~iscell(quantityNames)
 quantityNames \= {quantityNames};
 end
 if (\~exist('recalculate', 'var'))
 recalculate \= false;
 end
 for j \= 1:length(quantityNames)

 if (isfield(track.dq, quantityNames{j}) \&\& \~recalculate)
 continue;
 end
 %short\-circuit the normal track location program and use 
 %the midpoint instead of the center of mass
 if strcmp(quantityNames{j}, 'iloc')
 calculatePosition(track);
 continue
 end
 if (Track.validDQName(quantityNames{j}))
 track.calculateDerivedQuantity@Track(quantityNames{j}, recalculate);
 continue
 end
 switch(quantityNames{j})
 case {'ihead', 'itail', 'imid'}
 track.calculateDerivedQuantity({'eti', 'ihtValid'}, false);
 calculateInterpedBody(track);
 case {'shead', 'stail', 'smid'}
 qname \= quantityNames{j};
 qname(1\) \= 'i';
 track.calculateDerivedQuantity(qname, false);
 calculateSmoothedBody(track, quantityNames{j});
 case {'vhead', 'vtail', 'vmid'}
 qname \= quantityNames{j};
 qname(1\) \= 'i';
 track.calculateDerivedQuantity(qname, false);
 calculateVelocity(track, quantityNames{j});
 case {'sphead', 'sptail', 'spmid'}
 calculateSpeed(track, quantityNames{j});
 case {'ibodytheta','sbodytheta'}
 track.calculateDerivedQuantity({'ihead', 'itail', 'imid'});
 if (quantityNames{j}(1\)\=\='s' \|\| quantityNames{j}(1\) \=\= 't')
 track.calculateDerivedQuantity({'shead', 'stail', 'smid'});
 end
 calculateBodyAngle(track, quantityNames{j})
 case {'dbodytheta', 'dsbodytheta'}
 calculateDBodyAngle(track);
 case {'ihtValid'}
 track.calculateDerivedQuantity('eti');
 calculateInterpedHTValid(track);
 case {'vel\_dp'}
 track.calculateDerivedQuantity({'shead', 'smid', 'vel', 'speed'});
 calculateVel\_DP(track);
 case {'vheadperp','spheadperp'}
 track.calculateDerivedQuantity({'shead', 'smid', 'stail'});
 calculateVHeadPerp(track);
 case {'itmdir', 'stmdir', 'imhdir', 'smhdir'}
 track.calculateDerivedQuantity({'ihead', 'itail', 'imid'});
 if (quantityNames{j}(1\)\=\='s' \|\| quantityNames{j}(1\) \=\= 't')
 track.calculateDerivedQuantity({'shead', 'stail', 'smid'});
 end
 calculateBodyDirection(track, quantityNames{j});
 case 'ispine'
 track.calculateDerivedQuantity('eti');
 calculateInterpedSpine(track);
 case 'spineLength'
 track.calculateDerivedQuantity({'eti', 'ispine'});
 calculateSpineLength(track);
 case {'spineCurv'}
 track.calculateDerivedQuantity({'eti', 'ispine', 'spineLength'});
 calculateSpineCurv(track);
 case {'spineTheta'}
 calculateSpineTheta(track);
 case {'sspineTheta'}
 track.dq.sspineTheta \= lowpass1D(track.getDerivedQuantity('spineTheta'), track.dr.smoothTime/track.dr.interpTime);
 
 case {'dspineCurv', 'dspineTheta'}
 calculateDSpineCurv(track);
 
 case 'spineWidth'
 track.dq.spineWidth \= track.getDerivedQuantity('iarea')./track.getDerivedQuantity('spineLength');
 case {'fastTailSpeed', 'fastHeadSpeed', 'fastMidSpeed'}
 calculateFastSpeed(track);
 case {'periAmp', 'periFreq', 'periPhase'} %'periPhase', 'periTau', 'periMean'}
 calculatePeristalsis(track);
 case {'spineDist'}
 calculateSpineDist (track);
 
 otherwise
 disp (\['I don''t recognize the quantity: ' quantityNames{j}]);
 end%switch
 end%for
end %cdq
function calculateInterpedHTValid(track) 
 pt \= \[track.pt];
 et \= \[pt.et];
 htv \= double(\[pt.htValid]);
 
 %et \= \[track.pt.et];
 %htv \= double(\[track.pt.htValid]);
 track.dq.ihtValid \= ((interp1(et, htv', track.dq.eti, 'linear')) \> 0\.99\);
end

function calculateInterpedBody(track)
 pt \= \[track.pt];
 htv \= \[pt.htValid];
 pt \= pt(htv);
 et \= \[pt.et];
 h \= \[pt.head];
 t \= \[pt.tail];
 m \= \[pt.mid];
 %et \= \[track.pt(\[track.pt.htValid]).et];
 %loc \= \[track.pt(\[track.pt.htValid]).(qn(2:end))];
 if (length(et) \< 2\)
 track.dq.ihead \= NaN(2,length(track.dq.eti));
 track.dq.imid \= NaN(2,length(track.dq.eti));
 track.dq.itail \= NaN(2,length(track.dq.eti));
 return;
 end
 try
 track.dq.ihead \= double((interp1(et, double(h'), track.dq.eti, 'linear','extrap')))';
 track.dq.imid \= double((interp1(et, double(m'), track.dq.eti, 'linear','extrap')))';
 track.dq.itail \= double((interp1(et, double(t'), track.dq.eti, 'linear','extrap')))';
 catch me
 disp (me.getReport());
 size(et)
 size(h)
 track.dq.ihead \= NaN(2,length(track.dq.eti));
 track.dq.imid \= NaN(2,length(track.dq.eti));
 track.dq.itail \= NaN(2,length(track.dq.eti));
 end
 % track.dq.ihead \= single((interp1(et(htv), double(h(:,htv))', track.dq.eti, 'linear')))';
 % track.dq.imid \= single((interp1(et(htv), double(m(:,htv))', track.dq.eti, 'linear')))';
 % track.dq.itail \= single((interp1(et(htv), double(t(:,htv))', track.dq.eti, 'linear')))';
% track.dq.(qn) \= single((interp1(et, double(loc)', track.dq.eti, 'linear'))');
 
end

function calculateSmoothedBody(track,qn)
 sigma \= track.dr.smoothTime/track.dr.interpTime;
 track.dq.(qn) \= double(lowpass1D(track.getDerivedQuantity(\['i' qn(2:end)]), sigma));
end

function calculateVelocity(track, qn) 
 sigma \= track.dr.derivTime/track.dr.interpTime;
 qn2 \= qn; qn2(1\) \= 's';
 track.dq.(qn) \= double(deriv(track.getDerivedQuantity(qn2\), sigma))/track.dr.interpTime; %velocity is in pixels per second
 
end
function calculateSpeed(track, qn) 
 qn2 \= qn(2:end); qn2(1\) \= 'v';
 track.dq.(qn) \= sqrt (sum(track.getDerivedQuantity(qn2\).^2\));
end

 
function calculatePosition(track)
 track.calculateDerivedQuantity('eti');
 pt \= \[track.pt];
 et \= \[pt.et];
 loc \= \[pt.mid];
 track.dq.iloc \= double((interp1(et, double(loc)', track.dq.eti, 'linear'))');
end

 
function calculateBodyAngle(track, qn)
 mh \= track.dq.(\[qn(1\) 'head']) \- track.dq.(\[qn(1\) 'mid']);
 tm \= track.dq.(\[qn(1\) 'mid'])\- track.dq.(\[qn(1\) 'tail']); 
 alltheta \= \[atan2(mh(2,:), mh(1,:));atan2(tm(2,:), tm(1,:))]; %tail angle \- head angle
 track.dq.(qn) \= \-diff(unwrap(alltheta));
end

 function calculateBodyDirection(track, qn)
 mh \= track.dq.(\[qn(1\) 'head']) \- track.dq.(\[qn(1\) 'mid']);
 tm \= track.dq.(\[qn(1\) 'mid'])\- track.dq.(\[qn(1\) 'tail']); 
 if (qn(2\) \=\= 't')
 l \= sqrt(sum(tm.^2\));
 track.dq.(qn) \= tm./\[l;l];
 else
 l \= sqrt(sum(mh.^2\));
 track.dq.(qn) \= mh./\[l;l];
 end
 end


function calculateVel\_DP(track)
 mh \= track.dq.shead \- track.dq.smid;
 mhnorm \= sqrt(sum(mh.^2\));
 try 
 mh \= mh ./ \[mhnorm;mhnorm];
 catch me
 disp(me.getReport);
 sum(track.dq.ihtValid) 
 size(mh)
 size(mhnorm)
 size(\[mhnorm;mhnorm])
 track
 track.dq
 
 end
 %track.dq.mhdir \= mh;
 v \= track.dq.vel;
 s \= track.dq.speed;
 v \= v ./ \[s;s];
 track.dq.vel\_dp \= dot(v,mh);
end
function calculateVHeadPerp(track) 
%{
 tm \= track.dq.smid \- track.dq.stail;
 tmnorm \= sqrt(sum(tm.^2\));
 vh \= deriv(track.dq.shead, track.dr.derivTime./track.dr.interpTime);
 vhnorm \= sqrt(sum(vh.^2\));
 vhnorm(vhnorm \<\= eps) \= eps;
 try 
 tm \= tm ./ \[tmnorm;tmnorm];
 vhn \= vh ./ \[vhnorm;vhnorm];
 catch me
 disp(me.getReport);
 sum(track.dq.ihtValid) 
 size(tm)
 size(tmnorm)
 size(\[tmnorm;tmnorm])
 track
 track.dq
 
 end
 alpha \= dot(vhn,tm);
%}
 tm \= track.getDerivedQuantity('stmdir');
 vh \= track.getDerivedQuantity('vhead');
 vhnorm \= sqrt(sum(vh.^2\));
 vhnorm(vhnorm \<\= eps) \= eps;
 try 
 vhn \= vh ./ \[vhnorm;vhnorm];
 catch me
 disp(me.getReport);
 sum(track.dq.ihtValid) 
 size(vh)
 size(vhnorm)
 size(\[vhnorm;vhnorm])
 track
 track.dq 
 end
 alpha \= dot(vhn,tm);
 track.dq.vheadperp \= vh \- vh.\*\[alpha;alpha];
 track.dq.spheadperp \= sqrt(sum(vh.^2\));
end
function calculateInterpedSpine(track) 
 
 ncp \= 11;
 pt \= \[track.pt];
 et \= \[pt.et];
 htv \= \[pt.htValid];
 pt \= pt(htv);
 et \= et(htv);
 
 spine \= reshape(\[pt.spine], 2, ncp, \[]);
 valid \= squeeze(all(all(isfinite(spine))));
 spine \= spine(:,:,valid);
 et \= et(valid);
 
 sl \= squeeze(cumsum(sqrt(sum(diff(spine(:,\[1 1:end], :),\[],2\).^2,1\)),2\));
 for j \= 1:size(spine, 3\)
 while (any(diff(sl(:,j)) \=\= 0\))
 sl(diff(sl(:,j))\=\=0,j) \= sl(diff(sl(:,j))\=\=0,j) \- 1E\-8;
 end
 spine(:,:,j) \= interp1(sl(:,j), spine(:,:,j)', linspace(min(sl(:,j)), max(sl(:,j)), ncp))';
 end
 spine \= permute(spine,\[3 1 2]);
 
 
 % try
 ispine \= interp1(et, spine, track.dq.eti,'linear','extrap'); %use normal linear interpolation for valid spine values
 %use nearest neighbor interpolation for invalid spine values \-\-
 %added by mhg 7/2/2012
 ihtinv \= \~track.getDerivedQuantity('ihtValid');
 if (any(ihtinv))
 ispine(ihtinv, :, :) \= interp1(et, spine, track.dq.eti(ihtinv), 'nearest', 'extrap');
 end 
 ispine \= permute(ispine, \[2 3 1]);
 
 
 
 
 track.dq.ispine \= ispine;
% catch me
% disp(me.getReport)
% track
% size(spine)
% end
end
function calculateSpineLength(track)
 track.dq.spineLength \= squeeze(sum(sqrt(sum(diff(track.dq.ispine,\[],2\).^2,1\)),2\))';
end
function calculateFastSpeed(track)
 track.calculateDerivedQuantity({'eti', 'itail', 'ihead', 'imid'});
 tm \= track.dq.imid \- track.dq.itail;
 tm \= tm./repmat(sqrt(sum(tm.^2\)),\[2 1]);
 %mh \= track.dq.ihead \- track.dq.imid;
 %th \= track.dq.ihead \- track.dq.itail;
 track.dq.fastTailSpeed \= dot (deriv(track.dq.itail, 1\), tm)/track.dr.interpTime;
 track.dq.fastHeadSpeed \= dot (deriv(track.dq.ihead, 1\), tm)/track.dr.interpTime;
 track.dq.fastMidSpeed \= dot (deriv(track.dq.imid, 1\), tm)/track.dr.interpTime;
 
 %sqrt(sum(deriv(track.dq.itail,1\)).^2\)/track.dr.interpTime;
 %track.dq.fastHeadSpeed \= sqrt(sum(deriv(track.dq.ihead,1\)).^2\)/track.dr.interpTime;
 %track.dq.fastMidSpeed \= sqrt(sum(deriv(track.dq.imid,1\)).^2\)/track.dr.interpTime;
end
function calculatePeristalsis(track)

 %tail velocity seems smoothest
 track.calculateDerivedQuantity({'eti', 'itail'});
 derivtime \= 0\.05;
 vt \= (deriv(track.dq.itail,derivtime/track.dr.interpTime))/track.dr.interpTime;
 tm \= lowpass1D(track.dq.imid \- track.dq.itail, derivtime/track.dr.interpTime);
 
 vtm \= dot(vt, tm);
% vtm \= vt;% \- mean(vt);
 vtm(vtm \> percentile(vtm, 0\.99\)) \= percentile(vtm, 0\.99\);
 vtm(vtm \< percentile(vtm, 0\.01\)) \= percentile(vtm, 0\.01\);
 time\_window \= min(track.dq.eti(end)\-track.dq.eti(1\), 10\);
 
 %using all tail velocity, find overall best peristaltic frequency
 Hs \= spectrum.welch('Hamming', time\_window/track.dr.interpTime);
 hpsd \= Hs.psd(vtm, 'Fs', 1 / track.dr.interpTime, 'NormalizedFrequency', false);
 ps \= hpsd.Data;
 f \= hpsd.Frequencies;
 ps \= ps(f \> 0\.5\);
 f \= f(f \> 0\.5\);
 \[\~,I] \= max(ps); 
 bestfreq \= f(I);
 if (bestfreq \< 1 \|\| bestfreq \> 5\)
 warning (\['overall peristaltic frequency: ' num2str(bestfreq,3\) ' is outside expected range']);
 end
 %now use autocorrelation to find local frequency
 periodInPts \= 1/(track.dr.interpTime\*bestfreq);
 minshift \= floor(periodInPts \* 0\.8\);
 maxshift \= ceil(periodInPts \* 1\.4\);
 winsize \= periodInPts\*1\.5;
 acf \= autocorrInWindow(vtm, minshift, maxshift, winsize, true);
 ssf \= squareSumInWindow(vtm, minshift, maxshift, winsize, true);
 z \= 2\*acf./ssf;
 \[b,I] \= max(z);
 a \= interp2(z, 1:length(I), I\-1, '\*nearest');
 c \= interp2(z, 1:length(I), I\+1, '\*nearest');
 a(isnan(a)) \= b(isnan(a));
 c(isnan(c)) \= b(isnan(c));
 I2 \= I \+ 0\.5 \* (a\-c)./(a\-2\*b\+c);
 fs \= 1\./(track.dr.interpTime\*(minshift \- 1 \+ I2\));
 zcut \= 0\.75;%percentile(b, 0\.1\);
% figure(1\)
% pcolor (track.dq.eti, minshift:maxshift, z); shading flat; colorbar vert;
% figure(2\)
% pcolor (track.dq.eti, minshift:maxshift, sort(z)); shading flat; colorbar vert;
% zz \= sort(z, 1 , 'descend');
% figure(3\); clf
% for n \= 2:10
% plot (track.dq.eti, mean(zz(1:n,:))); hold all
% end
 pv \= b \> zcut \& (max(z) \> 2\*min(z));
 if (nnz(pv) \< 2\)
 pv \= b \> zcut; %this is a kludge \-\- not sure what pv, b, zcut are 10/26/2014 \-\- gershow
 end
 
 pf \= interp1(track.dq.eti(pv) \+ (winsize/2\.0\)\*track.dr.interpTime, fs(pv), track.dq.eti, 'linear', 'extrap');
 targetFreq \= 1/50;
 
 %stretch time to create a uniform frequency
 dfun \= @(xx,ss) targetFreq/track.dr.interpTime./interp1(pf, ss, 'linear', bestfreq);
 nspts \= bestfreq\*track.dr.interpTime/targetFreq \* length(pf);
 \[\~,s] \= ode15s(dfun, 1:(nspts\*1\.25\), 1\);
 s \= s(s \< length(pf))';
 
 %tail velocity and position semi\-regularized to have a peristaltic frequency of
 %targetFreq regardless of position
 vti \= interp1(vtm, s, 'linear', 0\);
 %tpi \= interp1(track.dq.itail', s, 'linear')';
 
 %find period of peristaltic movement when tail is relatively still
 tk \= unique(\[0:(0\.5/targetFreq) \-(0:(0\.5/targetFreq))]);
 ck \= exp(sqrt(\-1\)\*2\*pi\*targetFreq\*tk);
 c \= conv2(vti, ck, 'same');
 th \= angle(c);
 %mag \= abs(c);
 \[\~,fi] \= findPositiveZeroCrossings(th);
 periInds \= interp1(s, fi); %points in non\-morphed time that mark pause point of peristalsis cycle
 periDist \= sqrt(sum(diff(interp1(track.dq.imid', periInds))'.^2\));
 periPeriod \= diff(interp1(track.dq.eti, periInds));
 periQuality \= interp1(b, periInds);
 periQuality \= interp1(periQuality, 1\.5:length(periQuality), 'linear');
 periMag \= interp1(interp1(abs(c), fi),1\.5:length(periInds)); 
 
 
 periTimePoint \= 0\.5 \* (interp1(track.dq.eti, periInds(1:(end\-1\))) \+ interp1(track.dq.eti, periInds(2:end)));
 track.dq.periAmp \= interp1(periTimePoint, periDist, track.dq.eti, 'linear', 'extrap');
 track.dq.periPeriod \= interp1(periTimePoint, periPeriod, track.dq.eti, 'linear', 'extrap');
 track.dq.periFreq \= pf;
 track.dq.periValid \= pv;
 %figure(1\); clf; plot (pf, track.dq.periFreq, 'b.');
 
 track.dq.periPhase \= interp1(s, th, 1:length(track.dq.eti));
 track.dq.periSpeed \= interp1(periTimePoint, periDist./periPeriod, track.dq.eti, 'linear', 'extrap');
 track.dq.periQuality \= b;
% figure(1\);
% plot (periPeriod, periDist, 'b.');
% figure(2\);
% plot (periPeriod, periQuality, 'r.');
% figure(3\);
% plot (periQuality, periDist, 'g.');
% figure(4\)
% plot (periPeriod(periQuality \> zcut), periDist(periQuality \> zcut), 'b.');
 
 
 
 
end

function calculateSpineDist (track)
 is \= track.getDerivedQuantity('ispine');
 is \= is \- repmat(permute(track.getDerivedQuantity('iloc'), \[1 3 2]), \[1 size(is,2\) 1]);
 splen \= size(is, 2\);
 ds \= diff(is, \[],3\);
% dmp \= diff(track.getDerivedQuantity('iloc'),\[],2\);
 
 dsq \= sqrt(sum(ds.^2\));
 % mpdist \= sqrt(sum(diff(track.getDerivedQuantity('iloc'),\[],2\).^2\)); 
 sd \= (squeeze(sum(dsq,2\)))';
 % track.dq.spineDist \= (\[0 (sd/splen \- mpdist)])/track.dr.interpTime;
 track.dq.spineDist \= (\[0 sd/(splen)]);
end

function calculateDBodyAngle(track) 
 sigma \= track.dr.derivTime/track.dr.interpTime;
 th \= unwrap(track.getDerivedQuantity('ibodytheta'));
 track.dq.dbodytheta \= deriv(th, sigma);
 th \= unwrap(track.getDerivedQuantity('sbodytheta'));
 track.dq.dsbodytheta \= deriv(th, sigma);
 

end

function calculateSpineCurv(track)
 is \= track.getDerivedQuantity('ispine');
 sz \= size(is,2\);
 is \= interp1(permute(is, \[2 1 3]), linspace(1,sz,100\));
 v \= 0\.5\*(diff(is(2:end,:,:)) \+ diff(is(1:end\-1,:,:)));
 a \= 0\.5\*(diff(v(2:end,:,:)) \+ diff(v(1:end\-1,:,:)));
 v \= v(2:end\-1,:,:);
 cv \= mean((v(:,1,:).\*a(:,2,:)) \- (v(:,2,:).\*a(:,1,:))./(sum(v.^2, 2\)).^1\.5\);
 track.dq.spineCurv \= squeeze(cv)';
 % track.dq.spineTheta \= track.dq.spineLength.\*track.dq.spineCurv;
end

function calculateSpineTheta(track)
 is \= track.getDerivedQuantity('ispine');
 nspinepts \= size(is,2\);

 range \= max(2,round(nspinepts/5\)); 
 midind \= ceil(nspinepts/2\) \+ (\-range:range);

 sqe \= zeros(length(midind), size(is, 3\));
 dt \= sqe;
 %thh \= sqe;
 for j \= 1:length(midind)

 tail \= is(:,1:midind(j), :);
 head \= is(:,midind(j):end, :);
 \[\~, dvt, sqet] \= fitLine (tail);
 \[\~, dvh, sqeh] \= fitLine (head);
 tht \= atan2(dvt(2,:), dvt(1,:));
 thh \= atan2(dvh(2,:), dvh(1,:));
 dt(j,:) \= diff(unwrap(\[tht;thh])); 
 sqe(j,:) \= sqet\+sqeh;
 end

 \[\~,I] \= min(sqe);
 track.dq.spineTheta \= dt(sub2ind(size(dt), I, 1:length(I)));
end

function calculateDSpineCurv(track)
 sigma \= track.dr.derivTime/track.dr.interpTime;
 th \= unwrap(track.getDerivedQuantity('spineTheta'));
 track.dq.spineTheta \= deriv(th, sigma);
 cv \= track.getDerivedQuantity('spineCurv');
 track.dq.dspineCurv \= deriv(cv, sigma);
 
end
\-\-\-

\#\#\# File: setSegmentSpeeds.m (ID: @MaggotTrack.18\)

function setSegmentSpeeds (track, mso)
% automatically sets run start/end speed thresholds based on speed near
% points of high curvature
% 
% function setSegmentSpeeds (track, mso)
%
% outputs: none
% inputs: 
% track \< MaggotTrack
% mso \< MaggotSegmentationOptions
% If segmentation options (mso) are given, use those.
% Otherwise, default to existing track.so options. 

existsAndDefault('mso', track.so);
if (mso.autoset\_curv\_cut)
 mso.curv\_cut \= mso.autoset\_curv\_cut\_mult / median(track.getDerivedQuantity('spineLength')); %autoset\_curv\_cut\_mult default is 5
end
track.so \= mso;


% Extract all the speeds and curvatures from the track (or is it all
% tracks?)
sp \= track.getDerivedQuantity(mso.speed\_field);
cv \= track.getDerivedQuantity('curv');

% Keep only the curvatures that are above the segmentation threshold.
highcurv \= abs(cv) \> mso.curv\_cut;
% Issue warnings if there are zero or few points above threshold. 
if (isempty(highcurv))
 disp(\['locInFile \= ' num2str(track.locInFile) ' no high curvature']);
 return
end
if (sum(highcurv) \< 4\)
 disp(\['trackNum \= ' num2str(track.trackNum) ' npts \= ' num2str(track.npts) ' locInFile \= ' num2str(track.locInFile) ' few high curvature points']);
end

% Calculate average speed (and standard deviation) of larvae with
% curvatures above the threshold. Then set the "stop" speed cutoff to be
% the mean \+ stdev. 
u \= mean(sp(highcurv));
s \= std(sp(highcurv));
track.so.stop\_speed\_cut \= u \+ s;

% Not sure what this does. Expands which points are above the curvature
% threshold, then cuts out the original points above threshold. The result
% being a set of points that occur near when the larval curvature is above
% threshold? Then take the average speed (and stdev) of these points,
% using that as the cutoff for restarting a run? 
nearhc \= imdilate(highcurv, ones(5\)) \&\~highcurv;
u \= mean(sp(nearhc));
s \= std(sp(nearhc));
track.so.start\_speed\_cut \= u \+ s;



\-\-\-

\#\#\# File: parallelMovies.m (ID: @MaggotTrack.19\)

function varargout \= parallelMovies(track, varargin)
%function parallelMovies(track, varargin)
%
%this function was used to make videos for a presentation, but the videos
%are, in fact, confusing
delayTime \= 0\.05;
ptbuffer \= 3;
for j \= 1:length(track)
 track(j).expt.openDataFile;
 fid(j) \= track(j).expt.fid;
end
AxesList \= \[];
npts \= \[];
TitleOptions \= {'Color', 'w', 'FontSize', 14};
AxesOptions \= {'Color', 'k', 'XColor', 'w', 'YColor', 'w', 'Box', 'on', 'LineWidth', 2, 'Layer', 'top',...
 'XTick', \[], 'YTick', \[]};
aviobj \= \[];
avirect \= \[];
varargin \= assignApplicable(varargin);
if (isempty(AxesList))
 order \= \[1 3 4 2];
 for j \= 1:4
 AxesList(j) \= subplot(2,2,order(j)); %\#ok
 end
end

indset \= {\[], \[], \[], \[]};
tnum \= {\[], \[], \[], \[]};
tind \= {\[], \[], \[], \[]};
offset \= 0;
for j \= 1:length(track)
 runs \= track(j).isrun;
 reos \= false(size(runs));
 acchs \= false(size(runs));
 rejhs \= false(size(runs));

 reos(\[track(j).reorientation(\[track(j).reorientation.numHS] \> 0\).inds]) \= true;
 acchs(\[track(j).headSwing(\[track(j).headSwing.valid] \& \[track(j).headSwing.accepted]).inds]) \= true;
 rejhs(\[track(j).headSwing(\[track(j).headSwing.valid] \& \~(\[track(j).headSwing.accepted])).inds]) \= true;

 runs \= imerode(runs, ones(\[1 2\*ptbuffer \+ 1]));
 reos \= imdilate(reos, ones(\[1 2\*ptbuffer \+ 1]));
 nh \= \[zeros(\[1 2\*ptbuffer]) ones(\[1 2\*ptbuffer\+1])];
 acchs \= imdilate(acchs, nh);
 rejhs \= imdilate(rejhs, ones(\[1 2\*ptbuffer \+ 1]));

 indmap \= track(j).getDerivedQuantity('mapInterpedToPts');

 tind{1} \= \[tind{1} find(runs)];
 tind{2} \= \[tind{2} find(acchs)];
 tind{3} \= \[tind{3} find(rejhs)];
 tind{4} \= \[tind{4} find(reos)];
 
 
 runinds \= offset \+ (indmap(runs));
 reoinds\= offset \+ (indmap(reos));
 accinds \= offset \+ (indmap(acchs));
 rejinds \= offset \+ (indmap(rejhs));
 indset{1} \= \[indset{1} runinds];
 indset{2} \= \[indset{2} accinds];
 indset{3} \= \[indset{3} rejinds];
 indset{4} \= \[indset{4} reoinds];
 tnum{1} \= \[tnum{1} repmat(j, size(runinds))];
 tnum{2} \= \[tnum{2} repmat(j, size(accinds))];
 tnum{3} \= \[tnum{3} repmat(j, size(rejinds))];
 tnum{4} \= \[tnum{4} repmat(j, size(reoinds))];
 offset \= offset \+ length(track(j).pt);
end
if isempty(npts)
 npts \= max(\[length(indset{1}), length(indset{2}), length(indset{3}), length(indset{4})]);
end

ttls \= {'Runs', 'Accepted Head Sweeps', 'Rejected Head Sweeps', 'Reorientations'};
pt \= \[track.pt];
for j \= 1:npts
 for k \= 1:4
 ind \= mod(j\-1, length(indset{k})) \+ 1;
 %ind \= indset{k}(ind);
 pt(indset{k}(ind)).drawTrackImage(\[],'Axes', AxesList(k), 'fid', fid(tnum{k}(ind)), varargin{:});
 shading(AxesList(k), 'interp')
 
 pn \= {'XLim', 'YLim'};
 pv \= get(AxesList(k), pn);
 pinds \= tind{k}(ind) \+ (\-50:0\);
 pinds \= pinds(pinds \> 1\);
 
 hold (AxesList(k), 'on');
 track(tnum{k}(ind)).plotPath('sloc', 'b.\-','Axes',AxesList(k),'inds', pinds);
 
 title(AxesList(k), ttls{k}, TitleOptions{:});
 set(AxesList(k), pn, pv);
 set(AxesList(k), AxesOptions{:});
 hold(AxesList(k), 'off');
 
 end
 if \~isempty(aviobj)
 if (isempty(avirect))
 F \= getframe(gcf);
 else
 F \= getframe(gcf, avirect);
 end 
 aviobj \= addframe(aviobj, F);
 end
 pause(delayTime);
end

if (nargout \> 0\)
 varargout{1} \= aviobj;
end
\-\-\-

\#\#\# Folder: @Run (ID: @Run)

\-\-\-

\#\#\# File: meanThetaRelativeTo.m (ID: @Run.1\)

function mhr \= meanThetaRelativeTo(run, dirField)
%function mhr \= meanThetaRelativeTo(run, dirField)
%
%gets the average heading over the course of a run, relative to dirField
%
% run \< RUN
% dirField \- string; run.getDerivedQuantity(dirField) yields 4\-quadrant
% angles

vel \= run.getDerivedQuantity('vel');
theta \= run.getDerivedQuantity(dirField);
rvel \= zeros(size(vel));
rvel(1,:) \= cos(theta).\*vel(1,:) \+ sin(theta).\*vel(2,:);
rvel(2,:) \= cos(theta).\*vel(2,:) \- sin(theta).\*vel(1,:);

mhr \= atan2(sum(rvel(2,:)), sum(rvel(1,:)));
\-\-\-

\#\#\# File: Run.m (ID: @Run.2\)

classdef Run \< TrackPart
 %UNTITLED7 Summary of this class goes here
 % Detailed explanation goes here
 
 properties
 startTheta;
 endTheta;
 meanTheta;
 euclidLength;
 pathLength;
 runTime; 
 end
 properties (Dependent)
 nextRun;
 previousRun; 
 prevReorientation;
 nextReorientation;
 end
 methods
 function nr \= get.nextRun(obj)
 nr \= obj.getAdjacent('next', 'run');
 end
 function nr \= get.nextReorientation(obj)
 nr \= obj.getAdjacent('next', 'reorientation');
 end
 function pr \= get.previousRun(obj)
 pr \= obj.getAdjacent('prev', 'run');
 end
 function pr \= get.prevReorientation(obj)
 pr \= obj.getAdjacent('prev', 'reorientation');
 end
 
 end 
 
 %{
 methods
 function set.previousRun (obj, value)
 if (\~isempty(value) \&\& isa (value, 'Run'))
 value.nextRun \= obj;
 end
 obj.previousRun \= value;
 end
 function set.prevReorientation (obj, value)
 if (\~isempty(value) \&\& isfield (value, 'nextRun'))
 value.nextRun \= obj;
 end
 obj.prevReorientation \= value;
 end
 function set.nextReorientation (obj, value)
 if (\~isempty(value) \&\& isfield (value, 'prevRun'))
 value.nextRun \= obj;
 end
 obj.nextReorientation \= value;
 end
 end
 %}
 methods
 calculateMetrics(run, moveEndPosition);
 draw(run, varargin);
 str \= getReport(run, varargin);
 mhr \= meanThetaRelativeTo(run, dirField);
 function qv \= getDerivedQuantity (tp, field, varargin) 
 if (\~strcmpi(field, 'meanThetaRelativeTo'))
 qv \= getDerivedQuantity@TrackPart (tp, field, varargin{:});
 return;
 end
 if (isempty(tp.inds))
 qv \= \[];
 return;
 end
 if (isempty(varargin) \|\| \~ischar(varargin{1}))
 error ('meanThetaRelativeTo requires direction field name as argument');
 end
 qv \= meanThetaRelativeTo(tp, varargin{1});
 end
 end
 methods %constructor
 function run \= Run(varargin)
 %run \= Run(track, startInd, endInd)
% dbstack
 arglist \= {'track', 'startInd', 'endInd'};
 if (nargin \> 0\)
 for j \= 1:min(nargin, length(arglist))
 run.(arglist{j}) \= varargin{j};
 end
 if (nargin \>\= length(arglist))
 %got everything we wanted, so calculate away
 run.calculateMetrics(true);
 end
 end
 end
 end
end


\-\-\-

\#\#\# File: getReport.m (ID: @Run.3\)

function str \= getReport(run, varargin)
%generates a report about a run
%function getReport(run, varargin)
%
%output: STR (a string, or cell of strings if multiple runs)
%input: run \< Run
%optional arguments:
% meanFields: default {'speed'}: fields over which to display a mean
% value

str \= \['Run: ', getReport@TrackPart(run, varargin{:})];

\-\-\-

\#\#\# File: draw.m (ID: @Run.4\)

function draw(run, varargin) 
%function draw(run, varargin) 
%
if (isempty(run.track))
 return;
end
Color \= 'b\-';
LineWidth \= 1\.5; 

varargin \= assignApplicable(varargin);

ih \= ishold;
plot (run.track.dq.sloc(1,run.inds), run.track.dq.sloc(2,run.inds), Color, 'LineWidth', LineWidth, varargin{:});
hold on;
t \= rad2deg(run.track.dq.theta(run.inds(1\)));
t \= mod(t,360\);
if (t \< 45 \|\| t \>\= 315\)
 symbol \= 'g\>';
end
if (45 \<\=t \&\& t \< 135\)
 symbol \= 'g^';
end
if (135 \<\=t \&\& t \< 225\)
 symbol \= 'g\<';
end
if (225 \<\= t)
 symbol \= 'gv';
end

plot (run.track.dq.sloc(1,run.inds(1\)), run.track.dq.sloc(2,run.inds(1\)), symbol);
plot (run.track.dq.sloc(1,run.inds(end)), run.track.dq.sloc(2,run.inds(end)), 'rh');

if (\~ih)
 hold off
end

\-\-\-

\#\#\# File: calculateMetrics.m (ID: @Run.5\)

function calculateMetrics(run, moveEndPosition)
%run.calculateMetrics()
%based on the track and indices already set, it finds a bunch of stuff
%for easy reading later
 if (\~exist('moveEndPosition', 'var'))
 moveEndPosition \= false;
 end
 run.track.calculateDerivedQuantity ({'eti', 'sloc', 'theta', 'pathLength', 'acc', 'fastTailSpeed'});
 
 if (moveEndPosition)
 dsp \= diff(run.track.dq.speed);
 %this is a change to better determine turn start time
 testinds \= floor(run.endInd \- run.track.dr.smoothTime/run.track.dr.interpTime):ceil(run.endInd\+run.track.dr.smoothTime/run.track.dr.interpTime);
 testinds \= testinds(testinds \> run.startInd\+run.track.so.minRunTime/(2\*run.track.dr.interpTime) \& testinds \< length(run.track.dq.eti)); %avoid run getting too short \-\- shouldn't be a problem ever
 testinds \= testinds(testinds \< run.endInd \| dsp(testinds) \< 0\); %if it's still slowing down, extend past observed end of the run
 \[\~,I] \= min(run.track.dq.fastTailSpeed(testinds)); %maggot often backs its tail up at the beginning of a turn
 run.endInd \= testinds(1\) \+ I \- 2;
 %end change
 end
 
 ptbuffer \= floor(min(1,run.track.so.minRunTime/2\)/run.track.dr.interpTime);
 
 
 run.inds \= run.startInd:run.endInd;
 startTheta \= mean(unwrap(run.track.dq.theta(run.startInd \+ (1:ptbuffer))));
 endTheta \= mean(unwrap(run.track.dq.theta(run.endInd \+ 1 \- (1:ptbuffer))));
 run.startTheta \= mod(startTheta\+pi,2\*pi) \- pi;
 run.endTheta \= mod(endTheta\+pi,2\*pi) \- pi;
 
 displacement \= run.track.dq.sloc(:,run.endInd) \- run.track.dq.sloc(:,run.startInd);
 run.meanTheta \= atan2(displacement(2\), displacement(1\));
 run.euclidLength \= sqrt(sum((displacement).^2\)); 
 run.pathLength \= run.track.dq.pathLength(run.endInd) \- run.track.dq.pathLength(run.startInd);
 run.runTime \= run.track.dq.eti(run.endInd) \- run.track.dq.eti(run.startInd);
end~~~~~~~~~~~~~~